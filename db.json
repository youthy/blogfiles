{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/img/082.png","path":"img/082.png","modified":0,"renderable":0},{"_id":"source/img/083.png","path":"img/083.png","modified":0,"renderable":0},{"_id":"source/img/084.png","path":"img/084.png","modified":0,"renderable":0},{"_id":"source/img/baitutang.jpg","path":"img/baitutang.jpg","modified":0,"renderable":0},{"_id":"source/img/24.png","path":"img/24.png","modified":0,"renderable":0},{"_id":"source/img/chaodiancipao.gif","path":"img/chaodiancipao.gif","modified":0,"renderable":0},{"_id":"source/img/chizuoqian.jpg","path":"img/chizuoqian.jpg","modified":0,"renderable":0},{"_id":"source/img/danwanlunpo.jpg","path":"img/danwanlunpo.jpg","modified":0,"renderable":0},{"_id":"source/img/emozhimi.jpg","path":"img/emozhimi.jpg","modified":0,"renderable":0},{"_id":"source/img/ets1.png","path":"img/ets1.png","modified":0,"renderable":0},{"_id":"source/img/ets2.png","path":"img/ets2.png","modified":0,"renderable":0},{"_id":"source/img/fatezero.jpg","path":"img/fatezero.jpg","modified":0,"renderable":0},{"_id":"source/img/gitcafe1.png","path":"img/gitcafe1.png","modified":0,"renderable":0},{"_id":"source/img/gitcafe2.png","path":"img/gitcafe2.png","modified":0,"renderable":0},{"_id":"source/img/gitcafe3.png","path":"img/gitcafe3.png","modified":0,"renderable":0},{"_id":"source/img/gitcafe4.png","path":"img/gitcafe4.png","modified":0,"renderable":0},{"_id":"source/img/gitcafe5.png","path":"img/gitcafe5.png","modified":0,"renderable":0},{"_id":"source/img/gitcafe6.png","path":"img/gitcafe6.png","modified":0,"renderable":0},{"_id":"source/img/heijiao.jpg","path":"img/heijiao.jpg","modified":0,"renderable":0},{"_id":"source/img/killlakill.jpg","path":"img/killlakill.jpg","modified":0,"renderable":0},{"_id":"source/img/lovelive.jpg","path":"img/lovelive.jpg","modified":0,"renderable":0},{"_id":"source/img/mingyunshizhimen.jpg","path":"img/mingyunshizhimen.jpg","modified":0,"renderable":0},{"_id":"source/img/ranch_1.png","path":"img/ranch_1.png","modified":0,"renderable":0},{"_id":"source/img/ranch_2.png","path":"img/ranch_2.png","modified":0,"renderable":0},{"_id":"source/img/ranch_3.png","path":"img/ranch_3.png","modified":0,"renderable":0},{"_id":"source/img/test.png","path":"img/test.png","modified":0,"renderable":0},{"_id":"source/img/tiancaimajiangshaonv.jpg","path":"img/tiancaimajiangshaonv.jpg","modified":0,"renderable":0},{"_id":"source/img/wangxiangxueshenghui.png","path":"img/wangxiangxueshenghui.png","modified":0,"renderable":0},{"_id":"source/img/xiaoyuan.jpg","path":"img/xiaoyuan.jpg","modified":0,"renderable":0},{"_id":"source/img/yangyan.jpg","path":"img/yangyan.jpg","modified":0,"renderable":0},{"_id":"source/img/yiqiyiqi.gif","path":"img/yiqiyiqi.gif","modified":0,"renderable":0},{"_id":"source/img/yiqiyiqi2.gif","path":"img/yiqiyiqi2.gif","modified":0,"renderable":0},{"_id":"source/img/选区_025.png","path":"img/选区_025.png","modified":0,"renderable":0},{"_id":"source/img/选区_026.png","path":"img/选区_026.png","modified":0,"renderable":0},{"_id":"source/img/选区_033.png","path":"img/选区_033.png","modified":0,"renderable":0},{"_id":"source/img/选区_034.png","path":"img/选区_034.png","modified":0,"renderable":0},{"_id":"source/img/选区_035.png","path":"img/选区_035.png","modified":0,"renderable":0},{"_id":"source/img/选区_045.png","path":"img/选区_045.png","modified":0,"renderable":0},{"_id":"source/img/选区_046.png","path":"img/选区_046.png","modified":0,"renderable":0},{"_id":"themes/hexo-theme-yilia/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/img/coderwall.png","path":"img/coderwall.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/img/delicious.png","path":"img/delicious.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/img/douban.png","path":"img/douban.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/img/e4de299979dcde1b881d6ccacf9e2518_b.png","path":"img/e4de299979dcde1b881d6ccacf9e2518_b.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/img/facebook.png","path":"img/facebook.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/img/github.png","path":"img/github.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/img/google.png","path":"img/google.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/img/img-err.png","path":"img/img-err.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/img/img-loading.png","path":"img/img-loading.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/img/linkedin.png","path":"img/linkedin.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/img/mail.png","path":"img/mail.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/img/pinboard.png","path":"img/pinboard.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/img/pinterest.png","path":"img/pinterest.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/img/rss.png","path":"img/rss.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/img/search.png","path":"img/search.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/img/stackoverflow.png","path":"img/stackoverflow.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/img/twitter.png","path":"img/twitter.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/img/weibo.png","path":"img/weibo.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/img/zhihu.png","path":"img/zhihu.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/js/instagram.js","path":"js/instagram.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/js/jquery.lazyload.js","path":"js/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/js/mobile.js","path":"js/mobile.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/js/pc.js","path":"js/pc.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/css/fonts/fontawesome-webfont.svgz","path":"css/fonts/fontawesome-webfont.svgz","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/hexo-theme-yilia/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/.nojekyll","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1530006567731},{"_id":"source/CNAME~","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1530006567732},{"_id":"source/CNAME","hash":"2f997ed1e488b4ed563a1aff0cc7769ff49b4ed6","modified":1530006567731},{"_id":"source/baidu_verify_BA4RKG2m6D.html","hash":"3f05b83892ee5ef46f7d73e689d8e50fed4d88ae","modified":1530006567741},{"_id":"source/_posts/Erlang-ETS.md","hash":"91ab0571f2379f29dcc3481d7a09ea87ca89dc13","modified":1530006567732},{"_id":"source/_posts/Erlang中的位语法(bit-syntax).md","hash":"53ac0fa4deee932b47ddfd28bc3149a86a09e96d","modified":1530006567733},{"_id":"source/google7c485c194d355632.html","hash":"224762e1205cd1992fa18eab592ee9b1aedc20ea","modified":1530006567741},{"_id":"source/baidu_verify_BA4RKG2m6D.html~","hash":"3f05b83892ee5ef46f7d73e689d8e50fed4d88ae","modified":1530006567741},{"_id":"source/_posts/Erlang中的lists模块.md","hash":"3a16c4be918d074d9ffeec4a419d7a07515ea75c","modified":1530006567732},{"_id":"source/_posts/Linux下代理实现shadowsocks.md","hash":"7dbf88da5166294f3cfd725f5805afca8672130a","modified":1530006567733},{"_id":"source/_posts/Markdown所能识别代码高亮的语言.md","hash":"e1bb28577ee32ae31b18e468e4c9e17de8c797ee","modified":1530006567733},{"_id":"source/_posts/Regex-正则表达式.md","hash":"8b243dadfcd8f32b5933b382a388a642d1063271","modified":1530006567733},{"_id":"source/_posts/erlang-question-gen-server-and-init.md","hash":"b10ff1d03f4d2872f96718f63b8730a5257b787b","modified":1530006567734},{"_id":"source/_posts/erlang_mysql_driver.md","hash":"07e23597d083fef7fd1bd5409affabf9c07d581a","modified":1530006567734},{"_id":"source/_posts/erlang_mysql_driver源码分析(二).md","hash":"205d686c82bb30b3dfcff94cccc8e346dd246204","modified":1530006567734},{"_id":"source/_posts/erlang_mysql_driver源码分析(三).md","hash":"9e2cb5652be1765e6bc07ac91b0cda59586916d6","modified":1530006567734},{"_id":"source/_posts/erl命令和参数.md","hash":"dc381690567d8788170b0b29314cb4c654dc796e","modified":1530006567735},{"_id":"source/_posts/erlang实现多人聊天室模型.md","hash":"0851b6deec4179ac90a9d0fca9383ddb32a654ba","modified":1530006567735},{"_id":"source/_posts/gitnote.md","hash":"57a2ba8751ec2e271f2d83341c4704941a589b4a","modified":1530006567736},{"_id":"source/_posts/linux修改键盘映射.md","hash":"805ec2baff4ca21c1bf46a48e008c1c14a0c0679","modified":1530006567736},{"_id":"source/_posts/erlang有关效率的一些limit.md","hash":"674bd9279e8999121a2a1b6d6a2e6933815ac888","modified":1530006567735},{"_id":"source/_posts/makefile笔记.md","hash":"ded6c8b8e0ff6af9aa053146177af155b4ff431f","modified":1530006567736},{"_id":"source/_posts/makefile笔记.md~","hash":"c7624b4b122b804d76f87468efa1fe3319d1353b","modified":1530006567736},{"_id":"source/_posts/ranch笔记.md","hash":"5ba8aa5366e9505a5a75c4ee53bb0d2f847a891b","modified":1530006567736},{"_id":"source/_posts/github屏蔽百度爬虫的解决办法.md","hash":"400a621a3cc0f98890c57f125dea10ae05e4f3fb","modified":1530006567735},{"_id":"source/_posts/vim复制到系统剪切板.md","hash":"d209fe79781ae6a39a2b8fe76ce65453edcfa5fc","modified":1530006567737},{"_id":"source/_posts/vimscript笔记.md","hash":"38fe90925f08ff49dbc1e330562e3a7386320ce5","modified":1530006567737},{"_id":"source/_posts/ubuntu-LAMP搭建.md","hash":"f2e2a83593b3ef9a1882da9ae188eb9ac85a7b8b","modified":1530006567737},{"_id":"source/_posts/ssh登陆远程主机.md","hash":"dcdb2ca2aba5e4bdabcb2192b96f859c8950db24","modified":1530006567737},{"_id":"source/_posts/今天看了变形金刚4.md","hash":"e0d860b408d5268fbce6cf165a42a244724d078a","modified":1530006567739},{"_id":"source/_posts/youthy的番剧历史.md","hash":"56e44b5603b6445d6d58fbd595c1b26172a7cba6","modified":1530006567737},{"_id":"source/_posts/使用github管理hexo本地文件.md","hash":"a26c4e38a6ee7353bafd4c815ed70f32288ed994","modified":1530006567739},{"_id":"source/_posts/一辈子の好朋友劵.md","hash":"d776e8b103c1d45167daa7cf94d68e579e2997ea","modified":1530006567739},{"_id":"source/_posts/工作五个月后.md","hash":"5cd05fac19878af20b0dfa6ab8be9c855b171bfb","modified":1530006567740},{"_id":"source/_posts/关于hexo的toc.md","hash":"66cc015af196d831aeab1681995c85bba864a67c","modified":1530006567739},{"_id":"source/about/index.md","hash":"1da8c2d3bfe01ac1db8ff149b03ced660d3b0a6f","modified":1530006567740},{"_id":"source/_posts/欢迎来到youthy的博客.md","hash":"0f8dea6c6cb583c523441bbb069d9460686f57ff","modified":1530006567740},{"_id":"source/about/index.md~","hash":"f1d56b4ae3efabeabf4f81560c42cf7be2727cff","modified":1530006567740},{"_id":"source/img/.jpg","hash":"01a5564c04e41ac4d3b53cfae06bfc1bb7cdb140","modified":1530006567742},{"_id":"source/img/082.png","hash":"817a7f9f8d15c868c75b35dfcb272deaef57b26e","modified":1530006567743},{"_id":"source/img/083.png","hash":"8d9d64031ceaa012df09911a76fa60ff22cde6bb","modified":1530006567743},{"_id":"source/img/084.png","hash":"a3193348dfb5fd4efb70b611d1ab20fb5fb45fb2","modified":1530006567743},{"_id":"source/img/baitutang.jpg","hash":"cd5cdd560b981c8b908ed760574a5f098a17a00d","modified":1530006567744},{"_id":"source/img/24.png","hash":"38a83bf7c2effb1f45305f2ef451e59c0b1aca9c","modified":1530006567743},{"_id":"source/img/chizuoqian.jpg","hash":"96e0f97c404293f9f8a9bc0a1f085912eefec9fd","modified":1530006567746},{"_id":"source/img/emozhimi.jpg","hash":"4e465dcb8e51a324fc30d49de99fc8a005e85154","modified":1530006567748},{"_id":"source/img/danwanlunpo.jpg","hash":"847fda763d327e5badf570ebe61d2151d656304a","modified":1530006567747},{"_id":"source/img/ets1.png","hash":"9ace53a7ffabfa5f1c191336d14b0aafe8f9f856","modified":1530006567748},{"_id":"source/img/ets2.png","hash":"6e7b384ed9062698920ca6b506b2e24739fd88f7","modified":1530006567749},{"_id":"source/img/fatezero.jpg","hash":"4e65dac474a31096209c366092024e7e6a52579e","modified":1530006567749},{"_id":"source/img/gitcafe2.png","hash":"9b9105cb1722541d2f6b5dd84fea17c6c7df6263","modified":1530006567750},{"_id":"source/img/gitcafe1.png","hash":"d1a4bbae55295f703582a7ffaf5a55a5e41a45b8","modified":1530006567749},{"_id":"source/img/gitcafe3.png","hash":"0fe314cdb6a1096c172ff63c6260d8cd2adaba95","modified":1530006567750},{"_id":"source/img/gitcafe5.png","hash":"f18f905623af5abec902229cdc5474a66075d596","modified":1530006567751},{"_id":"source/img/gitcafe6.png","hash":"eae936515602ba32ee2cb95a7a50d159a23501a5","modified":1530006567752},{"_id":"source/img/gitcafe4.png","hash":"632f68cfd8968d9e9fcf6b446ea8c709caa18a84","modified":1530006567751},{"_id":"source/img/heijiao.jpg","hash":"56bed625705ff5d993c94280b7fdd091d25e805b","modified":1530006567752},{"_id":"source/img/ranch_1.png","hash":"7344447b954bcc3637c00f24379facafa7e5f152","modified":1530006567756},{"_id":"source/img/ranch_2.png","hash":"73d847eac4d3e03b60698630467c78bc2a039cee","modified":1530006567756},{"_id":"source/img/ranch_3.png","hash":"d268adca0ddd710d994e6ef377e32044e8828257","modified":1530006567757},{"_id":"source/img/test.png","hash":"7961033b0c418b3def73402c2d8eed6ebb58573b","modified":1530006567757},{"_id":"source/img/选区_025.png","hash":"317f478d1b15fe3604764847143484211df5e526","modified":1530006567764},{"_id":"source/img/选区_026.png","hash":"c52784d1914a7c2ea2c1a49f1f15d5dd6cd427c9","modified":1530006567764},{"_id":"source/img/选区_033.png","hash":"d46b43ac292cd3d5df6507fc8cd6ad96dbc7f41b","modified":1530006567764},{"_id":"source/img/选区_035.png","hash":"e3a464a13c43036ca35875a9fd8718d322a1f422","modified":1530006567765},{"_id":"source/img/选区_045.png","hash":"536955fa2b0fd6c4224ea786fb5e22b24fae4bf4","modified":1530006567765},{"_id":"source/img/选区_046.png","hash":"09270565900425fbfc478db52ff14969fe7c1769","modified":1530006567765},{"_id":"source/img/选区_034.png","hash":"b75671e452e207c019f3489d772af5ae0ce38cec","modified":1530006567764},{"_id":"source/img/killlakill.jpg","hash":"ee801b31db06382dc9c4c6a4eb22e1168dc041fa","modified":1530006567753},{"_id":"source/img/lovelive.jpg","hash":"8b5e4246f1ae74abebf9ee635618c3893fe7488f","modified":1530006567753},{"_id":"source/img/tiancaimajiangshaonv.jpg","hash":"7fe662f6178a718c625949bdf916262d8385d35e","modified":1530006567758},{"_id":"source/img/yangyan.jpg","hash":"0c370a372ac07f182c9f3bcac80b9d24ee0fa181","modified":1530006567761},{"_id":"source/img/yiqiyiqi.gif","hash":"358bb8b3cdfe5ef8391b97661e4cdbea4bf9066b","modified":1530006567762},{"_id":"source/img/mingyunshizhimen.jpg","hash":"5f18e4525878f1761f66b84bdc9a7655719601a9","modified":1530006567756},{"_id":"source/img/yiqiyiqi2.gif","hash":"fea6dd987a32156a986e5757ff872a112c69bf56","modified":1530006567763},{"_id":"source/img/xiaoyuan.jpg","hash":"02acc63a727ae00df78d2220cb55a896e0e5d54c","modified":1530006567760},{"_id":"source/img/chaodiancipao.gif","hash":"dad0b54a71328fef2399a8c02c075c300c49cabf","modified":1530006567746},{"_id":"source/img/wangxiangxueshenghui.png","hash":"20b9440f9f58974e5da81509f0f2a349d799203c","modified":1530006567759},{"_id":"themes/hexo-theme-yilia/README.md","hash":"8648a81b3ae08a4accd6b0541533e662511e6400","modified":1530006567792},{"_id":"themes/hexo-theme-yilia/_config.yml","hash":"b1ce92745da3d5655f20eb01fe97f20c8b626ddb","modified":1530006567793},{"_id":"themes/hexo-theme-yilia/package.json","hash":"00357ef6f24eb049074da81809e98f973f528cca","modified":1530006567797},{"_id":"themes/hexo-theme-yilia/layout/.DS_Store","hash":"693e513b44d5241ea897cc90cc71aeba091283b9","modified":1530006567793},{"_id":"themes/hexo-theme-yilia/_config.yml~","hash":"2d96eccc1e45d6557b4780d145d5c548eaa38043","modified":1530006567793},{"_id":"themes/hexo-theme-yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1530006567796},{"_id":"themes/hexo-theme-yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1530006567796},{"_id":"themes/hexo-theme-yilia/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1530006567797},{"_id":"themes/hexo-theme-yilia/layout/layout.ejs","hash":"4a5566f704f3246f5ef77badddf18d2e16750328","modified":1530006567797},{"_id":"themes/hexo-theme-yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1530006567797},{"_id":"themes/hexo-theme-yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1530006567797},{"_id":"themes/hexo-theme-yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1530006567797},{"_id":"themes/hexo-theme-yilia/layout/_partial/.DS_Store","hash":"e32979f5a18bff84e197c13b48f4c54e03796e4a","modified":1530006567793},{"_id":"themes/hexo-theme-yilia/layout/_partial/after-footer.ejs","hash":"082504c9fd8600306d4ca55f03e3cbb0ddd99dd7","modified":1530006567793},{"_id":"themes/hexo-theme-yilia/layout/_partial/archive-post.ejs","hash":"8dfb6d68aa8a0661d26c32ce1ce1f45815364c3a","modified":1530006567793},{"_id":"themes/hexo-theme-yilia/layout/_partial/archive.ejs","hash":"a6e94061ac55b9eb55275f87b608d62f6ea35659","modified":1530006567794},{"_id":"themes/hexo-theme-yilia/layout/_partial/article.ejs","hash":"ef8dd558f908f293c34123c0b7ff879d2fd0c09f","modified":1530006567794},{"_id":"themes/hexo-theme-yilia/layout/_partial/footer.ejs","hash":"f2994e0acd1d606ebf4680afc4fa652e148ccf4e","modified":1530006567794},{"_id":"themes/hexo-theme-yilia/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1530006567794},{"_id":"themes/hexo-theme-yilia/layout/_partial/head.ejs","hash":"963c106412a3ab142871976978ecc9884aeca17a","modified":1530006567794},{"_id":"themes/hexo-theme-yilia/layout/_partial/header.ejs","hash":"6387a93dad7c3d778eb91e3821852fbf6813880c","modified":1530006567794},{"_id":"themes/hexo-theme-yilia/layout/_partial/mathjax.ejs","hash":"54fab4d3d64cb937d6baec7324ffabf9f202b883","modified":1530006567795},{"_id":"themes/hexo-theme-yilia/layout/_partial/left-col.ejs","hash":"70a9951e4e2d30aabba88e75c3fa54b9235ce6a6","modified":1530006567795},{"_id":"themes/hexo-theme-yilia/layout/_partial/mobile-nav.ejs","hash":"cd0af87ee781ac9c2b0e6a2a05b063d4bd497d9c","modified":1530006567795},{"_id":"themes/hexo-theme-yilia/source/css/.DS_Store","hash":"fc5a428fe40854a0ba66b4cea196c6700a57cae7","modified":1530006567798},{"_id":"themes/hexo-theme-yilia/source/css/_extend.styl","hash":"8ab1ad313bd6707d248c5ca1ee9a5eab8d815e42","modified":1530006567798},{"_id":"themes/hexo-theme-yilia/source/css/_variables.styl","hash":"8b63ea3c7199524b9a1541075c6f8fb2c0d0ea3d","modified":1530006567801},{"_id":"themes/hexo-theme-yilia/source/css/style.styl","hash":"456e8cfe3b0b0371e81848ea9b0bc7ffd5360921","modified":1530006567803},{"_id":"themes/hexo-theme-yilia/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1530006567803},{"_id":"themes/hexo-theme-yilia/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1530006567803},{"_id":"themes/hexo-theme-yilia/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1530006567804},{"_id":"themes/hexo-theme-yilia/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1530006567804},{"_id":"themes/hexo-theme-yilia/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1530006567804},{"_id":"themes/hexo-theme-yilia/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1530006567804},{"_id":"themes/hexo-theme-yilia/source/fancybox/jquery.fancybox.css","hash":"b6aa6692c2e5f8bd74d96827b78570f0c5683c20","modified":1530006567805},{"_id":"themes/hexo-theme-yilia/source/img/coderwall.png","hash":"fa84676c4d654e040e51fd34bfcd9f9348cd5331","modified":1530006567806},{"_id":"themes/hexo-theme-yilia/source/fancybox/jquery.fancybox.js","hash":"a82597493d75ea989ca586e09173cff332efe41e","modified":1530006567806},{"_id":"themes/hexo-theme-yilia/source/img/delicious.png","hash":"9553a5f5189e4a953e04a58a49dbfa74b86b73dd","modified":1530006567806},{"_id":"themes/hexo-theme-yilia/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1530006567806},{"_id":"themes/hexo-theme-yilia/source/img/facebook.png","hash":"d19ad7a0903daf26817afd8753cd97e0cc714f54","modified":1530006567807},{"_id":"themes/hexo-theme-yilia/source/img/douban.png","hash":"e2ade003ffadd5826ee66ec23901c2d6e8607e4e","modified":1530006567806},{"_id":"themes/hexo-theme-yilia/source/img/github.png","hash":"b84d03b32fa388dcbf149296ebd16dce6223d48d","modified":1530006567807},{"_id":"themes/hexo-theme-yilia/source/img/google.png","hash":"61a21fec7346fa3400b747ac9a201cf3d5bc013d","modified":1530006567807},{"_id":"themes/hexo-theme-yilia/source/img/img-err.png","hash":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b","modified":1530006567808},{"_id":"themes/hexo-theme-yilia/source/img/img-loading.png","hash":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031","modified":1530006567808},{"_id":"themes/hexo-theme-yilia/source/img/mail.png","hash":"fca8199cc77fdbd700a45bf56d091c82f4a67fe7","modified":1530006567808},{"_id":"themes/hexo-theme-yilia/source/img/linkedin.png","hash":"e203138fb53c257cb214e97f4e30091b9c568d2c","modified":1530006567808},{"_id":"themes/hexo-theme-yilia/source/img/pinboard.png","hash":"0891fbb6d092fa012bf936019923383d84c6aeb0","modified":1530006567808},{"_id":"themes/hexo-theme-yilia/source/img/pinterest.png","hash":"9c72917f8779c083157c6ce7a5d62ed4874f0630","modified":1530006567808},{"_id":"themes/hexo-theme-yilia/source/img/rss.png","hash":"430fd47340e75214c081abd05cd7410cf7c71b86","modified":1530006567809},{"_id":"themes/hexo-theme-yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1530006567809},{"_id":"themes/hexo-theme-yilia/source/img/search.png","hash":"1ab76b03297ae2ce61ec59dd9bf8727f1fbbcedd","modified":1530006567809},{"_id":"themes/hexo-theme-yilia/source/img/stackoverflow.png","hash":"da5dfe9043055c95e479d49c78cd3b020de608f2","modified":1530006567809},{"_id":"themes/hexo-theme-yilia/source/img/twitter.png","hash":"14dbb8e62d056525253bc0de13acd1723da7a934","modified":1530006567810},{"_id":"themes/hexo-theme-yilia/source/img/weibo.png","hash":"280dae3fd38086158b4a1b57edb94c06b1a5014b","modified":1530006567810},{"_id":"themes/hexo-theme-yilia/source/img/zhihu.png","hash":"a6d6ef65e9ac82e613a311810391ebb90d9b1c1d","modified":1530006567810},{"_id":"themes/hexo-theme-yilia/source/js/instagram.js","hash":"81e13cacf4947118ed1920e59b04ccf6beef6b86","modified":1530006567811},{"_id":"themes/hexo-theme-yilia/source/js/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1530006567810},{"_id":"themes/hexo-theme-yilia/source/js/jquery.lazyload.js","hash":"c11a2e7b330d16d06feabd0a8477099adf9d6799","modified":1530006567811},{"_id":"themes/hexo-theme-yilia/source/js/main.js","hash":"e2633f282e377a4169649c9f17dc96036ad4fc64","modified":1530006567811},{"_id":"themes/hexo-theme-yilia/source/js/mobile.js","hash":"b68cc01d24e80973c48205f551da87f3f3427644","modified":1530006567811},{"_id":"themes/hexo-theme-yilia/source/js/pc.js","hash":"a5397d34a04084ee089b4b1e26457ab46ecea63e","modified":1530006567812},{"_id":"themes/hexo-theme-yilia/layout/_partial/post/category.ejs","hash":"d4f0e36f9a2167e91082dbd7d52425a06d2bebbf","modified":1530006567795},{"_id":"themes/hexo-theme-yilia/layout/_partial/post/date.ejs","hash":"c0c988334e857a77ba455a056dfa21809e7e76a5","modified":1530006567795},{"_id":"themes/hexo-theme-yilia/layout/_partial/post/duoshuo.ejs","hash":"e8399025ed3b980aedb821c92855889f5f12fd5b","modified":1530006567795},{"_id":"themes/hexo-theme-yilia/layout/_partial/post/tag.ejs","hash":"78612cfc091d7d861a70455a0dc8c3036e460879","modified":1530006567796},{"_id":"themes/hexo-theme-yilia/layout/_partial/post/nav.ejs","hash":"d19dee2082528e1844bed3aa4e4bd59f15fd7a7a","modified":1530006567796},{"_id":"themes/hexo-theme-yilia/layout/_partial/post/share.ejs","hash":"da39b4ba0c0ce4e1932fd45c5aee10e8aca41f28","modified":1530006567796},{"_id":"themes/hexo-theme-yilia/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1530006567796},{"_id":"themes/hexo-theme-yilia/source/css/_partial/article.styl","hash":"872fc4e63509fef885c939e5fd70e6ed439beced","modified":1530006567798},{"_id":"themes/hexo-theme-yilia/source/css/_partial/archive.styl","hash":"8b349f1605024dcdae054e04f02d71a2e84957c2","modified":1530006567798},{"_id":"themes/hexo-theme-yilia/source/css/_partial/header.styl","hash":"67e59feb18eee6026717cb440d86ab9551782628","modified":1530006567798},{"_id":"themes/hexo-theme-yilia/source/css/_partial/footer.styl","hash":"7ca837a4cc34db1c35f01baec85eb10ccc64ea86","modified":1530006567798},{"_id":"themes/hexo-theme-yilia/source/css/_partial/highlight.styl","hash":"8987b455f11a141d8507d722ad48241add1b0bf0","modified":1530006567799},{"_id":"themes/hexo-theme-yilia/source/css/_partial/instagram.styl","hash":"8a7b07bf5ea2d3588c0019f722c245bb1a8696af","modified":1530006567799},{"_id":"themes/hexo-theme-yilia/source/css/_partial/mobile-slider.styl","hash":"e19c7fae6968ad3ea6cfc110900a991f9b5fce31","modified":1530006567799},{"_id":"themes/hexo-theme-yilia/source/css/_partial/mobile.styl","hash":"3a03b04ef8ac305aa5dbf7b9db99cd9377d07383","modified":1530006567799},{"_id":"themes/hexo-theme-yilia/source/css/_partial/main.styl","hash":"4268f759920106a576c6037264076b36018ff73b","modified":1530006567799},{"_id":"themes/hexo-theme-yilia/source/css/_partial/page.styl","hash":"720b5b169bc28ccba3794efce9b7cd39f243dec7","modified":1530006567800},{"_id":"themes/hexo-theme-yilia/source/css/_partial/scroll.styl","hash":"5539a38f9acd603d453a0ea0d8ce10893cf83d22","modified":1530006567800},{"_id":"themes/hexo-theme-yilia/source/css/_partial/share.styl","hash":"22697b9a9877ab9f018364feb57aeea4a8313c9a","modified":1530006567800},{"_id":"themes/hexo-theme-yilia/source/css/_partial/wheelmenu.styl","hash":"74630c56944e27bef53ef0c0e391611a2eec2ed0","modified":1530006567800},{"_id":"themes/hexo-theme-yilia/source/css/_partial/tagcloud.styl","hash":"af0115de5c6455f899a2e09225b50224982c039d","modified":1530006567800},{"_id":"themes/hexo-theme-yilia/source/css/_util/mixin.styl","hash":"429bad87fc156eacf226c5e35b0eafc277f2504b","modified":1530006567801},{"_id":"themes/hexo-theme-yilia/source/css/_util/grid.styl","hash":"1aa883ab432d9e4139c89dcbd40ae2bd1528d029","modified":1530006567800},{"_id":"themes/hexo-theme-yilia/source/css/fonts/fontawesome-webfont.svgz","hash":"4bfdd33ed702e32ae01399fcc2652377f78e7626","modified":1530006567802},{"_id":"themes/hexo-theme-yilia/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1530006567804},{"_id":"themes/hexo-theme-yilia/source/css/fonts/fontawesome-webfont.eot","hash":"3ce87b82c7a4ffdf65e96765c2ffda10b1a283c6","modified":1530006567801},{"_id":"themes/hexo-theme-yilia/source/css/fonts/fontawesome-webfont.woff","hash":"cafc4ac5761a0a252d33dce4ea3952cf9a38d832","modified":1530006567803},{"_id":"themes/hexo-theme-yilia/source/css/fonts/fontawesome-webfont.ttf","hash":"1480b8101b02da9bc4c60341b5e185e63e585064","modified":1530006567802},{"_id":"themes/hexo-theme-yilia/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1530006567805},{"_id":"themes/hexo-theme-yilia/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1530006567805},{"_id":"themes/hexo-theme-yilia/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1530006567805},{"_id":"themes/hexo-theme-yilia/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1530006567805},{"_id":"themes/hexo-theme-yilia/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1530006567805},{"_id":"themes/hexo-theme-yilia/source/img/e4de299979dcde1b881d6ccacf9e2518_b.png","hash":"0efcc2289584743f2cfaf8086d5219e701426065","modified":1530006567807},{"_id":"themes/hexo-theme-yilia/source/css/fonts/fontawesome-webfont.svg","hash":"ba13657479b46daecb6336bfe376f84cef3ae58b","modified":1530006567802}],"Category":[{"name":"erlang","_id":"ckqw7jdvj00046f1rdocwffqu"},{"name":"Erlang","_id":"ckqw7jdvo000a6f1rbcmu8okt"},{"name":"教程","_id":"ckqw7jdvw000n6f1rfy60dttg"},{"name":"markdown","_id":"ckqw7jdw0000v6f1rh4e4awmo"},{"name":"杂谈","_id":"ckqw7jdwg001v6f1r9btv59vu"},{"name":"二次元","_id":"ckqw7jdwj00236f1r250tbsqu"},{"name":"hexo","_id":"ckqw7jdwo002f6f1req9g2vy5"}],"Data":[],"Page":[{"layout":"false","_content":"BA4RKG2m6D\n","source":"baidu_verify_BA4RKG2m6D.html","raw":"layout: false\n---\nBA4RKG2m6D\n","date":"2018-06-26T09:49:27.741Z","updated":"2018-06-26T09:49:27.741Z","path":"baidu_verify_BA4RKG2m6D.html","title":"","comments":1,"_id":"ckqw7jdvb00006f1r49ilhtbq","content":"BA4RKG2m6D","site":{"data":{}},"excerpt":"","more":"BA4RKG2m6D"},{"layout":"false","_content":"google-site-verification: google7c485c194d355632.html\n","source":"google7c485c194d355632.html","raw":"layout: false\n---\ngoogle-site-verification: google7c485c194d355632.html\n","date":"2018-06-26T09:49:27.741Z","updated":"2018-06-26T09:49:27.741Z","path":"google7c485c194d355632.html","title":"","comments":1,"_id":"ckqw7jdvh00026f1r2wuta72b","content":"google-site-verification: google7c485c194d355632.html","site":{"data":{}},"excerpt":"","more":"google-site-verification: google7c485c194d355632.html"},{"title":"about","date":"2014-06-16T11:32:31.000Z","_content":"![](http://youthy-picture.qiniudn.com/u=3721929596,1825898289&fm=21&gp=0.jpg)\n###  博主:youthy\n###  学校:BUPT\n###  Email:yuyouqi101205@gmail.com\n","source":"about/index.md","raw":"title: about\ndate: 2014-06-16 19:32:31\n---\n![](http://youthy-picture.qiniudn.com/u=3721929596,1825898289&fm=21&gp=0.jpg)\n###  博主:youthy\n###  学校:BUPT\n###  Email:yuyouqi101205@gmail.com\n","updated":"2018-06-26T09:49:27.740Z","path":"about/index.html","comments":1,"layout":"page","_id":"ckqw7jdvl00066f1rerfwcv0j","content":"<p><img src=\"http://youthy-picture.qiniudn.com/u=3721929596,1825898289&amp;fm=21&amp;gp=0.jpg\" alt=\"\"></p>\n<h3 id=\"博主:youthy\">博主:youthy</h3><h3 id=\"学校:BUPT\">学校:BUPT</h3><h3 id=\"Email:yuyouqi101205@gmail-com\">Email:<a href=\"mailto:yuyouqi101205@gmail.com\">yuyouqi101205@gmail.com</a></h3>","site":{"data":{}},"excerpt":"","more":"<p><img src=\"http://youthy-picture.qiniudn.com/u=3721929596,1825898289&amp;fm=21&amp;gp=0.jpg\" alt=\"\"></p>\n<h3 id=\"博主:youthy\">博主:youthy</h3><h3 id=\"学校:BUPT\">学校:BUPT</h3><h3 id=\"Email:yuyouqi101205@gmail-com\">Email:<a href=\"mailto:yuyouqi101205@gmail.com\">yuyouqi101205@gmail.com</a></h3>"}],"Post":[{"title":"Erlang存储模块之ETS","date":"2014-10-25T10:31:33.000Z","toc":true,"_content":"***********\n\n<!--more-->\n<!-- toc -->\n\n## 创建:\n#### new/2\n\n> new(Name, Options) -> tid() | atom()\n\nName = atom()\nOptions = [Option]\n Option = Type | Access | named_table | {keypos,Pos} | {heir,pid(),HeirData} | {heir,none} | Tweaks\n  Type = set | ordered_set | bag | duplicate_bag\n  Access = public | protected | private\n  Tweaks = {write_concurrency,boolean()} | {read_concurrency,boolean()} | compressed\n  Pos = integer()\n  HeirData = term()\n\n首先ets中保存的是元组(tuple),元组的第一个元素为key\n\n**Type**\n即类型,set是异键表,表示这个ets中的key是唯一的,不能相同,bag表示的是同键表,它允许多个元素有相同的key,但是key之后的元素不能相同,即不能有完全相同的tuple.order_set是set的变种,表示按key排序的ets表,duplicate_bag表示key之外的元素也可以相同,即可以存在完全相同的tuple.\nset: {playerid1, <<\"yuyouqi\">>, 1},{playerid2, <<\"youthy\">>, 0}. ---default type\nbag: {playerid1, <<\"yuyouqi\">>, 1}, {playerid1, lvl90}.\nduplicate_bag: {playerid1, hello}, {playerid1, hello}....{playerid1, hello}\n\n还需要注意的是orderd_set 里面判断key是否相同用的是==而不是=:=,也就意味着1和1.0是相同的key,而其他类型的ets则不是.\n**Access**\npublic是任何进程都可读写这个ets\nprotected是只有创建者进程可以改写ets,其他进程只能读取,这个是默认选项\nprivate是只有创建者进程可以读写.\n**{keypos, Pos}**\n用来指定Pos位置为key.\n> 在不指定任何Option的时候,默认是以上三个[set, protected, {keypos, 1}]\n\n**其他**\nnamed_table 指定可以通过Name访问这个ets.\n**{heir,Pid,HeirData} | {heir,none}**这个用来控制继承,在创建一个ets时,如果声明了这个,表示这个ets的owner死掉之后,将发送{'ETS-TRANSFER',tid(),FromPid,HeirData}这个消息给Pid这个进程,其中tid()是ets的table id.看以下的例子\n```erlang\n1> HeirPid = spawn(fun() -> receive {'ETS-TRANSFER', Tid, FromPid, HeirData} -> ets:insert(Tid, HeirData), timer:sleep(100000) end end).\n%% 创建用于继承的进程\n<0.34.0>\n2> OwnerPid = spawn(fun() -> ets:new(person, [named_table, {heir, HeirPid, {1, youthy}}]), receive die -> ok end end).\n<0.36.0>\n%% 创建用于初始化ets的进程,声明heir参数.\n3> observer:start().\nok\n%% 启动观察器\n```\n![](../../../../img/选区_045.png)\n此时我们可以看到person这个表的owner是<0.36.0>\n```erlang\n4> ets:tab2list(person).\n[]\n%% person中没有任何数据\n5> OwnerPid ! die.\ndie\n%% 让OwnerPid死亡\n6> observer:start(). \nok\n7> ets:tab2list(person).\n[{1,youthy}]\n```\n\n![](../../../../img/选区_046.png)\n再次观察可以看到person这个表已经继承给了HeirPid,并且里面有了数据.数据是我主动插入的HeirData.\n\n{write_concurrency,boolean()}/{read_concurrency,boolean()}/compressed\nwrite,read默认都是false,当分别指定为true时,编译器会优化,会使write更快,read更快,但是在读写之间的切换会很慢,只适合于单纯的写表或读表.\ncompressed会压缩ets节省空间,但是对ets的操作尤其,match,select等遍历所有元素的操作会慢很多,慎用.\n**************\n## 对表的操作\n\n上面完成了对ets的创建,接下来自然就是对ets的操作.\n\n### 一.插入\n#### insert/2\n>  insert(Tab, ObjectOrObjects) -> true\nTypes:\nTab = tid() | atom()\nObjectOrObjects = tuple() | [tuple()]\n\nTab为ets的TableId, 如果声明为named_table可以为对应的名字.\n1.**insert是原子操作,BIF,不管object是多个tuple组成的list还是单独一个tuple**\n2.**如果像set表中插入具有相同key的多个元素,则只有一个能被插入,而且不知道具体哪个会被插入,如果是order_set要记住此时key相同的原则不是靠=:=而是==,也就是match(模式匹配)和equal(相等)的区别**\n#### insert_new/2\n>insert_new(Tab, ObjectOrObjects) -> boolean()\nTypes:\nTab = tid() | atom()\nObjectOrObjects = tuple() | [tuple()]\n\n大体与insert相同,只不过这个insert直插入ets中不存在键值,当发现key在ets表中已经存在,则返回false.也是原子操作,也就是就算是insert_new一个list的东西,只要有一个key存在了,这个插入就是失败的\n\n### 二.查询\n#### lookup/2\n> lookup(Tab, Key) -> [Object]\nTypes:\nTab = tid() | atom()\nKey = term()\nObject = tuple()\n \n注意结果返回是list.同样order_set是特别的,1.0与1是相同的key.\n#### lookup_element/3\n> lookup_element(Tab, Key, Pos) -> Elem\nTypes:\nTab = tid() | atom()\nKey = term()\nPos = integer()\nElem = term() | [term()]\n\n这个返回的是key的tuple里面pos位置的元素.\n```\n1> ets:new(person, [named_table, set]).\nperson\n2> ets:insert(person, {player1, man, sword}).\ntrue\n3> ets:lookup_element(person, player1, 3).\nsword\n```\n\n如果pos处不存在元素则会报bagarg错误\n### 三.删除\n#### delete/1\n> delete(Tab) -> true\nTypes:\nTab = tid() | atom()\n\n#### delete/2\n删除整个ets\n> delete(Tab, Key) -> true\nTypes:\nTab = tid() | atom()\nKey = term()\n\n#### delete_all_objects/1\n删除key所对应的键值\n> delete_all_objects(Tab) -> true\nTypes:\nTab = tid() | atom()\n\n#### delete_object/2\n删除Tab里面所有的值,与delete不同的是不会删掉这个ets\n> delete_object(Tab,Object) -> true\nTypes:\nTab = tid() | atom()\nObject = tuple()\n\n删除object,主要用于bag型,因为bag是key对应多个object,只删除这个object,而保留key对应其他的object.\nexample:\n```\n1> ets:new(ingredients, [set, named_table]).\ningredients\n2> ets:insert(ingredients, {bacon, great}).\ntrue\n3> ets:lookup(ingredients, bacon).\n[{bacon,great}]\n4> ets:insert(ingredients, [{bacon, awesome}, {cabbage, alright}]).\ntrue\n5> ets:lookup(ingredients, bacon).\n[{bacon,awesome}]\n6> ets:lookup(ingredients, cabbage).\n[{cabbage,alright}]\n7> ets:delete(ingredients, cabbage).\ntrue\n8> ets:lookup(ingredients, cabbage).\n[]\n```\n\n### 三.其他\n#### tab2list/1\n> tab2list(Tab) -> [Object]\nTypes:\nTab = tab()\nObject = tuple()\nReturns a list of all objects in the table Tab.\n\n列出Tab中所有元素\n#### all/1\n> all() -> [Tab]\nTypes:\nTab = tid() | atom()\n \n列出当前节点所有的ets\n\n#### tab2file/2\n> tab2file(Tab, Filename) -> ok | {error, Reason}\nTypes:\nTab = tab()\nFilename = file:name()\nReason = term()\nDumps the table Tab to the file Filename.\n\n#### tab2file/3\n> tab2file(Tab, Filename, Options) -> ok | {error, Reason}\nTypes:\nTab = tab()\nFilename = file:name()\nOptions = [Option]\nOption = {extended_info, [ExtInfo]}\nExtInfo = md5sum | object_count\nReason = term()\n\n将ets储存到文件,\nextended_info 选项参数指定什么额外信息要在转储过程中一同被写进，参数选项有以下值：\nobject_count：被标记在文件尾后的实际被写进文件的对象数量。\nmd5sum：在文件里的文件头数据和对象数据都会用内置的 MD5 函数来效验。所有对象数据的 MD5 校验值会被卸载文件尾，因此读取数据的验证将检测在文件数据里的校验值。\n不管参数 extended_info 是否使用，在 stdlib-1.15.1 之前的 ets 版本该参数无效。反之可以将文件中的ets读入.\n\n#### file2tab/1\n> file2tab(Filename) -> {ok, Tab} | {error, Reason}\nTypes:\nFilename = file:name()\nTab = tab()\nReason = term()\n\n#### file2tab/2\n> file2tab(Filename, Options) -> {ok, Tab} | {error, Reason}\nTypes:\nFilename = file:name()\nTab = tab()\nOptions = [Option]\nOption = {verify, boolean()}\nReason = term()\n\nfile2tab    的option是[{verify, true|false}], 默认是false,即是否验证.当指定为true时,如果tab2file时没有指定{extended_info},则写入内存时比较大小是否一致,在ets为public或者该ets在写入的时候同时更新了数据,很容易在读入时出错,所以一般需要指定{extended_info, [object_count]},写入实际写入的大小.如果指定为{extended_info, [md5sum]},则会消耗更多的时间与cpu资源来读入.\n\n\n\n```\nErlang R15B (erts-5.9) [source] [smp:2:2] [async-threads:0] [hipe] [kernel-poll:false]\n\nEshell V5.9  (abort with ^G)\n1> \n1> ets:new(person, [named_table]).\nperson\n2> ets:insert(person, {name, sex, career}).\ntrue\n3> ets:all().\n[person,8207,4110,13,file_io_servers,inet_hosts_file_byaddr,\n inet_hosts_file_byname,inet_hosts_byaddr,inet_hosts_byname,\n inet_cache,inet_db,global_pid_ids,global_pid_names,\n global_names_ext,global_names,global_locks,ac_tab]\n4> ets:tab2file(person, \"person.ets\").\nok\n5> ets:delete(person).\ntrue\n6> ets:all().\n[disk_log_pids,disk_log_names,8207,4110,13,file_io_servers,\n inet_hosts_file_byaddr,inet_hosts_file_byname,\n inet_hosts_byaddr,inet_hosts_byname,inet_cache,inet_db,\n global_pid_ids,global_pid_names,global_names_ext,\n global_names,global_locks,ac_tab]\n7> ets:file2tab(\"person.ets\").\n{ok,person}\n8> ets:all().\n[disk_log_pids,disk_log_names,person,8207,4110,13,\n file_io_servers,inet_hosts_file_byaddr,\n inet_hosts_file_byname,inet_hosts_byaddr,inet_hosts_byname,\n inet_cache,inet_db,global_pid_ids,global_pid_names,\n global_names_ext,global_names,global_locks,ac_tab]\n9> ets:tab2list(person).\n[{name,sex,career}]\n10> ets:tab2file(person, \"person.ets\", [{extended_info, [object_count]}]).\nok\n11> ets:delete(person).\ntrue\n12> ets:file2tab(\"person.ets\",[{verify, true}]).\n{ok,person}\n13> ets:tab2list(person).\n[{name,sex,career}]\n```\n\n#### first/1\n> first(Tab) -> Key | '$end_of_table'\nTypes:\nTab = tid() | atom()\nKey = term()\n\n#### last/1\n> last(Tab) -> Key | '$end_of_table'\n\n#### next/2\n> next(Tab, Key1) -> Key2 | '$end_of_table'\nTypes:\nTab = tid() | atom()\nKey1 = Key2 = term()\n\n#### prev/2\n> prev(Tab, Key1) -> Key2 | '$end_of_table'\n\nfirst返回ets第一个key,last返回最后一个key, 如果没有内容则返回end_of_table, 可以用next返回下一个key,prev返回上一个key\n```\n31> ets:tab2list(person).\n[{4,ok},{1,23},{2,34}]\n32> ets:first(person).\n2\n33> ets:next(person, 2).\n1\n34> ets:next(person, 1).\n4\n35> ets:next(person, 4).\n'$end_of_table'\n```\n\n#### foldl/3\n> foldl(Function, Acc0, Tab) -> Acc1\nTypes:\nFunction = fun((Element :: term(), AccIn) -> AccOut)\nTab = tab()\nAcc0 = Acc1 = AccIn = AccOut = term()\n\n内部实际调用的还是lists:foldl,根据看源码发现,首先通过ets:first找到第一个key,然后调用ets:lookup(Table, Key),找到第一个元素,此时返回的元素在一个list里面,然后对这个列表用lists:foldl,Function本身是对ets每个元素执行的,包括key.例子如下.\n```\n1> ets:new(double, [named_table]).\ndouble\n2> ets:insert(double, [{1, 14},{2, 12}, {3, 23}]).\ntrue\n3> ets:tab2list(double).\n[{1,14},{2,12},{3,23}]\n4> ets:foldl(fun({K, V}, Acc) -> [{K, V * 2}|Acc] end, [], double).\n[{1,28},{2,24},{3,46}]\n```\n\n#### foldr/3\n>foldr(Function, Acc0, Tab) -> Acc1\nTypes:\nFunction = fun((Element :: term(), AccIn) -> AccOut)\nTab = tab()\nAcc0 = Acc1 = AccIn = AccOut = term()\n\n同foldl.\n\n#### give_away/3\ngive_away(Tab, Pid, GiftData) -> true\nTypes:\nTab = tid() | atom()\nPid = pid()\nGiftData = term()\n类似于new的heir继承,在ets的owner进程调用,将Tab这个ets穿给Pid这个进程,传送的消息为{'ETS-TRANSFER',Tab,FromPid,GiftData},Pid可以receive这个消息做不同的事情.\n\n#### i/0 i/1\n> i() -> ok\ni(Tab) -> ok\n\n用于查看ets信息\n#### info/1 info/2\n> info(Tab) -> [{Item, Value}] | undefined\nTypes:\nTab = tid() | atom()\nItem = atom(), see below\nValue = term(), see below\ninfo(Tab, Item) -> Value | undefined\nTypes:\nTab = tid() | atom()\nItem, Value - see below\n\n当Tab是个TableId,但是这个ets已经不存在的时候会返回undefined\n\n#### match/2 match/3 match/1\n> match(Tab, Pattern) -> [Match]\nTypes:\nTab = tid() | atom()\nPattern = tuple()\nMatch = [term()]\n\n> match(Tab, Pattern, Limit) -> {[Match],Continuation} | '$end_of_table'\nTypes:\nTab = tid() | atom()\nPattern = tuple()\nMatch = [term()]\nContinuation = term()\n\n>match(Continuation) -> {[Match],Continuation} | '$end_of_table'\nTypes:\nMatch = [term()]\nContinuation = term()\n\n\n说白了就是模式匹配,lookup只能通过key查找,而实际上面对bag类型,同样的key对应很多值,我们需要额外的添加筛选条件,所以就有了match.\n```\n3> ets:new(player, [bag, named_table]).\nplayer\n4> ets:insert(player,[{player1, career1, goodsbag1},{player1, career2, goodsbag2}, {player1, career3, goodsbag3}]).\ntrue\n5> ets:tab2list(player).\n[{player1,career1,goodsbag1},\n {player1,career2,goodsbag2},\n {player1,career3,goodsbag3}]\n6> ets:match(player, {player1, '$1', goodsbag2}).\n[[career2]]\n7> ets:match(player, {player1, '$1', '_'}).      \n[[career1],[career2],[career3]]\n8> ets:match(player, {'_', '$1', 'goodsbag3'}).\n[[career3]]\n```\n\n$后面加数字用来表示想要得到的变量,'_'表示要忽略的变量.值得注意的是如果key指定的match是搞笑的,如果不指定key则需要遍历整个表,如果ets很大,则会很耗时.\n\n#### match_object/2 match_object/3\n>match_object(Tab, Pattern) -> [Object]\nTypes:\nTab = tid() | atom()\nPattern = Object = tuple()\n\n>match_object(Tab, Pattern, Limit) -> {[Match],Continuation} | '$end_of_table'\nTypes:\nTab = tid() | atom()\nPattern = tuple()\nMatch = [term()]\nContinuation = term()\n\n> match_object(Continuation) -> {[Match],Continuation} | '$end_of_table'\nTypes:\nMatch = [term()]\nContinuation = term()\n\n与match一样,只不过这个返回的是整个object,而不是$所指定的值\n#### init_table/2\n>init_table(Tab, InitFun) -> true\nTypes:\nTab = tab()\nInitFun = fun((Arg) -> Res)\nArg = read | close\nRes = end_of_input | {Objects :: [term()], InitFun} | term()\n\n 官方doc上面说\n >This function is provided for compatibility with the dets module, it is not more efficient than filling a table by using ets:insert/2\n\n我们可以看出这个是为了和dets兼容才提供了这个接口,其实效率不比insert高,\nInitFun是个fun函数,这个函数接受read和close这两个传入值, 返回结果如Res所示,如 fun(read) -> end_of_input end. 其实这个函数的文档写的有些语焉不详,我们还是可以通过官方代码直到具体什么意思.\n```erlang\n-spec init_table(Tab, InitFun) -> 'true' when\n      Tab :: tab(),\n      InitFun :: fun((Arg) -> Res),\n      Arg :: 'read' | 'close',\n      Res :: 'end_of_input' | {Objects :: [term()], InitFun} | term().\n\ninit_table(Table, Fun) ->\n    ets:delete_all_objects(Table),\n    init_table_continue(Table, Fun(read)).\n\ninit_table_continue(_Table, end_of_input) ->\n    true;\ninit_table_continue(Table, {List, Fun}) when is_list(List), is_function(Fun) ->\n    case (catch init_table_sub(Table, List)) of\n\t{'EXIT', Reason} ->\n\t    (catch Fun(close)),\n\t    exit(Reason);\n\ttrue ->\n\t    init_table_continue(Table, Fun(read))\n    end;\ninit_table_continue(_Table, Error) ->\n    exit(Error).\n\ninit_table_sub(_Table, []) ->\n    true;\ninit_table_sub(Table, [H|T]) ->\n    ets:insert(Table, H),\n    init_table_sub(Table, T).\n```\n\n可以看出首先用delete_all_objects删掉了之前ets的数据,之后在init_table_sub中分别插入List中的元素,在调用List,之后的initfun,遇到end_of_input为止. j\n举个简单的例子\n```erlang\n21> ets:new(test, [named_table]).\ntest\n22> ets:insert(test, {test1, result1}).\ntrue\n23> ets:tab2list(test).\n[{test1,result1}]\n24> ets:init_table(test, fun(read) -> {[{test2, result2},{test3, result3}], fun(read) -> end_of_input end} end).\ntrue\n25> ets:tab2list(test).\n[{test3,result3},{test2,result2}]\n```\n\n#### member/2\n> member(Tab, Key) -> true | false\n\n如果key在Tab中有值则返回true,否则false\n\n#### rename/2\n> rename(Tab, Name) -> Name\n\n重命名一个table,只对有名字的table有效\n\n#### safe_fixtable/2\n> safe_fixtable(Tab, true|false) -> true\n\n当一个进程对某个ets用了safe_fixtable(Tab, true)后,这个进程对这个ets的first和next操作的key只返回没有返回过的key,也就是说ets表中的每个key只返回一次,为什么这么说呢.我们知道ordered_set中的key是排好序的,只要不停的next,肯定会得到更大的key,加入删除了之前一个较小的key,那么再次插入时,也不过next到这个key,但是set,bag表不是,有可能在next的过程中,如果有别的进程删除了你之前遍历过的key,之后在插入,将有可能再次next到这个key,safe_fixtable的作用就是对每个结果只返回一次,这个在游戏中对线上玩家列表的操作有一定作用,ets的官方文档中的foldl等也用到了.\n>Note that no deleted objects are actually removed from a fixed table until it has been released. If a process fixes a table but never releases it, the memory used by the deleted objects will never be freed. The performance of operations on the table will also degrade significantly.\n\n值得注意的是在有进程对ets fixtable的情况对ets中数据的删除并没有真正的删除,直到这个进程死掉或者释放掉safe_fixtable为止,此时对ets的操作效率将显著降低, 所以尽量少用ets:foldl.\n可参考:http://stackoverflow.com/questions/20327171/etsfoldl-vs-deleted-elements/20338795#20338795\n\n#### setopts/2\n> setopts(Tab, Opts) -> true\n\nopts只能是[{heir,pid(),HeirData} | {heir,none}],用于在table创建后修改继承选项,只能由table的owner调用\n\n#### update_counter/3\n> update_counter(Tab, Key, UpdateOp) -> Result\nupdate_counter(Tab, Key, [UpdateOp]) -> [Result]\nupdate_counter(Tab, Key, Incr) -> Result\nTypes:\nTab = tid() | atom()\nKey = term()\nUpdateOp = {Pos,Incr} | {Pos,Incr,Threshold,SetValue}\nPos = Incr = Threshold = SetValue = Result = integer()\n\n更新ets中的数据,省去从ets去数据,相加在存入这个流程, Threshold是阈值,根据incr的正负,当结果大于或小于阈值时,将值设为SetValue.\n***只能用于set和ordered_set***\n```erlang\n3> ets:new(test, [named_table]).\ntest\n4> \n4> ets:insert(test,[{one, 1},{two, 2},{three, 3},{four, 4}]).\ntrue\n5> ets:update_counter(test, one, 1). \n2\n6> ets:tab2list(test).\n[{two,2},{three,3},{one,2},{four,4}]\n7> ets:insert(test,{five, haha, 5}).\ntrue\n8> ets:update_counter(test, five, {3, 1}).\n6\n9> ets:tab2list(test).\n[{two,2},{five,haha,6},{three,3},{one,2},{four,4}]\n10> ets:update_counter(test, five, {3, 1, 6, 5}).\n5\n11> ets:tab2list(test).\n[{two,2},{five,haha,5},{three,3},{one,2},{four,4}]\n```\n\n#### update_element/3\n> update_element(Tab, Key, {Pos,Value}) -> true | false\nupdate_element(Tab, Key, [{Pos,Value}]) -> true | false\nTypes:\nTab = tid() | atom()\nKey = Value = term()\nPos = integer()\n\n大致跟上面一样,未找到Key会返回false.\n\n\n### 所有关于match specification\n\n下面的函数都有用到MatchSpec这个数据类型，\n定义见: [doc]: (http://www.erlang.org/doc/apps/erts/match_spec.html).\nmatch specification用于更为复杂的匹配情况,可以用于ets和erlang:trace_pattern中,一个ms的具体例子可能如下\n\n![](../../../../img/ets1.png)\n\n乍看之下是非常难懂的,抽象一下大致是这个样子\n[{InitialPattern1, Guards1, ReturnedValue1},\n{InitialPattern2, Guards2, ReturnedValue2}].\n上面的{'$1','$2',<<1>>,'$3','$4'}是InitialPattern, [{'andalso',{'>','$4',150},{'<','$4',500}},\n{'orelse',{'==','$2',meat},{'==','$2',dairy}}]和[{'<','$3',4.0},{is_float,'$3'}]是Guards1和Guards2,['$1']是returnedvalue.\n\nInitialPattern是将变量绑定到具体的$数字上,然后通过guard,得到returnvalue.\nGuard的语序是{FunctionOrOperator, Arg1, ..., ArgN},'andalso' 'orelse'和'<'等属于FunctionorOperator,后面的是参数.\n{'andalso',{'>','$4',150},{'<','$4',500}}翻译过来就是 when $4 > 150 andalso $4 < 500.\n如果满足这个Guard就返回$1.\n\n当然让我们去写这样一个match是很不符合人类的发展的,所以我们要用到下面的函数\n#### fun2ms/1\n> fun2ms(LiteralFun) -> MatchSpec\nTypes:\nLiteralFun = function()\nMatchSpec = match_spec()\n这个函数将我们熟悉的fun函数转换成match specification的形式,这个转换过程由ms_transform完成,\n需要在模块开头加上\n***-include_lib(\"stdlib/include/ms_transform.hrl\").***\n需要注意的是fun的参数只有一个,只能是一个变量或者一个tuple不能使list等,不能使bit流.\n\n```\n1> ets:fun2ms(fun(X) when X > 10 -> X end).   \n[{'$1',[{'>','$1',10}],['$1']}]\n2> ets:fun2ms(fun({X, Y}) when X > 10, Y < 20 -> X * Y end).\n[{{'$1','$2'},\n  [{'>','$1',10},{'<','$2',20}],\n  [{'*','$1','$2'}]}]\n```\n\nms的在ets中的主要作用是用在select语句中,达到类似于mysql中select的效果\n#### select/1/2/3\n> select(Tab, MatchSpec) -> [Match]\nselect(Tab, MatchSpec, Limit) -> {[Match],Continuation} | '$end_of_table'\nselect(Continuation) -> {[Match],Continuation} | '$end_of_table'\nTypes:\nTab = tid() | atom()\nMatch = term()\nMatchSpec = match_spec()\nContinuation = term()\n\nselect/2将所有符合MatchSpec的结果返回，select/3制定了limit。返回的Continuation可以用在select/1中。为何这么做？官方说明是\n> This is a space efficient way to work on objects in a table which is still faster than traversing the table object by object using ets:first/1 and ets:next/1.\n\n这样节省空间，同时比用first，next更加快。\n下面的例子是在player表中有两个#player结构的数据。一个返回的是10010这个id的玩家，之后调用select(C)将第二个10011玩家玩家返回同时返回end of table。如果将end of table传入select会直接返回end of table。\n\n![](../../../../img/ets2.png)\n\nlearn you some erlang书中的例子，\n```\n11> rd(food, {name, calories, price, group}).\nfood\n12> ets:new(food, [ordered_set, {keypos,#food.name}, named_table]).\nfood\n13> ets:insert(food, [#food{name=salmon, calories=88, price=4.00, group=meat},\n13> #food{name=cereals, calories=178, price=2.79, group=bread},\n13> #food{name=milk, calories=150, price=3.23, group=dairy},\n13> #food{name=cake, calories=650, price=7.21, group=delicious},\n13> #food{name=bacon, calories=800, price=6.32, group=meat},\n13> #food{name=sandwich, calories=550, price=5.78, group=whatever}]).\ntrue\n14> ets:select(food, ets:fun2ms(fun(N = #food{calories=C}) when C < 600 -> N end)).\n[#food{name = cereals,calories = 178,price = 2.79,group = bread},\n#food{name = milk,calories = 150,price = 3.23,group = dairy},\n#food{name = salmon,calories = 88,price = 4.0,group = meat},\n#food{name = sandwich,calories = 550,price = 5.78,group = whatever}]\n15> ets:select_reverse(food, ets:fun2ms(fun(N = #food{calories=C}) when C < 600 -> N end)).\n[#food{name = sandwich,calories = 550,price = 5.78,group = whatever},\n#food{name = salmon,calories = 88,price = 4.0,group = meat},\n#food{name = milk,calories = 150,price = 3.23,group = dairy},\n#food{name = cereals,calories = 178,price = 2.79,group = bread}]\n```\n 同时在官方doc的ms_transform中有个多个子句的例子\n \n``` \n ets:select(emp_tab, ets:fun2ms(\n                      fun(#emp{empno = E, surname = \"Smith\" }) ->\n                              {guru,E};\n                         (#emp{empno = E, empyear = Y}) when Y < 1997  ->\n                              {inventory, E};\n                         (#emp{empno = E, empyear = Y}) when Y > 2001  ->\n                              {newbie, E};\n                         (#emp{empno = E, empyear = Y}) -> % 1997 -- 2001\n                              {rookie, E}\n                      end)).  \n```\n\n#### select_count/2\n> select_count(Tab, MatchSpec) -> NumMatched\nTypes:\nTab = tid() | atom()\nObject = tuple()\nMatchSpec = match_spec()\nNumMatched = integer()\n对MS返回为true的会计数。如下，得出player表中id大于0的玩家数。\n\n```\n ets:select_count(player, ets:fun2ms(fun(#player{id = ID}) -> ID > 0  end)).    \n2\n```\n\n#### select_delete/2\n> select_delete(Tab, MatchSpec) -> NumDeleted\nTypes:\nTab = tid() | atom()\nObject = tuple()\nMatchSpec = match_spec()\nNumDeleted = integer()\n\n大致同count，将返回true的object从表中删掉。\n\n#### select_reverse/1/2/3\n> select_reverse(Tab, MatchSpec) -> [Match]\nTypes:\nTab = tid() | atom()\nMatch = term()\nMatchSpec = match_spec()\nselect_reverse(Tab, MatchSpec, Limit) -> {[Match],Continuation} | '$end_of_table'\nTypes:\nTab = tid() | atom()\nMatch = term()\nMatchSpec = match_spec()\nContinuation = term()\nselect_reverse(Tab, MatchSpec) -> [Match]\nTypes:\nTab = tid() | atom()\nMatch = term()\nMatchSpec = match_spec()\n\n与只不过将select的结果反序，对order_set表有效，其他类型的表与select返回结果一致。\n```\n1> T = ets:new(x,[ordered_set]).\n2> [ ets:insert(T,{N}) || N <- lists:seq(1,10) ].\n...\n3> {R0,C0} = ets:select_reverse(T,[{'_',[],['$_']}],4).\n...\n4> R0.\n[{10},{9},{8},{7}]\n5> {R1,C1} = ets:select_reverse(C0).\n...\n6> R1.\n[{6},{5},{4},{3}]\n7> {R2,C2} = ets:select_reverse(C1).\n...\n8> R2.\n[{2},{1}]\n9> '$end_of_table' = ets:select_reverse(C2).\n...\n```\n\n#### match_spec_compile/1\n#### match_spec_run/2\n#### is_compiled_ms/1\n\n> match_spec_compile(MatchSpec) -> CompiledMatchSpec\nTypes:\nMatchSpec = match_spec()\nCompiledMatchSpec = comp_match_spec()\nmatch_spec_run(List,CompiledMatchSpec) -> list()\nTypes:\nList = [ tuple() ]\nCompiledMatchSpec = comp_match_spec()\nis_compiled_ms(Term) -> boolean()\nTypes:\nTerm = term()\n\nmatch_spec_compile将一个MS编译成一个不可见的内部形式供match_spec_run调用，is_compile_ms用来判断这个编译结果是否是个正确的编译，因为编译后的内部形式不能再节点间传递也不能储存在硬盘上。\n比如\n```\nets:is_compiled_ms(ets:match_spec_compile([{'_',[],[true]}])). \n```\n返回的是true\n```\nMS = ets:match_spec_compile([{'_',[],[true]}]),\nBroken = binary_to_term(term_to_binary(MS)),\nets:is_compiled_ms(Broken).\n```\n返回的是false，因为不接受外部的转化。会使其失去原有的信息。\n```\nMatchSpec = ets:fun2ms(fun({M, N}) when N > 3 -> M end),\nCompiledMatchSpec = ets:match_spec_compile(MatchSpec),\nList = [{1, 2}, {3, 4}, {5, 6}],\nets:match_spec_run(List, CompiledMatchSpec).\n```\n\n如果MatchSpec不是个合格的Ms会抛badarg的错误。\n\n#### repair_continuation/2\n> repair_continuation(Continuation, MatchSpec) -> Continuation\nTypes:\nContinuation = continuation()\nMatchSpec = match_spec()\n\n用来修复select/3返回的continuation，如果continuation在被转化为外部形势（用来在节点间传递)，会失效，但是使用repair_continuation可以恢复。\n例：\n```\n%% 无效\nT=ets:new(x,[]),\n{_,C} = ets:select(T,ets:fun2ms(fun({N,_}=A)\nwhen (N rem 10) =:= 0 ->\nA\nend),10),\nBroken = binary_to_term(term_to_binary(C)),\nets:select(Broken).\n\n%% 有效\nT=ets:new(x,[]),\nMS = ets:fun2ms(fun({N,_}=A)\nwhen (N rem 10) =:= 0 ->\nA\nend),\n{_,C} = ets:select(T,MS,10),\nBroken = binary_to_term(term_to_binary(C)),\nets:select(ets:repair_continuation(Broken,MS)).\n```\n\n\n","source":"_posts/Erlang-ETS.md","raw":"title: 'Erlang存储模块之ETS'\ndate: 2014-10-25 18:31:33\ntags: erlang\ncategories: erlang\ntoc: true\n---\n***********\n\n<!--more-->\n<!-- toc -->\n\n## 创建:\n#### new/2\n\n> new(Name, Options) -> tid() | atom()\n\nName = atom()\nOptions = [Option]\n Option = Type | Access | named_table | {keypos,Pos} | {heir,pid(),HeirData} | {heir,none} | Tweaks\n  Type = set | ordered_set | bag | duplicate_bag\n  Access = public | protected | private\n  Tweaks = {write_concurrency,boolean()} | {read_concurrency,boolean()} | compressed\n  Pos = integer()\n  HeirData = term()\n\n首先ets中保存的是元组(tuple),元组的第一个元素为key\n\n**Type**\n即类型,set是异键表,表示这个ets中的key是唯一的,不能相同,bag表示的是同键表,它允许多个元素有相同的key,但是key之后的元素不能相同,即不能有完全相同的tuple.order_set是set的变种,表示按key排序的ets表,duplicate_bag表示key之外的元素也可以相同,即可以存在完全相同的tuple.\nset: {playerid1, <<\"yuyouqi\">>, 1},{playerid2, <<\"youthy\">>, 0}. ---default type\nbag: {playerid1, <<\"yuyouqi\">>, 1}, {playerid1, lvl90}.\nduplicate_bag: {playerid1, hello}, {playerid1, hello}....{playerid1, hello}\n\n还需要注意的是orderd_set 里面判断key是否相同用的是==而不是=:=,也就意味着1和1.0是相同的key,而其他类型的ets则不是.\n**Access**\npublic是任何进程都可读写这个ets\nprotected是只有创建者进程可以改写ets,其他进程只能读取,这个是默认选项\nprivate是只有创建者进程可以读写.\n**{keypos, Pos}**\n用来指定Pos位置为key.\n> 在不指定任何Option的时候,默认是以上三个[set, protected, {keypos, 1}]\n\n**其他**\nnamed_table 指定可以通过Name访问这个ets.\n**{heir,Pid,HeirData} | {heir,none}**这个用来控制继承,在创建一个ets时,如果声明了这个,表示这个ets的owner死掉之后,将发送{'ETS-TRANSFER',tid(),FromPid,HeirData}这个消息给Pid这个进程,其中tid()是ets的table id.看以下的例子\n```erlang\n1> HeirPid = spawn(fun() -> receive {'ETS-TRANSFER', Tid, FromPid, HeirData} -> ets:insert(Tid, HeirData), timer:sleep(100000) end end).\n%% 创建用于继承的进程\n<0.34.0>\n2> OwnerPid = spawn(fun() -> ets:new(person, [named_table, {heir, HeirPid, {1, youthy}}]), receive die -> ok end end).\n<0.36.0>\n%% 创建用于初始化ets的进程,声明heir参数.\n3> observer:start().\nok\n%% 启动观察器\n```\n![](../../../../img/选区_045.png)\n此时我们可以看到person这个表的owner是<0.36.0>\n```erlang\n4> ets:tab2list(person).\n[]\n%% person中没有任何数据\n5> OwnerPid ! die.\ndie\n%% 让OwnerPid死亡\n6> observer:start(). \nok\n7> ets:tab2list(person).\n[{1,youthy}]\n```\n\n![](../../../../img/选区_046.png)\n再次观察可以看到person这个表已经继承给了HeirPid,并且里面有了数据.数据是我主动插入的HeirData.\n\n{write_concurrency,boolean()}/{read_concurrency,boolean()}/compressed\nwrite,read默认都是false,当分别指定为true时,编译器会优化,会使write更快,read更快,但是在读写之间的切换会很慢,只适合于单纯的写表或读表.\ncompressed会压缩ets节省空间,但是对ets的操作尤其,match,select等遍历所有元素的操作会慢很多,慎用.\n**************\n## 对表的操作\n\n上面完成了对ets的创建,接下来自然就是对ets的操作.\n\n### 一.插入\n#### insert/2\n>  insert(Tab, ObjectOrObjects) -> true\nTypes:\nTab = tid() | atom()\nObjectOrObjects = tuple() | [tuple()]\n\nTab为ets的TableId, 如果声明为named_table可以为对应的名字.\n1.**insert是原子操作,BIF,不管object是多个tuple组成的list还是单独一个tuple**\n2.**如果像set表中插入具有相同key的多个元素,则只有一个能被插入,而且不知道具体哪个会被插入,如果是order_set要记住此时key相同的原则不是靠=:=而是==,也就是match(模式匹配)和equal(相等)的区别**\n#### insert_new/2\n>insert_new(Tab, ObjectOrObjects) -> boolean()\nTypes:\nTab = tid() | atom()\nObjectOrObjects = tuple() | [tuple()]\n\n大体与insert相同,只不过这个insert直插入ets中不存在键值,当发现key在ets表中已经存在,则返回false.也是原子操作,也就是就算是insert_new一个list的东西,只要有一个key存在了,这个插入就是失败的\n\n### 二.查询\n#### lookup/2\n> lookup(Tab, Key) -> [Object]\nTypes:\nTab = tid() | atom()\nKey = term()\nObject = tuple()\n \n注意结果返回是list.同样order_set是特别的,1.0与1是相同的key.\n#### lookup_element/3\n> lookup_element(Tab, Key, Pos) -> Elem\nTypes:\nTab = tid() | atom()\nKey = term()\nPos = integer()\nElem = term() | [term()]\n\n这个返回的是key的tuple里面pos位置的元素.\n```\n1> ets:new(person, [named_table, set]).\nperson\n2> ets:insert(person, {player1, man, sword}).\ntrue\n3> ets:lookup_element(person, player1, 3).\nsword\n```\n\n如果pos处不存在元素则会报bagarg错误\n### 三.删除\n#### delete/1\n> delete(Tab) -> true\nTypes:\nTab = tid() | atom()\n\n#### delete/2\n删除整个ets\n> delete(Tab, Key) -> true\nTypes:\nTab = tid() | atom()\nKey = term()\n\n#### delete_all_objects/1\n删除key所对应的键值\n> delete_all_objects(Tab) -> true\nTypes:\nTab = tid() | atom()\n\n#### delete_object/2\n删除Tab里面所有的值,与delete不同的是不会删掉这个ets\n> delete_object(Tab,Object) -> true\nTypes:\nTab = tid() | atom()\nObject = tuple()\n\n删除object,主要用于bag型,因为bag是key对应多个object,只删除这个object,而保留key对应其他的object.\nexample:\n```\n1> ets:new(ingredients, [set, named_table]).\ningredients\n2> ets:insert(ingredients, {bacon, great}).\ntrue\n3> ets:lookup(ingredients, bacon).\n[{bacon,great}]\n4> ets:insert(ingredients, [{bacon, awesome}, {cabbage, alright}]).\ntrue\n5> ets:lookup(ingredients, bacon).\n[{bacon,awesome}]\n6> ets:lookup(ingredients, cabbage).\n[{cabbage,alright}]\n7> ets:delete(ingredients, cabbage).\ntrue\n8> ets:lookup(ingredients, cabbage).\n[]\n```\n\n### 三.其他\n#### tab2list/1\n> tab2list(Tab) -> [Object]\nTypes:\nTab = tab()\nObject = tuple()\nReturns a list of all objects in the table Tab.\n\n列出Tab中所有元素\n#### all/1\n> all() -> [Tab]\nTypes:\nTab = tid() | atom()\n \n列出当前节点所有的ets\n\n#### tab2file/2\n> tab2file(Tab, Filename) -> ok | {error, Reason}\nTypes:\nTab = tab()\nFilename = file:name()\nReason = term()\nDumps the table Tab to the file Filename.\n\n#### tab2file/3\n> tab2file(Tab, Filename, Options) -> ok | {error, Reason}\nTypes:\nTab = tab()\nFilename = file:name()\nOptions = [Option]\nOption = {extended_info, [ExtInfo]}\nExtInfo = md5sum | object_count\nReason = term()\n\n将ets储存到文件,\nextended_info 选项参数指定什么额外信息要在转储过程中一同被写进，参数选项有以下值：\nobject_count：被标记在文件尾后的实际被写进文件的对象数量。\nmd5sum：在文件里的文件头数据和对象数据都会用内置的 MD5 函数来效验。所有对象数据的 MD5 校验值会被卸载文件尾，因此读取数据的验证将检测在文件数据里的校验值。\n不管参数 extended_info 是否使用，在 stdlib-1.15.1 之前的 ets 版本该参数无效。反之可以将文件中的ets读入.\n\n#### file2tab/1\n> file2tab(Filename) -> {ok, Tab} | {error, Reason}\nTypes:\nFilename = file:name()\nTab = tab()\nReason = term()\n\n#### file2tab/2\n> file2tab(Filename, Options) -> {ok, Tab} | {error, Reason}\nTypes:\nFilename = file:name()\nTab = tab()\nOptions = [Option]\nOption = {verify, boolean()}\nReason = term()\n\nfile2tab    的option是[{verify, true|false}], 默认是false,即是否验证.当指定为true时,如果tab2file时没有指定{extended_info},则写入内存时比较大小是否一致,在ets为public或者该ets在写入的时候同时更新了数据,很容易在读入时出错,所以一般需要指定{extended_info, [object_count]},写入实际写入的大小.如果指定为{extended_info, [md5sum]},则会消耗更多的时间与cpu资源来读入.\n\n\n\n```\nErlang R15B (erts-5.9) [source] [smp:2:2] [async-threads:0] [hipe] [kernel-poll:false]\n\nEshell V5.9  (abort with ^G)\n1> \n1> ets:new(person, [named_table]).\nperson\n2> ets:insert(person, {name, sex, career}).\ntrue\n3> ets:all().\n[person,8207,4110,13,file_io_servers,inet_hosts_file_byaddr,\n inet_hosts_file_byname,inet_hosts_byaddr,inet_hosts_byname,\n inet_cache,inet_db,global_pid_ids,global_pid_names,\n global_names_ext,global_names,global_locks,ac_tab]\n4> ets:tab2file(person, \"person.ets\").\nok\n5> ets:delete(person).\ntrue\n6> ets:all().\n[disk_log_pids,disk_log_names,8207,4110,13,file_io_servers,\n inet_hosts_file_byaddr,inet_hosts_file_byname,\n inet_hosts_byaddr,inet_hosts_byname,inet_cache,inet_db,\n global_pid_ids,global_pid_names,global_names_ext,\n global_names,global_locks,ac_tab]\n7> ets:file2tab(\"person.ets\").\n{ok,person}\n8> ets:all().\n[disk_log_pids,disk_log_names,person,8207,4110,13,\n file_io_servers,inet_hosts_file_byaddr,\n inet_hosts_file_byname,inet_hosts_byaddr,inet_hosts_byname,\n inet_cache,inet_db,global_pid_ids,global_pid_names,\n global_names_ext,global_names,global_locks,ac_tab]\n9> ets:tab2list(person).\n[{name,sex,career}]\n10> ets:tab2file(person, \"person.ets\", [{extended_info, [object_count]}]).\nok\n11> ets:delete(person).\ntrue\n12> ets:file2tab(\"person.ets\",[{verify, true}]).\n{ok,person}\n13> ets:tab2list(person).\n[{name,sex,career}]\n```\n\n#### first/1\n> first(Tab) -> Key | '$end_of_table'\nTypes:\nTab = tid() | atom()\nKey = term()\n\n#### last/1\n> last(Tab) -> Key | '$end_of_table'\n\n#### next/2\n> next(Tab, Key1) -> Key2 | '$end_of_table'\nTypes:\nTab = tid() | atom()\nKey1 = Key2 = term()\n\n#### prev/2\n> prev(Tab, Key1) -> Key2 | '$end_of_table'\n\nfirst返回ets第一个key,last返回最后一个key, 如果没有内容则返回end_of_table, 可以用next返回下一个key,prev返回上一个key\n```\n31> ets:tab2list(person).\n[{4,ok},{1,23},{2,34}]\n32> ets:first(person).\n2\n33> ets:next(person, 2).\n1\n34> ets:next(person, 1).\n4\n35> ets:next(person, 4).\n'$end_of_table'\n```\n\n#### foldl/3\n> foldl(Function, Acc0, Tab) -> Acc1\nTypes:\nFunction = fun((Element :: term(), AccIn) -> AccOut)\nTab = tab()\nAcc0 = Acc1 = AccIn = AccOut = term()\n\n内部实际调用的还是lists:foldl,根据看源码发现,首先通过ets:first找到第一个key,然后调用ets:lookup(Table, Key),找到第一个元素,此时返回的元素在一个list里面,然后对这个列表用lists:foldl,Function本身是对ets每个元素执行的,包括key.例子如下.\n```\n1> ets:new(double, [named_table]).\ndouble\n2> ets:insert(double, [{1, 14},{2, 12}, {3, 23}]).\ntrue\n3> ets:tab2list(double).\n[{1,14},{2,12},{3,23}]\n4> ets:foldl(fun({K, V}, Acc) -> [{K, V * 2}|Acc] end, [], double).\n[{1,28},{2,24},{3,46}]\n```\n\n#### foldr/3\n>foldr(Function, Acc0, Tab) -> Acc1\nTypes:\nFunction = fun((Element :: term(), AccIn) -> AccOut)\nTab = tab()\nAcc0 = Acc1 = AccIn = AccOut = term()\n\n同foldl.\n\n#### give_away/3\ngive_away(Tab, Pid, GiftData) -> true\nTypes:\nTab = tid() | atom()\nPid = pid()\nGiftData = term()\n类似于new的heir继承,在ets的owner进程调用,将Tab这个ets穿给Pid这个进程,传送的消息为{'ETS-TRANSFER',Tab,FromPid,GiftData},Pid可以receive这个消息做不同的事情.\n\n#### i/0 i/1\n> i() -> ok\ni(Tab) -> ok\n\n用于查看ets信息\n#### info/1 info/2\n> info(Tab) -> [{Item, Value}] | undefined\nTypes:\nTab = tid() | atom()\nItem = atom(), see below\nValue = term(), see below\ninfo(Tab, Item) -> Value | undefined\nTypes:\nTab = tid() | atom()\nItem, Value - see below\n\n当Tab是个TableId,但是这个ets已经不存在的时候会返回undefined\n\n#### match/2 match/3 match/1\n> match(Tab, Pattern) -> [Match]\nTypes:\nTab = tid() | atom()\nPattern = tuple()\nMatch = [term()]\n\n> match(Tab, Pattern, Limit) -> {[Match],Continuation} | '$end_of_table'\nTypes:\nTab = tid() | atom()\nPattern = tuple()\nMatch = [term()]\nContinuation = term()\n\n>match(Continuation) -> {[Match],Continuation} | '$end_of_table'\nTypes:\nMatch = [term()]\nContinuation = term()\n\n\n说白了就是模式匹配,lookup只能通过key查找,而实际上面对bag类型,同样的key对应很多值,我们需要额外的添加筛选条件,所以就有了match.\n```\n3> ets:new(player, [bag, named_table]).\nplayer\n4> ets:insert(player,[{player1, career1, goodsbag1},{player1, career2, goodsbag2}, {player1, career3, goodsbag3}]).\ntrue\n5> ets:tab2list(player).\n[{player1,career1,goodsbag1},\n {player1,career2,goodsbag2},\n {player1,career3,goodsbag3}]\n6> ets:match(player, {player1, '$1', goodsbag2}).\n[[career2]]\n7> ets:match(player, {player1, '$1', '_'}).      \n[[career1],[career2],[career3]]\n8> ets:match(player, {'_', '$1', 'goodsbag3'}).\n[[career3]]\n```\n\n$后面加数字用来表示想要得到的变量,'_'表示要忽略的变量.值得注意的是如果key指定的match是搞笑的,如果不指定key则需要遍历整个表,如果ets很大,则会很耗时.\n\n#### match_object/2 match_object/3\n>match_object(Tab, Pattern) -> [Object]\nTypes:\nTab = tid() | atom()\nPattern = Object = tuple()\n\n>match_object(Tab, Pattern, Limit) -> {[Match],Continuation} | '$end_of_table'\nTypes:\nTab = tid() | atom()\nPattern = tuple()\nMatch = [term()]\nContinuation = term()\n\n> match_object(Continuation) -> {[Match],Continuation} | '$end_of_table'\nTypes:\nMatch = [term()]\nContinuation = term()\n\n与match一样,只不过这个返回的是整个object,而不是$所指定的值\n#### init_table/2\n>init_table(Tab, InitFun) -> true\nTypes:\nTab = tab()\nInitFun = fun((Arg) -> Res)\nArg = read | close\nRes = end_of_input | {Objects :: [term()], InitFun} | term()\n\n 官方doc上面说\n >This function is provided for compatibility with the dets module, it is not more efficient than filling a table by using ets:insert/2\n\n我们可以看出这个是为了和dets兼容才提供了这个接口,其实效率不比insert高,\nInitFun是个fun函数,这个函数接受read和close这两个传入值, 返回结果如Res所示,如 fun(read) -> end_of_input end. 其实这个函数的文档写的有些语焉不详,我们还是可以通过官方代码直到具体什么意思.\n```erlang\n-spec init_table(Tab, InitFun) -> 'true' when\n      Tab :: tab(),\n      InitFun :: fun((Arg) -> Res),\n      Arg :: 'read' | 'close',\n      Res :: 'end_of_input' | {Objects :: [term()], InitFun} | term().\n\ninit_table(Table, Fun) ->\n    ets:delete_all_objects(Table),\n    init_table_continue(Table, Fun(read)).\n\ninit_table_continue(_Table, end_of_input) ->\n    true;\ninit_table_continue(Table, {List, Fun}) when is_list(List), is_function(Fun) ->\n    case (catch init_table_sub(Table, List)) of\n\t{'EXIT', Reason} ->\n\t    (catch Fun(close)),\n\t    exit(Reason);\n\ttrue ->\n\t    init_table_continue(Table, Fun(read))\n    end;\ninit_table_continue(_Table, Error) ->\n    exit(Error).\n\ninit_table_sub(_Table, []) ->\n    true;\ninit_table_sub(Table, [H|T]) ->\n    ets:insert(Table, H),\n    init_table_sub(Table, T).\n```\n\n可以看出首先用delete_all_objects删掉了之前ets的数据,之后在init_table_sub中分别插入List中的元素,在调用List,之后的initfun,遇到end_of_input为止. j\n举个简单的例子\n```erlang\n21> ets:new(test, [named_table]).\ntest\n22> ets:insert(test, {test1, result1}).\ntrue\n23> ets:tab2list(test).\n[{test1,result1}]\n24> ets:init_table(test, fun(read) -> {[{test2, result2},{test3, result3}], fun(read) -> end_of_input end} end).\ntrue\n25> ets:tab2list(test).\n[{test3,result3},{test2,result2}]\n```\n\n#### member/2\n> member(Tab, Key) -> true | false\n\n如果key在Tab中有值则返回true,否则false\n\n#### rename/2\n> rename(Tab, Name) -> Name\n\n重命名一个table,只对有名字的table有效\n\n#### safe_fixtable/2\n> safe_fixtable(Tab, true|false) -> true\n\n当一个进程对某个ets用了safe_fixtable(Tab, true)后,这个进程对这个ets的first和next操作的key只返回没有返回过的key,也就是说ets表中的每个key只返回一次,为什么这么说呢.我们知道ordered_set中的key是排好序的,只要不停的next,肯定会得到更大的key,加入删除了之前一个较小的key,那么再次插入时,也不过next到这个key,但是set,bag表不是,有可能在next的过程中,如果有别的进程删除了你之前遍历过的key,之后在插入,将有可能再次next到这个key,safe_fixtable的作用就是对每个结果只返回一次,这个在游戏中对线上玩家列表的操作有一定作用,ets的官方文档中的foldl等也用到了.\n>Note that no deleted objects are actually removed from a fixed table until it has been released. If a process fixes a table but never releases it, the memory used by the deleted objects will never be freed. The performance of operations on the table will also degrade significantly.\n\n值得注意的是在有进程对ets fixtable的情况对ets中数据的删除并没有真正的删除,直到这个进程死掉或者释放掉safe_fixtable为止,此时对ets的操作效率将显著降低, 所以尽量少用ets:foldl.\n可参考:http://stackoverflow.com/questions/20327171/etsfoldl-vs-deleted-elements/20338795#20338795\n\n#### setopts/2\n> setopts(Tab, Opts) -> true\n\nopts只能是[{heir,pid(),HeirData} | {heir,none}],用于在table创建后修改继承选项,只能由table的owner调用\n\n#### update_counter/3\n> update_counter(Tab, Key, UpdateOp) -> Result\nupdate_counter(Tab, Key, [UpdateOp]) -> [Result]\nupdate_counter(Tab, Key, Incr) -> Result\nTypes:\nTab = tid() | atom()\nKey = term()\nUpdateOp = {Pos,Incr} | {Pos,Incr,Threshold,SetValue}\nPos = Incr = Threshold = SetValue = Result = integer()\n\n更新ets中的数据,省去从ets去数据,相加在存入这个流程, Threshold是阈值,根据incr的正负,当结果大于或小于阈值时,将值设为SetValue.\n***只能用于set和ordered_set***\n```erlang\n3> ets:new(test, [named_table]).\ntest\n4> \n4> ets:insert(test,[{one, 1},{two, 2},{three, 3},{four, 4}]).\ntrue\n5> ets:update_counter(test, one, 1). \n2\n6> ets:tab2list(test).\n[{two,2},{three,3},{one,2},{four,4}]\n7> ets:insert(test,{five, haha, 5}).\ntrue\n8> ets:update_counter(test, five, {3, 1}).\n6\n9> ets:tab2list(test).\n[{two,2},{five,haha,6},{three,3},{one,2},{four,4}]\n10> ets:update_counter(test, five, {3, 1, 6, 5}).\n5\n11> ets:tab2list(test).\n[{two,2},{five,haha,5},{three,3},{one,2},{four,4}]\n```\n\n#### update_element/3\n> update_element(Tab, Key, {Pos,Value}) -> true | false\nupdate_element(Tab, Key, [{Pos,Value}]) -> true | false\nTypes:\nTab = tid() | atom()\nKey = Value = term()\nPos = integer()\n\n大致跟上面一样,未找到Key会返回false.\n\n\n### 所有关于match specification\n\n下面的函数都有用到MatchSpec这个数据类型，\n定义见: [doc]: (http://www.erlang.org/doc/apps/erts/match_spec.html).\nmatch specification用于更为复杂的匹配情况,可以用于ets和erlang:trace_pattern中,一个ms的具体例子可能如下\n\n![](../../../../img/ets1.png)\n\n乍看之下是非常难懂的,抽象一下大致是这个样子\n[{InitialPattern1, Guards1, ReturnedValue1},\n{InitialPattern2, Guards2, ReturnedValue2}].\n上面的{'$1','$2',<<1>>,'$3','$4'}是InitialPattern, [{'andalso',{'>','$4',150},{'<','$4',500}},\n{'orelse',{'==','$2',meat},{'==','$2',dairy}}]和[{'<','$3',4.0},{is_float,'$3'}]是Guards1和Guards2,['$1']是returnedvalue.\n\nInitialPattern是将变量绑定到具体的$数字上,然后通过guard,得到returnvalue.\nGuard的语序是{FunctionOrOperator, Arg1, ..., ArgN},'andalso' 'orelse'和'<'等属于FunctionorOperator,后面的是参数.\n{'andalso',{'>','$4',150},{'<','$4',500}}翻译过来就是 when $4 > 150 andalso $4 < 500.\n如果满足这个Guard就返回$1.\n\n当然让我们去写这样一个match是很不符合人类的发展的,所以我们要用到下面的函数\n#### fun2ms/1\n> fun2ms(LiteralFun) -> MatchSpec\nTypes:\nLiteralFun = function()\nMatchSpec = match_spec()\n这个函数将我们熟悉的fun函数转换成match specification的形式,这个转换过程由ms_transform完成,\n需要在模块开头加上\n***-include_lib(\"stdlib/include/ms_transform.hrl\").***\n需要注意的是fun的参数只有一个,只能是一个变量或者一个tuple不能使list等,不能使bit流.\n\n```\n1> ets:fun2ms(fun(X) when X > 10 -> X end).   \n[{'$1',[{'>','$1',10}],['$1']}]\n2> ets:fun2ms(fun({X, Y}) when X > 10, Y < 20 -> X * Y end).\n[{{'$1','$2'},\n  [{'>','$1',10},{'<','$2',20}],\n  [{'*','$1','$2'}]}]\n```\n\nms的在ets中的主要作用是用在select语句中,达到类似于mysql中select的效果\n#### select/1/2/3\n> select(Tab, MatchSpec) -> [Match]\nselect(Tab, MatchSpec, Limit) -> {[Match],Continuation} | '$end_of_table'\nselect(Continuation) -> {[Match],Continuation} | '$end_of_table'\nTypes:\nTab = tid() | atom()\nMatch = term()\nMatchSpec = match_spec()\nContinuation = term()\n\nselect/2将所有符合MatchSpec的结果返回，select/3制定了limit。返回的Continuation可以用在select/1中。为何这么做？官方说明是\n> This is a space efficient way to work on objects in a table which is still faster than traversing the table object by object using ets:first/1 and ets:next/1.\n\n这样节省空间，同时比用first，next更加快。\n下面的例子是在player表中有两个#player结构的数据。一个返回的是10010这个id的玩家，之后调用select(C)将第二个10011玩家玩家返回同时返回end of table。如果将end of table传入select会直接返回end of table。\n\n![](../../../../img/ets2.png)\n\nlearn you some erlang书中的例子，\n```\n11> rd(food, {name, calories, price, group}).\nfood\n12> ets:new(food, [ordered_set, {keypos,#food.name}, named_table]).\nfood\n13> ets:insert(food, [#food{name=salmon, calories=88, price=4.00, group=meat},\n13> #food{name=cereals, calories=178, price=2.79, group=bread},\n13> #food{name=milk, calories=150, price=3.23, group=dairy},\n13> #food{name=cake, calories=650, price=7.21, group=delicious},\n13> #food{name=bacon, calories=800, price=6.32, group=meat},\n13> #food{name=sandwich, calories=550, price=5.78, group=whatever}]).\ntrue\n14> ets:select(food, ets:fun2ms(fun(N = #food{calories=C}) when C < 600 -> N end)).\n[#food{name = cereals,calories = 178,price = 2.79,group = bread},\n#food{name = milk,calories = 150,price = 3.23,group = dairy},\n#food{name = salmon,calories = 88,price = 4.0,group = meat},\n#food{name = sandwich,calories = 550,price = 5.78,group = whatever}]\n15> ets:select_reverse(food, ets:fun2ms(fun(N = #food{calories=C}) when C < 600 -> N end)).\n[#food{name = sandwich,calories = 550,price = 5.78,group = whatever},\n#food{name = salmon,calories = 88,price = 4.0,group = meat},\n#food{name = milk,calories = 150,price = 3.23,group = dairy},\n#food{name = cereals,calories = 178,price = 2.79,group = bread}]\n```\n 同时在官方doc的ms_transform中有个多个子句的例子\n \n``` \n ets:select(emp_tab, ets:fun2ms(\n                      fun(#emp{empno = E, surname = \"Smith\" }) ->\n                              {guru,E};\n                         (#emp{empno = E, empyear = Y}) when Y < 1997  ->\n                              {inventory, E};\n                         (#emp{empno = E, empyear = Y}) when Y > 2001  ->\n                              {newbie, E};\n                         (#emp{empno = E, empyear = Y}) -> % 1997 -- 2001\n                              {rookie, E}\n                      end)).  \n```\n\n#### select_count/2\n> select_count(Tab, MatchSpec) -> NumMatched\nTypes:\nTab = tid() | atom()\nObject = tuple()\nMatchSpec = match_spec()\nNumMatched = integer()\n对MS返回为true的会计数。如下，得出player表中id大于0的玩家数。\n\n```\n ets:select_count(player, ets:fun2ms(fun(#player{id = ID}) -> ID > 0  end)).    \n2\n```\n\n#### select_delete/2\n> select_delete(Tab, MatchSpec) -> NumDeleted\nTypes:\nTab = tid() | atom()\nObject = tuple()\nMatchSpec = match_spec()\nNumDeleted = integer()\n\n大致同count，将返回true的object从表中删掉。\n\n#### select_reverse/1/2/3\n> select_reverse(Tab, MatchSpec) -> [Match]\nTypes:\nTab = tid() | atom()\nMatch = term()\nMatchSpec = match_spec()\nselect_reverse(Tab, MatchSpec, Limit) -> {[Match],Continuation} | '$end_of_table'\nTypes:\nTab = tid() | atom()\nMatch = term()\nMatchSpec = match_spec()\nContinuation = term()\nselect_reverse(Tab, MatchSpec) -> [Match]\nTypes:\nTab = tid() | atom()\nMatch = term()\nMatchSpec = match_spec()\n\n与只不过将select的结果反序，对order_set表有效，其他类型的表与select返回结果一致。\n```\n1> T = ets:new(x,[ordered_set]).\n2> [ ets:insert(T,{N}) || N <- lists:seq(1,10) ].\n...\n3> {R0,C0} = ets:select_reverse(T,[{'_',[],['$_']}],4).\n...\n4> R0.\n[{10},{9},{8},{7}]\n5> {R1,C1} = ets:select_reverse(C0).\n...\n6> R1.\n[{6},{5},{4},{3}]\n7> {R2,C2} = ets:select_reverse(C1).\n...\n8> R2.\n[{2},{1}]\n9> '$end_of_table' = ets:select_reverse(C2).\n...\n```\n\n#### match_spec_compile/1\n#### match_spec_run/2\n#### is_compiled_ms/1\n\n> match_spec_compile(MatchSpec) -> CompiledMatchSpec\nTypes:\nMatchSpec = match_spec()\nCompiledMatchSpec = comp_match_spec()\nmatch_spec_run(List,CompiledMatchSpec) -> list()\nTypes:\nList = [ tuple() ]\nCompiledMatchSpec = comp_match_spec()\nis_compiled_ms(Term) -> boolean()\nTypes:\nTerm = term()\n\nmatch_spec_compile将一个MS编译成一个不可见的内部形式供match_spec_run调用，is_compile_ms用来判断这个编译结果是否是个正确的编译，因为编译后的内部形式不能再节点间传递也不能储存在硬盘上。\n比如\n```\nets:is_compiled_ms(ets:match_spec_compile([{'_',[],[true]}])). \n```\n返回的是true\n```\nMS = ets:match_spec_compile([{'_',[],[true]}]),\nBroken = binary_to_term(term_to_binary(MS)),\nets:is_compiled_ms(Broken).\n```\n返回的是false，因为不接受外部的转化。会使其失去原有的信息。\n```\nMatchSpec = ets:fun2ms(fun({M, N}) when N > 3 -> M end),\nCompiledMatchSpec = ets:match_spec_compile(MatchSpec),\nList = [{1, 2}, {3, 4}, {5, 6}],\nets:match_spec_run(List, CompiledMatchSpec).\n```\n\n如果MatchSpec不是个合格的Ms会抛badarg的错误。\n\n#### repair_continuation/2\n> repair_continuation(Continuation, MatchSpec) -> Continuation\nTypes:\nContinuation = continuation()\nMatchSpec = match_spec()\n\n用来修复select/3返回的continuation，如果continuation在被转化为外部形势（用来在节点间传递)，会失效，但是使用repair_continuation可以恢复。\n例：\n```\n%% 无效\nT=ets:new(x,[]),\n{_,C} = ets:select(T,ets:fun2ms(fun({N,_}=A)\nwhen (N rem 10) =:= 0 ->\nA\nend),10),\nBroken = binary_to_term(term_to_binary(C)),\nets:select(Broken).\n\n%% 有效\nT=ets:new(x,[]),\nMS = ets:fun2ms(fun({N,_}=A)\nwhen (N rem 10) =:= 0 ->\nA\nend),\n{_,C} = ets:select(T,MS,10),\nBroken = binary_to_term(term_to_binary(C)),\nets:select(ets:repair_continuation(Broken,MS)).\n```\n\n\n","slug":"Erlang-ETS","published":1,"updated":"2018-06-26T09:49:27.732Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqw7jdve00016f1rerd94mqo","content":"<hr>\n<span id=\"more\"></span>\n<!-- toc -->\n<ul>\n<li><a href=\"#---\">创建:</a><ul>\n<li><a href=\"#new-2\">new/2</a></li>\n</ul>\n</li>\n<li><a href=\"#-----\">对表的操作</a><ul>\n<li><a href=\"#---\">一.插入</a><ul>\n<li><a href=\"#insert-2\">insert/2</a></li>\n<li><a href=\"#insert-new-2\">insert_new/2</a></li>\n</ul>\n</li>\n<li><a href=\"#---\">二.查询</a><ul>\n<li><a href=\"#lookup-2\">lookup/2</a></li>\n<li><a href=\"#lookup-element-3\">lookup_element/3</a></li>\n</ul>\n</li>\n<li><a href=\"#---\">三.删除</a><ul>\n<li><a href=\"#delete-1\">delete/1</a></li>\n<li><a href=\"#delete-2\">delete/2</a></li>\n<li><a href=\"#delete-all-objects-1\">delete_all_objects/1</a></li>\n<li><a href=\"#delete-object-2\">delete_object/2</a></li>\n</ul>\n</li>\n<li><a href=\"#---\">三.其他</a><ul>\n<li><a href=\"#tab2list-1\">tab2list/1</a></li>\n<li><a href=\"#all-1\">all/1</a></li>\n<li><a href=\"#tab2file-2\">tab2file/2</a></li>\n<li><a href=\"#tab2file-3\">tab2file/3</a></li>\n<li><a href=\"#file2tab-1\">file2tab/1</a></li>\n<li><a href=\"#file2tab-2\">file2tab/2</a></li>\n<li><a href=\"#first-1\">first/1</a></li>\n<li><a href=\"#last-1\">last/1</a></li>\n<li><a href=\"#next-2\">next/2</a></li>\n<li><a href=\"#prev-2\">prev/2</a></li>\n<li><a href=\"#foldl-3\">foldl/3</a></li>\n<li><a href=\"#foldr-3\">foldr/3</a></li>\n<li><a href=\"#give-away-3\">give_away/3</a></li>\n<li><a href=\"#i-0-i-1\">i/0 i/1</a></li>\n<li><a href=\"#info-1-info-2\">info/1 info/2</a></li>\n<li><a href=\"#match-2-match-3-match-1\">match/2 match/3 match/1</a></li>\n<li><a href=\"#match-object-2-match-object-3\">match_object/2 match_object/3</a></li>\n<li><a href=\"#init-table-2\">init_table/2</a></li>\n<li><a href=\"#member-2\">member/2</a></li>\n<li><a href=\"#rename-2\">rename/2</a></li>\n<li><a href=\"#safe-fixtable-2\">safe_fixtable/2</a></li>\n<li><a href=\"#setopts-2\">setopts/2</a></li>\n<li><a href=\"#update-counter-3\">update_counter/3</a></li>\n<li><a href=\"#update-element-3\">update_element/3</a></li>\n</ul>\n</li>\n<li><a href=\"#----match-specification\">所有关于match specification</a><ul>\n<li><a href=\"#fun2ms-1\">fun2ms/1</a></li>\n<li><a href=\"#select-1-2-3\">select/1/2/3</a></li>\n<li><a href=\"#select-count-2\">select_count/2</a></li>\n<li><a href=\"#select-delete-2\">select_delete/2</a></li>\n<li><a href=\"#select-reverse-1-2-3\">select_reverse/1/2/3</a></li>\n<li><a href=\"#match-spec-compile-1\">match_spec_compile/1</a></li>\n<li><a href=\"#match-spec-run-2\">match_spec_run/2</a></li>\n<li><a href=\"#is-compiled-ms-1\">is_compiled_ms/1</a></li>\n<li><a href=\"#repair-continuation-2\">repair_continuation/2</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<!-- tocstop -->\n<h2 id=\"创建:\">创建:</h2><h4 id=\"new/2\">new/2</h4><blockquote>\n<p>new(Name, Options) -&gt; tid() | atom()</p>\n</blockquote>\n<p>Name = atom()<br>Options = [Option]<br> Option = Type | Access | named_table | {keypos,Pos} | {heir,pid(),HeirData} | {heir,none} | Tweaks<br>  Type = set | ordered_set | bag | duplicate_bag<br>  Access = public | protected | private<br>  Tweaks = {write_concurrency,boolean()} | {read_concurrency,boolean()} | compressed<br>  Pos = integer()<br>  HeirData = term()</p>\n<p>首先ets中保存的是元组(tuple),元组的第一个元素为key</p>\n<p><strong>Type</strong><br>即类型,set是异键表,表示这个ets中的key是唯一的,不能相同,bag表示的是同键表,它允许多个元素有相同的key,但是key之后的元素不能相同,即不能有完全相同的tuple.order_set是set的变种,表示按key排序的ets表,duplicate_bag表示key之外的元素也可以相同,即可以存在完全相同的tuple.<br>set: {playerid1, &lt;&lt;&quot;yuyouqi&quot;&gt;&gt;, 1},{playerid2, &lt;&lt;&quot;youthy&quot;&gt;&gt;, 0}. ---default type<br>bag: {playerid1, &lt;&lt;&quot;yuyouqi&quot;&gt;&gt;, 1}, {playerid1, lvl90}.<br>duplicate_bag: {playerid1, hello}, {playerid1, hello}....{playerid1, hello}</p>\n<p>还需要注意的是orderd_set 里面判断key是否相同用的是==而不是=:=,也就意味着1和1.0是相同的key,而其他类型的ets则不是.<br><strong>Access</strong><br>public是任何进程都可读写这个ets<br>protected是只有创建者进程可以改写ets,其他进程只能读取,这个是默认选项<br>private是只有创建者进程可以读写.<br><strong>{keypos, Pos}</strong><br>用来指定Pos位置为key.</p>\n<blockquote>\n<p>在不指定任何Option的时候,默认是以上三个[set, protected, {keypos, 1}]</p>\n</blockquote>\n<p><strong>其他</strong><br>named_table 指定可以通过Name访问这个ets.<br><strong>{heir,Pid,HeirData} | {heir,none}</strong>这个用来控制继承,在创建一个ets时,如果声明了这个,表示这个ets的owner死掉之后,将发送{&#39;ETS-TRANSFER&#39;,tid(),FromPid,HeirData}这个消息给Pid这个进程,其中tid()是ets的table id.看以下的例子<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>&gt; HeirPid = spawn(<span class=\"keyword\">fun</span>() -&gt; <span class=\"keyword\">receive</span> &#123;&#x27;ETS-TRANSFER&#x27;, Tid, FromPid, HeirData&#125; -&gt; ets:insert(Tid, HeirData), timer:sleep(<span class=\"number\">100000</span>) <span class=\"keyword\">end</span> <span class=\"keyword\">end</span>).</span><br><span class=\"line\"><span class=\"comment\">%% 创建用于继承的进程</span></span><br><span class=\"line\">&lt;<span class=\"number\">0.34</span>.<span class=\"number\">0</span>&gt;</span><br><span class=\"line\"><span class=\"number\">2</span>&gt; OwnerPid = spawn(<span class=\"keyword\">fun</span>() -&gt; ets:new(person, [named_table, &#123;heir, HeirPid, &#123;<span class=\"number\">1</span>, youthy&#125;&#125;]), <span class=\"keyword\">receive</span> die -&gt; ok <span class=\"keyword\">end</span> <span class=\"keyword\">end</span>).</span><br><span class=\"line\">&lt;<span class=\"number\">0.36</span>.<span class=\"number\">0</span>&gt;</span><br><span class=\"line\"><span class=\"comment\">%% 创建用于初始化ets的进程,声明heir参数.</span></span><br><span class=\"line\"><span class=\"number\">3</span>&gt; observer:start().</span><br><span class=\"line\">ok</span><br><span class=\"line\"><span class=\"comment\">%% 启动观察器</span></span><br></pre></td></tr></table></figure><br><img src=\"../../../../img/选区_045.png\" alt=\"\"><br>此时我们可以看到person这个表的owner是&lt;0.36.0&gt;<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">4</span>&gt; ets:tab2list(person).</span><br><span class=\"line\">[]</span><br><span class=\"line\"><span class=\"comment\">%% person中没有任何数据</span></span><br><span class=\"line\"><span class=\"number\">5</span>&gt; OwnerPid ! die.</span><br><span class=\"line\">die</span><br><span class=\"line\"><span class=\"comment\">%% 让OwnerPid死亡</span></span><br><span class=\"line\"><span class=\"number\">6</span>&gt; observer:start(). </span><br><span class=\"line\">ok</span><br><span class=\"line\"><span class=\"number\">7</span>&gt; ets:tab2list(person).</span><br><span class=\"line\">[&#123;<span class=\"number\">1</span>,youthy&#125;]</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"../../../../img/选区_046.png\" alt=\"\"><br>再次观察可以看到person这个表已经继承给了HeirPid,并且里面有了数据.数据是我主动插入的HeirData.</p>\n<p>{write_concurrency,boolean()}/{read_concurrency,boolean()}/compressed<br>write,read默认都是false,当分别指定为true时,编译器会优化,会使write更快,read更快,但是在读写之间的切换会很慢,只适合于单纯的写表或读表.<br>compressed会压缩ets节省空间,但是对ets的操作尤其,match,select等遍历所有元素的操作会慢很多,慎用.</p>\n<hr>\n<h2 id=\"对表的操作\">对表的操作</h2><p>上面完成了对ets的创建,接下来自然就是对ets的操作.</p>\n<h3 id=\"一-插入\">一.插入</h3><h4 id=\"insert/2\">insert/2</h4><blockquote>\n<p> insert(Tab, ObjectOrObjects) -&gt; true<br>Types:<br>Tab = tid() | atom()<br>ObjectOrObjects = tuple() | [tuple()]</p>\n</blockquote>\n<p>Tab为ets的TableId, 如果声明为named_table可以为对应的名字.<br>1.<strong>insert是原子操作,BIF,不管object是多个tuple组成的list还是单独一个tuple</strong><br>2.<strong>如果像set表中插入具有相同key的多个元素,则只有一个能被插入,而且不知道具体哪个会被插入,如果是order_set要记住此时key相同的原则不是靠=:=而是==,也就是match(模式匹配)和equal(相等)的区别</strong></p>\n<h4 id=\"insert_new/2\">insert_new/2</h4><blockquote>\n<p>insert_new(Tab, ObjectOrObjects) -&gt; boolean()<br>Types:<br>Tab = tid() | atom()<br>ObjectOrObjects = tuple() | [tuple()]</p>\n</blockquote>\n<p>大体与insert相同,只不过这个insert直插入ets中不存在键值,当发现key在ets表中已经存在,则返回false.也是原子操作,也就是就算是insert_new一个list的东西,只要有一个key存在了,这个插入就是失败的</p>\n<h3 id=\"二-查询\">二.查询</h3><h4 id=\"lookup/2\">lookup/2</h4><blockquote>\n<p>lookup(Tab, Key) -&gt; [Object]<br>Types:<br>Tab = tid() | atom()<br>Key = term()<br>Object = tuple()</p>\n</blockquote>\n<p>注意结果返回是list.同样order_set是特别的,1.0与1是相同的key.</p>\n<h4 id=\"lookup_element/3\">lookup_element/3</h4><blockquote>\n<p>lookup_element(Tab, Key, Pos) -&gt; Elem<br>Types:<br>Tab = tid() | atom()<br>Key = term()<br>Pos = integer()<br>Elem = term() | [term()]</p>\n</blockquote>\n<p>这个返回的是key的tuple里面pos位置的元素.<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1&gt; ets:new(person, [named_table, set]).</span><br><span class=\"line\">person</span><br><span class=\"line\">2&gt; ets:insert(person, &#123;player1, man, sword&#125;).</span><br><span class=\"line\">true</span><br><span class=\"line\">3&gt; ets:lookup_element(person, player1, 3).</span><br><span class=\"line\">sword</span><br></pre></td></tr></table></figure></p>\n<p>如果pos处不存在元素则会报bagarg错误</p>\n<h3 id=\"三-删除\">三.删除</h3><h4 id=\"delete/1\">delete/1</h4><blockquote>\n<p>delete(Tab) -&gt; true<br>Types:<br>Tab = tid() | atom()</p>\n</blockquote>\n<h4 id=\"delete/2\">delete/2</h4><p>删除整个ets</p>\n<blockquote>\n<p>delete(Tab, Key) -&gt; true<br>Types:<br>Tab = tid() | atom()<br>Key = term()</p>\n</blockquote>\n<h4 id=\"delete_all_objects/1\">delete_all_objects/1</h4><p>删除key所对应的键值</p>\n<blockquote>\n<p>delete_all_objects(Tab) -&gt; true<br>Types:<br>Tab = tid() | atom()</p>\n</blockquote>\n<h4 id=\"delete_object/2\">delete_object/2</h4><p>删除Tab里面所有的值,与delete不同的是不会删掉这个ets</p>\n<blockquote>\n<p>delete_object(Tab,Object) -&gt; true<br>Types:<br>Tab = tid() | atom()<br>Object = tuple()</p>\n</blockquote>\n<p>删除object,主要用于bag型,因为bag是key对应多个object,只删除这个object,而保留key对应其他的object.<br>example:<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1&gt; ets:new(ingredients, [set, named_table]).</span><br><span class=\"line\">ingredients</span><br><span class=\"line\">2&gt; ets:insert(ingredients, &#123;bacon, great&#125;).</span><br><span class=\"line\">true</span><br><span class=\"line\">3&gt; ets:lookup(ingredients, bacon).</span><br><span class=\"line\">[&#123;bacon,great&#125;]</span><br><span class=\"line\">4&gt; ets:insert(ingredients, [&#123;bacon, awesome&#125;, &#123;cabbage, alright&#125;]).</span><br><span class=\"line\">true</span><br><span class=\"line\">5&gt; ets:lookup(ingredients, bacon).</span><br><span class=\"line\">[&#123;bacon,awesome&#125;]</span><br><span class=\"line\">6&gt; ets:lookup(ingredients, cabbage).</span><br><span class=\"line\">[&#123;cabbage,alright&#125;]</span><br><span class=\"line\">7&gt; ets:delete(ingredients, cabbage).</span><br><span class=\"line\">true</span><br><span class=\"line\">8&gt; ets:lookup(ingredients, cabbage).</span><br><span class=\"line\">[]</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"三-其他\">三.其他</h3><h4 id=\"tab2list/1\">tab2list/1</h4><blockquote>\n<p>tab2list(Tab) -&gt; [Object]<br>Types:<br>Tab = tab()<br>Object = tuple()<br>Returns a list of all objects in the table Tab.</p>\n</blockquote>\n<p>列出Tab中所有元素</p>\n<h4 id=\"all/1\">all/1</h4><blockquote>\n<p>all() -&gt; [Tab]<br>Types:<br>Tab = tid() | atom()</p>\n</blockquote>\n<p>列出当前节点所有的ets</p>\n<h4 id=\"tab2file/2\">tab2file/2</h4><blockquote>\n<p>tab2file(Tab, Filename) -&gt; ok | {error, Reason}<br>Types:<br>Tab = tab()<br>Filename = file:name()<br>Reason = term()<br>Dumps the table Tab to the file Filename.</p>\n</blockquote>\n<h4 id=\"tab2file/3\">tab2file/3</h4><blockquote>\n<p>tab2file(Tab, Filename, Options) -&gt; ok | {error, Reason}<br>Types:<br>Tab = tab()<br>Filename = file:name()<br>Options = [Option]<br>Option = {extended_info, [ExtInfo]}<br>ExtInfo = md5sum | object_count<br>Reason = term()</p>\n</blockquote>\n<p>将ets储存到文件,<br>extended_info 选项参数指定什么额外信息要在转储过程中一同被写进，参数选项有以下值：<br>object_count：被标记在文件尾后的实际被写进文件的对象数量。<br>md5sum：在文件里的文件头数据和对象数据都会用内置的 MD5 函数来效验。所有对象数据的 MD5 校验值会被卸载文件尾，因此读取数据的验证将检测在文件数据里的校验值。<br>不管参数 extended_info 是否使用，在 stdlib-1.15.1 之前的 ets 版本该参数无效。反之可以将文件中的ets读入.</p>\n<h4 id=\"file2tab/1\">file2tab/1</h4><blockquote>\n<p>file2tab(Filename) -&gt; {ok, Tab} | {error, Reason}<br>Types:<br>Filename = file:name()<br>Tab = tab()<br>Reason = term()</p>\n</blockquote>\n<h4 id=\"file2tab/2\">file2tab/2</h4><blockquote>\n<p>file2tab(Filename, Options) -&gt; {ok, Tab} | {error, Reason}<br>Types:<br>Filename = file:name()<br>Tab = tab()<br>Options = [Option]<br>Option = {verify, boolean()}<br>Reason = term()</p>\n</blockquote>\n<p>file2tab    的option是[{verify, true|false}], 默认是false,即是否验证.当指定为true时,如果tab2file时没有指定{extended_info},则写入内存时比较大小是否一致,在ets为public或者该ets在写入的时候同时更新了数据,很容易在读入时出错,所以一般需要指定{extended_info, [object_count]},写入实际写入的大小.如果指定为{extended_info, [md5sum]},则会消耗更多的时间与cpu资源来读入.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Erlang R15B (erts-5.9) [source] [smp:2:2] [async-threads:0] [hipe] [kernel-poll:false]</span><br><span class=\"line\"></span><br><span class=\"line\">Eshell V5.9  (abort with ^G)</span><br><span class=\"line\">1&gt; </span><br><span class=\"line\">1&gt; ets:new(person, [named_table]).</span><br><span class=\"line\">person</span><br><span class=\"line\">2&gt; ets:insert(person, &#123;name, sex, career&#125;).</span><br><span class=\"line\">true</span><br><span class=\"line\">3&gt; ets:all().</span><br><span class=\"line\">[person,8207,4110,13,file_io_servers,inet_hosts_file_byaddr,</span><br><span class=\"line\"> inet_hosts_file_byname,inet_hosts_byaddr,inet_hosts_byname,</span><br><span class=\"line\"> inet_cache,inet_db,global_pid_ids,global_pid_names,</span><br><span class=\"line\"> global_names_ext,global_names,global_locks,ac_tab]</span><br><span class=\"line\">4&gt; ets:tab2file(person, &quot;person.ets&quot;).</span><br><span class=\"line\">ok</span><br><span class=\"line\">5&gt; ets:delete(person).</span><br><span class=\"line\">true</span><br><span class=\"line\">6&gt; ets:all().</span><br><span class=\"line\">[disk_log_pids,disk_log_names,8207,4110,13,file_io_servers,</span><br><span class=\"line\"> inet_hosts_file_byaddr,inet_hosts_file_byname,</span><br><span class=\"line\"> inet_hosts_byaddr,inet_hosts_byname,inet_cache,inet_db,</span><br><span class=\"line\"> global_pid_ids,global_pid_names,global_names_ext,</span><br><span class=\"line\"> global_names,global_locks,ac_tab]</span><br><span class=\"line\">7&gt; ets:file2tab(&quot;person.ets&quot;).</span><br><span class=\"line\">&#123;ok,person&#125;</span><br><span class=\"line\">8&gt; ets:all().</span><br><span class=\"line\">[disk_log_pids,disk_log_names,person,8207,4110,13,</span><br><span class=\"line\"> file_io_servers,inet_hosts_file_byaddr,</span><br><span class=\"line\"> inet_hosts_file_byname,inet_hosts_byaddr,inet_hosts_byname,</span><br><span class=\"line\"> inet_cache,inet_db,global_pid_ids,global_pid_names,</span><br><span class=\"line\"> global_names_ext,global_names,global_locks,ac_tab]</span><br><span class=\"line\">9&gt; ets:tab2list(person).</span><br><span class=\"line\">[&#123;name,sex,career&#125;]</span><br><span class=\"line\">10&gt; ets:tab2file(person, &quot;person.ets&quot;, [&#123;extended_info, [object_count]&#125;]).</span><br><span class=\"line\">ok</span><br><span class=\"line\">11&gt; ets:delete(person).</span><br><span class=\"line\">true</span><br><span class=\"line\">12&gt; ets:file2tab(&quot;person.ets&quot;,[&#123;verify, true&#125;]).</span><br><span class=\"line\">&#123;ok,person&#125;</span><br><span class=\"line\">13&gt; ets:tab2list(person).</span><br><span class=\"line\">[&#123;name,sex,career&#125;]</span><br></pre></td></tr></table></figure>\n<h4 id=\"first/1\">first/1</h4><blockquote>\n<p>first(Tab) -&gt; Key | &#39;$end_of_table&#39;<br>Types:<br>Tab = tid() | atom()<br>Key = term()</p>\n</blockquote>\n<h4 id=\"last/1\">last/1</h4><blockquote>\n<p>last(Tab) -&gt; Key | &#39;$end_of_table&#39;</p>\n</blockquote>\n<h4 id=\"next/2\">next/2</h4><blockquote>\n<p>next(Tab, Key1) -&gt; Key2 | &#39;$end_of_table&#39;<br>Types:<br>Tab = tid() | atom()<br>Key1 = Key2 = term()</p>\n</blockquote>\n<h4 id=\"prev/2\">prev/2</h4><blockquote>\n<p>prev(Tab, Key1) -&gt; Key2 | &#39;$end_of_table&#39;</p>\n</blockquote>\n<p>first返回ets第一个key,last返回最后一个key, 如果没有内容则返回end_of_table, 可以用next返回下一个key,prev返回上一个key<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">31&gt; ets:tab2list(person).</span><br><span class=\"line\">[&#123;4,ok&#125;,&#123;1,23&#125;,&#123;2,34&#125;]</span><br><span class=\"line\">32&gt; ets:first(person).</span><br><span class=\"line\">2</span><br><span class=\"line\">33&gt; ets:next(person, 2).</span><br><span class=\"line\">1</span><br><span class=\"line\">34&gt; ets:next(person, 1).</span><br><span class=\"line\">4</span><br><span class=\"line\">35&gt; ets:next(person, 4).</span><br><span class=\"line\">&#x27;$end_of_table&#x27;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"foldl/3\">foldl/3</h4><blockquote>\n<p>foldl(Function, Acc0, Tab) -&gt; Acc1<br>Types:<br>Function = fun((Element :: term(), AccIn) -&gt; AccOut)<br>Tab = tab()<br>Acc0 = Acc1 = AccIn = AccOut = term()</p>\n</blockquote>\n<p>内部实际调用的还是lists:foldl,根据看源码发现,首先通过ets:first找到第一个key,然后调用ets:lookup(Table, Key),找到第一个元素,此时返回的元素在一个list里面,然后对这个列表用lists:foldl,Function本身是对ets每个元素执行的,包括key.例子如下.<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1&gt; ets:new(double, [named_table]).</span><br><span class=\"line\">double</span><br><span class=\"line\">2&gt; ets:insert(double, [&#123;1, 14&#125;,&#123;2, 12&#125;, &#123;3, 23&#125;]).</span><br><span class=\"line\">true</span><br><span class=\"line\">3&gt; ets:tab2list(double).</span><br><span class=\"line\">[&#123;1,14&#125;,&#123;2,12&#125;,&#123;3,23&#125;]</span><br><span class=\"line\">4&gt; ets:foldl(fun(&#123;K, V&#125;, Acc) -&gt; [&#123;K, V * 2&#125;|Acc] end, [], double).</span><br><span class=\"line\">[&#123;1,28&#125;,&#123;2,24&#125;,&#123;3,46&#125;]</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"foldr/3\">foldr/3</h4><blockquote>\n<p>foldr(Function, Acc0, Tab) -&gt; Acc1<br>Types:<br>Function = fun((Element :: term(), AccIn) -&gt; AccOut)<br>Tab = tab()<br>Acc0 = Acc1 = AccIn = AccOut = term()</p>\n</blockquote>\n<p>同foldl.</p>\n<h4 id=\"give_away/3\">give_away/3</h4><p>give_away(Tab, Pid, GiftData) -&gt; true<br>Types:<br>Tab = tid() | atom()<br>Pid = pid()<br>GiftData = term()<br>类似于new的heir继承,在ets的owner进程调用,将Tab这个ets穿给Pid这个进程,传送的消息为{&#39;ETS-TRANSFER&#39;,Tab,FromPid,GiftData},Pid可以receive这个消息做不同的事情.</p>\n<h4 id=\"i/0_i/1\">i/0 i/1</h4><blockquote>\n<p>i() -&gt; ok<br>i(Tab) -&gt; ok</p>\n</blockquote>\n<p>用于查看ets信息</p>\n<h4 id=\"info/1_info/2\">info/1 info/2</h4><blockquote>\n<p>info(Tab) -&gt; [{Item, Value}] | undefined<br>Types:<br>Tab = tid() | atom()<br>Item = atom(), see below<br>Value = term(), see below<br>info(Tab, Item) -&gt; Value | undefined<br>Types:<br>Tab = tid() | atom()<br>Item, Value - see below</p>\n</blockquote>\n<p>当Tab是个TableId,但是这个ets已经不存在的时候会返回undefined</p>\n<h4 id=\"match/2_match/3_match/1\">match/2 match/3 match/1</h4><blockquote>\n<p>match(Tab, Pattern) -&gt; [Match]<br>Types:<br>Tab = tid() | atom()<br>Pattern = tuple()<br>Match = [term()]</p>\n</blockquote>\n<blockquote>\n<p>match(Tab, Pattern, Limit) -&gt; {[Match],Continuation} | &#39;$end_of_table&#39;<br>Types:<br>Tab = tid() | atom()<br>Pattern = tuple()<br>Match = [term()]<br>Continuation = term()</p>\n</blockquote>\n<blockquote>\n<p>match(Continuation) -&gt; {[Match],Continuation} | &#39;$end_of_table&#39;<br>Types:<br>Match = [term()]<br>Continuation = term()</p>\n</blockquote>\n<p>说白了就是模式匹配,lookup只能通过key查找,而实际上面对bag类型,同样的key对应很多值,我们需要额外的添加筛选条件,所以就有了match.<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3&gt; ets:new(player, [bag, named_table]).</span><br><span class=\"line\">player</span><br><span class=\"line\">4&gt; ets:insert(player,[&#123;player1, career1, goodsbag1&#125;,&#123;player1, career2, goodsbag2&#125;, &#123;player1, career3, goodsbag3&#125;]).</span><br><span class=\"line\">true</span><br><span class=\"line\">5&gt; ets:tab2list(player).</span><br><span class=\"line\">[&#123;player1,career1,goodsbag1&#125;,</span><br><span class=\"line\"> &#123;player1,career2,goodsbag2&#125;,</span><br><span class=\"line\"> &#123;player1,career3,goodsbag3&#125;]</span><br><span class=\"line\">6&gt; ets:match(player, &#123;player1, &#x27;$1&#x27;, goodsbag2&#125;).</span><br><span class=\"line\">[[career2]]</span><br><span class=\"line\">7&gt; ets:match(player, &#123;player1, &#x27;$1&#x27;, &#x27;_&#x27;&#125;).      </span><br><span class=\"line\">[[career1],[career2],[career3]]</span><br><span class=\"line\">8&gt; ets:match(player, &#123;&#x27;_&#x27;, &#x27;$1&#x27;, &#x27;goodsbag3&#x27;&#125;).</span><br><span class=\"line\">[[career3]]</span><br></pre></td></tr></table></figure></p>\n<p>$后面加数字用来表示想要得到的变量,&#39;_&#39;表示要忽略的变量.值得注意的是如果key指定的match是搞笑的,如果不指定key则需要遍历整个表,如果ets很大,则会很耗时.</p>\n<h4 id=\"match_object/2_match_object/3\">match_object/2 match_object/3</h4><blockquote>\n<p>match_object(Tab, Pattern) -&gt; [Object]<br>Types:<br>Tab = tid() | atom()<br>Pattern = Object = tuple()</p>\n</blockquote>\n<blockquote>\n<p>match_object(Tab, Pattern, Limit) -&gt; {[Match],Continuation} | &#39;$end_of_table&#39;<br>Types:<br>Tab = tid() | atom()<br>Pattern = tuple()<br>Match = [term()]<br>Continuation = term()</p>\n</blockquote>\n<blockquote>\n<p>match_object(Continuation) -&gt; {[Match],Continuation} | &#39;$end_of_table&#39;<br>Types:<br>Match = [term()]<br>Continuation = term()</p>\n</blockquote>\n<p>与match一样,只不过这个返回的是整个object,而不是$所指定的值</p>\n<h4 id=\"init_table/2\">init_table/2</h4><blockquote>\n<p>init_table(Tab, InitFun) -&gt; true<br>Types:<br>Tab = tab()<br>InitFun = fun((Arg) -&gt; Res)<br>Arg = read | close<br>Res = end_of_input | {Objects :: [term()], InitFun} | term()</p>\n</blockquote>\n<p> 官方doc上面说</p>\n<blockquote>\n<p>This function is provided for compatibility with the dets module, it is not more efficient than filling a table by using ets:insert/2</p>\n</blockquote>\n<p>我们可以看出这个是为了和dets兼容才提供了这个接口,其实效率不比insert高,<br>InitFun是个fun函数,这个函数接受read和close这两个传入值, 返回结果如Res所示,如 fun(read) -&gt; end_of_input end. 其实这个函数的文档写的有些语焉不详,我们还是可以通过官方代码直到具体什么意思.<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">-spec</span> init_table<span class=\"params\">(Tab, InitFun)</span> -&gt; &#x27;true&#x27; when</span><br><span class=\"line\">      Tab :: tab<span class=\"params\">()</span>,</span><br><span class=\"line\">      InitFun :: fun<span class=\"params\">((Arg)</span> -&gt; Res),</span><br><span class=\"line\">      Arg :: &#x27;read&#x27; | &#x27;close&#x27;,</span><br><span class=\"line\">      Res :: &#x27;end_of_input&#x27; | &#123;Objects :: [term<span class=\"params\">()</span>], InitFun&#125; | term<span class=\"params\">()</span>.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">init_table</span><span class=\"params\">(Table, Fun)</span> -&gt;</span></span><br><span class=\"line\">    ets:delete_all_objects(Table),</span><br><span class=\"line\">    init_table_continue(Table, Fun(read)).</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">init_table_continue</span><span class=\"params\">(_Table, end_of_input)</span> -&gt;</span></span><br><span class=\"line\">    <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">init_table_continue</span><span class=\"params\">(Table, &#123;List, Fun&#125;)</span> <span class=\"title\">when</span> <span class=\"title\">is_list</span><span class=\"params\">(List)</span>, <span class=\"title\">is_function</span><span class=\"params\">(Fun)</span> -&gt;</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> (<span class=\"keyword\">catch</span> init_table_sub(Table, List)) <span class=\"keyword\">of</span></span><br><span class=\"line\">\t&#123;&#x27;EXIT&#x27;, Reason&#125; -&gt;</span><br><span class=\"line\">\t    (<span class=\"keyword\">catch</span> Fun(close)),</span><br><span class=\"line\">\t    exit(Reason);</span><br><span class=\"line\">\t<span class=\"literal\">true</span> -&gt;</span><br><span class=\"line\">\t    init_table_continue(Table, Fun(read))</span><br><span class=\"line\">    <span class=\"keyword\">end</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">init_table_continue</span><span class=\"params\">(_Table, Error)</span> -&gt;</span></span><br><span class=\"line\">    exit(Error).</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">init_table_sub</span><span class=\"params\">(_Table, [])</span> -&gt;</span></span><br><span class=\"line\">    <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">init_table_sub</span><span class=\"params\">(Table, [H|T])</span> -&gt;</span></span><br><span class=\"line\">    ets:insert(Table, H),</span><br><span class=\"line\">    init_table_sub(Table, T).</span><br></pre></td></tr></table></figure></p>\n<p>可以看出首先用delete_all_objects删掉了之前ets的数据,之后在init_table_sub中分别插入List中的元素,在调用List,之后的initfun,遇到end_of_input为止. j<br>举个简单的例子<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">21</span>&gt; ets:new(test, [named_table]).</span><br><span class=\"line\">test</span><br><span class=\"line\"><span class=\"number\">22</span>&gt; ets:insert(test, &#123;test1, result1&#125;).</span><br><span class=\"line\"><span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"number\">23</span>&gt; ets:tab2list(test).</span><br><span class=\"line\">[&#123;test1,result1&#125;]</span><br><span class=\"line\"><span class=\"number\">24</span>&gt; ets:init_table(test, <span class=\"keyword\">fun</span>(read) -&gt; &#123;[&#123;test2, result2&#125;,&#123;test3, result3&#125;], <span class=\"keyword\">fun</span>(read) -&gt; <span class=\"keyword\">end</span>_of_input end&#125; <span class=\"keyword\">end</span>).</span><br><span class=\"line\"><span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"number\">25</span>&gt; ets:tab2list(test).</span><br><span class=\"line\">[&#123;test3,result3&#125;,&#123;test2,result2&#125;]</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"member/2\">member/2</h4><blockquote>\n<p>member(Tab, Key) -&gt; true | false</p>\n</blockquote>\n<p>如果key在Tab中有值则返回true,否则false</p>\n<h4 id=\"rename/2\">rename/2</h4><blockquote>\n<p>rename(Tab, Name) -&gt; Name</p>\n</blockquote>\n<p>重命名一个table,只对有名字的table有效</p>\n<h4 id=\"safe_fixtable/2\">safe_fixtable/2</h4><blockquote>\n<p>safe_fixtable(Tab, true|false) -&gt; true</p>\n</blockquote>\n<p>当一个进程对某个ets用了safe_fixtable(Tab, true)后,这个进程对这个ets的first和next操作的key只返回没有返回过的key,也就是说ets表中的每个key只返回一次,为什么这么说呢.我们知道ordered_set中的key是排好序的,只要不停的next,肯定会得到更大的key,加入删除了之前一个较小的key,那么再次插入时,也不过next到这个key,但是set,bag表不是,有可能在next的过程中,如果有别的进程删除了你之前遍历过的key,之后在插入,将有可能再次next到这个key,safe_fixtable的作用就是对每个结果只返回一次,这个在游戏中对线上玩家列表的操作有一定作用,ets的官方文档中的foldl等也用到了.</p>\n<blockquote>\n<p>Note that no deleted objects are actually removed from a fixed table until it has been released. If a process fixes a table but never releases it, the memory used by the deleted objects will never be freed. The performance of operations on the table will also degrade significantly.</p>\n</blockquote>\n<p>值得注意的是在有进程对ets fixtable的情况对ets中数据的删除并没有真正的删除,直到这个进程死掉或者释放掉safe_fixtable为止,此时对ets的操作效率将显著降低, 所以尽量少用ets:foldl.<br>可参考:<a href=\"http://stackoverflow.com/questions/20327171/etsfoldl-vs-deleted-elements/20338795#20338795\">http://stackoverflow.com/questions/20327171/etsfoldl-vs-deleted-elements/20338795#20338795</a></p>\n<h4 id=\"setopts/2\">setopts/2</h4><blockquote>\n<p>setopts(Tab, Opts) -&gt; true</p>\n</blockquote>\n<p>opts只能是[{heir,pid(),HeirData} | {heir,none}],用于在table创建后修改继承选项,只能由table的owner调用</p>\n<h4 id=\"update_counter/3\">update_counter/3</h4><blockquote>\n<p>update_counter(Tab, Key, UpdateOp) -&gt; Result<br>update_counter(Tab, Key, [UpdateOp]) -&gt; [Result]<br>update_counter(Tab, Key, Incr) -&gt; Result<br>Types:<br>Tab = tid() | atom()<br>Key = term()<br>UpdateOp = {Pos,Incr} | {Pos,Incr,Threshold,SetValue}<br>Pos = Incr = Threshold = SetValue = Result = integer()</p>\n</blockquote>\n<p>更新ets中的数据,省去从ets去数据,相加在存入这个流程, Threshold是阈值,根据incr的正负,当结果大于或小于阈值时,将值设为SetValue.<br><strong><em>只能用于set和ordered_set</em></strong><br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">3</span>&gt; ets:new(test, [named_table]).</span><br><span class=\"line\">test</span><br><span class=\"line\"><span class=\"number\">4</span>&gt; </span><br><span class=\"line\"><span class=\"number\">4</span>&gt; ets:insert(test,[&#123;one, <span class=\"number\">1</span>&#125;,&#123;two, <span class=\"number\">2</span>&#125;,&#123;three, <span class=\"number\">3</span>&#125;,&#123;four, <span class=\"number\">4</span>&#125;]).</span><br><span class=\"line\"><span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"number\">5</span>&gt; ets:update_counter(test, one, <span class=\"number\">1</span>). </span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">6</span>&gt; ets:tab2list(test).</span><br><span class=\"line\">[&#123;two,<span class=\"number\">2</span>&#125;,&#123;three,<span class=\"number\">3</span>&#125;,&#123;one,<span class=\"number\">2</span>&#125;,&#123;four,<span class=\"number\">4</span>&#125;]</span><br><span class=\"line\"><span class=\"number\">7</span>&gt; ets:insert(test,&#123;five, haha, <span class=\"number\">5</span>&#125;).</span><br><span class=\"line\"><span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"number\">8</span>&gt; ets:update_counter(test, five, &#123;<span class=\"number\">3</span>, <span class=\"number\">1</span>&#125;).</span><br><span class=\"line\"><span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"number\">9</span>&gt; ets:tab2list(test).</span><br><span class=\"line\">[&#123;two,<span class=\"number\">2</span>&#125;,&#123;five,haha,<span class=\"number\">6</span>&#125;,&#123;three,<span class=\"number\">3</span>&#125;,&#123;one,<span class=\"number\">2</span>&#125;,&#123;four,<span class=\"number\">4</span>&#125;]</span><br><span class=\"line\"><span class=\"number\">10</span>&gt; ets:update_counter(test, five, &#123;<span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">6</span>, <span class=\"number\">5</span>&#125;).</span><br><span class=\"line\"><span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"number\">11</span>&gt; ets:tab2list(test).</span><br><span class=\"line\">[&#123;two,<span class=\"number\">2</span>&#125;,&#123;five,haha,<span class=\"number\">5</span>&#125;,&#123;three,<span class=\"number\">3</span>&#125;,&#123;one,<span class=\"number\">2</span>&#125;,&#123;four,<span class=\"number\">4</span>&#125;]</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"update_element/3\">update_element/3</h4><blockquote>\n<p>update_element(Tab, Key, {Pos,Value}) -&gt; true | false<br>update_element(Tab, Key, [{Pos,Value}]) -&gt; true | false<br>Types:<br>Tab = tid() | atom()<br>Key = Value = term()<br>Pos = integer()</p>\n</blockquote>\n<p>大致跟上面一样,未找到Key会返回false.</p>\n<h3 id=\"所有关于match_specification\">所有关于match specification</h3><p>下面的函数都有用到MatchSpec这个数据类型，<br>定义见: [doc]: (<a href=\"http://www.erlang.org/doc/apps/erts/match_spec.html)\">http://www.erlang.org/doc/apps/erts/match_spec.html)</a>.<br>match specification用于更为复杂的匹配情况,可以用于ets和erlang:trace_pattern中,一个ms的具体例子可能如下</p>\n<p><img src=\"../../../../img/ets1.png\" alt=\"\"></p>\n<p>乍看之下是非常难懂的,抽象一下大致是这个样子<br>[{InitialPattern1, Guards1, ReturnedValue1},<br>{InitialPattern2, Guards2, ReturnedValue2}].<br>上面的{&#39;$1&#39;,&#39;$2&#39;,&lt;<1>&gt;,&#39;$3&#39;,&#39;$4&#39;}是InitialPattern, [{&#39;andalso&#39;,{&#39;&gt;&#39;,&#39;$4&#39;,150},{&#39;&lt;&#39;,&#39;$4&#39;,500}},<br>{&#39;orelse&#39;,{&#39;==&#39;,&#39;$2&#39;,meat},{&#39;==&#39;,&#39;$2&#39;,dairy}}]和[{&#39;&lt;&#39;,&#39;$3&#39;,4.0},{is_float,&#39;$3&#39;}]是Guards1和Guards2,[&#39;$1&#39;]是returnedvalue.</p>\n<p>InitialPattern是将变量绑定到具体的$数字上,然后通过guard,得到returnvalue.<br>Guard的语序是{FunctionOrOperator, Arg1, ..., ArgN},&#39;andalso&#39; &#39;orelse&#39;和&#39;&lt;&#39;等属于FunctionorOperator,后面的是参数.<br>{&#39;andalso&#39;,{&#39;&gt;&#39;,&#39;$4&#39;,150},{&#39;&lt;&#39;,&#39;$4&#39;,500}}翻译过来就是 when $4 &gt; 150 andalso $4 &lt; 500.<br>如果满足这个Guard就返回$1.</p>\n<p>当然让我们去写这样一个match是很不符合人类的发展的,所以我们要用到下面的函数</p>\n<h4 id=\"fun2ms/1\">fun2ms/1</h4><blockquote>\n<p>fun2ms(LiteralFun) -&gt; MatchSpec<br>Types:<br>LiteralFun = function()<br>MatchSpec = match_spec()<br>这个函数将我们熟悉的fun函数转换成match specification的形式,这个转换过程由ms_transform完成,<br>需要在模块开头加上<br><strong><em>-include_lib(&quot;stdlib/include/ms_transform.hrl&quot;).</em></strong><br>需要注意的是fun的参数只有一个,只能是一个变量或者一个tuple不能使list等,不能使bit流.</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1&gt; ets:fun2ms(fun(X) when X &gt; 10 -&gt; X end).   </span><br><span class=\"line\">[&#123;&#x27;$1&#x27;,[&#123;&#x27;&gt;&#x27;,&#x27;$1&#x27;,10&#125;],[&#x27;$1&#x27;]&#125;]</span><br><span class=\"line\">2&gt; ets:fun2ms(fun(&#123;X, Y&#125;) when X &gt; 10, Y &lt; 20 -&gt; X * Y end).</span><br><span class=\"line\">[&#123;&#123;&#x27;$1&#x27;,&#x27;$2&#x27;&#125;,</span><br><span class=\"line\">  [&#123;&#x27;&gt;&#x27;,&#x27;$1&#x27;,10&#125;,&#123;&#x27;&lt;&#x27;,&#x27;$2&#x27;,20&#125;],</span><br><span class=\"line\">  [&#123;&#x27;*&#x27;,&#x27;$1&#x27;,&#x27;$2&#x27;&#125;]&#125;]</span><br></pre></td></tr></table></figure>\n<p>ms的在ets中的主要作用是用在select语句中,达到类似于mysql中select的效果</p>\n<h4 id=\"select/1/2/3\">select/1/2/3</h4><blockquote>\n<p>select(Tab, MatchSpec) -&gt; [Match]<br>select(Tab, MatchSpec, Limit) -&gt; {[Match],Continuation} | &#39;$end_of_table&#39;<br>select(Continuation) -&gt; {[Match],Continuation} | &#39;$end_of_table&#39;<br>Types:<br>Tab = tid() | atom()<br>Match = term()<br>MatchSpec = match_spec()<br>Continuation = term()</p>\n</blockquote>\n<p>select/2将所有符合MatchSpec的结果返回，select/3制定了limit。返回的Continuation可以用在select/1中。为何这么做？官方说明是</p>\n<blockquote>\n<p>This is a space efficient way to work on objects in a table which is still faster than traversing the table object by object using ets:first/1 and ets:next/1.</p>\n</blockquote>\n<p>这样节省空间，同时比用first，next更加快。<br>下面的例子是在player表中有两个#player结构的数据。一个返回的是10010这个id的玩家，之后调用select(C)将第二个10011玩家玩家返回同时返回end of table。如果将end of table传入select会直接返回end of table。</p>\n<p><img src=\"../../../../img/ets2.png\" alt=\"\"></p>\n<p>learn you some erlang书中的例子，<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">11&gt; rd(food, &#123;name, calories, price, group&#125;).</span><br><span class=\"line\">food</span><br><span class=\"line\">12&gt; ets:new(food, [ordered_set, &#123;keypos,#food.name&#125;, named_table]).</span><br><span class=\"line\">food</span><br><span class=\"line\">13&gt; ets:insert(food, [#food&#123;name=salmon, calories=88, price=4.00, group=meat&#125;,</span><br><span class=\"line\">13&gt; #food&#123;name=cereals, calories=178, price=2.79, group=bread&#125;,</span><br><span class=\"line\">13&gt; #food&#123;name=milk, calories=150, price=3.23, group=dairy&#125;,</span><br><span class=\"line\">13&gt; #food&#123;name=cake, calories=650, price=7.21, group=delicious&#125;,</span><br><span class=\"line\">13&gt; #food&#123;name=bacon, calories=800, price=6.32, group=meat&#125;,</span><br><span class=\"line\">13&gt; #food&#123;name=sandwich, calories=550, price=5.78, group=whatever&#125;]).</span><br><span class=\"line\">true</span><br><span class=\"line\">14&gt; ets:select(food, ets:fun2ms(fun(N = #food&#123;calories=C&#125;) when C &lt; 600 -&gt; N end)).</span><br><span class=\"line\">[#food&#123;name = cereals,calories = 178,price = 2.79,group = bread&#125;,</span><br><span class=\"line\">#food&#123;name = milk,calories = 150,price = 3.23,group = dairy&#125;,</span><br><span class=\"line\">#food&#123;name = salmon,calories = 88,price = 4.0,group = meat&#125;,</span><br><span class=\"line\">#food&#123;name = sandwich,calories = 550,price = 5.78,group = whatever&#125;]</span><br><span class=\"line\">15&gt; ets:select_reverse(food, ets:fun2ms(fun(N = #food&#123;calories=C&#125;) when C &lt; 600 -&gt; N end)).</span><br><span class=\"line\">[#food&#123;name = sandwich,calories = 550,price = 5.78,group = whatever&#125;,</span><br><span class=\"line\">#food&#123;name = salmon,calories = 88,price = 4.0,group = meat&#125;,</span><br><span class=\"line\">#food&#123;name = milk,calories = 150,price = 3.23,group = dairy&#125;,</span><br><span class=\"line\">#food&#123;name = cereals,calories = 178,price = 2.79,group = bread&#125;]</span><br></pre></td></tr></table></figure><br> 同时在官方doc的ms_transform中有个多个子句的例子</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ets:select(emp_tab, ets:fun2ms(</span><br><span class=\"line\">                     fun(#emp&#123;empno = E, surname = &quot;Smith&quot; &#125;) -&gt;</span><br><span class=\"line\">                             &#123;guru,E&#125;;</span><br><span class=\"line\">                        (#emp&#123;empno = E, empyear = Y&#125;) when Y &lt; 1997  -&gt;</span><br><span class=\"line\">                             &#123;inventory, E&#125;;</span><br><span class=\"line\">                        (#emp&#123;empno = E, empyear = Y&#125;) when Y &gt; 2001  -&gt;</span><br><span class=\"line\">                             &#123;newbie, E&#125;;</span><br><span class=\"line\">                        (#emp&#123;empno = E, empyear = Y&#125;) -&gt; % 1997 -- 2001</span><br><span class=\"line\">                             &#123;rookie, E&#125;</span><br><span class=\"line\">                     end)).  </span><br></pre></td></tr></table></figure>\n<h4 id=\"select_count/2\">select_count/2</h4><blockquote>\n<p>select_count(Tab, MatchSpec) -&gt; NumMatched<br>Types:<br>Tab = tid() | atom()<br>Object = tuple()<br>MatchSpec = match_spec()<br>NumMatched = integer()<br>对MS返回为true的会计数。如下，得出player表中id大于0的玩家数。</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> ets:select_count(player, ets:fun2ms(fun(#player&#123;id = ID&#125;) -&gt; ID &gt; 0  end)).    </span><br><span class=\"line\">2</span><br></pre></td></tr></table></figure>\n<h4 id=\"select_delete/2\">select_delete/2</h4><blockquote>\n<p>select_delete(Tab, MatchSpec) -&gt; NumDeleted<br>Types:<br>Tab = tid() | atom()<br>Object = tuple()<br>MatchSpec = match_spec()<br>NumDeleted = integer()</p>\n</blockquote>\n<p>大致同count，将返回true的object从表中删掉。</p>\n<h4 id=\"select_reverse/1/2/3\">select_reverse/1/2/3</h4><blockquote>\n<p>select_reverse(Tab, MatchSpec) -&gt; [Match]<br>Types:<br>Tab = tid() | atom()<br>Match = term()<br>MatchSpec = match_spec()<br>select_reverse(Tab, MatchSpec, Limit) -&gt; {[Match],Continuation} | &#39;$end_of_table&#39;<br>Types:<br>Tab = tid() | atom()<br>Match = term()<br>MatchSpec = match_spec()<br>Continuation = term()<br>select_reverse(Tab, MatchSpec) -&gt; [Match]<br>Types:<br>Tab = tid() | atom()<br>Match = term()<br>MatchSpec = match_spec()</p>\n</blockquote>\n<p>与只不过将select的结果反序，对order_set表有效，其他类型的表与select返回结果一致。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1&gt; T = ets:new(x,[ordered_set]).</span><br><span class=\"line\">2&gt; [ ets:insert(T,&#123;N&#125;) || N &lt;- lists:seq(1,10) ].</span><br><span class=\"line\">...</span><br><span class=\"line\">3&gt; &#123;R0,C0&#125; = ets:select_reverse(T,[&#123;&#x27;_&#x27;,[],[&#x27;$_&#x27;]&#125;],4).</span><br><span class=\"line\">...</span><br><span class=\"line\">4&gt; R0.</span><br><span class=\"line\">[&#123;10&#125;,&#123;9&#125;,&#123;8&#125;,&#123;7&#125;]</span><br><span class=\"line\">5&gt; &#123;R1,C1&#125; = ets:select_reverse(C0).</span><br><span class=\"line\">...</span><br><span class=\"line\">6&gt; R1.</span><br><span class=\"line\">[&#123;6&#125;,&#123;5&#125;,&#123;4&#125;,&#123;3&#125;]</span><br><span class=\"line\">7&gt; &#123;R2,C2&#125; = ets:select_reverse(C1).</span><br><span class=\"line\">...</span><br><span class=\"line\">8&gt; R2.</span><br><span class=\"line\">[&#123;2&#125;,&#123;1&#125;]</span><br><span class=\"line\">9&gt; &#x27;$end_of_table&#x27; = ets:select_reverse(C2).</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"match_spec_compile/1\">match_spec_compile/1</h4><h4 id=\"match_spec_run/2\">match_spec_run/2</h4><h4 id=\"is_compiled_ms/1\">is_compiled_ms/1</h4><blockquote>\n<p>match_spec_compile(MatchSpec) -&gt; CompiledMatchSpec<br>Types:<br>MatchSpec = match_spec()<br>CompiledMatchSpec = comp_match_spec()<br>match_spec_run(List,CompiledMatchSpec) -&gt; list()<br>Types:<br>List = [ tuple() ]<br>CompiledMatchSpec = comp_match_spec()<br>is_compiled_ms(Term) -&gt; boolean()<br>Types:<br>Term = term()</p>\n</blockquote>\n<p>match_spec_compile将一个MS编译成一个不可见的内部形式供match_spec_run调用，is_compile_ms用来判断这个编译结果是否是个正确的编译，因为编译后的内部形式不能再节点间传递也不能储存在硬盘上。<br>比如<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ets:is_compiled_ms(ets:match_spec_compile([&#123;&#x27;_&#x27;,[],[true]&#125;])). </span><br></pre></td></tr></table></figure><br>返回的是true<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MS = ets:match_spec_compile([&#123;&#x27;_&#x27;,[],[true]&#125;]),</span><br><span class=\"line\">Broken = binary_to_term(term_to_binary(MS)),</span><br><span class=\"line\">ets:is_compiled_ms(Broken).</span><br></pre></td></tr></table></figure><br>返回的是false，因为不接受外部的转化。会使其失去原有的信息。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MatchSpec = ets:fun2ms(fun(&#123;M, N&#125;) when N &gt; 3 -&gt; M end),</span><br><span class=\"line\">CompiledMatchSpec = ets:match_spec_compile(MatchSpec),</span><br><span class=\"line\">List = [&#123;1, 2&#125;, &#123;3, 4&#125;, &#123;5, 6&#125;],</span><br><span class=\"line\">ets:match_spec_run(List, CompiledMatchSpec).</span><br></pre></td></tr></table></figure></p>\n<p>如果MatchSpec不是个合格的Ms会抛badarg的错误。</p>\n<h4 id=\"repair_continuation/2\">repair_continuation/2</h4><blockquote>\n<p>repair_continuation(Continuation, MatchSpec) -&gt; Continuation<br>Types:<br>Continuation = continuation()<br>MatchSpec = match_spec()</p>\n</blockquote>\n<p>用来修复select/3返回的continuation，如果continuation在被转化为外部形势（用来在节点间传递)，会失效，但是使用repair_continuation可以恢复。<br>例：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">%% 无效</span><br><span class=\"line\">T=ets:new(x,[]),</span><br><span class=\"line\">&#123;_,C&#125; = ets:select(T,ets:fun2ms(fun(&#123;N,_&#125;=A)</span><br><span class=\"line\">when (N rem 10) =:= 0 -&gt;</span><br><span class=\"line\">A</span><br><span class=\"line\">end),10),</span><br><span class=\"line\">Broken = binary_to_term(term_to_binary(C)),</span><br><span class=\"line\">ets:select(Broken).</span><br><span class=\"line\"></span><br><span class=\"line\">%% 有效</span><br><span class=\"line\">T=ets:new(x,[]),</span><br><span class=\"line\">MS = ets:fun2ms(fun(&#123;N,_&#125;=A)</span><br><span class=\"line\">when (N rem 10) =:= 0 -&gt;</span><br><span class=\"line\">A</span><br><span class=\"line\">end),</span><br><span class=\"line\">&#123;_,C&#125; = ets:select(T,MS,10),</span><br><span class=\"line\">Broken = binary_to_term(term_to_binary(C)),</span><br><span class=\"line\">ets:select(ets:repair_continuation(Broken,MS)).</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<hr>","more":"<!-- toc -->\n<ul>\n<li><a href=\"#---\">创建:</a><ul>\n<li><a href=\"#new-2\">new/2</a></li>\n</ul>\n</li>\n<li><a href=\"#-----\">对表的操作</a><ul>\n<li><a href=\"#---\">一.插入</a><ul>\n<li><a href=\"#insert-2\">insert/2</a></li>\n<li><a href=\"#insert-new-2\">insert_new/2</a></li>\n</ul>\n</li>\n<li><a href=\"#---\">二.查询</a><ul>\n<li><a href=\"#lookup-2\">lookup/2</a></li>\n<li><a href=\"#lookup-element-3\">lookup_element/3</a></li>\n</ul>\n</li>\n<li><a href=\"#---\">三.删除</a><ul>\n<li><a href=\"#delete-1\">delete/1</a></li>\n<li><a href=\"#delete-2\">delete/2</a></li>\n<li><a href=\"#delete-all-objects-1\">delete_all_objects/1</a></li>\n<li><a href=\"#delete-object-2\">delete_object/2</a></li>\n</ul>\n</li>\n<li><a href=\"#---\">三.其他</a><ul>\n<li><a href=\"#tab2list-1\">tab2list/1</a></li>\n<li><a href=\"#all-1\">all/1</a></li>\n<li><a href=\"#tab2file-2\">tab2file/2</a></li>\n<li><a href=\"#tab2file-3\">tab2file/3</a></li>\n<li><a href=\"#file2tab-1\">file2tab/1</a></li>\n<li><a href=\"#file2tab-2\">file2tab/2</a></li>\n<li><a href=\"#first-1\">first/1</a></li>\n<li><a href=\"#last-1\">last/1</a></li>\n<li><a href=\"#next-2\">next/2</a></li>\n<li><a href=\"#prev-2\">prev/2</a></li>\n<li><a href=\"#foldl-3\">foldl/3</a></li>\n<li><a href=\"#foldr-3\">foldr/3</a></li>\n<li><a href=\"#give-away-3\">give_away/3</a></li>\n<li><a href=\"#i-0-i-1\">i/0 i/1</a></li>\n<li><a href=\"#info-1-info-2\">info/1 info/2</a></li>\n<li><a href=\"#match-2-match-3-match-1\">match/2 match/3 match/1</a></li>\n<li><a href=\"#match-object-2-match-object-3\">match_object/2 match_object/3</a></li>\n<li><a href=\"#init-table-2\">init_table/2</a></li>\n<li><a href=\"#member-2\">member/2</a></li>\n<li><a href=\"#rename-2\">rename/2</a></li>\n<li><a href=\"#safe-fixtable-2\">safe_fixtable/2</a></li>\n<li><a href=\"#setopts-2\">setopts/2</a></li>\n<li><a href=\"#update-counter-3\">update_counter/3</a></li>\n<li><a href=\"#update-element-3\">update_element/3</a></li>\n</ul>\n</li>\n<li><a href=\"#----match-specification\">所有关于match specification</a><ul>\n<li><a href=\"#fun2ms-1\">fun2ms/1</a></li>\n<li><a href=\"#select-1-2-3\">select/1/2/3</a></li>\n<li><a href=\"#select-count-2\">select_count/2</a></li>\n<li><a href=\"#select-delete-2\">select_delete/2</a></li>\n<li><a href=\"#select-reverse-1-2-3\">select_reverse/1/2/3</a></li>\n<li><a href=\"#match-spec-compile-1\">match_spec_compile/1</a></li>\n<li><a href=\"#match-spec-run-2\">match_spec_run/2</a></li>\n<li><a href=\"#is-compiled-ms-1\">is_compiled_ms/1</a></li>\n<li><a href=\"#repair-continuation-2\">repair_continuation/2</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<!-- tocstop -->\n<h2 id=\"创建:\">创建:</h2><h4 id=\"new/2\">new/2</h4><blockquote>\n<p>new(Name, Options) -&gt; tid() | atom()</p>\n</blockquote>\n<p>Name = atom()<br>Options = [Option]<br> Option = Type | Access | named_table | {keypos,Pos} | {heir,pid(),HeirData} | {heir,none} | Tweaks<br>  Type = set | ordered_set | bag | duplicate_bag<br>  Access = public | protected | private<br>  Tweaks = {write_concurrency,boolean()} | {read_concurrency,boolean()} | compressed<br>  Pos = integer()<br>  HeirData = term()</p>\n<p>首先ets中保存的是元组(tuple),元组的第一个元素为key</p>\n<p><strong>Type</strong><br>即类型,set是异键表,表示这个ets中的key是唯一的,不能相同,bag表示的是同键表,它允许多个元素有相同的key,但是key之后的元素不能相同,即不能有完全相同的tuple.order_set是set的变种,表示按key排序的ets表,duplicate_bag表示key之外的元素也可以相同,即可以存在完全相同的tuple.<br>set: {playerid1, &lt;&lt;&quot;yuyouqi&quot;&gt;&gt;, 1},{playerid2, &lt;&lt;&quot;youthy&quot;&gt;&gt;, 0}. ---default type<br>bag: {playerid1, &lt;&lt;&quot;yuyouqi&quot;&gt;&gt;, 1}, {playerid1, lvl90}.<br>duplicate_bag: {playerid1, hello}, {playerid1, hello}....{playerid1, hello}</p>\n<p>还需要注意的是orderd_set 里面判断key是否相同用的是==而不是=:=,也就意味着1和1.0是相同的key,而其他类型的ets则不是.<br><strong>Access</strong><br>public是任何进程都可读写这个ets<br>protected是只有创建者进程可以改写ets,其他进程只能读取,这个是默认选项<br>private是只有创建者进程可以读写.<br><strong>{keypos, Pos}</strong><br>用来指定Pos位置为key.</p>\n<blockquote>\n<p>在不指定任何Option的时候,默认是以上三个[set, protected, {keypos, 1}]</p>\n</blockquote>\n<p><strong>其他</strong><br>named_table 指定可以通过Name访问这个ets.<br><strong>{heir,Pid,HeirData} | {heir,none}</strong>这个用来控制继承,在创建一个ets时,如果声明了这个,表示这个ets的owner死掉之后,将发送{&#39;ETS-TRANSFER&#39;,tid(),FromPid,HeirData}这个消息给Pid这个进程,其中tid()是ets的table id.看以下的例子<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>&gt; HeirPid = spawn(<span class=\"keyword\">fun</span>() -&gt; <span class=\"keyword\">receive</span> &#123;&#x27;ETS-TRANSFER&#x27;, Tid, FromPid, HeirData&#125; -&gt; ets:insert(Tid, HeirData), timer:sleep(<span class=\"number\">100000</span>) <span class=\"keyword\">end</span> <span class=\"keyword\">end</span>).</span><br><span class=\"line\"><span class=\"comment\">%% 创建用于继承的进程</span></span><br><span class=\"line\">&lt;<span class=\"number\">0.34</span>.<span class=\"number\">0</span>&gt;</span><br><span class=\"line\"><span class=\"number\">2</span>&gt; OwnerPid = spawn(<span class=\"keyword\">fun</span>() -&gt; ets:new(person, [named_table, &#123;heir, HeirPid, &#123;<span class=\"number\">1</span>, youthy&#125;&#125;]), <span class=\"keyword\">receive</span> die -&gt; ok <span class=\"keyword\">end</span> <span class=\"keyword\">end</span>).</span><br><span class=\"line\">&lt;<span class=\"number\">0.36</span>.<span class=\"number\">0</span>&gt;</span><br><span class=\"line\"><span class=\"comment\">%% 创建用于初始化ets的进程,声明heir参数.</span></span><br><span class=\"line\"><span class=\"number\">3</span>&gt; observer:start().</span><br><span class=\"line\">ok</span><br><span class=\"line\"><span class=\"comment\">%% 启动观察器</span></span><br></pre></td></tr></table></figure><br><img src=\"../../../../img/选区_045.png\" alt=\"\"><br>此时我们可以看到person这个表的owner是&lt;0.36.0&gt;<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">4</span>&gt; ets:tab2list(person).</span><br><span class=\"line\">[]</span><br><span class=\"line\"><span class=\"comment\">%% person中没有任何数据</span></span><br><span class=\"line\"><span class=\"number\">5</span>&gt; OwnerPid ! die.</span><br><span class=\"line\">die</span><br><span class=\"line\"><span class=\"comment\">%% 让OwnerPid死亡</span></span><br><span class=\"line\"><span class=\"number\">6</span>&gt; observer:start(). </span><br><span class=\"line\">ok</span><br><span class=\"line\"><span class=\"number\">7</span>&gt; ets:tab2list(person).</span><br><span class=\"line\">[&#123;<span class=\"number\">1</span>,youthy&#125;]</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"../../../../img/选区_046.png\" alt=\"\"><br>再次观察可以看到person这个表已经继承给了HeirPid,并且里面有了数据.数据是我主动插入的HeirData.</p>\n<p>{write_concurrency,boolean()}/{read_concurrency,boolean()}/compressed<br>write,read默认都是false,当分别指定为true时,编译器会优化,会使write更快,read更快,但是在读写之间的切换会很慢,只适合于单纯的写表或读表.<br>compressed会压缩ets节省空间,但是对ets的操作尤其,match,select等遍历所有元素的操作会慢很多,慎用.</p>\n<hr>\n<h2 id=\"对表的操作\">对表的操作</h2><p>上面完成了对ets的创建,接下来自然就是对ets的操作.</p>\n<h3 id=\"一-插入\">一.插入</h3><h4 id=\"insert/2\">insert/2</h4><blockquote>\n<p> insert(Tab, ObjectOrObjects) -&gt; true<br>Types:<br>Tab = tid() | atom()<br>ObjectOrObjects = tuple() | [tuple()]</p>\n</blockquote>\n<p>Tab为ets的TableId, 如果声明为named_table可以为对应的名字.<br>1.<strong>insert是原子操作,BIF,不管object是多个tuple组成的list还是单独一个tuple</strong><br>2.<strong>如果像set表中插入具有相同key的多个元素,则只有一个能被插入,而且不知道具体哪个会被插入,如果是order_set要记住此时key相同的原则不是靠=:=而是==,也就是match(模式匹配)和equal(相等)的区别</strong></p>\n<h4 id=\"insert_new/2\">insert_new/2</h4><blockquote>\n<p>insert_new(Tab, ObjectOrObjects) -&gt; boolean()<br>Types:<br>Tab = tid() | atom()<br>ObjectOrObjects = tuple() | [tuple()]</p>\n</blockquote>\n<p>大体与insert相同,只不过这个insert直插入ets中不存在键值,当发现key在ets表中已经存在,则返回false.也是原子操作,也就是就算是insert_new一个list的东西,只要有一个key存在了,这个插入就是失败的</p>\n<h3 id=\"二-查询\">二.查询</h3><h4 id=\"lookup/2\">lookup/2</h4><blockquote>\n<p>lookup(Tab, Key) -&gt; [Object]<br>Types:<br>Tab = tid() | atom()<br>Key = term()<br>Object = tuple()</p>\n</blockquote>\n<p>注意结果返回是list.同样order_set是特别的,1.0与1是相同的key.</p>\n<h4 id=\"lookup_element/3\">lookup_element/3</h4><blockquote>\n<p>lookup_element(Tab, Key, Pos) -&gt; Elem<br>Types:<br>Tab = tid() | atom()<br>Key = term()<br>Pos = integer()<br>Elem = term() | [term()]</p>\n</blockquote>\n<p>这个返回的是key的tuple里面pos位置的元素.<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1&gt; ets:new(person, [named_table, set]).</span><br><span class=\"line\">person</span><br><span class=\"line\">2&gt; ets:insert(person, &#123;player1, man, sword&#125;).</span><br><span class=\"line\">true</span><br><span class=\"line\">3&gt; ets:lookup_element(person, player1, 3).</span><br><span class=\"line\">sword</span><br></pre></td></tr></table></figure></p>\n<p>如果pos处不存在元素则会报bagarg错误</p>\n<h3 id=\"三-删除\">三.删除</h3><h4 id=\"delete/1\">delete/1</h4><blockquote>\n<p>delete(Tab) -&gt; true<br>Types:<br>Tab = tid() | atom()</p>\n</blockquote>\n<h4 id=\"delete/2\">delete/2</h4><p>删除整个ets</p>\n<blockquote>\n<p>delete(Tab, Key) -&gt; true<br>Types:<br>Tab = tid() | atom()<br>Key = term()</p>\n</blockquote>\n<h4 id=\"delete_all_objects/1\">delete_all_objects/1</h4><p>删除key所对应的键值</p>\n<blockquote>\n<p>delete_all_objects(Tab) -&gt; true<br>Types:<br>Tab = tid() | atom()</p>\n</blockquote>\n<h4 id=\"delete_object/2\">delete_object/2</h4><p>删除Tab里面所有的值,与delete不同的是不会删掉这个ets</p>\n<blockquote>\n<p>delete_object(Tab,Object) -&gt; true<br>Types:<br>Tab = tid() | atom()<br>Object = tuple()</p>\n</blockquote>\n<p>删除object,主要用于bag型,因为bag是key对应多个object,只删除这个object,而保留key对应其他的object.<br>example:<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1&gt; ets:new(ingredients, [set, named_table]).</span><br><span class=\"line\">ingredients</span><br><span class=\"line\">2&gt; ets:insert(ingredients, &#123;bacon, great&#125;).</span><br><span class=\"line\">true</span><br><span class=\"line\">3&gt; ets:lookup(ingredients, bacon).</span><br><span class=\"line\">[&#123;bacon,great&#125;]</span><br><span class=\"line\">4&gt; ets:insert(ingredients, [&#123;bacon, awesome&#125;, &#123;cabbage, alright&#125;]).</span><br><span class=\"line\">true</span><br><span class=\"line\">5&gt; ets:lookup(ingredients, bacon).</span><br><span class=\"line\">[&#123;bacon,awesome&#125;]</span><br><span class=\"line\">6&gt; ets:lookup(ingredients, cabbage).</span><br><span class=\"line\">[&#123;cabbage,alright&#125;]</span><br><span class=\"line\">7&gt; ets:delete(ingredients, cabbage).</span><br><span class=\"line\">true</span><br><span class=\"line\">8&gt; ets:lookup(ingredients, cabbage).</span><br><span class=\"line\">[]</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"三-其他\">三.其他</h3><h4 id=\"tab2list/1\">tab2list/1</h4><blockquote>\n<p>tab2list(Tab) -&gt; [Object]<br>Types:<br>Tab = tab()<br>Object = tuple()<br>Returns a list of all objects in the table Tab.</p>\n</blockquote>\n<p>列出Tab中所有元素</p>\n<h4 id=\"all/1\">all/1</h4><blockquote>\n<p>all() -&gt; [Tab]<br>Types:<br>Tab = tid() | atom()</p>\n</blockquote>\n<p>列出当前节点所有的ets</p>\n<h4 id=\"tab2file/2\">tab2file/2</h4><blockquote>\n<p>tab2file(Tab, Filename) -&gt; ok | {error, Reason}<br>Types:<br>Tab = tab()<br>Filename = file:name()<br>Reason = term()<br>Dumps the table Tab to the file Filename.</p>\n</blockquote>\n<h4 id=\"tab2file/3\">tab2file/3</h4><blockquote>\n<p>tab2file(Tab, Filename, Options) -&gt; ok | {error, Reason}<br>Types:<br>Tab = tab()<br>Filename = file:name()<br>Options = [Option]<br>Option = {extended_info, [ExtInfo]}<br>ExtInfo = md5sum | object_count<br>Reason = term()</p>\n</blockquote>\n<p>将ets储存到文件,<br>extended_info 选项参数指定什么额外信息要在转储过程中一同被写进，参数选项有以下值：<br>object_count：被标记在文件尾后的实际被写进文件的对象数量。<br>md5sum：在文件里的文件头数据和对象数据都会用内置的 MD5 函数来效验。所有对象数据的 MD5 校验值会被卸载文件尾，因此读取数据的验证将检测在文件数据里的校验值。<br>不管参数 extended_info 是否使用，在 stdlib-1.15.1 之前的 ets 版本该参数无效。反之可以将文件中的ets读入.</p>\n<h4 id=\"file2tab/1\">file2tab/1</h4><blockquote>\n<p>file2tab(Filename) -&gt; {ok, Tab} | {error, Reason}<br>Types:<br>Filename = file:name()<br>Tab = tab()<br>Reason = term()</p>\n</blockquote>\n<h4 id=\"file2tab/2\">file2tab/2</h4><blockquote>\n<p>file2tab(Filename, Options) -&gt; {ok, Tab} | {error, Reason}<br>Types:<br>Filename = file:name()<br>Tab = tab()<br>Options = [Option]<br>Option = {verify, boolean()}<br>Reason = term()</p>\n</blockquote>\n<p>file2tab    的option是[{verify, true|false}], 默认是false,即是否验证.当指定为true时,如果tab2file时没有指定{extended_info},则写入内存时比较大小是否一致,在ets为public或者该ets在写入的时候同时更新了数据,很容易在读入时出错,所以一般需要指定{extended_info, [object_count]},写入实际写入的大小.如果指定为{extended_info, [md5sum]},则会消耗更多的时间与cpu资源来读入.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Erlang R15B (erts-5.9) [source] [smp:2:2] [async-threads:0] [hipe] [kernel-poll:false]</span><br><span class=\"line\"></span><br><span class=\"line\">Eshell V5.9  (abort with ^G)</span><br><span class=\"line\">1&gt; </span><br><span class=\"line\">1&gt; ets:new(person, [named_table]).</span><br><span class=\"line\">person</span><br><span class=\"line\">2&gt; ets:insert(person, &#123;name, sex, career&#125;).</span><br><span class=\"line\">true</span><br><span class=\"line\">3&gt; ets:all().</span><br><span class=\"line\">[person,8207,4110,13,file_io_servers,inet_hosts_file_byaddr,</span><br><span class=\"line\"> inet_hosts_file_byname,inet_hosts_byaddr,inet_hosts_byname,</span><br><span class=\"line\"> inet_cache,inet_db,global_pid_ids,global_pid_names,</span><br><span class=\"line\"> global_names_ext,global_names,global_locks,ac_tab]</span><br><span class=\"line\">4&gt; ets:tab2file(person, &quot;person.ets&quot;).</span><br><span class=\"line\">ok</span><br><span class=\"line\">5&gt; ets:delete(person).</span><br><span class=\"line\">true</span><br><span class=\"line\">6&gt; ets:all().</span><br><span class=\"line\">[disk_log_pids,disk_log_names,8207,4110,13,file_io_servers,</span><br><span class=\"line\"> inet_hosts_file_byaddr,inet_hosts_file_byname,</span><br><span class=\"line\"> inet_hosts_byaddr,inet_hosts_byname,inet_cache,inet_db,</span><br><span class=\"line\"> global_pid_ids,global_pid_names,global_names_ext,</span><br><span class=\"line\"> global_names,global_locks,ac_tab]</span><br><span class=\"line\">7&gt; ets:file2tab(&quot;person.ets&quot;).</span><br><span class=\"line\">&#123;ok,person&#125;</span><br><span class=\"line\">8&gt; ets:all().</span><br><span class=\"line\">[disk_log_pids,disk_log_names,person,8207,4110,13,</span><br><span class=\"line\"> file_io_servers,inet_hosts_file_byaddr,</span><br><span class=\"line\"> inet_hosts_file_byname,inet_hosts_byaddr,inet_hosts_byname,</span><br><span class=\"line\"> inet_cache,inet_db,global_pid_ids,global_pid_names,</span><br><span class=\"line\"> global_names_ext,global_names,global_locks,ac_tab]</span><br><span class=\"line\">9&gt; ets:tab2list(person).</span><br><span class=\"line\">[&#123;name,sex,career&#125;]</span><br><span class=\"line\">10&gt; ets:tab2file(person, &quot;person.ets&quot;, [&#123;extended_info, [object_count]&#125;]).</span><br><span class=\"line\">ok</span><br><span class=\"line\">11&gt; ets:delete(person).</span><br><span class=\"line\">true</span><br><span class=\"line\">12&gt; ets:file2tab(&quot;person.ets&quot;,[&#123;verify, true&#125;]).</span><br><span class=\"line\">&#123;ok,person&#125;</span><br><span class=\"line\">13&gt; ets:tab2list(person).</span><br><span class=\"line\">[&#123;name,sex,career&#125;]</span><br></pre></td></tr></table></figure>\n<h4 id=\"first/1\">first/1</h4><blockquote>\n<p>first(Tab) -&gt; Key | &#39;$end_of_table&#39;<br>Types:<br>Tab = tid() | atom()<br>Key = term()</p>\n</blockquote>\n<h4 id=\"last/1\">last/1</h4><blockquote>\n<p>last(Tab) -&gt; Key | &#39;$end_of_table&#39;</p>\n</blockquote>\n<h4 id=\"next/2\">next/2</h4><blockquote>\n<p>next(Tab, Key1) -&gt; Key2 | &#39;$end_of_table&#39;<br>Types:<br>Tab = tid() | atom()<br>Key1 = Key2 = term()</p>\n</blockquote>\n<h4 id=\"prev/2\">prev/2</h4><blockquote>\n<p>prev(Tab, Key1) -&gt; Key2 | &#39;$end_of_table&#39;</p>\n</blockquote>\n<p>first返回ets第一个key,last返回最后一个key, 如果没有内容则返回end_of_table, 可以用next返回下一个key,prev返回上一个key<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">31&gt; ets:tab2list(person).</span><br><span class=\"line\">[&#123;4,ok&#125;,&#123;1,23&#125;,&#123;2,34&#125;]</span><br><span class=\"line\">32&gt; ets:first(person).</span><br><span class=\"line\">2</span><br><span class=\"line\">33&gt; ets:next(person, 2).</span><br><span class=\"line\">1</span><br><span class=\"line\">34&gt; ets:next(person, 1).</span><br><span class=\"line\">4</span><br><span class=\"line\">35&gt; ets:next(person, 4).</span><br><span class=\"line\">&#x27;$end_of_table&#x27;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"foldl/3\">foldl/3</h4><blockquote>\n<p>foldl(Function, Acc0, Tab) -&gt; Acc1<br>Types:<br>Function = fun((Element :: term(), AccIn) -&gt; AccOut)<br>Tab = tab()<br>Acc0 = Acc1 = AccIn = AccOut = term()</p>\n</blockquote>\n<p>内部实际调用的还是lists:foldl,根据看源码发现,首先通过ets:first找到第一个key,然后调用ets:lookup(Table, Key),找到第一个元素,此时返回的元素在一个list里面,然后对这个列表用lists:foldl,Function本身是对ets每个元素执行的,包括key.例子如下.<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1&gt; ets:new(double, [named_table]).</span><br><span class=\"line\">double</span><br><span class=\"line\">2&gt; ets:insert(double, [&#123;1, 14&#125;,&#123;2, 12&#125;, &#123;3, 23&#125;]).</span><br><span class=\"line\">true</span><br><span class=\"line\">3&gt; ets:tab2list(double).</span><br><span class=\"line\">[&#123;1,14&#125;,&#123;2,12&#125;,&#123;3,23&#125;]</span><br><span class=\"line\">4&gt; ets:foldl(fun(&#123;K, V&#125;, Acc) -&gt; [&#123;K, V * 2&#125;|Acc] end, [], double).</span><br><span class=\"line\">[&#123;1,28&#125;,&#123;2,24&#125;,&#123;3,46&#125;]</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"foldr/3\">foldr/3</h4><blockquote>\n<p>foldr(Function, Acc0, Tab) -&gt; Acc1<br>Types:<br>Function = fun((Element :: term(), AccIn) -&gt; AccOut)<br>Tab = tab()<br>Acc0 = Acc1 = AccIn = AccOut = term()</p>\n</blockquote>\n<p>同foldl.</p>\n<h4 id=\"give_away/3\">give_away/3</h4><p>give_away(Tab, Pid, GiftData) -&gt; true<br>Types:<br>Tab = tid() | atom()<br>Pid = pid()<br>GiftData = term()<br>类似于new的heir继承,在ets的owner进程调用,将Tab这个ets穿给Pid这个进程,传送的消息为{&#39;ETS-TRANSFER&#39;,Tab,FromPid,GiftData},Pid可以receive这个消息做不同的事情.</p>\n<h4 id=\"i/0_i/1\">i/0 i/1</h4><blockquote>\n<p>i() -&gt; ok<br>i(Tab) -&gt; ok</p>\n</blockquote>\n<p>用于查看ets信息</p>\n<h4 id=\"info/1_info/2\">info/1 info/2</h4><blockquote>\n<p>info(Tab) -&gt; [{Item, Value}] | undefined<br>Types:<br>Tab = tid() | atom()<br>Item = atom(), see below<br>Value = term(), see below<br>info(Tab, Item) -&gt; Value | undefined<br>Types:<br>Tab = tid() | atom()<br>Item, Value - see below</p>\n</blockquote>\n<p>当Tab是个TableId,但是这个ets已经不存在的时候会返回undefined</p>\n<h4 id=\"match/2_match/3_match/1\">match/2 match/3 match/1</h4><blockquote>\n<p>match(Tab, Pattern) -&gt; [Match]<br>Types:<br>Tab = tid() | atom()<br>Pattern = tuple()<br>Match = [term()]</p>\n</blockquote>\n<blockquote>\n<p>match(Tab, Pattern, Limit) -&gt; {[Match],Continuation} | &#39;$end_of_table&#39;<br>Types:<br>Tab = tid() | atom()<br>Pattern = tuple()<br>Match = [term()]<br>Continuation = term()</p>\n</blockquote>\n<blockquote>\n<p>match(Continuation) -&gt; {[Match],Continuation} | &#39;$end_of_table&#39;<br>Types:<br>Match = [term()]<br>Continuation = term()</p>\n</blockquote>\n<p>说白了就是模式匹配,lookup只能通过key查找,而实际上面对bag类型,同样的key对应很多值,我们需要额外的添加筛选条件,所以就有了match.<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3&gt; ets:new(player, [bag, named_table]).</span><br><span class=\"line\">player</span><br><span class=\"line\">4&gt; ets:insert(player,[&#123;player1, career1, goodsbag1&#125;,&#123;player1, career2, goodsbag2&#125;, &#123;player1, career3, goodsbag3&#125;]).</span><br><span class=\"line\">true</span><br><span class=\"line\">5&gt; ets:tab2list(player).</span><br><span class=\"line\">[&#123;player1,career1,goodsbag1&#125;,</span><br><span class=\"line\"> &#123;player1,career2,goodsbag2&#125;,</span><br><span class=\"line\"> &#123;player1,career3,goodsbag3&#125;]</span><br><span class=\"line\">6&gt; ets:match(player, &#123;player1, &#x27;$1&#x27;, goodsbag2&#125;).</span><br><span class=\"line\">[[career2]]</span><br><span class=\"line\">7&gt; ets:match(player, &#123;player1, &#x27;$1&#x27;, &#x27;_&#x27;&#125;).      </span><br><span class=\"line\">[[career1],[career2],[career3]]</span><br><span class=\"line\">8&gt; ets:match(player, &#123;&#x27;_&#x27;, &#x27;$1&#x27;, &#x27;goodsbag3&#x27;&#125;).</span><br><span class=\"line\">[[career3]]</span><br></pre></td></tr></table></figure></p>\n<p>$后面加数字用来表示想要得到的变量,&#39;_&#39;表示要忽略的变量.值得注意的是如果key指定的match是搞笑的,如果不指定key则需要遍历整个表,如果ets很大,则会很耗时.</p>\n<h4 id=\"match_object/2_match_object/3\">match_object/2 match_object/3</h4><blockquote>\n<p>match_object(Tab, Pattern) -&gt; [Object]<br>Types:<br>Tab = tid() | atom()<br>Pattern = Object = tuple()</p>\n</blockquote>\n<blockquote>\n<p>match_object(Tab, Pattern, Limit) -&gt; {[Match],Continuation} | &#39;$end_of_table&#39;<br>Types:<br>Tab = tid() | atom()<br>Pattern = tuple()<br>Match = [term()]<br>Continuation = term()</p>\n</blockquote>\n<blockquote>\n<p>match_object(Continuation) -&gt; {[Match],Continuation} | &#39;$end_of_table&#39;<br>Types:<br>Match = [term()]<br>Continuation = term()</p>\n</blockquote>\n<p>与match一样,只不过这个返回的是整个object,而不是$所指定的值</p>\n<h4 id=\"init_table/2\">init_table/2</h4><blockquote>\n<p>init_table(Tab, InitFun) -&gt; true<br>Types:<br>Tab = tab()<br>InitFun = fun((Arg) -&gt; Res)<br>Arg = read | close<br>Res = end_of_input | {Objects :: [term()], InitFun} | term()</p>\n</blockquote>\n<p> 官方doc上面说</p>\n<blockquote>\n<p>This function is provided for compatibility with the dets module, it is not more efficient than filling a table by using ets:insert/2</p>\n</blockquote>\n<p>我们可以看出这个是为了和dets兼容才提供了这个接口,其实效率不比insert高,<br>InitFun是个fun函数,这个函数接受read和close这两个传入值, 返回结果如Res所示,如 fun(read) -&gt; end_of_input end. 其实这个函数的文档写的有些语焉不详,我们还是可以通过官方代码直到具体什么意思.<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">-spec</span> init_table<span class=\"params\">(Tab, InitFun)</span> -&gt; &#x27;true&#x27; when</span><br><span class=\"line\">      Tab :: tab<span class=\"params\">()</span>,</span><br><span class=\"line\">      InitFun :: fun<span class=\"params\">((Arg)</span> -&gt; Res),</span><br><span class=\"line\">      Arg :: &#x27;read&#x27; | &#x27;close&#x27;,</span><br><span class=\"line\">      Res :: &#x27;end_of_input&#x27; | &#123;Objects :: [term<span class=\"params\">()</span>], InitFun&#125; | term<span class=\"params\">()</span>.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">init_table</span><span class=\"params\">(Table, Fun)</span> -&gt;</span></span><br><span class=\"line\">    ets:delete_all_objects(Table),</span><br><span class=\"line\">    init_table_continue(Table, Fun(read)).</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">init_table_continue</span><span class=\"params\">(_Table, end_of_input)</span> -&gt;</span></span><br><span class=\"line\">    <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">init_table_continue</span><span class=\"params\">(Table, &#123;List, Fun&#125;)</span> <span class=\"title\">when</span> <span class=\"title\">is_list</span><span class=\"params\">(List)</span>, <span class=\"title\">is_function</span><span class=\"params\">(Fun)</span> -&gt;</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> (<span class=\"keyword\">catch</span> init_table_sub(Table, List)) <span class=\"keyword\">of</span></span><br><span class=\"line\">\t&#123;&#x27;EXIT&#x27;, Reason&#125; -&gt;</span><br><span class=\"line\">\t    (<span class=\"keyword\">catch</span> Fun(close)),</span><br><span class=\"line\">\t    exit(Reason);</span><br><span class=\"line\">\t<span class=\"literal\">true</span> -&gt;</span><br><span class=\"line\">\t    init_table_continue(Table, Fun(read))</span><br><span class=\"line\">    <span class=\"keyword\">end</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">init_table_continue</span><span class=\"params\">(_Table, Error)</span> -&gt;</span></span><br><span class=\"line\">    exit(Error).</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">init_table_sub</span><span class=\"params\">(_Table, [])</span> -&gt;</span></span><br><span class=\"line\">    <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">init_table_sub</span><span class=\"params\">(Table, [H|T])</span> -&gt;</span></span><br><span class=\"line\">    ets:insert(Table, H),</span><br><span class=\"line\">    init_table_sub(Table, T).</span><br></pre></td></tr></table></figure></p>\n<p>可以看出首先用delete_all_objects删掉了之前ets的数据,之后在init_table_sub中分别插入List中的元素,在调用List,之后的initfun,遇到end_of_input为止. j<br>举个简单的例子<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">21</span>&gt; ets:new(test, [named_table]).</span><br><span class=\"line\">test</span><br><span class=\"line\"><span class=\"number\">22</span>&gt; ets:insert(test, &#123;test1, result1&#125;).</span><br><span class=\"line\"><span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"number\">23</span>&gt; ets:tab2list(test).</span><br><span class=\"line\">[&#123;test1,result1&#125;]</span><br><span class=\"line\"><span class=\"number\">24</span>&gt; ets:init_table(test, <span class=\"keyword\">fun</span>(read) -&gt; &#123;[&#123;test2, result2&#125;,&#123;test3, result3&#125;], <span class=\"keyword\">fun</span>(read) -&gt; <span class=\"keyword\">end</span>_of_input end&#125; <span class=\"keyword\">end</span>).</span><br><span class=\"line\"><span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"number\">25</span>&gt; ets:tab2list(test).</span><br><span class=\"line\">[&#123;test3,result3&#125;,&#123;test2,result2&#125;]</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"member/2\">member/2</h4><blockquote>\n<p>member(Tab, Key) -&gt; true | false</p>\n</blockquote>\n<p>如果key在Tab中有值则返回true,否则false</p>\n<h4 id=\"rename/2\">rename/2</h4><blockquote>\n<p>rename(Tab, Name) -&gt; Name</p>\n</blockquote>\n<p>重命名一个table,只对有名字的table有效</p>\n<h4 id=\"safe_fixtable/2\">safe_fixtable/2</h4><blockquote>\n<p>safe_fixtable(Tab, true|false) -&gt; true</p>\n</blockquote>\n<p>当一个进程对某个ets用了safe_fixtable(Tab, true)后,这个进程对这个ets的first和next操作的key只返回没有返回过的key,也就是说ets表中的每个key只返回一次,为什么这么说呢.我们知道ordered_set中的key是排好序的,只要不停的next,肯定会得到更大的key,加入删除了之前一个较小的key,那么再次插入时,也不过next到这个key,但是set,bag表不是,有可能在next的过程中,如果有别的进程删除了你之前遍历过的key,之后在插入,将有可能再次next到这个key,safe_fixtable的作用就是对每个结果只返回一次,这个在游戏中对线上玩家列表的操作有一定作用,ets的官方文档中的foldl等也用到了.</p>\n<blockquote>\n<p>Note that no deleted objects are actually removed from a fixed table until it has been released. If a process fixes a table but never releases it, the memory used by the deleted objects will never be freed. The performance of operations on the table will also degrade significantly.</p>\n</blockquote>\n<p>值得注意的是在有进程对ets fixtable的情况对ets中数据的删除并没有真正的删除,直到这个进程死掉或者释放掉safe_fixtable为止,此时对ets的操作效率将显著降低, 所以尽量少用ets:foldl.<br>可参考:<a href=\"http://stackoverflow.com/questions/20327171/etsfoldl-vs-deleted-elements/20338795#20338795\">http://stackoverflow.com/questions/20327171/etsfoldl-vs-deleted-elements/20338795#20338795</a></p>\n<h4 id=\"setopts/2\">setopts/2</h4><blockquote>\n<p>setopts(Tab, Opts) -&gt; true</p>\n</blockquote>\n<p>opts只能是[{heir,pid(),HeirData} | {heir,none}],用于在table创建后修改继承选项,只能由table的owner调用</p>\n<h4 id=\"update_counter/3\">update_counter/3</h4><blockquote>\n<p>update_counter(Tab, Key, UpdateOp) -&gt; Result<br>update_counter(Tab, Key, [UpdateOp]) -&gt; [Result]<br>update_counter(Tab, Key, Incr) -&gt; Result<br>Types:<br>Tab = tid() | atom()<br>Key = term()<br>UpdateOp = {Pos,Incr} | {Pos,Incr,Threshold,SetValue}<br>Pos = Incr = Threshold = SetValue = Result = integer()</p>\n</blockquote>\n<p>更新ets中的数据,省去从ets去数据,相加在存入这个流程, Threshold是阈值,根据incr的正负,当结果大于或小于阈值时,将值设为SetValue.<br><strong><em>只能用于set和ordered_set</em></strong><br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">3</span>&gt; ets:new(test, [named_table]).</span><br><span class=\"line\">test</span><br><span class=\"line\"><span class=\"number\">4</span>&gt; </span><br><span class=\"line\"><span class=\"number\">4</span>&gt; ets:insert(test,[&#123;one, <span class=\"number\">1</span>&#125;,&#123;two, <span class=\"number\">2</span>&#125;,&#123;three, <span class=\"number\">3</span>&#125;,&#123;four, <span class=\"number\">4</span>&#125;]).</span><br><span class=\"line\"><span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"number\">5</span>&gt; ets:update_counter(test, one, <span class=\"number\">1</span>). </span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">6</span>&gt; ets:tab2list(test).</span><br><span class=\"line\">[&#123;two,<span class=\"number\">2</span>&#125;,&#123;three,<span class=\"number\">3</span>&#125;,&#123;one,<span class=\"number\">2</span>&#125;,&#123;four,<span class=\"number\">4</span>&#125;]</span><br><span class=\"line\"><span class=\"number\">7</span>&gt; ets:insert(test,&#123;five, haha, <span class=\"number\">5</span>&#125;).</span><br><span class=\"line\"><span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"number\">8</span>&gt; ets:update_counter(test, five, &#123;<span class=\"number\">3</span>, <span class=\"number\">1</span>&#125;).</span><br><span class=\"line\"><span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"number\">9</span>&gt; ets:tab2list(test).</span><br><span class=\"line\">[&#123;two,<span class=\"number\">2</span>&#125;,&#123;five,haha,<span class=\"number\">6</span>&#125;,&#123;three,<span class=\"number\">3</span>&#125;,&#123;one,<span class=\"number\">2</span>&#125;,&#123;four,<span class=\"number\">4</span>&#125;]</span><br><span class=\"line\"><span class=\"number\">10</span>&gt; ets:update_counter(test, five, &#123;<span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">6</span>, <span class=\"number\">5</span>&#125;).</span><br><span class=\"line\"><span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"number\">11</span>&gt; ets:tab2list(test).</span><br><span class=\"line\">[&#123;two,<span class=\"number\">2</span>&#125;,&#123;five,haha,<span class=\"number\">5</span>&#125;,&#123;three,<span class=\"number\">3</span>&#125;,&#123;one,<span class=\"number\">2</span>&#125;,&#123;four,<span class=\"number\">4</span>&#125;]</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"update_element/3\">update_element/3</h4><blockquote>\n<p>update_element(Tab, Key, {Pos,Value}) -&gt; true | false<br>update_element(Tab, Key, [{Pos,Value}]) -&gt; true | false<br>Types:<br>Tab = tid() | atom()<br>Key = Value = term()<br>Pos = integer()</p>\n</blockquote>\n<p>大致跟上面一样,未找到Key会返回false.</p>\n<h3 id=\"所有关于match_specification\">所有关于match specification</h3><p>下面的函数都有用到MatchSpec这个数据类型，<br>定义见: [doc]: (<a href=\"http://www.erlang.org/doc/apps/erts/match_spec.html)\">http://www.erlang.org/doc/apps/erts/match_spec.html)</a>.<br>match specification用于更为复杂的匹配情况,可以用于ets和erlang:trace_pattern中,一个ms的具体例子可能如下</p>\n<p><img src=\"../../../../img/ets1.png\" alt=\"\"></p>\n<p>乍看之下是非常难懂的,抽象一下大致是这个样子<br>[{InitialPattern1, Guards1, ReturnedValue1},<br>{InitialPattern2, Guards2, ReturnedValue2}].<br>上面的{&#39;$1&#39;,&#39;$2&#39;,&lt;<1>&gt;,&#39;$3&#39;,&#39;$4&#39;}是InitialPattern, [{&#39;andalso&#39;,{&#39;&gt;&#39;,&#39;$4&#39;,150},{&#39;&lt;&#39;,&#39;$4&#39;,500}},<br>{&#39;orelse&#39;,{&#39;==&#39;,&#39;$2&#39;,meat},{&#39;==&#39;,&#39;$2&#39;,dairy}}]和[{&#39;&lt;&#39;,&#39;$3&#39;,4.0},{is_float,&#39;$3&#39;}]是Guards1和Guards2,[&#39;$1&#39;]是returnedvalue.</p>\n<p>InitialPattern是将变量绑定到具体的$数字上,然后通过guard,得到returnvalue.<br>Guard的语序是{FunctionOrOperator, Arg1, ..., ArgN},&#39;andalso&#39; &#39;orelse&#39;和&#39;&lt;&#39;等属于FunctionorOperator,后面的是参数.<br>{&#39;andalso&#39;,{&#39;&gt;&#39;,&#39;$4&#39;,150},{&#39;&lt;&#39;,&#39;$4&#39;,500}}翻译过来就是 when $4 &gt; 150 andalso $4 &lt; 500.<br>如果满足这个Guard就返回$1.</p>\n<p>当然让我们去写这样一个match是很不符合人类的发展的,所以我们要用到下面的函数</p>\n<h4 id=\"fun2ms/1\">fun2ms/1</h4><blockquote>\n<p>fun2ms(LiteralFun) -&gt; MatchSpec<br>Types:<br>LiteralFun = function()<br>MatchSpec = match_spec()<br>这个函数将我们熟悉的fun函数转换成match specification的形式,这个转换过程由ms_transform完成,<br>需要在模块开头加上<br><strong><em>-include_lib(&quot;stdlib/include/ms_transform.hrl&quot;).</em></strong><br>需要注意的是fun的参数只有一个,只能是一个变量或者一个tuple不能使list等,不能使bit流.</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1&gt; ets:fun2ms(fun(X) when X &gt; 10 -&gt; X end).   </span><br><span class=\"line\">[&#123;&#x27;$1&#x27;,[&#123;&#x27;&gt;&#x27;,&#x27;$1&#x27;,10&#125;],[&#x27;$1&#x27;]&#125;]</span><br><span class=\"line\">2&gt; ets:fun2ms(fun(&#123;X, Y&#125;) when X &gt; 10, Y &lt; 20 -&gt; X * Y end).</span><br><span class=\"line\">[&#123;&#123;&#x27;$1&#x27;,&#x27;$2&#x27;&#125;,</span><br><span class=\"line\">  [&#123;&#x27;&gt;&#x27;,&#x27;$1&#x27;,10&#125;,&#123;&#x27;&lt;&#x27;,&#x27;$2&#x27;,20&#125;],</span><br><span class=\"line\">  [&#123;&#x27;*&#x27;,&#x27;$1&#x27;,&#x27;$2&#x27;&#125;]&#125;]</span><br></pre></td></tr></table></figure>\n<p>ms的在ets中的主要作用是用在select语句中,达到类似于mysql中select的效果</p>\n<h4 id=\"select/1/2/3\">select/1/2/3</h4><blockquote>\n<p>select(Tab, MatchSpec) -&gt; [Match]<br>select(Tab, MatchSpec, Limit) -&gt; {[Match],Continuation} | &#39;$end_of_table&#39;<br>select(Continuation) -&gt; {[Match],Continuation} | &#39;$end_of_table&#39;<br>Types:<br>Tab = tid() | atom()<br>Match = term()<br>MatchSpec = match_spec()<br>Continuation = term()</p>\n</blockquote>\n<p>select/2将所有符合MatchSpec的结果返回，select/3制定了limit。返回的Continuation可以用在select/1中。为何这么做？官方说明是</p>\n<blockquote>\n<p>This is a space efficient way to work on objects in a table which is still faster than traversing the table object by object using ets:first/1 and ets:next/1.</p>\n</blockquote>\n<p>这样节省空间，同时比用first，next更加快。<br>下面的例子是在player表中有两个#player结构的数据。一个返回的是10010这个id的玩家，之后调用select(C)将第二个10011玩家玩家返回同时返回end of table。如果将end of table传入select会直接返回end of table。</p>\n<p><img src=\"../../../../img/ets2.png\" alt=\"\"></p>\n<p>learn you some erlang书中的例子，<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">11&gt; rd(food, &#123;name, calories, price, group&#125;).</span><br><span class=\"line\">food</span><br><span class=\"line\">12&gt; ets:new(food, [ordered_set, &#123;keypos,#food.name&#125;, named_table]).</span><br><span class=\"line\">food</span><br><span class=\"line\">13&gt; ets:insert(food, [#food&#123;name=salmon, calories=88, price=4.00, group=meat&#125;,</span><br><span class=\"line\">13&gt; #food&#123;name=cereals, calories=178, price=2.79, group=bread&#125;,</span><br><span class=\"line\">13&gt; #food&#123;name=milk, calories=150, price=3.23, group=dairy&#125;,</span><br><span class=\"line\">13&gt; #food&#123;name=cake, calories=650, price=7.21, group=delicious&#125;,</span><br><span class=\"line\">13&gt; #food&#123;name=bacon, calories=800, price=6.32, group=meat&#125;,</span><br><span class=\"line\">13&gt; #food&#123;name=sandwich, calories=550, price=5.78, group=whatever&#125;]).</span><br><span class=\"line\">true</span><br><span class=\"line\">14&gt; ets:select(food, ets:fun2ms(fun(N = #food&#123;calories=C&#125;) when C &lt; 600 -&gt; N end)).</span><br><span class=\"line\">[#food&#123;name = cereals,calories = 178,price = 2.79,group = bread&#125;,</span><br><span class=\"line\">#food&#123;name = milk,calories = 150,price = 3.23,group = dairy&#125;,</span><br><span class=\"line\">#food&#123;name = salmon,calories = 88,price = 4.0,group = meat&#125;,</span><br><span class=\"line\">#food&#123;name = sandwich,calories = 550,price = 5.78,group = whatever&#125;]</span><br><span class=\"line\">15&gt; ets:select_reverse(food, ets:fun2ms(fun(N = #food&#123;calories=C&#125;) when C &lt; 600 -&gt; N end)).</span><br><span class=\"line\">[#food&#123;name = sandwich,calories = 550,price = 5.78,group = whatever&#125;,</span><br><span class=\"line\">#food&#123;name = salmon,calories = 88,price = 4.0,group = meat&#125;,</span><br><span class=\"line\">#food&#123;name = milk,calories = 150,price = 3.23,group = dairy&#125;,</span><br><span class=\"line\">#food&#123;name = cereals,calories = 178,price = 2.79,group = bread&#125;]</span><br></pre></td></tr></table></figure><br> 同时在官方doc的ms_transform中有个多个子句的例子</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ets:select(emp_tab, ets:fun2ms(</span><br><span class=\"line\">                     fun(#emp&#123;empno = E, surname = &quot;Smith&quot; &#125;) -&gt;</span><br><span class=\"line\">                             &#123;guru,E&#125;;</span><br><span class=\"line\">                        (#emp&#123;empno = E, empyear = Y&#125;) when Y &lt; 1997  -&gt;</span><br><span class=\"line\">                             &#123;inventory, E&#125;;</span><br><span class=\"line\">                        (#emp&#123;empno = E, empyear = Y&#125;) when Y &gt; 2001  -&gt;</span><br><span class=\"line\">                             &#123;newbie, E&#125;;</span><br><span class=\"line\">                        (#emp&#123;empno = E, empyear = Y&#125;) -&gt; % 1997 -- 2001</span><br><span class=\"line\">                             &#123;rookie, E&#125;</span><br><span class=\"line\">                     end)).  </span><br></pre></td></tr></table></figure>\n<h4 id=\"select_count/2\">select_count/2</h4><blockquote>\n<p>select_count(Tab, MatchSpec) -&gt; NumMatched<br>Types:<br>Tab = tid() | atom()<br>Object = tuple()<br>MatchSpec = match_spec()<br>NumMatched = integer()<br>对MS返回为true的会计数。如下，得出player表中id大于0的玩家数。</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> ets:select_count(player, ets:fun2ms(fun(#player&#123;id = ID&#125;) -&gt; ID &gt; 0  end)).    </span><br><span class=\"line\">2</span><br></pre></td></tr></table></figure>\n<h4 id=\"select_delete/2\">select_delete/2</h4><blockquote>\n<p>select_delete(Tab, MatchSpec) -&gt; NumDeleted<br>Types:<br>Tab = tid() | atom()<br>Object = tuple()<br>MatchSpec = match_spec()<br>NumDeleted = integer()</p>\n</blockquote>\n<p>大致同count，将返回true的object从表中删掉。</p>\n<h4 id=\"select_reverse/1/2/3\">select_reverse/1/2/3</h4><blockquote>\n<p>select_reverse(Tab, MatchSpec) -&gt; [Match]<br>Types:<br>Tab = tid() | atom()<br>Match = term()<br>MatchSpec = match_spec()<br>select_reverse(Tab, MatchSpec, Limit) -&gt; {[Match],Continuation} | &#39;$end_of_table&#39;<br>Types:<br>Tab = tid() | atom()<br>Match = term()<br>MatchSpec = match_spec()<br>Continuation = term()<br>select_reverse(Tab, MatchSpec) -&gt; [Match]<br>Types:<br>Tab = tid() | atom()<br>Match = term()<br>MatchSpec = match_spec()</p>\n</blockquote>\n<p>与只不过将select的结果反序，对order_set表有效，其他类型的表与select返回结果一致。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1&gt; T = ets:new(x,[ordered_set]).</span><br><span class=\"line\">2&gt; [ ets:insert(T,&#123;N&#125;) || N &lt;- lists:seq(1,10) ].</span><br><span class=\"line\">...</span><br><span class=\"line\">3&gt; &#123;R0,C0&#125; = ets:select_reverse(T,[&#123;&#x27;_&#x27;,[],[&#x27;$_&#x27;]&#125;],4).</span><br><span class=\"line\">...</span><br><span class=\"line\">4&gt; R0.</span><br><span class=\"line\">[&#123;10&#125;,&#123;9&#125;,&#123;8&#125;,&#123;7&#125;]</span><br><span class=\"line\">5&gt; &#123;R1,C1&#125; = ets:select_reverse(C0).</span><br><span class=\"line\">...</span><br><span class=\"line\">6&gt; R1.</span><br><span class=\"line\">[&#123;6&#125;,&#123;5&#125;,&#123;4&#125;,&#123;3&#125;]</span><br><span class=\"line\">7&gt; &#123;R2,C2&#125; = ets:select_reverse(C1).</span><br><span class=\"line\">...</span><br><span class=\"line\">8&gt; R2.</span><br><span class=\"line\">[&#123;2&#125;,&#123;1&#125;]</span><br><span class=\"line\">9&gt; &#x27;$end_of_table&#x27; = ets:select_reverse(C2).</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"match_spec_compile/1\">match_spec_compile/1</h4><h4 id=\"match_spec_run/2\">match_spec_run/2</h4><h4 id=\"is_compiled_ms/1\">is_compiled_ms/1</h4><blockquote>\n<p>match_spec_compile(MatchSpec) -&gt; CompiledMatchSpec<br>Types:<br>MatchSpec = match_spec()<br>CompiledMatchSpec = comp_match_spec()<br>match_spec_run(List,CompiledMatchSpec) -&gt; list()<br>Types:<br>List = [ tuple() ]<br>CompiledMatchSpec = comp_match_spec()<br>is_compiled_ms(Term) -&gt; boolean()<br>Types:<br>Term = term()</p>\n</blockquote>\n<p>match_spec_compile将一个MS编译成一个不可见的内部形式供match_spec_run调用，is_compile_ms用来判断这个编译结果是否是个正确的编译，因为编译后的内部形式不能再节点间传递也不能储存在硬盘上。<br>比如<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ets:is_compiled_ms(ets:match_spec_compile([&#123;&#x27;_&#x27;,[],[true]&#125;])). </span><br></pre></td></tr></table></figure><br>返回的是true<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MS = ets:match_spec_compile([&#123;&#x27;_&#x27;,[],[true]&#125;]),</span><br><span class=\"line\">Broken = binary_to_term(term_to_binary(MS)),</span><br><span class=\"line\">ets:is_compiled_ms(Broken).</span><br></pre></td></tr></table></figure><br>返回的是false，因为不接受外部的转化。会使其失去原有的信息。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MatchSpec = ets:fun2ms(fun(&#123;M, N&#125;) when N &gt; 3 -&gt; M end),</span><br><span class=\"line\">CompiledMatchSpec = ets:match_spec_compile(MatchSpec),</span><br><span class=\"line\">List = [&#123;1, 2&#125;, &#123;3, 4&#125;, &#123;5, 6&#125;],</span><br><span class=\"line\">ets:match_spec_run(List, CompiledMatchSpec).</span><br></pre></td></tr></table></figure></p>\n<p>如果MatchSpec不是个合格的Ms会抛badarg的错误。</p>\n<h4 id=\"repair_continuation/2\">repair_continuation/2</h4><blockquote>\n<p>repair_continuation(Continuation, MatchSpec) -&gt; Continuation<br>Types:<br>Continuation = continuation()<br>MatchSpec = match_spec()</p>\n</blockquote>\n<p>用来修复select/3返回的continuation，如果continuation在被转化为外部形势（用来在节点间传递)，会失效，但是使用repair_continuation可以恢复。<br>例：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">%% 无效</span><br><span class=\"line\">T=ets:new(x,[]),</span><br><span class=\"line\">&#123;_,C&#125; = ets:select(T,ets:fun2ms(fun(&#123;N,_&#125;=A)</span><br><span class=\"line\">when (N rem 10) =:= 0 -&gt;</span><br><span class=\"line\">A</span><br><span class=\"line\">end),10),</span><br><span class=\"line\">Broken = binary_to_term(term_to_binary(C)),</span><br><span class=\"line\">ets:select(Broken).</span><br><span class=\"line\"></span><br><span class=\"line\">%% 有效</span><br><span class=\"line\">T=ets:new(x,[]),</span><br><span class=\"line\">MS = ets:fun2ms(fun(&#123;N,_&#125;=A)</span><br><span class=\"line\">when (N rem 10) =:= 0 -&gt;</span><br><span class=\"line\">A</span><br><span class=\"line\">end),</span><br><span class=\"line\">&#123;_,C&#125; = ets:select(T,MS,10),</span><br><span class=\"line\">Broken = binary_to_term(term_to_binary(C)),</span><br><span class=\"line\">ets:select(ets:repair_continuation(Broken,MS)).</span><br></pre></td></tr></table></figure></p>"},{"title":"Erlang中的lists模块","date":"2014-07-11T13:13:31.000Z","_content":"\n> 个人感觉erlang里面lists模块用的地方非常多,因为erlang中没有for循环,很多函数功能多是靠lists的map,filter或者列表解析完成的,所以lists里面的函数非常重要\n\n<!--more-->\n<!-- toc -->\n### all/2\n> all(Func, List) -> boolean()\n\n如果全员执行Func都返回true,则这个表达式返回true,否则返回false.\n\n\n```erlang\n2> lists:all(fun(X) -> is_integer(X) end, [1,2,3,4]).\ntrue\n3> lists:all(fun(X) -> is_integer(X) end, [1,2,\"haha\",4]).\nfalse\n```\n\n### any/2\n> any(Pred, List) -> boolean()\n\n与all大致相同,如果有任意一个List中的元素返回true,则any返回true.\n\n### append/1\n> append(ListOfLists) -> List1\n\n用于合并子列表,列表中元素最起码要有一层深度,而且append只能去掉一层的深度,如果子元素没有深度,就会抛错\n```erlang\n5> lists:append([[1,2,3],[2,3],[1],[2]]).\n[1,2,3,2,3,1,2]\n7> lists:append([[1,2,3],[2,3],[1],[[1,[3,2]],2]]).\n[1,2,3,2,3,1,[1,[3,2]],2]\n8> lists:append([1,[2,3],[3]]).\n** exception error: bad argument\n     in operator  ++/2\n        called as 1 ++ [2,3,3]\n     in call from lists:append/1 (lists.erl, line 74)\n```\n\n因为在append的源码是:\n> 73 append([E]) -> E;\n  74 append([H|T]) -> H ++ append(T);\n  75 append([]) -> []. \n\n所以上面说 `++`附近出错,因为1不是列表.\n\n\n### append/2\n> append(List1, List2) -> List3\n\n源码\n>  append(L1, L2) -> L1 ++ L2.\n\n用于合并两个列表,其实append实质就是++,所以需要注意效率,因为++是将左边的列表都一遍,因此在递归中要始终保持左边的列表要是最短的那个.\n```erlang\n9> lists:append(\"haha\",\"heihei\").\n\"hahaheihei\"\n```\n\n### concat/1\n> concat([Things]) -> string()\n\nThings可以使integer,float,atom,string, concat将他们转换成一个字符串,如果Things中含有list,可能会整体装换成list.\n例如\n```\n10> lists:concat([\"haha\",[1],3,3.14,atom]).\n[104,97,104,97,1,51,51,46,49,52,48,48,48,48,48,48,48,48,48,\n 48,48,48,48,49,50,52,51,52,101|...]\n11> lists:concat([\"haha\",3,3.14,atom]).    \n\"haha33.14000000000000012434e+00atom\"\n```\n源码:\n```erlang\nconcat(List) ->\n    flatmap(fun thing_to_list/1, List).\n\nthing_to_list(X) when is_integer(X) -> integer_to_list(X);\nthing_to_list(X) when is_float(X)   -> float_to_list(X);\nthing_to_list(X) when is_atom(X)    -> atom_to_list(X);\nthing_to_list(X) when is_list(X)    -> X.\t%Assumed to be a string\n```\n\n### delete/2\n> delete(Elem, List) -> List1\n\n删除List中第一个等于Elem的元素,返回一个新的list\n```\n12> lists:delete(1,[1,2,1,3,4]).\n[2,1,3,4]\n```\n\n### dropwhile/2\n> dropwhile(Func, List) -> List1\n \n从左边开始去掉List中Func返回值为true的元素,遇到第一个返回false的元素时终止,并返回剩下列表.\n例子:\n```\n16> lists:dropwhile(fun(X) -> X rem 2 =:= 0  end, [2,4,3,5,6]).  \n[3,5,6]\n```\n源码实现:\n```erlang\ndropwhile(Pred, [Hd|Tail]=Rest) ->\n    case Pred(Hd) of\n\ttrue -> dropwhile(Pred, Tail);\n\tfalse -> Rest\n    end;\ndropwhile(Pred, []) when is_function(Pred, 1) -> [].\n```\n\n### duplicate/2\n> duplicate(N, Elem) -> List.\n\n生成N个Elem的列表.N不能使负数.原因可以看源码\n```erlang\n-spec duplicate(N, Elem) -> List when\n      N :: non_neg_integer(),\n      Elem :: T,\n      List :: [T],\n      T :: term().\n\nduplicate(N, X) when is_integer(N), N >= 0 -> duplicate(N, X, []).\n\nduplicate(0, _, L) -> L;\nduplicate(N, X, L) -> duplicate(N-1, X, [X|L]).\n```\n原理就是用列表构造,没添加一个H,N就-1,终止条件就是直到N=0,如果是负数则无法终止,所以不能为负\n例子:\n```\n17> lists:duplicate(3,\"haha\").\n[\"haha\",\"haha\",\"haha\"]\n```\n\n### filter/2\n> filter(Func, List) -> List1\n\n过滤器,返回列表,元素是List中所有Func返回值为true的元素.这个在工程中经常用.\n源码\n```erlang\n-spec filter(Pred, List1) -> List2 when\n      Pred :: fun((Elem :: T) -> boolean()),\n      List1 :: [T],\n      List2 :: [T],\n      T :: term().\n\nfilter(Pred, List) when is_function(Pred, 1) ->\n    [ E || E <- List, Pred(E) ].\n```\n可以看到,filter内部其实就是用列表解析实现的.\n例子:\n```\n19> lists:filter(fun(X) -> X rem 2 =:= 0 end, [2,4,3,5,6]).\n[2,4,6]\n```\n\n### flatlength/1\n> flatlength(DeepList) -> integer\n\n该函数返回一个深度列表的长度,如果是深度为1的列表可以直接用length(List)返回长度,\n官方doc这么说的\n> Equivalent to length(flatten(DeepList)), but more efficient.\n\n等同于深度列表扁平化后在length,但是这个做更搞笑,原因很简单,这个函数只不过计算长度,并没有将列表扁平化\n源码\n```erlang\n-spec flatlength(DeepList) -> non_neg_integer() when\n      DeepList :: [term() | DeepList].\n\nflatlength(List) ->\n    flatlength(List, 0).\n\nflatlength([H|T], L) when is_list(H) ->\n    flatlength(H, flatlength(T, L));\nflatlength([_|T], L) ->\n    flatlength(T, L + 1);\nflatlength([], L) -> L.\n```\n例子:\n```erlang\n> lists:flatlength([1,[2,[3],4,[5],6],[7,8]]).\n8\n```\n\n### flatten/1\n> flatten(Deeplist) -> List\n\n上面提到的flatten函数,用于扁平化一个深度列表,尽量少用,代价很高,甚至比++操作代价还高\n源码\n```erlang\n-spec flatten(DeepList) -> List when\n      DeepList :: [term() | DeepList],\n      List :: [term()].\n\nflatten(List) when is_list(List) ->\n    do_flatten(List, []).\n\n-spec flatten(DeepList, Tail) -> List when\n      DeepList :: [term() | DeepList],\n      Tail :: [term()],\n      List :: [term()].\n\nflatten(List, Tail) when is_list(List), is_list(Tail) ->\n    do_flatten(List, Tail).\n\ndo_flatten([H|T], Tail) when is_list(H) ->\n    do_flatten(H, do_flatten(T, Tail));\ndo_flatten([H|T], Tail) ->\n    [H|do_flatten(T, Tail)];\ndo_flatten([], Tail) ->\n    Tail.\n```\n\n在递归中为了伪递归,如果第一个元素是list就递归调用do_flatten,如果不是就用构造器放在新列表的头,剩下的部分继续调用do_flatten.\n**关于flatten的效率问题**\n在官方doc的efficiency guide中有专门一块Deep and flat lists,\n原文这么说\n> lists:flatten/1 builds an entirely new list. Therefore, it is expensive, and even more expensive than the ++ (which copies its left argument, but not its right argument).\nIn the following situations, you can easily avoid calling lists:flatten/1:\n1. When sending data to a port. Ports understand deep lists so there is no reason to flatten the list before sending it to the port.\n2. When calling BIFs that accept deep lists, such as list_to_binary/1 or iolist_to_binary/1.\n3. When you know that your list is only one level deep, you can can use lists:append/1.\n\n因为flatten是完全重建一个列表,甚至比++(复制左边,而右边保留)更为低效,但是有3种情况可以不适用flatten\n1. 往端口发送数据时,因为端口懂得深度列表\n2. 诸如`list_to_binary`和`iolist_to_binary`的BIF,不需要扁平化\n```erlang\n> list_to_binary([1,[2,[3,4]],5]).\n<<1,2,3,4,5>>\n```\n3. 如果我们知道列表深度只有一层,要用append代替flatten\n\n### flatten/2\n> flatten(DeepList, Tail) -> List.\n\n就是上面flatten/1调用的子函数,flatten(DeepList) 就是flatten(DeepList, []).\n函数在DeepList扁平化后append了一下Tail.\n```erlang\n27> lists:flatten([1,[3,[4,5],2]],[1,[2,[3]]]).\n[1,3,4,5,2,1,[2,[3]]]\n```\n\n### flatmap/2\n> flatmap(Func, List1) -> List2\n\n官方的说法是\n> That is, flatmap behaves as if it had been defined as follows:\nflatmap(Fun, List1) ->\n    append(map(Fun, List1)).\n\n就是List1中每个元素执行Fun,一般Fun返回一个列表,最后将这些列表append一下.\n例子:\n```erlang\n26> lists:flatmap(fun(X) -> [X, X+1] end, [1,3,5,7]).\n[1,2,3,4,5,6,7,8]\n```\n源码:\n```erlang\n-spec flatmap(Fun, List1) -> List2 when\n      Fun :: fun((A) -> [B]),\n      List1 :: [A],\n      List2 :: [B],\n      A :: term(),\n      B :: term().\n\nflatmap(F, [Hd|Tail]) ->\n    F(Hd) ++ flatmap(F, Tail);\nflatmap(F, []) when is_function(F, 1) -> [].\n```\n\n### foldl/3\n> foldl(Fun, Acc0, List) -> Acc1\n\n这个函数用的非常多,Fun是一个可接受2个参数的函数,例如fun(X, Sum) -> X + Sum end.那么List中的第一个元素带入X,然后Acc0带入Sum,执行得结果Acc1,然后将List中第二个元素带入X,将Acc1带入Sum,以此类推,每回fun的第二个参数是上把的结果,第一个元素是List中的元素.下面例子是一个累加函数\n例子:\n```erlang\n28> lists:foldl(fun(X, Sum) -> X + Sum end, 0, [2,4,6,8,10]).\n30\n```\n源码:\n```erlang\n-spec foldl(Fun, Acc0, List) -> Acc1 when\n      Fun :: fun((Elem :: T, AccIn) -> AccOut),\n      Acc0 :: term(),\n      Acc1 :: term(),\n      AccIn :: term(),\n      AccOut :: term(),\n      List :: [T],\n      T :: term().\n\nfoldl(F, Accu, [Hd|Tail]) ->\n    foldl(F, F(Hd, Accu), Tail);\nfoldl(F, Accu, []) when is_function(F, 2) -> Accu.\n```\n\n上面可以看到foldl的第二个参数就是F(Hd, Accu)的返回结果.\n\n\n### foldr/3\n不说了,跟上面一样,只不过是从右边开始带入.\n### map/2\n> map(Fun, List1) -> List2\n\n返回List1中每个元素执行Fun后的结果列表,官方doc上说执行顺序是运行时决定,这个和下面说的foreach不一样.\n例子:\n```erlang\n34> lists:map(fun(X) -> X*2 end, [1,2,3,4,5]).            \n[2,4,6,8,10]\n```\n源码:\n```erlang\nmap(F, [H|T]) ->\n    [F(H)|map(F, T)];\nmap(F, []) when is_function(F, 1) -> [].\n```\n\n### foreach/2\n\n> foreach(Fun, List1) -> ok.\n\n该函数和map很像,区别就是foreach只执行Fun函数却不保存结果,最后返回ok.\n源码:\n```erlang\nforeach(F, [Hd|Tail]) ->\n    F(Hd),\n    foreach(F, Tail);\nforeach(F, []) when is_function(F, 1) -> ok.\n```\n\n这里和map不同的是foreach的递归在执行完前一个元素的Fun函数后才会继续执行一下个元素的Fun函数,这里的执行顺序就是列表的顺序,官方doc上说:`this function is used for its side effects`\n我不是很理解具体有什么用...\n\n### keydelete/3\n> keydelete(Key, N, TupleList) -> TupleList1\n\n主要用于由{}tuple 组成的列表,删除Tuplelist中第一个第N个位置的值等于Key的tuple,N是tuple中key应该匹配的位置.这个也经常用,比如一个地图中存了{PlayerId, name, str, magic...}之类的tuplelist,如果玩家离开地图,可以让Key为PlayerId,然后keydelete这个玩家的信息,因为PlayerId一般都是唯一的.\n例子:\n```erlang\n37> lists:keydelete(2010211108, 1, [{2010211105, sice, 5},{2010211106, sice, 6},{2010211107, sice, 7},{2010211108, 8}]).\n[{2010211105,sice,5},\n {2010211106,sice,6},\n {2010211107,sice,7}]\n```\n源码:\n```erlang\nkeydelete(K, N, L) when is_integer(N), N > 0 ->\n    keydelete3(K, N, L).\n\nkeydelete3(Key, N, [H|T]) when element(N, H) == Key -> T;\nkeydelete3(Key, N, [H|T]) ->\n    [H|keydelete3(Key, N, T)];\nkeydelete3(_, _, []) -> [].\n```\n\n### keyfind/3\n> keyfind(Key, N, TupleList) -> Tuple | false\n\n大致同上,如字面意思,只不过不delete掉,没找到会返回false,不过这个是BIF,也就是说用c写的,在lists模块看不到实现方法,BIF的效率一般都很高.\n例子:\n```erlang\n38> lists:keyfind(2010211108, 1, [{2010211105, sice, 5},{2010211106, sice, 6},{2010211107, sice, 7}]). \nfalse\n39> lists:keyfind(2010211106, 1, [{2010211105, sice, 5},{2010211106, sice, 6},{2010211107, sice, 7}]).\n{2010211106,sice,6}\n```\n\n> BIF的源码可以把github上的[erlang/otp](https://github.com/erlang/otp)clone下来\n然后在otp/erts/emulator/beam里面可以找到BIF的c代码,lists里面的BIF写在erl_bif_lists.c中\n以下是keyfind的源码,以后的BIF代码就不贴了,感兴趣可以自己去找,不是那么好懂.\n\n```c\nkeyfind(int Bif, Process* p, Eterm Key, Eterm Pos, Eterm List)\n{\n    int max_iter = 10 * CONTEXT_REDS;\n    Sint pos;\n    Eterm term;\n\n    if (!is_small(Pos) || (pos = signed_val(Pos)) < 1) {\n\tBIF_ERROR(p, BADARG);\n    }\n\n    if (is_small(Key)) {\n\tdouble float_key = (double) signed_val(Key);\n\n\twhile (is_list(List)) {\n\t    if (--max_iter < 0) {\n\t\tBUMP_ALL_REDS(p);\n\t\tBIF_TRAP3(bif_export[Bif], p, Key, Pos, List);\n\t    }\n\t    term = CAR(list_val(List));\n\t    List = CDR(list_val(List));\n\t    if (is_tuple(term)) {\n\t\tEterm *tuple_ptr = tuple_val(term);\n\t\tif (pos <= arityval(*tuple_ptr)) {\n\t\t    Eterm element = tuple_ptr[pos];\n\t\t    if (Key == element) {\n\t\t\treturn term;\n\t\t    } else if (is_float(element)) {\n\t\t\tFloatDef f;\n\n\t\t\tGET_DOUBLE(element, f);\n\t\t\tif (f.fd == float_key) {\n\t\t\t    return term;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t}\n    } else if (is_immed(Key)) {\n\twhile (is_list(List)) {\n\t    if (--max_iter < 0) {\n\t\tBUMP_ALL_REDS(p);\n\t\tBIF_TRAP3(bif_export[Bif], p, Key, Pos, List);\n\t    }\n\t    term = CAR(list_val(List));\n\t    List = CDR(list_val(List));\n\t    if (is_tuple(term)) {\n\t\tEterm *tuple_ptr = tuple_val(term);\n\t\tif (pos <= arityval(*tuple_ptr)) {\n\t\t    Eterm element = tuple_ptr[pos];\n\t\t    if (Key == element) {\n\t\t\treturn term;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    } else {\n\twhile (is_list(List)) {\n\t    if (--max_iter < 0) {\n\t\tBUMP_ALL_REDS(p);\n\t\tBIF_TRAP3(bif_export[Bif], p, Key, Pos, List);\n\t    }\n\t    term = CAR(list_val(List));\n\t    List = CDR(list_val(List));\n\t    if (is_tuple(term)) {\n\t\tEterm *tuple_ptr = tuple_val(term);\n\t\tif (pos <= arityval(*tuple_ptr)) {\n\t\t    Eterm element = tuple_ptr[pos];\n\t\t    if (CMP(Key, element) == 0) {\n\t\t\treturn term;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n\n    if (is_not_nil(List))  {\n\tBIF_ERROR(p, BADARG);\n    }\n    return am_false;\n}\n```\n\n哎,跟这c代码比,还是erlang看起来舒服,简单.\n\n### keyserach/3\n> keysearch(Key, N, TupleList) -> {value, Tuple} | false\n\n与keyfind的功能相同,只不过返回值多了个value的标签,同样是BIF,lists.erl中没有源码,这个函数存在是为了向后兼容,keyfind用的更多些,但是keyfind是在R13B版本引入的,较老的版本用的是keysearch.\n\n### keymember/3\n> keymember(Key, N, Tuplelist) -> boolean()\n\n功能和以上大致一样,也是BIF,只不过返回是true或false.\n\n### keymap/3\n> keymap(Fun, N, Tuplelist) -> Tuplelist2\n\n用于将每个tuple的第N个元素替换为Fun(第N个元素)的执行结果.\n例子:\n```erlang\n40> lists:keymap(fun(X) -> atom_to_list(X) end, 2, [{1, john, boy},{2, aya, girl}, {3, cameron, robot}]).\n[{1,\"john\",boy},{2,\"aya\",girl},{3,\"cameron\",robot}]\n```\n源码:\n```erlang\nkeymap(Fun, Index, [Tup|Tail]) ->\n   [setelement(Index, Tup, Fun(element(Index, Tup)))|keymap(Fun, Index, Tail)];\nkeymap(Fun, Index, []) when is_integer(Index), Index >= 1, \n                            is_function(Fun, 1) -> [].\n```\n\nsetelement从字面就可以看出是将Tup的 Index内容替换为Fun(element(Index, Tup)). 而,element就是返回Tup中第Index的值,这些东西都浓缩到一句代码实现,所以说erlang很有意思.\n\n### keymerge/3\n> keymerge(N, TupleList1, TupleList2) -> TupleList3\n\n将TupleList1和TupleList2合并并排序,其中N用来制定用Tuple中的第N元素为依据排序,注意,tuplelist1和tuplelist2在执行keymerge前需要是已经按N排好序,否则顺序可能不正确,如果tuplelist1有和tuplelist2中有第N元素相同的tuple,则Tuplelist1的在前面.\n例子:\n```erlang\n42> lists:keymerge(2, [{a,1},{c,3}],[{b,2},{d,4}]).\n[{a,1},{b,2},{c,3},{d,4}]\n%顺序出错\n43> lists:keymerge(2, [{a,1},{c,3}],[{d,4},{b,2}]).     \n[{a,1},{c,3},{d,4},{b,2}]  \n%tuplelist1的在前面\n44> lists:keymerge(2, [{a,1},{c,3}],[{e,3},{d,4}]).\n[{a,1},{c,3},{e,3},{d,4}]\n```\n\n源码不放了,这个比较复杂,太长了,感兴趣的自己去找吧.\n\n### keyreplace/4\n> keyreplace(Key, N, TupleList1, NewTuple) -> TupleList2\n\n如字面意思,用于替换,将TupleList1中第N个值等于Key的tuple替换为NewTuple.只替换第一个.\n例子:\n```erlang\n46> lists:keyreplace(name2, 2, [{player1, name1, career1},{player2, name2, career2},{player3, name3, career3}], {player4, name4, career4}).\n[{player1,name1,career1},\n {player4,name4,career4},\n {player3,name3,career3}]\n```\n源码:\n```erlang\nkeyreplace(K, N, L, New) when is_integer(N), N > 0, is_tuple(New) ->\n    keyreplace3(K, N, L, New).\n\nkeyreplace3(Key, Pos, [Tup|Tail], New) when element(Pos, Tup) == Key ->\n    [New|Tail];\nkeyreplace3(Key, Pos, [H|T], New) ->\n    [H|keyreplace3(Key, Pos, T, New)];\nkeyreplace3(_, _, [], _) -> [].\n```\n\n### keysort/2\n> keysort(N, TupleList1) -> TupleList2.\n\nexample:\n```erlang\n47> lists:keysort(1,[{3,name3},{2, name2}, {4,name4},{1,name1}]).\n[{1,name1},{2,name2},{3,name3},{4,name4}]\n```\n\n源码不贴了,这个函数的源码很长.\n### keystore/4\n> keystore(Key, N, TupleList1, NewTuple) -> TupleList2.\n\n功能和keyreplace差不多,只不过当TupleList1中没有与Key相同的Tuple时,keyreplace返回的是原来的TupleList,而keystore是将NewTuple append在原TupleList上.\n例子;\n```erlang\n48> lists:keyreplace(name5, 2, [{player1, name1, career1},{player2, name2, career2},{player3, name3, career3}], {player4, name4, career4}).\n[{player1,name1,career1},\n {player2,name2,career2},\n {player3,name3,career3}]\n49> lists:keystore(name5, 2, [{player1, name1, career1},{player2, name2, career2},{player3, name3, career3}], {player4, name4, career4}).  \n[{player1,name1,career1},\n {player2,name2,career2},\n {player3,name3,career3},\n {player4,name4,career4}]\n```\n\n### keytake/3\n> keytake(Key, N, TupleList1) -> {value, Tuple, TupleList2} | false\n\n与大多数key打头的函数相同,字面意思是从TupleList中拿出第N个值和Key相等的Tuple,如果有的话,返回{value, Tuple, TupleList2},Tuple是想的Tuple,TupleList2是去掉Tuple后的新的TupleList.如果没找到则返回false.\nexample:\n```erlang\n50> lists:keytake(name2, 2, [{player1, name1, career1},{player2, name2, career2},{player3, name3, career3}]).                            \n{value,{player2,name2,career2},\n       [{player1,name1,career1},{player3,name3,career3}]}\n```\n源码:\n```erlang\nkeytake(Key, N, L) when is_integer(N), N > 0 ->\n    keytake(Key, N, L, []).\n\nkeytake(Key, N, [H|T], L) when element(N, H) == Key ->\n    {value, H, lists:reverse(L, T)};\nkeytake(Key, N, [H|T], L) ->\n    keytake(Key, N, T, [H|L]);\nkeytake(_K, _N, [], _L) -> false.\n```\n\n### last/1\n> last(List) -> Last\n\n返回List中最后一个元素.\n源码:\n```erlang\nlast([E|Es]) -> last(E, Es).\n\nlast(_, [E|Es]) -> last(E, Es);\nlast(E, []) -> E.\n```\n\n### mapfoldl/3\n> mapfoldl(Fun, Acc0, List1) -> {List2, Acc1}.\n\n官方的解释就是同时具有map和foldl的功能.直白点就是map完成List1->List2的变化,foldl完成 Acc0 -> Acc1的变化.\n因为foldl只能返回一个由List1得到的记过Acc1,而不能多List1本身得到新的List2,而map不能得到Acc1,却能完成List1到List2的变化.所以mapfoldl完成了两者的功能.看源码会比较清晰的理解下.\n源码:\n```erlang\n-spec mapfoldl(Fun, Acc0, List1) -> {List2, Acc1} when\n      Fun :: fun((A, AccIn) -> {B, AccOut}),\n      Acc0 :: term(),\n      Acc1 :: term(),\n      AccIn :: term(),\n      AccOut :: term(),\n      List1 :: [A],\n      List2 :: [B],\n      A :: term(),\n      B :: term().\n\nmapfoldl(F, Accu0, [Hd|Tail]) ->\n    {R,Accu1} = F(Hd, Accu0),\n    {Rs,Accu2} = mapfoldl(F, Accu1, Tail),\n    {[R|Rs],Accu2};\nmapfoldl(F, Accu, []) when is_function(F, 2) -> {[],Accu}.\n```\n注意,这里面的Fun返回的是{B, AccOut}的形式,而foldl的Fun是`      Fun :: fun((Elem :: T, AccIn) -> AccOut),\n`这里是最本质的区别.结合例子说下\n```erlang\n52> lists:mapfoldl(fun(X, Sum) -> {X*2, X + Sum} end, 0, [1,2,3,4,5]).\n{[2,4,6,8,10],15}\n```\n\n首先第一轮得到的{R, Accu1} = {2, 1},而{Rs, Accu2}需要递归执行mapfoldl,那么第二轮得到一个{R',Accu1'} = {4, 3},我们每轮能确切知道的只有{R, Accu1},但是mapfoldl要返回的是{[R|Rs],Accu2},所以需要一直递归下去,那么第三轮得到{6, 6},第四轮{8, 10},第五轮得到{10, 15},这时{10, 15}仍然是{R, Accu1},但是接下来由于Tail变成了空列表[],根据模式匹配,这次执行的是第二个mapfoldl函数,那么相当于执行mapfoldl{F, 15, []),得到最底层的{Rs, Accu2} = {[], 15},那么返回的{[R|Rs], Accu2}为{[10|[]], 15}.一直往上递归回去,结果得到{[2,4,6,8,10], 15}.\n\n### mapfoldr/3\n与上面的执行结果一样,只不过foldr是从右边开始,不影响List2的顺序.\n\n### max/1\n> max(List) -> Max\n\n返回第一个这个List中的最大数.\n例子:\n```erlang\n54> lists:max([a,b,c]).\nc\n55> lists:max([100,b,c]).\nc\n56> lists:max([{100},b,c]).\n{100}\n57> lists:max([{100},b,c,[90]]).\n\"Z\"\n58> lists:max([{100},b,c,[2]]). \n[2]\n59> lists:max([{100},b,c,[2],<<2>>]).\n<<2>>\n```\n\n这里注意下不同类型之间的比较顺序\n> number &lt; atom < reference < fun < port < pid < tuple < list < binary\n\n源码:\n```erlang\nmax([H|T]) -> max(T, H).\n\nmax([H|T], Max) when H > Max -> max(T, H);\nmax([_|T], Max)              -> max(T, Max);\nmax([],    Max)              -> Max.\n```\n\n### member/2\n> member(Elem, List) -> boolean()\n\n如果Elem是List中的元素就返回true, 否则返回false.BIF.源码是C写的.不贴了.\n### merge/1/2/3以及merge3/3\n> merge(ListOfLists) -> List1.\nmerge(List1, List2) -> List3.\nmerge(Fun, List1, List2) -> List3.\nmerge3(List1, List2, List3) -> List4\n\n暂且叫归并排序吧,merge/1,merge/2完成的就是合并并排序,顺序由小到大,merge3/3只不过可以合并3个列表.merge/3可以依据Fun更改顺序,排序依据是Fun(A, B)如果返回true,那么就是A在B的前面.\n举几个例子:\n```erlang\n60> lists:merge([[1],[4],[2,4],[3]]).\n[1,2,3,4,4]\n61> lists:merge([2,4,6],[1,3]).      \n[1,2,3,4,6]\n62> lists:merge(fun(A,B) -> A > B end, [5,4,2],[8,3,1]).\n[8,5,4,3,2,1]\n63> lists:merge(fun(A,B) -> A < B end, [5,4,2],[8,3,1]).\n[5,4,2,8,3,1]\n64> lists:merge(fun(A,B) -> A < B end, [2,4,5],[1,3,8]).\n[1,2,3,4,5,8]\n66> lists:merge3([2,4,6],[1,3],[2,3,5,7]).\n[1,2,2,3,3,4,5,6,7]\n```\n\n所有的排序都要求每个子List在排序前都是排好序的,如63行,由于子列表没有排好序,所以排序结果不正确.\nmerge的源码比较多而且杂,感兴趣自己去lists.erl里面看.\n\n### min/1\n> min(List) -> Min\n\n与max相反.\n\n### nth/2\n> nth(N, List) -> Elem\n\n返回第List的第N个元素.\n例子:\n```erlang\n67> lists:nth(2,[\"haha\",atom,2,<<\"binary\">>]). \natom\n```\n源码:\n```erlang\nnth(1, [H|_]) -> H;\nnth(N, [_|T]) when N > 1 ->\n    nth(N - 1, T).\n```\n\n### nthtail/2\n> nthtail(N, List) -> Tail\n\n返回List的第N个尾列表.\n例子:\n```erlang\n68> lists:nthtail(0,[1,2,3,4]).\n[1,2,3,4]\n69> lists:nthtail(1,[1,2,3,4]).\n[2,3,4]\n70> lists:nthtail(2,[1,2,3,4]).\n[3,4]\n71> lists:nthtail(4,[1,2,3,4]).\n[]\n```\n源码:\n```erlang\nnthtail(1, [_|T]) -> T;\nnthtail(N, [_|T]) when N > 1 ->\n    nthtail(N - 1, T);\nnthtail(0, L) when is_list(L) -> L.\n```\n\n### partition/2\n> partition(Fun, List1) -> {List1, List2}.\n\n字面意思是区分开,将List1依据Fun返回的true和false分为两个列表.\n例子:\n```erlang\n73> lists:partition(fun(X) -> X>2 end, [1,2,3,4]).\n{[3,4],[1,2]}\n```\n源码\n```erlang\npartition(Pred, L) ->\n    partition(Pred, L, [], []).\n\npartition(Pred, [H | T], As, Bs) ->\n    case Pred(H) of\n\ttrue -> partition(Pred, T, [H | As], Bs);\n\tfalse -> partition(Pred, T, As, [H | Bs])\n    end;\npartition(Pred, [], As, Bs) when is_function(Pred, 1) ->\n    {reverse(As), reverse(Bs)}.\n```\n\n### prefix/2\n> prefix(List1, List2) -> boolean().\n\n如果List1是List2的前缀则返回true,否则返回false\n例子:\n```erlang\n74> lists:prefix([1,2],[1,2,3,4]).                \ntrue\n75> lists:prefix([1,2],[1,3,4]).  \nfalse\n```\n源码很好理解:\n```erlang\nprefix([X|PreTail], [X|Tail]) ->\n    prefix(PreTail, Tail);\nprefix([], List) when is_list(List) -> true;\nprefix([_|_], List) when is_list(List) -> false.\n```\n\n如果第一元素都是X,则递归执行prefix,如果List1为[]了,那么返回true,如果遇到不相同的元素了就返回false.\n\n### reverse/1/2\n> reverse(List1) -> List2.\nreverse(List1, Tail) -> List2.\n\nreverse/1返回的是逆序的List1. reverse/2返回的是逆序的List1并且append了Tail.\n例子:\n```erlang\n76> lists:reverse([1,2,3,4]).\n[4,3,2,1]\n77> lists:reverse([1,2,3,4],[5,6,7]).\n[4,3,2,1,5,6,7]\n```\n源码:\n```erlang\n-spec reverse(List1) -> List2 when\n      List1 :: [T],\n      List2 :: [T],\n      T :: term().\n\nreverse([] = L) ->\n    L;\nreverse([_] = L) ->\n    L;\nreverse([A, B]) ->\n    [B, A];\nreverse([A, B | L]) ->\n    lists:reverse(L, [B, A]).\n```\n\n注意这里比较神奇的是reverse/1调用的是reverse/2,我一直以为reverse/1是BIF,其实reverse/2才是BIF,而且reverse/2在各种merge函数中多次调用,调用reverse/2的次数非常多,估计所以才将reverse/2写成了BIF吧.\n\n### seq/2/3\n> seq(From, To) -> List1\nseq(From, To, Incr) -> List2\n\n用于生成From到To的列表,Incr是递增的值.这个函数通常只用于最简单的功能,但是还是需要注意一下,这个函数报错的条件比较苛刻.官方给的说明是在一下会发生error错误.\n1. To < From - Incr 并且Incr是正数.\n2. To > From - Incr 并且Incr是负数.\n3. Incr为0时,From 不等于 To\n并且官方给出\n> length(lists:seq(From, To)) == To-From+1\nlength(lists:seq(From, To, Incr)) == (To-From+Incr) div Incr\n\n涵盖了上面3种情况,因为length不能是负数,其实只要看***To-From+Incr与Incr相除***是正数或者0就不会报错.\n以下是一些例子:\n```erlang\n78> lists:seq(1,4).\n[1,2,3,4]\n79> lists:seq(3,1).\n** exception error: no function clause matching lists:seq(3,1) (lists.erl, line 177)\n80> lists:seq(3,1,-1).\n[3,2,1]\n81> lists:seq(3,1,1). \n** exception error: no true branch found when evaluating an if expression\n     in function  lists:seq/3 (lists.erl, line 198)\n82> lists:seq(1,0,1).\n[]\n83> lists:seq(10,6,1).\n** exception error: no true branch found when evaluating an if expression\n     in function  lists:seq/3 (lists.erl, line 198)\n84> lists:seq(10,6,4).\n[]\n85> lists:seq(10,6,5).\n[]\n86> lists:seq(10,6,3).\n** exception error: no true branch found when evaluating an if expression\n     in function  lists:seq/3 (lists.erl, line 198)\n87> lists:seq(1,4).\n[1,2,3,4]\n88> lists:seq(1,0).\n[]\n89> lists:seq(3,0,-1).\n[3,2,1,0]\n90> lists:seq(10,6,4).\n[]\n91> lists:seq(10,6,3).\n** exception error: no true branch found when evaluating an if expression\n     in function  lists:seq/3 (lists.erl, line 198)\n92> lists:seq(6,8,-3).\n[]\n93> lists:seq(6,10,-3).\n** exception error: no true branch found when evaluating an if expression\n     in function  lists:seq/3 (lists.erl, line 198)\n94> lists:seq(1,2,0).  \n** exception error: no true branch found when evaluating an if expression\n     in function  lists:seq/3 (lists.erl, line 198)\n```\n\n### sort/1/2\n> sort(List1) -> List2.\nsort(Fun, List1) -> List2\n\n排序函数,应熟记不同类型之间的大小顺序,如例子:\n```erlang\n95> Ref = make_ref().\n#Ref<0.0.0.358>\n96> Fun = fun(X) -> X end.\n#Fun<erl_eval.6.111823515>\n97> {ok, Port}=gen_tcp:listen(8011,[]).\n{ok,#Port<0.619>}\n98> Pid = spawn(lists, seq, [1,100]).\n<0.151.0>\n99> lists:sort([<<2>>,[3],{4},Pid,Port,Fun,Ref,atom,5]).\n[5,atom,#Ref<0.0.0.358>,#Fun<erl_eval.6.111823515>,\n #Port<0.619>,<0.151.0>,\n {4},\n [3],\n <<2>>]\n```\n\n我在max函数提到过这个顺序,上面的结果也是按照这个顺序来的\n> number &lt; atom < reference < fun < port < pid < tuple < list < binary\n\nsort/2大致如merge/3,其中Fun可以用来改变默认的由小到大.\n\n### split/2\n> split(N, List1) -> {List2, List3}\n\n分割函数,将List1分割成前N个元素List2,和剩下的元素List3\n```erlang\n100> lists:split(3,[1,2,3,4,5]). \n{[1,2,3],[4,5]}\n```\n源码:\n```erlang\n-spec split(N, List1) -> {List2, List3} when\n      N :: non_neg_integer(),\n      List1 :: [T],\n      List2 :: [T],\n      List3 :: [T],\n      T :: term().\n\nsplit(N, List) when is_integer(N), N >= 0, is_list(List) ->\n    case split(N, List, []) of\n\t{_, _} = Result -> Result;\n\tFault when is_atom(Fault) ->\n\t    erlang:error(Fault, [N,List])\n    end;\nsplit(N, List) ->\n    erlang:error(badarg, [N,List]).\n\nsplit(0, L, R) ->\n    {lists:reverse(R, []), L};\nsplit(N, [H|T], R) ->\n    split(N-1, T, [H|R]);\nsplit(_, [], _) ->\n    badarg.\n```\n\n### splitwith/2\nsplitwith(Fun, List) -> {List1, List2}\n\nFun决定切割的规则,List1是在遇到Fun(X)为false之前的元素,List2是第一个Fun返回为false之后的列表.\n例子:\n```erlang\n101> lists:splitwith(fun(X) -> is_atom(X) end, [a,b,c,2,d,e,4]).\n{[a,b,c],[2,d,e,4]}\n```\n源码:\n```erlang\n-spec splitwith(Pred, List) -> {List1, List2} when\n      Pred :: fun((T) -> boolean()),\n      List :: [T],\n      List1 :: [T],\n      List2 :: [T],\n      T :: term().\n\nsplitwith(Pred, List) when is_function(Pred, 1) ->\n    splitwith(Pred, List, []).\n\nsplitwith(Pred, [Hd|Tail], Taken) ->\n    case Pred(Hd) of\n\ttrue -> splitwith(Pred, Tail, [Hd|Taken]);\n\tfalse -> {reverse(Taken), [Hd|Tail]}\n    end;\nsplitwith(Pred, [], Taken) when is_function(Pred, 1) ->\n    {reverse(Taken),[]}.\n```\n\n### sublist/2/3\n> sublist(List1, Len) -> List2\nsublist(List1, Start, Len) -> List2\n\n返回前List中前Len个元素,Len可以大于List的长度,这样整个List会返回.\nStart可以决定起始位置.\n例子:\n```erlang\n102> lists:sublist([1,2,3,4],2).                                \n[1,2]\n103> lists:sublist([1,2,3,4],2,2).\n[2,3]\n104> lists:sublist([1,2,3,4],5).  \n[1,2,3,4]\n105> lists:sublist([1,2,3,4],5,1).\n[]\n```\n源码\n```erlang\nsublist(List, L) when is_integer(L), is_list(List) ->\n    sublist_2(List, L).\n\nsublist_2([H|T], L) when L > 0 ->\n    [H|sublist_2(T, L-1)];\nsublist_2(_, 0) ->\n    [];\nsublist_2(List, L) when is_list(List), L > 0 ->\n    [].\n\n\nsublist(List, S, L) when is_integer(L), L >= 0 ->\n    sublist(nthtail(S-1, List), L).\n```\n\n### subtract/2\n> subtract(List1, List2) -> List3\n\n规则是这样的:对于List2中的每一个元素,在List1第一个与这个元素相等的元素被删掉,而成为List3.\n例如:\n```erlang\n107> lists:subtract([3,2,1,3,4,1],[1,3,5]). \n[2,3,4,1]\n```\n源码:\n```erlang\n-spec subtract(List1, List2) -> List3 when\n      List1 :: [T],\n      List2 :: [T],\n      List3 :: [T],\n      T :: term().\n\nsubtract(L1, L2) -> L1 -- L2.\n```\n\n很明显这个函数在最坏情况下,有length(List1)*length(List2)的复杂度,代价很高.官方给的建议是\n> Using ordered lists and ordsets:subtract/2 is a much better choice if both lists are long.\n\n使用ordset中的subtract/2,前提是这两个List是排好序的.\n源码:\n```erlang\n-spec subtract(Ordset1, Ordset2) -> Ordset3 when\n      Ordset1 :: ordset(_),\n      Ordset2 :: ordset(_),\n      Ordset3 :: ordset(_).\n\nsubtract([E1|Es1], [E2|_]=Set2) when E1 < E2 ->\n    [E1|subtract(Es1, Set2)];\nsubtract([E1|_]=Set1, [E2|Es2]) when E1 > E2 ->\n    subtract(Set1, Es2);\nsubtract([_E1|Es1], [_E2|Es2]) ->\t\t%E1 == E2\n    subtract(Es1, Es2);\nsubtract([], _) -> [];\nsubtract(Es1, []) -> Es1.\n```\n\n### suffix/2\n> suffix(List1, List2) -> boolean().\n\n如同prefix,如果List1是List2的后缀则返回true,否则返回false.\n例子:\n```erlang\n108> lists:suffix([3,1],[1,2,3,1]).                             \ntrue\n```\n源码:\n```erlang\nsuffix(Suffix, List) ->\n    Delta = length(List) - length(Suffix),\n    Delta >= 0 andalso nthtail(Delta, List) =:= Suffix.\n```\n\n### sum/1\n> sum(List) -> Sum\n\n得到一个List的和,注意List应为数字组成.否则抛错.\n源码:\n```erlang\nsum(L)          -> sum(L, 0).\n\nsum([H|T], Sum) -> sum(T, Sum + H);\nsum([], Sum)    -> Sum.\n```\n\n### takewhile/2\n> takewhile(Pred, List1) -> List2\n\n从List1中取出满足Pred为true的元素,直到遇到第一个false.也就是取出满足Pred的前缀.\n例子:\n```erlang\n109> lists:takewhile(fun(A) -> A < 3 end, [2,1,3,2,1]).\n[2,1]\n```\n源码:\n```erlang\ntakewhile(Pred, [Hd|Tail]) ->\n    case Pred(Hd) of\n\ttrue -> [Hd|takewhile(Pred, Tail)];\n\tfalse -> []\n    end;\ntakewhile(Pred, []) when is_function(Pred, 1) -> [].\n```\n\n### ukeymerge/3\n> ukeymerge(N, TupleList1, TupleList2) -> TupleList3\n\n类似于keymerge,但是u的意思是unique的意思,就是当TupleList1和TupleList2中有相同key的Tuple时将会删掉TupleList2中的Tuple.而且要求TupleList1和TupleList2在执行函数前自己本身不含有相同key的Tuple,否则结果会只删除一个TupleLIst2中的Tuple.结果不如人意.\n例子:\n```erlang\n1> lists:ukeymerge(2,[{1,10},{2,20},{5,50}],[{2,20},{4,40}]).\n[{1,10},{2,20},{4,40},{5,50}]\n2> lists:keymerge(2,[{1,10},{2,20},{5,50}],[{2,20},{4,40}]). \n[{1,10},{2,20},{2,20},{4,40},{5,50}]\n3> lists:ukeymerge(2,[{1,10},{2,20},{5,50}],[{2,20},{3,20},{4,40}]).\n[{1,10},{2,20},{3,20},{4,40},{5,50}]\n4> lists:ukeymerge(2,[{1,10},{2,20},{5,50}],[{2,20},{2,20},{4,40}]).\n[{1,10},{2,20},{2,20},{4,40},{5,50}]\n```\n\n可以看到keymerge和ukeymerge的差别,而且第3行是在TupleList2中有相同Key的Tuple,倒是结果中也有相同的key,这时因为只删除了第一个与TupleList1中相同的Tuple即{2, 20}.\n源码不贴了,凡是根merge有关的,都复杂而且长..\n\n### ukeysort/2\n> ukeysort(N, TupleList1) -> TupleList2\n\n与keysort差不多,同样u也是唯一的意思,只保留一个keyTuple,如以下例子:\n```erlang\n5> lists:ukeysort(2, [{1,10},{3,30},{4,40},{2,20},{5,20}]).         \n[{1,10},{2,20},{3,30},{4,40}]\n6> lists:keysort(2, [{1,10},{3,30},{4,40},{2,20},{5,20}]). \n[{1,10},{2,20},{5,20},{3,30},{4,40}]\n```\n\n### umerge/1/2/3以及 umerge3/3\n参加merge,只不过只保留一个相同的key.\n\n### uzip/1以及uzip3/1\n> unzip(List1) -> {List2, List3}\nunzip3(List1) -> {List2, List3, List4}\n\n用于分离TupleList中的每个Tuple的第一个元素进入List2,第二个元素进入List3.unzip3适用于3-Tuple的情况.\n例子:\n```erlang\n7> lists:unzip([{10210221, fubowen},{10210222, yuyouqi}, {10201223, xuyue}]).\n{[10210221,10210222,10201223],[fubowen,yuyouqi,xuyue]}\n8> lists:unzip3([{10210221, fubowen, 1},{10210222, yuyouqi, 1}, {102101001, aya, 0}]).\n{[10210221,10210222,102101001],\n [fubowen,yuyouqi,aya],\n [1,1,0]}\n```\n源码:\n```erlang\nunzip(Ts) -> unzip(Ts, [], []).\n\nunzip([{X, Y} | Ts], Xs, Ys) -> unzip(Ts, [X | Xs], [Y | Ys]);\nunzip([], Xs, Ys) -> {reverse(Xs), reverse(Ys)}.\n\nunzip3(Ts) -> unzip3(Ts, [], [], []).\n\nunzip3([{X, Y, Z} | Ts], Xs, Ys, Zs) ->\n    unzip3(Ts, [X | Xs], [Y | Ys], [Z | Zs]);\nunzip3([], Xs, Ys, Zs) ->\n    {reverse(Xs), reverse(Ys), reverse(Zs)}.\n```\n\n### zip/2以及zip3/3\n> zip(List1, List2) -> List3\nzip3(List1, List2, List3) -> List4\n\n就是unzip的反过程.\n\n### usort/1和usort/2\n> usort(List1) -> List2\nusort(Fun, List1) -> List2\n\n见sort,只不过只保留一个相同的值.\n例子:\n```erlang\n10> lists:usort([1,3,2,4,2,5,2,2,2]).\n[1,2,3,4,5]\n```\n\n### zipwith/3以及zipwith3/4\n> zipwith(Combine, List1, List2) -> List3\nzipwith3(Combine, List1, List2, List3) -> List4\n\n功能大致同zip/2,zip3/3相同,只不过多了个Combine Function,这个Combine决定了如何合并.\n例子:\n```erlang\n11> lists:zipwith(fun(X,Y) -> X+Y end, [1,2,3], [2,3,4]).\n[3,5,7]\n```\n\n至此,lists模块的函数全都介绍完毕,啊,好累,休息会.\n\n","source":"_posts/Erlang中的lists模块.md","raw":"title: Erlang中的lists模块\ndate: 2014-07-11 21:13:31\ntags: erlang \ncategories: Erlang\n---\n\n> 个人感觉erlang里面lists模块用的地方非常多,因为erlang中没有for循环,很多函数功能多是靠lists的map,filter或者列表解析完成的,所以lists里面的函数非常重要\n\n<!--more-->\n<!-- toc -->\n### all/2\n> all(Func, List) -> boolean()\n\n如果全员执行Func都返回true,则这个表达式返回true,否则返回false.\n\n\n```erlang\n2> lists:all(fun(X) -> is_integer(X) end, [1,2,3,4]).\ntrue\n3> lists:all(fun(X) -> is_integer(X) end, [1,2,\"haha\",4]).\nfalse\n```\n\n### any/2\n> any(Pred, List) -> boolean()\n\n与all大致相同,如果有任意一个List中的元素返回true,则any返回true.\n\n### append/1\n> append(ListOfLists) -> List1\n\n用于合并子列表,列表中元素最起码要有一层深度,而且append只能去掉一层的深度,如果子元素没有深度,就会抛错\n```erlang\n5> lists:append([[1,2,3],[2,3],[1],[2]]).\n[1,2,3,2,3,1,2]\n7> lists:append([[1,2,3],[2,3],[1],[[1,[3,2]],2]]).\n[1,2,3,2,3,1,[1,[3,2]],2]\n8> lists:append([1,[2,3],[3]]).\n** exception error: bad argument\n     in operator  ++/2\n        called as 1 ++ [2,3,3]\n     in call from lists:append/1 (lists.erl, line 74)\n```\n\n因为在append的源码是:\n> 73 append([E]) -> E;\n  74 append([H|T]) -> H ++ append(T);\n  75 append([]) -> []. \n\n所以上面说 `++`附近出错,因为1不是列表.\n\n\n### append/2\n> append(List1, List2) -> List3\n\n源码\n>  append(L1, L2) -> L1 ++ L2.\n\n用于合并两个列表,其实append实质就是++,所以需要注意效率,因为++是将左边的列表都一遍,因此在递归中要始终保持左边的列表要是最短的那个.\n```erlang\n9> lists:append(\"haha\",\"heihei\").\n\"hahaheihei\"\n```\n\n### concat/1\n> concat([Things]) -> string()\n\nThings可以使integer,float,atom,string, concat将他们转换成一个字符串,如果Things中含有list,可能会整体装换成list.\n例如\n```\n10> lists:concat([\"haha\",[1],3,3.14,atom]).\n[104,97,104,97,1,51,51,46,49,52,48,48,48,48,48,48,48,48,48,\n 48,48,48,48,49,50,52,51,52,101|...]\n11> lists:concat([\"haha\",3,3.14,atom]).    \n\"haha33.14000000000000012434e+00atom\"\n```\n源码:\n```erlang\nconcat(List) ->\n    flatmap(fun thing_to_list/1, List).\n\nthing_to_list(X) when is_integer(X) -> integer_to_list(X);\nthing_to_list(X) when is_float(X)   -> float_to_list(X);\nthing_to_list(X) when is_atom(X)    -> atom_to_list(X);\nthing_to_list(X) when is_list(X)    -> X.\t%Assumed to be a string\n```\n\n### delete/2\n> delete(Elem, List) -> List1\n\n删除List中第一个等于Elem的元素,返回一个新的list\n```\n12> lists:delete(1,[1,2,1,3,4]).\n[2,1,3,4]\n```\n\n### dropwhile/2\n> dropwhile(Func, List) -> List1\n \n从左边开始去掉List中Func返回值为true的元素,遇到第一个返回false的元素时终止,并返回剩下列表.\n例子:\n```\n16> lists:dropwhile(fun(X) -> X rem 2 =:= 0  end, [2,4,3,5,6]).  \n[3,5,6]\n```\n源码实现:\n```erlang\ndropwhile(Pred, [Hd|Tail]=Rest) ->\n    case Pred(Hd) of\n\ttrue -> dropwhile(Pred, Tail);\n\tfalse -> Rest\n    end;\ndropwhile(Pred, []) when is_function(Pred, 1) -> [].\n```\n\n### duplicate/2\n> duplicate(N, Elem) -> List.\n\n生成N个Elem的列表.N不能使负数.原因可以看源码\n```erlang\n-spec duplicate(N, Elem) -> List when\n      N :: non_neg_integer(),\n      Elem :: T,\n      List :: [T],\n      T :: term().\n\nduplicate(N, X) when is_integer(N), N >= 0 -> duplicate(N, X, []).\n\nduplicate(0, _, L) -> L;\nduplicate(N, X, L) -> duplicate(N-1, X, [X|L]).\n```\n原理就是用列表构造,没添加一个H,N就-1,终止条件就是直到N=0,如果是负数则无法终止,所以不能为负\n例子:\n```\n17> lists:duplicate(3,\"haha\").\n[\"haha\",\"haha\",\"haha\"]\n```\n\n### filter/2\n> filter(Func, List) -> List1\n\n过滤器,返回列表,元素是List中所有Func返回值为true的元素.这个在工程中经常用.\n源码\n```erlang\n-spec filter(Pred, List1) -> List2 when\n      Pred :: fun((Elem :: T) -> boolean()),\n      List1 :: [T],\n      List2 :: [T],\n      T :: term().\n\nfilter(Pred, List) when is_function(Pred, 1) ->\n    [ E || E <- List, Pred(E) ].\n```\n可以看到,filter内部其实就是用列表解析实现的.\n例子:\n```\n19> lists:filter(fun(X) -> X rem 2 =:= 0 end, [2,4,3,5,6]).\n[2,4,6]\n```\n\n### flatlength/1\n> flatlength(DeepList) -> integer\n\n该函数返回一个深度列表的长度,如果是深度为1的列表可以直接用length(List)返回长度,\n官方doc这么说的\n> Equivalent to length(flatten(DeepList)), but more efficient.\n\n等同于深度列表扁平化后在length,但是这个做更搞笑,原因很简单,这个函数只不过计算长度,并没有将列表扁平化\n源码\n```erlang\n-spec flatlength(DeepList) -> non_neg_integer() when\n      DeepList :: [term() | DeepList].\n\nflatlength(List) ->\n    flatlength(List, 0).\n\nflatlength([H|T], L) when is_list(H) ->\n    flatlength(H, flatlength(T, L));\nflatlength([_|T], L) ->\n    flatlength(T, L + 1);\nflatlength([], L) -> L.\n```\n例子:\n```erlang\n> lists:flatlength([1,[2,[3],4,[5],6],[7,8]]).\n8\n```\n\n### flatten/1\n> flatten(Deeplist) -> List\n\n上面提到的flatten函数,用于扁平化一个深度列表,尽量少用,代价很高,甚至比++操作代价还高\n源码\n```erlang\n-spec flatten(DeepList) -> List when\n      DeepList :: [term() | DeepList],\n      List :: [term()].\n\nflatten(List) when is_list(List) ->\n    do_flatten(List, []).\n\n-spec flatten(DeepList, Tail) -> List when\n      DeepList :: [term() | DeepList],\n      Tail :: [term()],\n      List :: [term()].\n\nflatten(List, Tail) when is_list(List), is_list(Tail) ->\n    do_flatten(List, Tail).\n\ndo_flatten([H|T], Tail) when is_list(H) ->\n    do_flatten(H, do_flatten(T, Tail));\ndo_flatten([H|T], Tail) ->\n    [H|do_flatten(T, Tail)];\ndo_flatten([], Tail) ->\n    Tail.\n```\n\n在递归中为了伪递归,如果第一个元素是list就递归调用do_flatten,如果不是就用构造器放在新列表的头,剩下的部分继续调用do_flatten.\n**关于flatten的效率问题**\n在官方doc的efficiency guide中有专门一块Deep and flat lists,\n原文这么说\n> lists:flatten/1 builds an entirely new list. Therefore, it is expensive, and even more expensive than the ++ (which copies its left argument, but not its right argument).\nIn the following situations, you can easily avoid calling lists:flatten/1:\n1. When sending data to a port. Ports understand deep lists so there is no reason to flatten the list before sending it to the port.\n2. When calling BIFs that accept deep lists, such as list_to_binary/1 or iolist_to_binary/1.\n3. When you know that your list is only one level deep, you can can use lists:append/1.\n\n因为flatten是完全重建一个列表,甚至比++(复制左边,而右边保留)更为低效,但是有3种情况可以不适用flatten\n1. 往端口发送数据时,因为端口懂得深度列表\n2. 诸如`list_to_binary`和`iolist_to_binary`的BIF,不需要扁平化\n```erlang\n> list_to_binary([1,[2,[3,4]],5]).\n<<1,2,3,4,5>>\n```\n3. 如果我们知道列表深度只有一层,要用append代替flatten\n\n### flatten/2\n> flatten(DeepList, Tail) -> List.\n\n就是上面flatten/1调用的子函数,flatten(DeepList) 就是flatten(DeepList, []).\n函数在DeepList扁平化后append了一下Tail.\n```erlang\n27> lists:flatten([1,[3,[4,5],2]],[1,[2,[3]]]).\n[1,3,4,5,2,1,[2,[3]]]\n```\n\n### flatmap/2\n> flatmap(Func, List1) -> List2\n\n官方的说法是\n> That is, flatmap behaves as if it had been defined as follows:\nflatmap(Fun, List1) ->\n    append(map(Fun, List1)).\n\n就是List1中每个元素执行Fun,一般Fun返回一个列表,最后将这些列表append一下.\n例子:\n```erlang\n26> lists:flatmap(fun(X) -> [X, X+1] end, [1,3,5,7]).\n[1,2,3,4,5,6,7,8]\n```\n源码:\n```erlang\n-spec flatmap(Fun, List1) -> List2 when\n      Fun :: fun((A) -> [B]),\n      List1 :: [A],\n      List2 :: [B],\n      A :: term(),\n      B :: term().\n\nflatmap(F, [Hd|Tail]) ->\n    F(Hd) ++ flatmap(F, Tail);\nflatmap(F, []) when is_function(F, 1) -> [].\n```\n\n### foldl/3\n> foldl(Fun, Acc0, List) -> Acc1\n\n这个函数用的非常多,Fun是一个可接受2个参数的函数,例如fun(X, Sum) -> X + Sum end.那么List中的第一个元素带入X,然后Acc0带入Sum,执行得结果Acc1,然后将List中第二个元素带入X,将Acc1带入Sum,以此类推,每回fun的第二个参数是上把的结果,第一个元素是List中的元素.下面例子是一个累加函数\n例子:\n```erlang\n28> lists:foldl(fun(X, Sum) -> X + Sum end, 0, [2,4,6,8,10]).\n30\n```\n源码:\n```erlang\n-spec foldl(Fun, Acc0, List) -> Acc1 when\n      Fun :: fun((Elem :: T, AccIn) -> AccOut),\n      Acc0 :: term(),\n      Acc1 :: term(),\n      AccIn :: term(),\n      AccOut :: term(),\n      List :: [T],\n      T :: term().\n\nfoldl(F, Accu, [Hd|Tail]) ->\n    foldl(F, F(Hd, Accu), Tail);\nfoldl(F, Accu, []) when is_function(F, 2) -> Accu.\n```\n\n上面可以看到foldl的第二个参数就是F(Hd, Accu)的返回结果.\n\n\n### foldr/3\n不说了,跟上面一样,只不过是从右边开始带入.\n### map/2\n> map(Fun, List1) -> List2\n\n返回List1中每个元素执行Fun后的结果列表,官方doc上说执行顺序是运行时决定,这个和下面说的foreach不一样.\n例子:\n```erlang\n34> lists:map(fun(X) -> X*2 end, [1,2,3,4,5]).            \n[2,4,6,8,10]\n```\n源码:\n```erlang\nmap(F, [H|T]) ->\n    [F(H)|map(F, T)];\nmap(F, []) when is_function(F, 1) -> [].\n```\n\n### foreach/2\n\n> foreach(Fun, List1) -> ok.\n\n该函数和map很像,区别就是foreach只执行Fun函数却不保存结果,最后返回ok.\n源码:\n```erlang\nforeach(F, [Hd|Tail]) ->\n    F(Hd),\n    foreach(F, Tail);\nforeach(F, []) when is_function(F, 1) -> ok.\n```\n\n这里和map不同的是foreach的递归在执行完前一个元素的Fun函数后才会继续执行一下个元素的Fun函数,这里的执行顺序就是列表的顺序,官方doc上说:`this function is used for its side effects`\n我不是很理解具体有什么用...\n\n### keydelete/3\n> keydelete(Key, N, TupleList) -> TupleList1\n\n主要用于由{}tuple 组成的列表,删除Tuplelist中第一个第N个位置的值等于Key的tuple,N是tuple中key应该匹配的位置.这个也经常用,比如一个地图中存了{PlayerId, name, str, magic...}之类的tuplelist,如果玩家离开地图,可以让Key为PlayerId,然后keydelete这个玩家的信息,因为PlayerId一般都是唯一的.\n例子:\n```erlang\n37> lists:keydelete(2010211108, 1, [{2010211105, sice, 5},{2010211106, sice, 6},{2010211107, sice, 7},{2010211108, 8}]).\n[{2010211105,sice,5},\n {2010211106,sice,6},\n {2010211107,sice,7}]\n```\n源码:\n```erlang\nkeydelete(K, N, L) when is_integer(N), N > 0 ->\n    keydelete3(K, N, L).\n\nkeydelete3(Key, N, [H|T]) when element(N, H) == Key -> T;\nkeydelete3(Key, N, [H|T]) ->\n    [H|keydelete3(Key, N, T)];\nkeydelete3(_, _, []) -> [].\n```\n\n### keyfind/3\n> keyfind(Key, N, TupleList) -> Tuple | false\n\n大致同上,如字面意思,只不过不delete掉,没找到会返回false,不过这个是BIF,也就是说用c写的,在lists模块看不到实现方法,BIF的效率一般都很高.\n例子:\n```erlang\n38> lists:keyfind(2010211108, 1, [{2010211105, sice, 5},{2010211106, sice, 6},{2010211107, sice, 7}]). \nfalse\n39> lists:keyfind(2010211106, 1, [{2010211105, sice, 5},{2010211106, sice, 6},{2010211107, sice, 7}]).\n{2010211106,sice,6}\n```\n\n> BIF的源码可以把github上的[erlang/otp](https://github.com/erlang/otp)clone下来\n然后在otp/erts/emulator/beam里面可以找到BIF的c代码,lists里面的BIF写在erl_bif_lists.c中\n以下是keyfind的源码,以后的BIF代码就不贴了,感兴趣可以自己去找,不是那么好懂.\n\n```c\nkeyfind(int Bif, Process* p, Eterm Key, Eterm Pos, Eterm List)\n{\n    int max_iter = 10 * CONTEXT_REDS;\n    Sint pos;\n    Eterm term;\n\n    if (!is_small(Pos) || (pos = signed_val(Pos)) < 1) {\n\tBIF_ERROR(p, BADARG);\n    }\n\n    if (is_small(Key)) {\n\tdouble float_key = (double) signed_val(Key);\n\n\twhile (is_list(List)) {\n\t    if (--max_iter < 0) {\n\t\tBUMP_ALL_REDS(p);\n\t\tBIF_TRAP3(bif_export[Bif], p, Key, Pos, List);\n\t    }\n\t    term = CAR(list_val(List));\n\t    List = CDR(list_val(List));\n\t    if (is_tuple(term)) {\n\t\tEterm *tuple_ptr = tuple_val(term);\n\t\tif (pos <= arityval(*tuple_ptr)) {\n\t\t    Eterm element = tuple_ptr[pos];\n\t\t    if (Key == element) {\n\t\t\treturn term;\n\t\t    } else if (is_float(element)) {\n\t\t\tFloatDef f;\n\n\t\t\tGET_DOUBLE(element, f);\n\t\t\tif (f.fd == float_key) {\n\t\t\t    return term;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t}\n    } else if (is_immed(Key)) {\n\twhile (is_list(List)) {\n\t    if (--max_iter < 0) {\n\t\tBUMP_ALL_REDS(p);\n\t\tBIF_TRAP3(bif_export[Bif], p, Key, Pos, List);\n\t    }\n\t    term = CAR(list_val(List));\n\t    List = CDR(list_val(List));\n\t    if (is_tuple(term)) {\n\t\tEterm *tuple_ptr = tuple_val(term);\n\t\tif (pos <= arityval(*tuple_ptr)) {\n\t\t    Eterm element = tuple_ptr[pos];\n\t\t    if (Key == element) {\n\t\t\treturn term;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    } else {\n\twhile (is_list(List)) {\n\t    if (--max_iter < 0) {\n\t\tBUMP_ALL_REDS(p);\n\t\tBIF_TRAP3(bif_export[Bif], p, Key, Pos, List);\n\t    }\n\t    term = CAR(list_val(List));\n\t    List = CDR(list_val(List));\n\t    if (is_tuple(term)) {\n\t\tEterm *tuple_ptr = tuple_val(term);\n\t\tif (pos <= arityval(*tuple_ptr)) {\n\t\t    Eterm element = tuple_ptr[pos];\n\t\t    if (CMP(Key, element) == 0) {\n\t\t\treturn term;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n\n    if (is_not_nil(List))  {\n\tBIF_ERROR(p, BADARG);\n    }\n    return am_false;\n}\n```\n\n哎,跟这c代码比,还是erlang看起来舒服,简单.\n\n### keyserach/3\n> keysearch(Key, N, TupleList) -> {value, Tuple} | false\n\n与keyfind的功能相同,只不过返回值多了个value的标签,同样是BIF,lists.erl中没有源码,这个函数存在是为了向后兼容,keyfind用的更多些,但是keyfind是在R13B版本引入的,较老的版本用的是keysearch.\n\n### keymember/3\n> keymember(Key, N, Tuplelist) -> boolean()\n\n功能和以上大致一样,也是BIF,只不过返回是true或false.\n\n### keymap/3\n> keymap(Fun, N, Tuplelist) -> Tuplelist2\n\n用于将每个tuple的第N个元素替换为Fun(第N个元素)的执行结果.\n例子:\n```erlang\n40> lists:keymap(fun(X) -> atom_to_list(X) end, 2, [{1, john, boy},{2, aya, girl}, {3, cameron, robot}]).\n[{1,\"john\",boy},{2,\"aya\",girl},{3,\"cameron\",robot}]\n```\n源码:\n```erlang\nkeymap(Fun, Index, [Tup|Tail]) ->\n   [setelement(Index, Tup, Fun(element(Index, Tup)))|keymap(Fun, Index, Tail)];\nkeymap(Fun, Index, []) when is_integer(Index), Index >= 1, \n                            is_function(Fun, 1) -> [].\n```\n\nsetelement从字面就可以看出是将Tup的 Index内容替换为Fun(element(Index, Tup)). 而,element就是返回Tup中第Index的值,这些东西都浓缩到一句代码实现,所以说erlang很有意思.\n\n### keymerge/3\n> keymerge(N, TupleList1, TupleList2) -> TupleList3\n\n将TupleList1和TupleList2合并并排序,其中N用来制定用Tuple中的第N元素为依据排序,注意,tuplelist1和tuplelist2在执行keymerge前需要是已经按N排好序,否则顺序可能不正确,如果tuplelist1有和tuplelist2中有第N元素相同的tuple,则Tuplelist1的在前面.\n例子:\n```erlang\n42> lists:keymerge(2, [{a,1},{c,3}],[{b,2},{d,4}]).\n[{a,1},{b,2},{c,3},{d,4}]\n%顺序出错\n43> lists:keymerge(2, [{a,1},{c,3}],[{d,4},{b,2}]).     \n[{a,1},{c,3},{d,4},{b,2}]  \n%tuplelist1的在前面\n44> lists:keymerge(2, [{a,1},{c,3}],[{e,3},{d,4}]).\n[{a,1},{c,3},{e,3},{d,4}]\n```\n\n源码不放了,这个比较复杂,太长了,感兴趣的自己去找吧.\n\n### keyreplace/4\n> keyreplace(Key, N, TupleList1, NewTuple) -> TupleList2\n\n如字面意思,用于替换,将TupleList1中第N个值等于Key的tuple替换为NewTuple.只替换第一个.\n例子:\n```erlang\n46> lists:keyreplace(name2, 2, [{player1, name1, career1},{player2, name2, career2},{player3, name3, career3}], {player4, name4, career4}).\n[{player1,name1,career1},\n {player4,name4,career4},\n {player3,name3,career3}]\n```\n源码:\n```erlang\nkeyreplace(K, N, L, New) when is_integer(N), N > 0, is_tuple(New) ->\n    keyreplace3(K, N, L, New).\n\nkeyreplace3(Key, Pos, [Tup|Tail], New) when element(Pos, Tup) == Key ->\n    [New|Tail];\nkeyreplace3(Key, Pos, [H|T], New) ->\n    [H|keyreplace3(Key, Pos, T, New)];\nkeyreplace3(_, _, [], _) -> [].\n```\n\n### keysort/2\n> keysort(N, TupleList1) -> TupleList2.\n\nexample:\n```erlang\n47> lists:keysort(1,[{3,name3},{2, name2}, {4,name4},{1,name1}]).\n[{1,name1},{2,name2},{3,name3},{4,name4}]\n```\n\n源码不贴了,这个函数的源码很长.\n### keystore/4\n> keystore(Key, N, TupleList1, NewTuple) -> TupleList2.\n\n功能和keyreplace差不多,只不过当TupleList1中没有与Key相同的Tuple时,keyreplace返回的是原来的TupleList,而keystore是将NewTuple append在原TupleList上.\n例子;\n```erlang\n48> lists:keyreplace(name5, 2, [{player1, name1, career1},{player2, name2, career2},{player3, name3, career3}], {player4, name4, career4}).\n[{player1,name1,career1},\n {player2,name2,career2},\n {player3,name3,career3}]\n49> lists:keystore(name5, 2, [{player1, name1, career1},{player2, name2, career2},{player3, name3, career3}], {player4, name4, career4}).  \n[{player1,name1,career1},\n {player2,name2,career2},\n {player3,name3,career3},\n {player4,name4,career4}]\n```\n\n### keytake/3\n> keytake(Key, N, TupleList1) -> {value, Tuple, TupleList2} | false\n\n与大多数key打头的函数相同,字面意思是从TupleList中拿出第N个值和Key相等的Tuple,如果有的话,返回{value, Tuple, TupleList2},Tuple是想的Tuple,TupleList2是去掉Tuple后的新的TupleList.如果没找到则返回false.\nexample:\n```erlang\n50> lists:keytake(name2, 2, [{player1, name1, career1},{player2, name2, career2},{player3, name3, career3}]).                            \n{value,{player2,name2,career2},\n       [{player1,name1,career1},{player3,name3,career3}]}\n```\n源码:\n```erlang\nkeytake(Key, N, L) when is_integer(N), N > 0 ->\n    keytake(Key, N, L, []).\n\nkeytake(Key, N, [H|T], L) when element(N, H) == Key ->\n    {value, H, lists:reverse(L, T)};\nkeytake(Key, N, [H|T], L) ->\n    keytake(Key, N, T, [H|L]);\nkeytake(_K, _N, [], _L) -> false.\n```\n\n### last/1\n> last(List) -> Last\n\n返回List中最后一个元素.\n源码:\n```erlang\nlast([E|Es]) -> last(E, Es).\n\nlast(_, [E|Es]) -> last(E, Es);\nlast(E, []) -> E.\n```\n\n### mapfoldl/3\n> mapfoldl(Fun, Acc0, List1) -> {List2, Acc1}.\n\n官方的解释就是同时具有map和foldl的功能.直白点就是map完成List1->List2的变化,foldl完成 Acc0 -> Acc1的变化.\n因为foldl只能返回一个由List1得到的记过Acc1,而不能多List1本身得到新的List2,而map不能得到Acc1,却能完成List1到List2的变化.所以mapfoldl完成了两者的功能.看源码会比较清晰的理解下.\n源码:\n```erlang\n-spec mapfoldl(Fun, Acc0, List1) -> {List2, Acc1} when\n      Fun :: fun((A, AccIn) -> {B, AccOut}),\n      Acc0 :: term(),\n      Acc1 :: term(),\n      AccIn :: term(),\n      AccOut :: term(),\n      List1 :: [A],\n      List2 :: [B],\n      A :: term(),\n      B :: term().\n\nmapfoldl(F, Accu0, [Hd|Tail]) ->\n    {R,Accu1} = F(Hd, Accu0),\n    {Rs,Accu2} = mapfoldl(F, Accu1, Tail),\n    {[R|Rs],Accu2};\nmapfoldl(F, Accu, []) when is_function(F, 2) -> {[],Accu}.\n```\n注意,这里面的Fun返回的是{B, AccOut}的形式,而foldl的Fun是`      Fun :: fun((Elem :: T, AccIn) -> AccOut),\n`这里是最本质的区别.结合例子说下\n```erlang\n52> lists:mapfoldl(fun(X, Sum) -> {X*2, X + Sum} end, 0, [1,2,3,4,5]).\n{[2,4,6,8,10],15}\n```\n\n首先第一轮得到的{R, Accu1} = {2, 1},而{Rs, Accu2}需要递归执行mapfoldl,那么第二轮得到一个{R',Accu1'} = {4, 3},我们每轮能确切知道的只有{R, Accu1},但是mapfoldl要返回的是{[R|Rs],Accu2},所以需要一直递归下去,那么第三轮得到{6, 6},第四轮{8, 10},第五轮得到{10, 15},这时{10, 15}仍然是{R, Accu1},但是接下来由于Tail变成了空列表[],根据模式匹配,这次执行的是第二个mapfoldl函数,那么相当于执行mapfoldl{F, 15, []),得到最底层的{Rs, Accu2} = {[], 15},那么返回的{[R|Rs], Accu2}为{[10|[]], 15}.一直往上递归回去,结果得到{[2,4,6,8,10], 15}.\n\n### mapfoldr/3\n与上面的执行结果一样,只不过foldr是从右边开始,不影响List2的顺序.\n\n### max/1\n> max(List) -> Max\n\n返回第一个这个List中的最大数.\n例子:\n```erlang\n54> lists:max([a,b,c]).\nc\n55> lists:max([100,b,c]).\nc\n56> lists:max([{100},b,c]).\n{100}\n57> lists:max([{100},b,c,[90]]).\n\"Z\"\n58> lists:max([{100},b,c,[2]]). \n[2]\n59> lists:max([{100},b,c,[2],<<2>>]).\n<<2>>\n```\n\n这里注意下不同类型之间的比较顺序\n> number &lt; atom < reference < fun < port < pid < tuple < list < binary\n\n源码:\n```erlang\nmax([H|T]) -> max(T, H).\n\nmax([H|T], Max) when H > Max -> max(T, H);\nmax([_|T], Max)              -> max(T, Max);\nmax([],    Max)              -> Max.\n```\n\n### member/2\n> member(Elem, List) -> boolean()\n\n如果Elem是List中的元素就返回true, 否则返回false.BIF.源码是C写的.不贴了.\n### merge/1/2/3以及merge3/3\n> merge(ListOfLists) -> List1.\nmerge(List1, List2) -> List3.\nmerge(Fun, List1, List2) -> List3.\nmerge3(List1, List2, List3) -> List4\n\n暂且叫归并排序吧,merge/1,merge/2完成的就是合并并排序,顺序由小到大,merge3/3只不过可以合并3个列表.merge/3可以依据Fun更改顺序,排序依据是Fun(A, B)如果返回true,那么就是A在B的前面.\n举几个例子:\n```erlang\n60> lists:merge([[1],[4],[2,4],[3]]).\n[1,2,3,4,4]\n61> lists:merge([2,4,6],[1,3]).      \n[1,2,3,4,6]\n62> lists:merge(fun(A,B) -> A > B end, [5,4,2],[8,3,1]).\n[8,5,4,3,2,1]\n63> lists:merge(fun(A,B) -> A < B end, [5,4,2],[8,3,1]).\n[5,4,2,8,3,1]\n64> lists:merge(fun(A,B) -> A < B end, [2,4,5],[1,3,8]).\n[1,2,3,4,5,8]\n66> lists:merge3([2,4,6],[1,3],[2,3,5,7]).\n[1,2,2,3,3,4,5,6,7]\n```\n\n所有的排序都要求每个子List在排序前都是排好序的,如63行,由于子列表没有排好序,所以排序结果不正确.\nmerge的源码比较多而且杂,感兴趣自己去lists.erl里面看.\n\n### min/1\n> min(List) -> Min\n\n与max相反.\n\n### nth/2\n> nth(N, List) -> Elem\n\n返回第List的第N个元素.\n例子:\n```erlang\n67> lists:nth(2,[\"haha\",atom,2,<<\"binary\">>]). \natom\n```\n源码:\n```erlang\nnth(1, [H|_]) -> H;\nnth(N, [_|T]) when N > 1 ->\n    nth(N - 1, T).\n```\n\n### nthtail/2\n> nthtail(N, List) -> Tail\n\n返回List的第N个尾列表.\n例子:\n```erlang\n68> lists:nthtail(0,[1,2,3,4]).\n[1,2,3,4]\n69> lists:nthtail(1,[1,2,3,4]).\n[2,3,4]\n70> lists:nthtail(2,[1,2,3,4]).\n[3,4]\n71> lists:nthtail(4,[1,2,3,4]).\n[]\n```\n源码:\n```erlang\nnthtail(1, [_|T]) -> T;\nnthtail(N, [_|T]) when N > 1 ->\n    nthtail(N - 1, T);\nnthtail(0, L) when is_list(L) -> L.\n```\n\n### partition/2\n> partition(Fun, List1) -> {List1, List2}.\n\n字面意思是区分开,将List1依据Fun返回的true和false分为两个列表.\n例子:\n```erlang\n73> lists:partition(fun(X) -> X>2 end, [1,2,3,4]).\n{[3,4],[1,2]}\n```\n源码\n```erlang\npartition(Pred, L) ->\n    partition(Pred, L, [], []).\n\npartition(Pred, [H | T], As, Bs) ->\n    case Pred(H) of\n\ttrue -> partition(Pred, T, [H | As], Bs);\n\tfalse -> partition(Pred, T, As, [H | Bs])\n    end;\npartition(Pred, [], As, Bs) when is_function(Pred, 1) ->\n    {reverse(As), reverse(Bs)}.\n```\n\n### prefix/2\n> prefix(List1, List2) -> boolean().\n\n如果List1是List2的前缀则返回true,否则返回false\n例子:\n```erlang\n74> lists:prefix([1,2],[1,2,3,4]).                \ntrue\n75> lists:prefix([1,2],[1,3,4]).  \nfalse\n```\n源码很好理解:\n```erlang\nprefix([X|PreTail], [X|Tail]) ->\n    prefix(PreTail, Tail);\nprefix([], List) when is_list(List) -> true;\nprefix([_|_], List) when is_list(List) -> false.\n```\n\n如果第一元素都是X,则递归执行prefix,如果List1为[]了,那么返回true,如果遇到不相同的元素了就返回false.\n\n### reverse/1/2\n> reverse(List1) -> List2.\nreverse(List1, Tail) -> List2.\n\nreverse/1返回的是逆序的List1. reverse/2返回的是逆序的List1并且append了Tail.\n例子:\n```erlang\n76> lists:reverse([1,2,3,4]).\n[4,3,2,1]\n77> lists:reverse([1,2,3,4],[5,6,7]).\n[4,3,2,1,5,6,7]\n```\n源码:\n```erlang\n-spec reverse(List1) -> List2 when\n      List1 :: [T],\n      List2 :: [T],\n      T :: term().\n\nreverse([] = L) ->\n    L;\nreverse([_] = L) ->\n    L;\nreverse([A, B]) ->\n    [B, A];\nreverse([A, B | L]) ->\n    lists:reverse(L, [B, A]).\n```\n\n注意这里比较神奇的是reverse/1调用的是reverse/2,我一直以为reverse/1是BIF,其实reverse/2才是BIF,而且reverse/2在各种merge函数中多次调用,调用reverse/2的次数非常多,估计所以才将reverse/2写成了BIF吧.\n\n### seq/2/3\n> seq(From, To) -> List1\nseq(From, To, Incr) -> List2\n\n用于生成From到To的列表,Incr是递增的值.这个函数通常只用于最简单的功能,但是还是需要注意一下,这个函数报错的条件比较苛刻.官方给的说明是在一下会发生error错误.\n1. To < From - Incr 并且Incr是正数.\n2. To > From - Incr 并且Incr是负数.\n3. Incr为0时,From 不等于 To\n并且官方给出\n> length(lists:seq(From, To)) == To-From+1\nlength(lists:seq(From, To, Incr)) == (To-From+Incr) div Incr\n\n涵盖了上面3种情况,因为length不能是负数,其实只要看***To-From+Incr与Incr相除***是正数或者0就不会报错.\n以下是一些例子:\n```erlang\n78> lists:seq(1,4).\n[1,2,3,4]\n79> lists:seq(3,1).\n** exception error: no function clause matching lists:seq(3,1) (lists.erl, line 177)\n80> lists:seq(3,1,-1).\n[3,2,1]\n81> lists:seq(3,1,1). \n** exception error: no true branch found when evaluating an if expression\n     in function  lists:seq/3 (lists.erl, line 198)\n82> lists:seq(1,0,1).\n[]\n83> lists:seq(10,6,1).\n** exception error: no true branch found when evaluating an if expression\n     in function  lists:seq/3 (lists.erl, line 198)\n84> lists:seq(10,6,4).\n[]\n85> lists:seq(10,6,5).\n[]\n86> lists:seq(10,6,3).\n** exception error: no true branch found when evaluating an if expression\n     in function  lists:seq/3 (lists.erl, line 198)\n87> lists:seq(1,4).\n[1,2,3,4]\n88> lists:seq(1,0).\n[]\n89> lists:seq(3,0,-1).\n[3,2,1,0]\n90> lists:seq(10,6,4).\n[]\n91> lists:seq(10,6,3).\n** exception error: no true branch found when evaluating an if expression\n     in function  lists:seq/3 (lists.erl, line 198)\n92> lists:seq(6,8,-3).\n[]\n93> lists:seq(6,10,-3).\n** exception error: no true branch found when evaluating an if expression\n     in function  lists:seq/3 (lists.erl, line 198)\n94> lists:seq(1,2,0).  \n** exception error: no true branch found when evaluating an if expression\n     in function  lists:seq/3 (lists.erl, line 198)\n```\n\n### sort/1/2\n> sort(List1) -> List2.\nsort(Fun, List1) -> List2\n\n排序函数,应熟记不同类型之间的大小顺序,如例子:\n```erlang\n95> Ref = make_ref().\n#Ref<0.0.0.358>\n96> Fun = fun(X) -> X end.\n#Fun<erl_eval.6.111823515>\n97> {ok, Port}=gen_tcp:listen(8011,[]).\n{ok,#Port<0.619>}\n98> Pid = spawn(lists, seq, [1,100]).\n<0.151.0>\n99> lists:sort([<<2>>,[3],{4},Pid,Port,Fun,Ref,atom,5]).\n[5,atom,#Ref<0.0.0.358>,#Fun<erl_eval.6.111823515>,\n #Port<0.619>,<0.151.0>,\n {4},\n [3],\n <<2>>]\n```\n\n我在max函数提到过这个顺序,上面的结果也是按照这个顺序来的\n> number &lt; atom < reference < fun < port < pid < tuple < list < binary\n\nsort/2大致如merge/3,其中Fun可以用来改变默认的由小到大.\n\n### split/2\n> split(N, List1) -> {List2, List3}\n\n分割函数,将List1分割成前N个元素List2,和剩下的元素List3\n```erlang\n100> lists:split(3,[1,2,3,4,5]). \n{[1,2,3],[4,5]}\n```\n源码:\n```erlang\n-spec split(N, List1) -> {List2, List3} when\n      N :: non_neg_integer(),\n      List1 :: [T],\n      List2 :: [T],\n      List3 :: [T],\n      T :: term().\n\nsplit(N, List) when is_integer(N), N >= 0, is_list(List) ->\n    case split(N, List, []) of\n\t{_, _} = Result -> Result;\n\tFault when is_atom(Fault) ->\n\t    erlang:error(Fault, [N,List])\n    end;\nsplit(N, List) ->\n    erlang:error(badarg, [N,List]).\n\nsplit(0, L, R) ->\n    {lists:reverse(R, []), L};\nsplit(N, [H|T], R) ->\n    split(N-1, T, [H|R]);\nsplit(_, [], _) ->\n    badarg.\n```\n\n### splitwith/2\nsplitwith(Fun, List) -> {List1, List2}\n\nFun决定切割的规则,List1是在遇到Fun(X)为false之前的元素,List2是第一个Fun返回为false之后的列表.\n例子:\n```erlang\n101> lists:splitwith(fun(X) -> is_atom(X) end, [a,b,c,2,d,e,4]).\n{[a,b,c],[2,d,e,4]}\n```\n源码:\n```erlang\n-spec splitwith(Pred, List) -> {List1, List2} when\n      Pred :: fun((T) -> boolean()),\n      List :: [T],\n      List1 :: [T],\n      List2 :: [T],\n      T :: term().\n\nsplitwith(Pred, List) when is_function(Pred, 1) ->\n    splitwith(Pred, List, []).\n\nsplitwith(Pred, [Hd|Tail], Taken) ->\n    case Pred(Hd) of\n\ttrue -> splitwith(Pred, Tail, [Hd|Taken]);\n\tfalse -> {reverse(Taken), [Hd|Tail]}\n    end;\nsplitwith(Pred, [], Taken) when is_function(Pred, 1) ->\n    {reverse(Taken),[]}.\n```\n\n### sublist/2/3\n> sublist(List1, Len) -> List2\nsublist(List1, Start, Len) -> List2\n\n返回前List中前Len个元素,Len可以大于List的长度,这样整个List会返回.\nStart可以决定起始位置.\n例子:\n```erlang\n102> lists:sublist([1,2,3,4],2).                                \n[1,2]\n103> lists:sublist([1,2,3,4],2,2).\n[2,3]\n104> lists:sublist([1,2,3,4],5).  \n[1,2,3,4]\n105> lists:sublist([1,2,3,4],5,1).\n[]\n```\n源码\n```erlang\nsublist(List, L) when is_integer(L), is_list(List) ->\n    sublist_2(List, L).\n\nsublist_2([H|T], L) when L > 0 ->\n    [H|sublist_2(T, L-1)];\nsublist_2(_, 0) ->\n    [];\nsublist_2(List, L) when is_list(List), L > 0 ->\n    [].\n\n\nsublist(List, S, L) when is_integer(L), L >= 0 ->\n    sublist(nthtail(S-1, List), L).\n```\n\n### subtract/2\n> subtract(List1, List2) -> List3\n\n规则是这样的:对于List2中的每一个元素,在List1第一个与这个元素相等的元素被删掉,而成为List3.\n例如:\n```erlang\n107> lists:subtract([3,2,1,3,4,1],[1,3,5]). \n[2,3,4,1]\n```\n源码:\n```erlang\n-spec subtract(List1, List2) -> List3 when\n      List1 :: [T],\n      List2 :: [T],\n      List3 :: [T],\n      T :: term().\n\nsubtract(L1, L2) -> L1 -- L2.\n```\n\n很明显这个函数在最坏情况下,有length(List1)*length(List2)的复杂度,代价很高.官方给的建议是\n> Using ordered lists and ordsets:subtract/2 is a much better choice if both lists are long.\n\n使用ordset中的subtract/2,前提是这两个List是排好序的.\n源码:\n```erlang\n-spec subtract(Ordset1, Ordset2) -> Ordset3 when\n      Ordset1 :: ordset(_),\n      Ordset2 :: ordset(_),\n      Ordset3 :: ordset(_).\n\nsubtract([E1|Es1], [E2|_]=Set2) when E1 < E2 ->\n    [E1|subtract(Es1, Set2)];\nsubtract([E1|_]=Set1, [E2|Es2]) when E1 > E2 ->\n    subtract(Set1, Es2);\nsubtract([_E1|Es1], [_E2|Es2]) ->\t\t%E1 == E2\n    subtract(Es1, Es2);\nsubtract([], _) -> [];\nsubtract(Es1, []) -> Es1.\n```\n\n### suffix/2\n> suffix(List1, List2) -> boolean().\n\n如同prefix,如果List1是List2的后缀则返回true,否则返回false.\n例子:\n```erlang\n108> lists:suffix([3,1],[1,2,3,1]).                             \ntrue\n```\n源码:\n```erlang\nsuffix(Suffix, List) ->\n    Delta = length(List) - length(Suffix),\n    Delta >= 0 andalso nthtail(Delta, List) =:= Suffix.\n```\n\n### sum/1\n> sum(List) -> Sum\n\n得到一个List的和,注意List应为数字组成.否则抛错.\n源码:\n```erlang\nsum(L)          -> sum(L, 0).\n\nsum([H|T], Sum) -> sum(T, Sum + H);\nsum([], Sum)    -> Sum.\n```\n\n### takewhile/2\n> takewhile(Pred, List1) -> List2\n\n从List1中取出满足Pred为true的元素,直到遇到第一个false.也就是取出满足Pred的前缀.\n例子:\n```erlang\n109> lists:takewhile(fun(A) -> A < 3 end, [2,1,3,2,1]).\n[2,1]\n```\n源码:\n```erlang\ntakewhile(Pred, [Hd|Tail]) ->\n    case Pred(Hd) of\n\ttrue -> [Hd|takewhile(Pred, Tail)];\n\tfalse -> []\n    end;\ntakewhile(Pred, []) when is_function(Pred, 1) -> [].\n```\n\n### ukeymerge/3\n> ukeymerge(N, TupleList1, TupleList2) -> TupleList3\n\n类似于keymerge,但是u的意思是unique的意思,就是当TupleList1和TupleList2中有相同key的Tuple时将会删掉TupleList2中的Tuple.而且要求TupleList1和TupleList2在执行函数前自己本身不含有相同key的Tuple,否则结果会只删除一个TupleLIst2中的Tuple.结果不如人意.\n例子:\n```erlang\n1> lists:ukeymerge(2,[{1,10},{2,20},{5,50}],[{2,20},{4,40}]).\n[{1,10},{2,20},{4,40},{5,50}]\n2> lists:keymerge(2,[{1,10},{2,20},{5,50}],[{2,20},{4,40}]). \n[{1,10},{2,20},{2,20},{4,40},{5,50}]\n3> lists:ukeymerge(2,[{1,10},{2,20},{5,50}],[{2,20},{3,20},{4,40}]).\n[{1,10},{2,20},{3,20},{4,40},{5,50}]\n4> lists:ukeymerge(2,[{1,10},{2,20},{5,50}],[{2,20},{2,20},{4,40}]).\n[{1,10},{2,20},{2,20},{4,40},{5,50}]\n```\n\n可以看到keymerge和ukeymerge的差别,而且第3行是在TupleList2中有相同Key的Tuple,倒是结果中也有相同的key,这时因为只删除了第一个与TupleList1中相同的Tuple即{2, 20}.\n源码不贴了,凡是根merge有关的,都复杂而且长..\n\n### ukeysort/2\n> ukeysort(N, TupleList1) -> TupleList2\n\n与keysort差不多,同样u也是唯一的意思,只保留一个keyTuple,如以下例子:\n```erlang\n5> lists:ukeysort(2, [{1,10},{3,30},{4,40},{2,20},{5,20}]).         \n[{1,10},{2,20},{3,30},{4,40}]\n6> lists:keysort(2, [{1,10},{3,30},{4,40},{2,20},{5,20}]). \n[{1,10},{2,20},{5,20},{3,30},{4,40}]\n```\n\n### umerge/1/2/3以及 umerge3/3\n参加merge,只不过只保留一个相同的key.\n\n### uzip/1以及uzip3/1\n> unzip(List1) -> {List2, List3}\nunzip3(List1) -> {List2, List3, List4}\n\n用于分离TupleList中的每个Tuple的第一个元素进入List2,第二个元素进入List3.unzip3适用于3-Tuple的情况.\n例子:\n```erlang\n7> lists:unzip([{10210221, fubowen},{10210222, yuyouqi}, {10201223, xuyue}]).\n{[10210221,10210222,10201223],[fubowen,yuyouqi,xuyue]}\n8> lists:unzip3([{10210221, fubowen, 1},{10210222, yuyouqi, 1}, {102101001, aya, 0}]).\n{[10210221,10210222,102101001],\n [fubowen,yuyouqi,aya],\n [1,1,0]}\n```\n源码:\n```erlang\nunzip(Ts) -> unzip(Ts, [], []).\n\nunzip([{X, Y} | Ts], Xs, Ys) -> unzip(Ts, [X | Xs], [Y | Ys]);\nunzip([], Xs, Ys) -> {reverse(Xs), reverse(Ys)}.\n\nunzip3(Ts) -> unzip3(Ts, [], [], []).\n\nunzip3([{X, Y, Z} | Ts], Xs, Ys, Zs) ->\n    unzip3(Ts, [X | Xs], [Y | Ys], [Z | Zs]);\nunzip3([], Xs, Ys, Zs) ->\n    {reverse(Xs), reverse(Ys), reverse(Zs)}.\n```\n\n### zip/2以及zip3/3\n> zip(List1, List2) -> List3\nzip3(List1, List2, List3) -> List4\n\n就是unzip的反过程.\n\n### usort/1和usort/2\n> usort(List1) -> List2\nusort(Fun, List1) -> List2\n\n见sort,只不过只保留一个相同的值.\n例子:\n```erlang\n10> lists:usort([1,3,2,4,2,5,2,2,2]).\n[1,2,3,4,5]\n```\n\n### zipwith/3以及zipwith3/4\n> zipwith(Combine, List1, List2) -> List3\nzipwith3(Combine, List1, List2, List3) -> List4\n\n功能大致同zip/2,zip3/3相同,只不过多了个Combine Function,这个Combine决定了如何合并.\n例子:\n```erlang\n11> lists:zipwith(fun(X,Y) -> X+Y end, [1,2,3], [2,3,4]).\n[3,5,7]\n```\n\n至此,lists模块的函数全都介绍完毕,啊,好累,休息会.\n\n","slug":"Erlang中的lists模块","published":1,"updated":"2018-06-26T09:49:27.732Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqw7jdvi00036f1r91no5wo1","content":"<blockquote>\n<p>个人感觉erlang里面lists模块用的地方非常多,因为erlang中没有for循环,很多函数功能多是靠lists的map,filter或者列表解析完成的,所以lists里面的函数非常重要</p>\n</blockquote>\n<span id=\"more\"></span>\n<!-- toc -->\n<ul>\n<li><a href=\"#all-2\">all/2</a></li>\n<li><a href=\"#any-2\">any/2</a></li>\n<li><a href=\"#append-1\">append/1</a></li>\n<li><a href=\"#append-2\">append/2</a></li>\n<li><a href=\"#concat-1\">concat/1</a></li>\n<li><a href=\"#delete-2\">delete/2</a></li>\n<li><a href=\"#dropwhile-2\">dropwhile/2</a></li>\n<li><a href=\"#duplicate-2\">duplicate/2</a></li>\n<li><a href=\"#filter-2\">filter/2</a></li>\n<li><a href=\"#flatlength-1\">flatlength/1</a></li>\n<li><a href=\"#flatten-1\">flatten/1</a></li>\n<li><a href=\"#flatten-2\">flatten/2</a></li>\n<li><a href=\"#flatmap-2\">flatmap/2</a></li>\n<li><a href=\"#foldl-3\">foldl/3</a></li>\n<li><a href=\"#foldr-3\">foldr/3</a></li>\n<li><a href=\"#map-2\">map/2</a></li>\n<li><a href=\"#foreach-2\">foreach/2</a></li>\n<li><a href=\"#keydelete-3\">keydelete/3</a></li>\n<li><a href=\"#keyfind-3\">keyfind/3</a></li>\n<li><a href=\"#keyserach-3\">keyserach/3</a></li>\n<li><a href=\"#keymember-3\">keymember/3</a></li>\n<li><a href=\"#keymap-3\">keymap/3</a></li>\n<li><a href=\"#keymerge-3\">keymerge/3</a></li>\n<li><a href=\"#keyreplace-4\">keyreplace/4</a></li>\n<li><a href=\"#keysort-2\">keysort/2</a></li>\n<li><a href=\"#keystore-4\">keystore/4</a></li>\n<li><a href=\"#keytake-3\">keytake/3</a></li>\n<li><a href=\"#last-1\">last/1</a></li>\n<li><a href=\"#mapfoldl-3\">mapfoldl/3</a></li>\n<li><a href=\"#mapfoldr-3\">mapfoldr/3</a></li>\n<li><a href=\"#max-1\">max/1</a></li>\n<li><a href=\"#member-2\">member/2</a></li>\n<li><a href=\"#merge-1-2-3--merge3-3\">merge/1/2/3以及merge3/3</a></li>\n<li><a href=\"#min-1\">min/1</a></li>\n<li><a href=\"#nth-2\">nth/2</a></li>\n<li><a href=\"#nthtail-2\">nthtail/2</a></li>\n<li><a href=\"#partition-2\">partition/2</a></li>\n<li><a href=\"#prefix-2\">prefix/2</a></li>\n<li><a href=\"#reverse-1-2\">reverse/1/2</a></li>\n<li><a href=\"#seq-2-3\">seq/2/3</a></li>\n<li><a href=\"#sort-1-2\">sort/1/2</a></li>\n<li><a href=\"#split-2\">split/2</a></li>\n<li><a href=\"#splitwith-2\">splitwith/2</a></li>\n<li><a href=\"#sublist-2-3\">sublist/2/3</a></li>\n<li><a href=\"#subtract-2\">subtract/2</a></li>\n<li><a href=\"#suffix-2\">suffix/2</a></li>\n<li><a href=\"#sum-1\">sum/1</a></li>\n<li><a href=\"#takewhile-2\">takewhile/2</a></li>\n<li><a href=\"#ukeymerge-3\">ukeymerge/3</a></li>\n<li><a href=\"#ukeysort-2\">ukeysort/2</a></li>\n<li><a href=\"#umerge-1-2-3---umerge3-3\">umerge/1/2/3以及 umerge3/3</a></li>\n<li><a href=\"#uzip-1--uzip3-1\">uzip/1以及uzip3/1</a></li>\n<li><a href=\"#zip-2--zip3-3\">zip/2以及zip3/3</a></li>\n<li><a href=\"#usort-1-usort-2\">usort/1和usort/2</a></li>\n<li><a href=\"#zipwith-3--zipwith3-4\">zipwith/3以及zipwith3/4</a></li>\n</ul>\n<!-- tocstop -->\n<h3 id=\"all/2\">all/2</h3><blockquote>\n<p>all(Func, List) -&gt; boolean()</p>\n</blockquote>\n<p>如果全员执行Func都返回true,则这个表达式返回true,否则返回false.</p>\n<figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2</span>&gt; lists:all(<span class=\"keyword\">fun</span>(X) -&gt; is_integer(X) <span class=\"keyword\">end</span>, [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]).</span><br><span class=\"line\"><span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"number\">3</span>&gt; lists:all(<span class=\"keyword\">fun</span>(X) -&gt; is_integer(X) <span class=\"keyword\">end</span>, [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"string\">&quot;haha&quot;</span>,<span class=\"number\">4</span>]).</span><br><span class=\"line\"><span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"any/2\">any/2</h3><blockquote>\n<p>any(Pred, List) -&gt; boolean()</p>\n</blockquote>\n<p>与all大致相同,如果有任意一个List中的元素返回true,则any返回true.</p>\n<h3 id=\"append/1\">append/1</h3><blockquote>\n<p>append(ListOfLists) -&gt; List1</p>\n</blockquote>\n<p>用于合并子列表,列表中元素最起码要有一层深度,而且append只能去掉一层的深度,如果子元素没有深度,就会抛错<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">5</span>&gt; lists:append([[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>],[<span class=\"number\">2</span>,<span class=\"number\">3</span>],[<span class=\"number\">1</span>],[<span class=\"number\">2</span>]]).</span><br><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>]</span><br><span class=\"line\"><span class=\"number\">7</span>&gt; lists:append([[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>],[<span class=\"number\">2</span>,<span class=\"number\">3</span>],[<span class=\"number\">1</span>],[[<span class=\"number\">1</span>,[<span class=\"number\">3</span>,<span class=\"number\">2</span>]],<span class=\"number\">2</span>]]).</span><br><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">1</span>,[<span class=\"number\">1</span>,[<span class=\"number\">3</span>,<span class=\"number\">2</span>]],<span class=\"number\">2</span>]</span><br><span class=\"line\"><span class=\"number\">8</span>&gt; lists:append([<span class=\"number\">1</span>,[<span class=\"number\">2</span>,<span class=\"number\">3</span>],[<span class=\"number\">3</span>]]).</span><br><span class=\"line\">** exception error: bad argument</span><br><span class=\"line\">     in operator  ++/<span class=\"number\">2</span></span><br><span class=\"line\">        called as <span class=\"number\">1</span> ++ [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">     in call from lists:append/<span class=\"number\">1</span> (lists.erl, line <span class=\"number\">74</span>)</span><br></pre></td></tr></table></figure></p>\n<p>因为在append的源码是:</p>\n<blockquote>\n<p>73 append([E]) -&gt; E;<br>  74 append([H|T]) -&gt; H ++ append(T);<br>  75 append([]) -&gt; []. </p>\n</blockquote>\n<p>所以上面说 <code>++</code>附近出错,因为1不是列表.</p>\n<h3 id=\"append/2\">append/2</h3><blockquote>\n<p>append(List1, List2) -&gt; List3</p>\n</blockquote>\n<p>源码</p>\n<blockquote>\n<p> append(L1, L2) -&gt; L1 ++ L2.</p>\n</blockquote>\n<p>用于合并两个列表,其实append实质就是++,所以需要注意效率,因为++是将左边的列表都一遍,因此在递归中要始终保持左边的列表要是最短的那个.<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">9</span>&gt; lists:append(<span class=\"string\">&quot;haha&quot;</span>,<span class=\"string\">&quot;heihei&quot;</span>).</span><br><span class=\"line\"><span class=\"string\">&quot;hahaheihei&quot;</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"concat/1\">concat/1</h3><blockquote>\n<p>concat([Things]) -&gt; string()</p>\n</blockquote>\n<p>Things可以使integer,float,atom,string, concat将他们转换成一个字符串,如果Things中含有list,可能会整体装换成list.<br>例如<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10&gt; lists:concat([&quot;haha&quot;,[1],3,3.14,atom]).</span><br><span class=\"line\">[104,97,104,97,1,51,51,46,49,52,48,48,48,48,48,48,48,48,48,</span><br><span class=\"line\"> 48,48,48,48,49,50,52,51,52,101|...]</span><br><span class=\"line\">11&gt; lists:concat([&quot;haha&quot;,3,3.14,atom]).    </span><br><span class=\"line\">&quot;haha33.14000000000000012434e+00atom&quot;</span><br></pre></td></tr></table></figure><br>源码:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">concat</span><span class=\"params\">(List)</span> -&gt;</span></span><br><span class=\"line\">    flatmap(fun thing_to_list/1, List).</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">thing_to_list</span><span class=\"params\">(X)</span> <span class=\"title\">when</span> <span class=\"title\">is_integer</span><span class=\"params\">(X)</span> -&gt;</span> integer_to_list(X);</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">thing_to_list</span><span class=\"params\">(X)</span> <span class=\"title\">when</span> <span class=\"title\">is_float</span><span class=\"params\">(X)</span>   -&gt;</span> float_to_list(X);</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">thing_to_list</span><span class=\"params\">(X)</span> <span class=\"title\">when</span> <span class=\"title\">is_atom</span><span class=\"params\">(X)</span>    -&gt;</span> atom_to_list(X);</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">thing_to_list</span><span class=\"params\">(X)</span> <span class=\"title\">when</span> <span class=\"title\">is_list</span><span class=\"params\">(X)</span>    -&gt;</span> X.\t<span class=\"comment\">%Assumed to be a string</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"delete/2\">delete/2</h3><blockquote>\n<p>delete(Elem, List) -&gt; List1</p>\n</blockquote>\n<p>删除List中第一个等于Elem的元素,返回一个新的list<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">12&gt; lists:delete(1,[1,2,1,3,4]).</span><br><span class=\"line\">[2,1,3,4]</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"dropwhile/2\">dropwhile/2</h3><blockquote>\n<p>dropwhile(Func, List) -&gt; List1</p>\n</blockquote>\n<p>从左边开始去掉List中Func返回值为true的元素,遇到第一个返回false的元素时终止,并返回剩下列表.<br>例子:<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">16&gt; lists:dropwhile(fun(X) -&gt; X rem 2 =:= 0  end, [2,4,3,5,6]).  </span><br><span class=\"line\">[3,5,6]</span><br></pre></td></tr></table></figure><br>源码实现:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">dropwhile</span><span class=\"params\">(Pred, [Hd|Tail]=Rest)</span> -&gt;</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> Pred(Hd) <span class=\"keyword\">of</span></span><br><span class=\"line\">\t<span class=\"literal\">true</span> -&gt; dropwhile(Pred, Tail);</span><br><span class=\"line\">\t<span class=\"literal\">false</span> -&gt; Rest</span><br><span class=\"line\">    <span class=\"keyword\">end</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">dropwhile</span><span class=\"params\">(Pred, [])</span> <span class=\"title\">when</span> <span class=\"title\">is_function</span><span class=\"params\">(Pred, <span class=\"number\">1</span>)</span> -&gt;</span> [].</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"duplicate/2\">duplicate/2</h3><blockquote>\n<p>duplicate(N, Elem) -&gt; List.</p>\n</blockquote>\n<p>生成N个Elem的列表.N不能使负数.原因可以看源码<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">-spec</span> duplicate<span class=\"params\">(N, Elem)</span> -&gt; List when</span><br><span class=\"line\">      N :: non_neg_integer<span class=\"params\">()</span>,</span><br><span class=\"line\">      Elem :: T,</span><br><span class=\"line\">      List :: [T],</span><br><span class=\"line\">      T :: term<span class=\"params\">()</span>.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">duplicate</span><span class=\"params\">(N, X)</span> <span class=\"title\">when</span> <span class=\"title\">is_integer</span><span class=\"params\">(N)</span>, N &gt;= 0 -&gt;</span> duplicate(N, X, []).</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">duplicate</span><span class=\"params\">(<span class=\"number\">0</span>, _, L)</span> -&gt;</span> L;</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">duplicate</span><span class=\"params\">(N, X, L)</span> -&gt;</span> duplicate(N-<span class=\"number\">1</span>, X, [X|L]).</span><br></pre></td></tr></table></figure><br>原理就是用列表构造,没添加一个H,N就-1,终止条件就是直到N=0,如果是负数则无法终止,所以不能为负<br>例子:<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">17&gt; lists:duplicate(3,&quot;haha&quot;).</span><br><span class=\"line\">[&quot;haha&quot;,&quot;haha&quot;,&quot;haha&quot;]</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"filter/2\">filter/2</h3><blockquote>\n<p>filter(Func, List) -&gt; List1</p>\n</blockquote>\n<p>过滤器,返回列表,元素是List中所有Func返回值为true的元素.这个在工程中经常用.<br>源码<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">-spec</span> filter<span class=\"params\">(Pred, List1)</span> -&gt; List2 when</span><br><span class=\"line\">      Pred :: fun<span class=\"params\">((Elem :: T)</span> -&gt; boolean<span class=\"params\">()</span>),</span><br><span class=\"line\">      List1 :: [T],</span><br><span class=\"line\">      List2 :: [T],</span><br><span class=\"line\">      T :: term<span class=\"params\">()</span>.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">filter</span><span class=\"params\">(Pred, List)</span> <span class=\"title\">when</span> <span class=\"title\">is_function</span><span class=\"params\">(Pred, <span class=\"number\">1</span>)</span> -&gt;</span></span><br><span class=\"line\">    [ E || E &lt;- List, Pred(E) ].</span><br></pre></td></tr></table></figure><br>可以看到,filter内部其实就是用列表解析实现的.<br>例子:<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">19&gt; lists:filter(fun(X) -&gt; X rem 2 =:= 0 end, [2,4,3,5,6]).</span><br><span class=\"line\">[2,4,6]</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"flatlength/1\">flatlength/1</h3><blockquote>\n<p>flatlength(DeepList) -&gt; integer</p>\n</blockquote>\n<p>该函数返回一个深度列表的长度,如果是深度为1的列表可以直接用length(List)返回长度,<br>官方doc这么说的</p>\n<blockquote>\n<p>Equivalent to length(flatten(DeepList)), but more efficient.</p>\n</blockquote>\n<p>等同于深度列表扁平化后在length,但是这个做更搞笑,原因很简单,这个函数只不过计算长度,并没有将列表扁平化<br>源码<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">-spec</span> flatlength<span class=\"params\">(DeepList)</span> -&gt; non_neg_integer<span class=\"params\">()</span> when</span><br><span class=\"line\">      DeepList :: [term<span class=\"params\">()</span> | DeepList].</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">flatlength</span><span class=\"params\">(List)</span> -&gt;</span></span><br><span class=\"line\">    flatlength(List, <span class=\"number\">0</span>).</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">flatlength</span><span class=\"params\">([H|T], L)</span> <span class=\"title\">when</span> <span class=\"title\">is_list</span><span class=\"params\">(H)</span> -&gt;</span></span><br><span class=\"line\">    flatlength(H, flatlength(T, L));</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">flatlength</span><span class=\"params\">([_|T], L)</span> -&gt;</span></span><br><span class=\"line\">    flatlength(T, L + <span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">flatlength</span><span class=\"params\">([], L)</span> -&gt;</span> L.</span><br></pre></td></tr></table></figure><br>例子:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; lists:flatlength([<span class=\"number\">1</span>,[<span class=\"number\">2</span>,[<span class=\"number\">3</span>],<span class=\"number\">4</span>,[<span class=\"number\">5</span>],<span class=\"number\">6</span>],[<span class=\"number\">7</span>,<span class=\"number\">8</span>]]).</span><br><span class=\"line\"><span class=\"number\">8</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"flatten/1\">flatten/1</h3><blockquote>\n<p>flatten(Deeplist) -&gt; List</p>\n</blockquote>\n<p>上面提到的flatten函数,用于扁平化一个深度列表,尽量少用,代价很高,甚至比++操作代价还高<br>源码<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">-spec</span> flatten<span class=\"params\">(DeepList)</span> -&gt; List when</span><br><span class=\"line\">      DeepList :: [term<span class=\"params\">()</span> | DeepList],</span><br><span class=\"line\">      List :: [term<span class=\"params\">()</span>].</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">flatten</span><span class=\"params\">(List)</span> <span class=\"title\">when</span> <span class=\"title\">is_list</span><span class=\"params\">(List)</span> -&gt;</span></span><br><span class=\"line\">    do_flatten(List, []).</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">-spec</span> flatten<span class=\"params\">(DeepList, Tail)</span> -&gt; List when</span><br><span class=\"line\">      DeepList :: [term<span class=\"params\">()</span> | DeepList],</span><br><span class=\"line\">      Tail :: [term<span class=\"params\">()</span>],</span><br><span class=\"line\">      List :: [term<span class=\"params\">()</span>].</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">flatten</span><span class=\"params\">(List, Tail)</span> <span class=\"title\">when</span> <span class=\"title\">is_list</span><span class=\"params\">(List)</span>, <span class=\"title\">is_list</span><span class=\"params\">(Tail)</span> -&gt;</span></span><br><span class=\"line\">    do_flatten(List, Tail).</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">do_flatten</span><span class=\"params\">([H|T], Tail)</span> <span class=\"title\">when</span> <span class=\"title\">is_list</span><span class=\"params\">(H)</span> -&gt;</span></span><br><span class=\"line\">    do_flatten(H, do_flatten(T, Tail));</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">do_flatten</span><span class=\"params\">([H|T], Tail)</span> -&gt;</span></span><br><span class=\"line\">    [H|do_flatten(T, Tail)];</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">do_flatten</span><span class=\"params\">([], Tail)</span> -&gt;</span></span><br><span class=\"line\">    Tail.</span><br></pre></td></tr></table></figure></p>\n<p>在递归中为了伪递归,如果第一个元素是list就递归调用do_flatten,如果不是就用构造器放在新列表的头,剩下的部分继续调用do_flatten.<br><strong>关于flatten的效率问题</strong><br>在官方doc的efficiency guide中有专门一块Deep and flat lists,<br>原文这么说</p>\n<blockquote>\n<p>lists:flatten/1 builds an entirely new list. Therefore, it is expensive, and even more expensive than the ++ (which copies its left argument, but not its right argument).<br>In the following situations, you can easily avoid calling lists:flatten/1:</p>\n<ol>\n<li>When sending data to a port. Ports understand deep lists so there is no reason to flatten the list before sending it to the port.</li>\n<li>When calling BIFs that accept deep lists, such as list_to_binary/1 or iolist_to_binary/1.</li>\n<li>When you know that your list is only one level deep, you can can use lists:append/1.</li>\n</ol>\n</blockquote>\n<p>因为flatten是完全重建一个列表,甚至比++(复制左边,而右边保留)更为低效,但是有3种情况可以不适用flatten</p>\n<ol>\n<li>往端口发送数据时,因为端口懂得深度列表</li>\n<li>诸如<code>list_to_binary</code>和<code>iolist_to_binary</code>的BIF,不需要扁平化<figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; list_to_binary([<span class=\"number\">1</span>,[<span class=\"number\">2</span>,[<span class=\"number\">3</span>,<span class=\"number\">4</span>]],<span class=\"number\">5</span>]).</span><br><span class=\"line\">&lt;&lt;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&gt;&gt;</span><br></pre></td></tr></table></figure></li>\n<li>如果我们知道列表深度只有一层,要用append代替flatten</li>\n</ol>\n<h3 id=\"flatten/2\">flatten/2</h3><blockquote>\n<p>flatten(DeepList, Tail) -&gt; List.</p>\n</blockquote>\n<p>就是上面flatten/1调用的子函数,flatten(DeepList) 就是flatten(DeepList, []).<br>函数在DeepList扁平化后append了一下Tail.<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">27</span>&gt; lists:flatten([<span class=\"number\">1</span>,[<span class=\"number\">3</span>,[<span class=\"number\">4</span>,<span class=\"number\">5</span>],<span class=\"number\">2</span>]],[<span class=\"number\">1</span>,[<span class=\"number\">2</span>,[<span class=\"number\">3</span>]]]).</span><br><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>,[<span class=\"number\">2</span>,[<span class=\"number\">3</span>]]]</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"flatmap/2\">flatmap/2</h3><blockquote>\n<p>flatmap(Func, List1) -&gt; List2</p>\n</blockquote>\n<p>官方的说法是</p>\n<blockquote>\n<p>That is, flatmap behaves as if it had been defined as follows:<br>flatmap(Fun, List1) -&gt;<br>    append(map(Fun, List1)).</p>\n</blockquote>\n<p>就是List1中每个元素执行Fun,一般Fun返回一个列表,最后将这些列表append一下.<br>例子:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">26</span>&gt; lists:flatmap(<span class=\"keyword\">fun</span>(X) -&gt; [X, X+<span class=\"number\">1</span>] <span class=\"keyword\">end</span>, [<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>]).</span><br><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>]</span><br></pre></td></tr></table></figure><br>源码:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">-spec</span> flatmap<span class=\"params\">(Fun, List1)</span> -&gt; List2 when</span><br><span class=\"line\">      Fun :: fun<span class=\"params\">((A)</span> -&gt; [B]),</span><br><span class=\"line\">      List1 :: [A],</span><br><span class=\"line\">      List2 :: [B],</span><br><span class=\"line\">      A :: term<span class=\"params\">()</span>,</span><br><span class=\"line\">      B :: term<span class=\"params\">()</span>.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">flatmap</span><span class=\"params\">(F, [Hd|Tail])</span> -&gt;</span></span><br><span class=\"line\">    F(Hd) ++ flatmap(F, Tail);</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">flatmap</span><span class=\"params\">(F, [])</span> <span class=\"title\">when</span> <span class=\"title\">is_function</span><span class=\"params\">(F, <span class=\"number\">1</span>)</span> -&gt;</span> [].</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"foldl/3\">foldl/3</h3><blockquote>\n<p>foldl(Fun, Acc0, List) -&gt; Acc1</p>\n</blockquote>\n<p>这个函数用的非常多,Fun是一个可接受2个参数的函数,例如fun(X, Sum) -&gt; X + Sum end.那么List中的第一个元素带入X,然后Acc0带入Sum,执行得结果Acc1,然后将List中第二个元素带入X,将Acc1带入Sum,以此类推,每回fun的第二个参数是上把的结果,第一个元素是List中的元素.下面例子是一个累加函数<br>例子:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">28</span>&gt; lists:foldl(<span class=\"keyword\">fun</span>(X, Sum) -&gt; X + Sum <span class=\"keyword\">end</span>, <span class=\"number\">0</span>, [<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">6</span>,<span class=\"number\">8</span>,<span class=\"number\">10</span>]).</span><br><span class=\"line\"><span class=\"number\">30</span></span><br></pre></td></tr></table></figure><br>源码:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">-spec</span> foldl<span class=\"params\">(Fun, Acc0, List)</span> -&gt; Acc1 when</span><br><span class=\"line\">      Fun :: fun<span class=\"params\">((Elem :: T, AccIn)</span> -&gt; AccOut),</span><br><span class=\"line\">      Acc0 :: term<span class=\"params\">()</span>,</span><br><span class=\"line\">      Acc1 :: term<span class=\"params\">()</span>,</span><br><span class=\"line\">      AccIn :: term<span class=\"params\">()</span>,</span><br><span class=\"line\">      AccOut :: term<span class=\"params\">()</span>,</span><br><span class=\"line\">      List :: [T],</span><br><span class=\"line\">      T :: term<span class=\"params\">()</span>.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">foldl</span><span class=\"params\">(F, Accu, [Hd|Tail])</span> -&gt;</span></span><br><span class=\"line\">    foldl(F, F(Hd, Accu), Tail);</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">foldl</span><span class=\"params\">(F, Accu, [])</span> <span class=\"title\">when</span> <span class=\"title\">is_function</span><span class=\"params\">(F, <span class=\"number\">2</span>)</span> -&gt;</span> Accu.</span><br></pre></td></tr></table></figure></p>\n<p>上面可以看到foldl的第二个参数就是F(Hd, Accu)的返回结果.</p>\n<h3 id=\"foldr/3\">foldr/3</h3><p>不说了,跟上面一样,只不过是从右边开始带入.</p>\n<h3 id=\"map/2\">map/2</h3><blockquote>\n<p>map(Fun, List1) -&gt; List2</p>\n</blockquote>\n<p>返回List1中每个元素执行Fun后的结果列表,官方doc上说执行顺序是运行时决定,这个和下面说的foreach不一样.<br>例子:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">34</span>&gt; lists:map(<span class=\"keyword\">fun</span>(X) -&gt; X*<span class=\"number\">2</span> <span class=\"keyword\">end</span>, [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>]).            </span><br><span class=\"line\">[<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">6</span>,<span class=\"number\">8</span>,<span class=\"number\">10</span>]</span><br></pre></td></tr></table></figure><br>源码:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">map</span><span class=\"params\">(F, [H|T])</span> -&gt;</span></span><br><span class=\"line\">    [F(H)|map(F, T)];</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">map</span><span class=\"params\">(F, [])</span> <span class=\"title\">when</span> <span class=\"title\">is_function</span><span class=\"params\">(F, <span class=\"number\">1</span>)</span> -&gt;</span> [].</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"foreach/2\">foreach/2</h3><blockquote>\n<p>foreach(Fun, List1) -&gt; ok.</p>\n</blockquote>\n<p>该函数和map很像,区别就是foreach只执行Fun函数却不保存结果,最后返回ok.<br>源码:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">foreach</span><span class=\"params\">(F, [Hd|Tail])</span> -&gt;</span></span><br><span class=\"line\">    F(Hd),</span><br><span class=\"line\">    foreach(F, Tail);</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">foreach</span><span class=\"params\">(F, [])</span> <span class=\"title\">when</span> <span class=\"title\">is_function</span><span class=\"params\">(F, <span class=\"number\">1</span>)</span> -&gt;</span> ok.</span><br></pre></td></tr></table></figure></p>\n<p>这里和map不同的是foreach的递归在执行完前一个元素的Fun函数后才会继续执行一下个元素的Fun函数,这里的执行顺序就是列表的顺序,官方doc上说:<code>this function is used for its side effects</code><br>我不是很理解具体有什么用...</p>\n<h3 id=\"keydelete/3\">keydelete/3</h3><blockquote>\n<p>keydelete(Key, N, TupleList) -&gt; TupleList1</p>\n</blockquote>\n<p>主要用于由{}tuple 组成的列表,删除Tuplelist中第一个第N个位置的值等于Key的tuple,N是tuple中key应该匹配的位置.这个也经常用,比如一个地图中存了{PlayerId, name, str, magic...}之类的tuplelist,如果玩家离开地图,可以让Key为PlayerId,然后keydelete这个玩家的信息,因为PlayerId一般都是唯一的.<br>例子:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">37</span>&gt; lists:keydelete(<span class=\"number\">2010211108</span>, <span class=\"number\">1</span>, [&#123;<span class=\"number\">2010211105</span>, sice, <span class=\"number\">5</span>&#125;,&#123;<span class=\"number\">2010211106</span>, sice, <span class=\"number\">6</span>&#125;,&#123;<span class=\"number\">2010211107</span>, sice, <span class=\"number\">7</span>&#125;,&#123;<span class=\"number\">2010211108</span>, <span class=\"number\">8</span>&#125;]).</span><br><span class=\"line\">[&#123;<span class=\"number\">2010211105</span>,sice,<span class=\"number\">5</span>&#125;,</span><br><span class=\"line\"> &#123;<span class=\"number\">2010211106</span>,sice,<span class=\"number\">6</span>&#125;,</span><br><span class=\"line\"> &#123;<span class=\"number\">2010211107</span>,sice,<span class=\"number\">7</span>&#125;]</span><br></pre></td></tr></table></figure><br>源码:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">keydelete</span><span class=\"params\">(K, N, L)</span> <span class=\"title\">when</span> <span class=\"title\">is_integer</span><span class=\"params\">(N)</span>, N &gt; 0 -&gt;</span></span><br><span class=\"line\">    keydelete3(K, N, L).</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">keydelete3</span><span class=\"params\">(Key, N, [H|T])</span> <span class=\"title\">when</span> <span class=\"title\">element</span><span class=\"params\">(N, H)</span> == K<span class=\"title\">ey</span> -&gt;</span> T;</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">keydelete3</span><span class=\"params\">(Key, N, [H|T])</span> -&gt;</span></span><br><span class=\"line\">    [H|keydelete3(Key, N, T)];</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">keydelete3</span><span class=\"params\">(_, _, [])</span> -&gt;</span> [].</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"keyfind/3\">keyfind/3</h3><blockquote>\n<p>keyfind(Key, N, TupleList) -&gt; Tuple | false</p>\n</blockquote>\n<p>大致同上,如字面意思,只不过不delete掉,没找到会返回false,不过这个是BIF,也就是说用c写的,在lists模块看不到实现方法,BIF的效率一般都很高.<br>例子:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">38</span>&gt; lists:keyfind(<span class=\"number\">2010211108</span>, <span class=\"number\">1</span>, [&#123;<span class=\"number\">2010211105</span>, sice, <span class=\"number\">5</span>&#125;,&#123;<span class=\"number\">2010211106</span>, sice, <span class=\"number\">6</span>&#125;,&#123;<span class=\"number\">2010211107</span>, sice, <span class=\"number\">7</span>&#125;]). </span><br><span class=\"line\"><span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"number\">39</span>&gt; lists:keyfind(<span class=\"number\">2010211106</span>, <span class=\"number\">1</span>, [&#123;<span class=\"number\">2010211105</span>, sice, <span class=\"number\">5</span>&#125;,&#123;<span class=\"number\">2010211106</span>, sice, <span class=\"number\">6</span>&#125;,&#123;<span class=\"number\">2010211107</span>, sice, <span class=\"number\">7</span>&#125;]).</span><br><span class=\"line\">&#123;<span class=\"number\">2010211106</span>,sice,<span class=\"number\">6</span>&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>BIF的源码可以把github上的<a href=\"https://github.com/erlang/otp\">erlang/otp</a>clone下来<br>然后在otp/erts/emulator/beam里面可以找到BIF的c代码,lists里面的BIF写在erl_bif_lists.c中<br>以下是keyfind的源码,以后的BIF代码就不贴了,感兴趣可以自己去找,不是那么好懂.</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">keyfind(<span class=\"keyword\">int</span> Bif, Process* p, Eterm Key, Eterm Pos, Eterm List)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> max_iter = <span class=\"number\">10</span> * CONTEXT_REDS;</span><br><span class=\"line\">    Sint pos;</span><br><span class=\"line\">    Eterm term;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!is_small(Pos) || (pos = signed_val(Pos)) &lt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\tBIF_ERROR(p, BADARG);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (is_small(Key)) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">double</span> float_key = (<span class=\"keyword\">double</span>) signed_val(Key);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (is_list(List)) &#123;</span><br><span class=\"line\">\t    <span class=\"keyword\">if</span> (--max_iter &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\tBUMP_ALL_REDS(p);</span><br><span class=\"line\">\t\tBIF_TRAP3(bif_export[Bif], p, Key, Pos, List);</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t    term = CAR(list_val(List));</span><br><span class=\"line\">\t    List = CDR(list_val(List));</span><br><span class=\"line\">\t    <span class=\"keyword\">if</span> (is_tuple(term)) &#123;</span><br><span class=\"line\">\t\tEterm *tuple_ptr = tuple_val(term);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (pos &lt;= arityval(*tuple_ptr)) &#123;</span><br><span class=\"line\">\t\t    Eterm element = tuple_ptr[pos];</span><br><span class=\"line\">\t\t    <span class=\"keyword\">if</span> (Key == element) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> term;</span><br><span class=\"line\">\t\t    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (is_float(element)) &#123;</span><br><span class=\"line\">\t\t\tFloatDef f;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tGET_DOUBLE(element, f);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (f.fd == float_key) &#123;</span><br><span class=\"line\">\t\t\t    <span class=\"keyword\">return</span> term;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t    &#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (is_immed(Key)) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (is_list(List)) &#123;</span><br><span class=\"line\">\t    <span class=\"keyword\">if</span> (--max_iter &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\tBUMP_ALL_REDS(p);</span><br><span class=\"line\">\t\tBIF_TRAP3(bif_export[Bif], p, Key, Pos, List);</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t    term = CAR(list_val(List));</span><br><span class=\"line\">\t    List = CDR(list_val(List));</span><br><span class=\"line\">\t    <span class=\"keyword\">if</span> (is_tuple(term)) &#123;</span><br><span class=\"line\">\t\tEterm *tuple_ptr = tuple_val(term);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (pos &lt;= arityval(*tuple_ptr)) &#123;</span><br><span class=\"line\">\t\t    Eterm element = tuple_ptr[pos];</span><br><span class=\"line\">\t\t    <span class=\"keyword\">if</span> (Key == element) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> term;</span><br><span class=\"line\">\t\t    &#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (is_list(List)) &#123;</span><br><span class=\"line\">\t    <span class=\"keyword\">if</span> (--max_iter &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\tBUMP_ALL_REDS(p);</span><br><span class=\"line\">\t\tBIF_TRAP3(bif_export[Bif], p, Key, Pos, List);</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t    term = CAR(list_val(List));</span><br><span class=\"line\">\t    List = CDR(list_val(List));</span><br><span class=\"line\">\t    <span class=\"keyword\">if</span> (is_tuple(term)) &#123;</span><br><span class=\"line\">\t\tEterm *tuple_ptr = tuple_val(term);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (pos &lt;= arityval(*tuple_ptr)) &#123;</span><br><span class=\"line\">\t\t    Eterm element = tuple_ptr[pos];</span><br><span class=\"line\">\t\t    <span class=\"keyword\">if</span> (CMP(Key, element) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> term;</span><br><span class=\"line\">\t\t    &#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (is_not_nil(List))  &#123;</span><br><span class=\"line\">\tBIF_ERROR(p, BADARG);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> am_false;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>哎,跟这c代码比,还是erlang看起来舒服,简单.</p>\n<h3 id=\"keyserach/3\">keyserach/3</h3><blockquote>\n<p>keysearch(Key, N, TupleList) -&gt; {value, Tuple} | false</p>\n</blockquote>\n<p>与keyfind的功能相同,只不过返回值多了个value的标签,同样是BIF,lists.erl中没有源码,这个函数存在是为了向后兼容,keyfind用的更多些,但是keyfind是在R13B版本引入的,较老的版本用的是keysearch.</p>\n<h3 id=\"keymember/3\">keymember/3</h3><blockquote>\n<p>keymember(Key, N, Tuplelist) -&gt; boolean()</p>\n</blockquote>\n<p>功能和以上大致一样,也是BIF,只不过返回是true或false.</p>\n<h3 id=\"keymap/3\">keymap/3</h3><blockquote>\n<p>keymap(Fun, N, Tuplelist) -&gt; Tuplelist2</p>\n</blockquote>\n<p>用于将每个tuple的第N个元素替换为Fun(第N个元素)的执行结果.<br>例子:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">40</span>&gt; lists:keymap(<span class=\"keyword\">fun</span>(X) -&gt; atom_to_list(X) <span class=\"keyword\">end</span>, <span class=\"number\">2</span>, [&#123;<span class=\"number\">1</span>, john, boy&#125;,&#123;<span class=\"number\">2</span>, aya, girl&#125;, &#123;<span class=\"number\">3</span>, cameron, robot&#125;]).</span><br><span class=\"line\">[&#123;<span class=\"number\">1</span>,<span class=\"string\">&quot;john&quot;</span>,boy&#125;,&#123;<span class=\"number\">2</span>,<span class=\"string\">&quot;aya&quot;</span>,girl&#125;,&#123;<span class=\"number\">3</span>,<span class=\"string\">&quot;cameron&quot;</span>,robot&#125;]</span><br></pre></td></tr></table></figure><br>源码:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">keymap</span><span class=\"params\">(Fun, Index, [Tup|Tail])</span> -&gt;</span></span><br><span class=\"line\">   [setelement(Index, Tup, Fun(element(Index, Tup)))|keymap(Fun, Index, Tail)];</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">keymap</span><span class=\"params\">(Fun, Index, [])</span> <span class=\"title\">when</span> <span class=\"title\">is_integer</span><span class=\"params\">(Index)</span>, I<span class=\"title\">ndex</span> &gt;= 1, </span></span><br><span class=\"line\"><span class=\"function\">                            <span class=\"title\">is_function</span><span class=\"params\">(Fun, <span class=\"number\">1</span>)</span> -&gt;</span> [].</span><br></pre></td></tr></table></figure></p>\n<p>setelement从字面就可以看出是将Tup的 Index内容替换为Fun(element(Index, Tup)). 而,element就是返回Tup中第Index的值,这些东西都浓缩到一句代码实现,所以说erlang很有意思.</p>\n<h3 id=\"keymerge/3\">keymerge/3</h3><blockquote>\n<p>keymerge(N, TupleList1, TupleList2) -&gt; TupleList3</p>\n</blockquote>\n<p>将TupleList1和TupleList2合并并排序,其中N用来制定用Tuple中的第N元素为依据排序,注意,tuplelist1和tuplelist2在执行keymerge前需要是已经按N排好序,否则顺序可能不正确,如果tuplelist1有和tuplelist2中有第N元素相同的tuple,则Tuplelist1的在前面.<br>例子:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">42</span>&gt; lists:keymerge(<span class=\"number\">2</span>, [&#123;a,<span class=\"number\">1</span>&#125;,&#123;c,<span class=\"number\">3</span>&#125;],[&#123;b,<span class=\"number\">2</span>&#125;,&#123;d,<span class=\"number\">4</span>&#125;]).</span><br><span class=\"line\">[&#123;a,<span class=\"number\">1</span>&#125;,&#123;b,<span class=\"number\">2</span>&#125;,&#123;c,<span class=\"number\">3</span>&#125;,&#123;d,<span class=\"number\">4</span>&#125;]</span><br><span class=\"line\"><span class=\"comment\">%顺序出错</span></span><br><span class=\"line\"><span class=\"number\">43</span>&gt; lists:keymerge(<span class=\"number\">2</span>, [&#123;a,<span class=\"number\">1</span>&#125;,&#123;c,<span class=\"number\">3</span>&#125;],[&#123;d,<span class=\"number\">4</span>&#125;,&#123;b,<span class=\"number\">2</span>&#125;]).     </span><br><span class=\"line\">[&#123;a,<span class=\"number\">1</span>&#125;,&#123;c,<span class=\"number\">3</span>&#125;,&#123;d,<span class=\"number\">4</span>&#125;,&#123;b,<span class=\"number\">2</span>&#125;]  </span><br><span class=\"line\"><span class=\"comment\">%tuplelist1的在前面</span></span><br><span class=\"line\"><span class=\"number\">44</span>&gt; lists:keymerge(<span class=\"number\">2</span>, [&#123;a,<span class=\"number\">1</span>&#125;,&#123;c,<span class=\"number\">3</span>&#125;],[&#123;e,<span class=\"number\">3</span>&#125;,&#123;d,<span class=\"number\">4</span>&#125;]).</span><br><span class=\"line\">[&#123;a,<span class=\"number\">1</span>&#125;,&#123;c,<span class=\"number\">3</span>&#125;,&#123;e,<span class=\"number\">3</span>&#125;,&#123;d,<span class=\"number\">4</span>&#125;]</span><br></pre></td></tr></table></figure></p>\n<p>源码不放了,这个比较复杂,太长了,感兴趣的自己去找吧.</p>\n<h3 id=\"keyreplace/4\">keyreplace/4</h3><blockquote>\n<p>keyreplace(Key, N, TupleList1, NewTuple) -&gt; TupleList2</p>\n</blockquote>\n<p>如字面意思,用于替换,将TupleList1中第N个值等于Key的tuple替换为NewTuple.只替换第一个.<br>例子:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">46</span>&gt; lists:keyreplace(name2, <span class=\"number\">2</span>, [&#123;player1, name1, career1&#125;,&#123;player2, name2, career2&#125;,&#123;player3, name3, career3&#125;], &#123;player4, name4, career4&#125;).</span><br><span class=\"line\">[&#123;player1,name1,career1&#125;,</span><br><span class=\"line\"> &#123;player4,name4,career4&#125;,</span><br><span class=\"line\"> &#123;player3,name3,career3&#125;]</span><br></pre></td></tr></table></figure><br>源码:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">keyreplace</span><span class=\"params\">(K, N, L, New)</span> <span class=\"title\">when</span> <span class=\"title\">is_integer</span><span class=\"params\">(N)</span>, N &gt; 0, <span class=\"title\">is_tuple</span><span class=\"params\">(New)</span> -&gt;</span></span><br><span class=\"line\">    keyreplace3(K, N, L, New).</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">keyreplace3</span><span class=\"params\">(Key, Pos, [Tup|Tail], New)</span> <span class=\"title\">when</span> <span class=\"title\">element</span><span class=\"params\">(Pos, Tup)</span> == K<span class=\"title\">ey</span> -&gt;</span></span><br><span class=\"line\">    [New|Tail];</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">keyreplace3</span><span class=\"params\">(Key, Pos, [H|T], New)</span> -&gt;</span></span><br><span class=\"line\">    [H|keyreplace3(Key, Pos, T, New)];</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">keyreplace3</span><span class=\"params\">(_, _, [], _)</span> -&gt;</span> [].</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"keysort/2\">keysort/2</h3><blockquote>\n<p>keysort(N, TupleList1) -&gt; TupleList2.</p>\n</blockquote>\n<p>example:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">47</span>&gt; lists:keysort(<span class=\"number\">1</span>,[&#123;<span class=\"number\">3</span>,name3&#125;,&#123;<span class=\"number\">2</span>, name2&#125;, &#123;<span class=\"number\">4</span>,name4&#125;,&#123;<span class=\"number\">1</span>,name1&#125;]).</span><br><span class=\"line\">[&#123;<span class=\"number\">1</span>,name1&#125;,&#123;<span class=\"number\">2</span>,name2&#125;,&#123;<span class=\"number\">3</span>,name3&#125;,&#123;<span class=\"number\">4</span>,name4&#125;]</span><br></pre></td></tr></table></figure></p>\n<p>源码不贴了,这个函数的源码很长.</p>\n<h3 id=\"keystore/4\">keystore/4</h3><blockquote>\n<p>keystore(Key, N, TupleList1, NewTuple) -&gt; TupleList2.</p>\n</blockquote>\n<p>功能和keyreplace差不多,只不过当TupleList1中没有与Key相同的Tuple时,keyreplace返回的是原来的TupleList,而keystore是将NewTuple append在原TupleList上.<br>例子;<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">48</span>&gt; lists:keyreplace(name5, <span class=\"number\">2</span>, [&#123;player1, name1, career1&#125;,&#123;player2, name2, career2&#125;,&#123;player3, name3, career3&#125;], &#123;player4, name4, career4&#125;).</span><br><span class=\"line\">[&#123;player1,name1,career1&#125;,</span><br><span class=\"line\"> &#123;player2,name2,career2&#125;,</span><br><span class=\"line\"> &#123;player3,name3,career3&#125;]</span><br><span class=\"line\"><span class=\"number\">49</span>&gt; lists:keystore(name5, <span class=\"number\">2</span>, [&#123;player1, name1, career1&#125;,&#123;player2, name2, career2&#125;,&#123;player3, name3, career3&#125;], &#123;player4, name4, career4&#125;).  </span><br><span class=\"line\">[&#123;player1,name1,career1&#125;,</span><br><span class=\"line\"> &#123;player2,name2,career2&#125;,</span><br><span class=\"line\"> &#123;player3,name3,career3&#125;,</span><br><span class=\"line\"> &#123;player4,name4,career4&#125;]</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"keytake/3\">keytake/3</h3><blockquote>\n<p>keytake(Key, N, TupleList1) -&gt; {value, Tuple, TupleList2} | false</p>\n</blockquote>\n<p>与大多数key打头的函数相同,字面意思是从TupleList中拿出第N个值和Key相等的Tuple,如果有的话,返回{value, Tuple, TupleList2},Tuple是想的Tuple,TupleList2是去掉Tuple后的新的TupleList.如果没找到则返回false.<br>example:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">50</span>&gt; lists:keytake(name2, <span class=\"number\">2</span>, [&#123;player1, name1, career1&#125;,&#123;player2, name2, career2&#125;,&#123;player3, name3, career3&#125;]).                            </span><br><span class=\"line\">&#123;value,&#123;player2,name2,career2&#125;,</span><br><span class=\"line\">       [&#123;player1,name1,career1&#125;,&#123;player3,name3,career3&#125;]&#125;</span><br></pre></td></tr></table></figure><br>源码:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">keytake</span><span class=\"params\">(Key, N, L)</span> <span class=\"title\">when</span> <span class=\"title\">is_integer</span><span class=\"params\">(N)</span>, N &gt; 0 -&gt;</span></span><br><span class=\"line\">    keytake(Key, N, L, []).</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">keytake</span><span class=\"params\">(Key, N, [H|T], L)</span> <span class=\"title\">when</span> <span class=\"title\">element</span><span class=\"params\">(N, H)</span> == K<span class=\"title\">ey</span> -&gt;</span></span><br><span class=\"line\">    &#123;value, H, lists:reverse(L, T)&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">keytake</span><span class=\"params\">(Key, N, [H|T], L)</span> -&gt;</span></span><br><span class=\"line\">    keytake(Key, N, T, [H|L]);</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">keytake</span><span class=\"params\">(_K, _N, [], _L)</span> -&gt;</span> <span class=\"literal\">false</span>.</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"last/1\">last/1</h3><blockquote>\n<p>last(List) -&gt; Last</p>\n</blockquote>\n<p>返回List中最后一个元素.<br>源码:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">last</span><span class=\"params\">([E|Es])</span> -&gt;</span> last(E, Es).</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">last</span><span class=\"params\">(_, [E|Es])</span> -&gt;</span> last(E, Es);</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">last</span><span class=\"params\">(E, [])</span> -&gt;</span> E.</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"mapfoldl/3\">mapfoldl/3</h3><blockquote>\n<p>mapfoldl(Fun, Acc0, List1) -&gt; {List2, Acc1}.</p>\n</blockquote>\n<p>官方的解释就是同时具有map和foldl的功能.直白点就是map完成List1-&gt;List2的变化,foldl完成 Acc0 -&gt; Acc1的变化.<br>因为foldl只能返回一个由List1得到的记过Acc1,而不能多List1本身得到新的List2,而map不能得到Acc1,却能完成List1到List2的变化.所以mapfoldl完成了两者的功能.看源码会比较清晰的理解下.<br>源码:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">-spec</span> mapfoldl<span class=\"params\">(Fun, Acc0, List1)</span> -&gt; &#123;List2, Acc1&#125; when</span><br><span class=\"line\">      Fun :: fun<span class=\"params\">((A, AccIn)</span> -&gt; &#123;B, AccOut&#125;),</span><br><span class=\"line\">      Acc0 :: term<span class=\"params\">()</span>,</span><br><span class=\"line\">      Acc1 :: term<span class=\"params\">()</span>,</span><br><span class=\"line\">      AccIn :: term<span class=\"params\">()</span>,</span><br><span class=\"line\">      AccOut :: term<span class=\"params\">()</span>,</span><br><span class=\"line\">      List1 :: [A],</span><br><span class=\"line\">      List2 :: [B],</span><br><span class=\"line\">      A :: term<span class=\"params\">()</span>,</span><br><span class=\"line\">      B :: term<span class=\"params\">()</span>.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">mapfoldl</span><span class=\"params\">(F, Accu0, [Hd|Tail])</span> -&gt;</span></span><br><span class=\"line\">    &#123;R,Accu1&#125; = F(Hd, Accu0),</span><br><span class=\"line\">    &#123;Rs,Accu2&#125; = mapfoldl(F, Accu1, Tail),</span><br><span class=\"line\">    &#123;[R|Rs],Accu2&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">mapfoldl</span><span class=\"params\">(F, Accu, [])</span> <span class=\"title\">when</span> <span class=\"title\">is_function</span><span class=\"params\">(F, <span class=\"number\">2</span>)</span> -&gt;</span> &#123;[],Accu&#125;.</span><br></pre></td></tr></table></figure><br>注意,这里面的Fun返回的是{B, AccOut}的形式,而foldl的Fun是<code>Fun :: fun((Elem :: T, AccIn) -&gt; AccOut),</code>这里是最本质的区别.结合例子说下<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">52</span>&gt; lists:mapfoldl(<span class=\"keyword\">fun</span>(X, Sum) -&gt; &#123;X*<span class=\"number\">2</span>, X + Sum&#125; <span class=\"keyword\">end</span>, <span class=\"number\">0</span>, [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>]).</span><br><span class=\"line\">&#123;[<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">6</span>,<span class=\"number\">8</span>,<span class=\"number\">10</span>],<span class=\"number\">15</span>&#125;</span><br></pre></td></tr></table></figure></p>\n<p>首先第一轮得到的{R, Accu1} = {2, 1},而{Rs, Accu2}需要递归执行mapfoldl,那么第二轮得到一个{R&#39;,Accu1&#39;} = {4, 3},我们每轮能确切知道的只有{R, Accu1},但是mapfoldl要返回的是{[R|Rs],Accu2},所以需要一直递归下去,那么第三轮得到{6, 6},第四轮{8, 10},第五轮得到{10, 15},这时{10, 15}仍然是{R, Accu1},但是接下来由于Tail变成了空列表[],根据模式匹配,这次执行的是第二个mapfoldl函数,那么相当于执行mapfoldl{F, 15, []),得到最底层的{Rs, Accu2} = {[], 15},那么返回的{[R|Rs], Accu2}为{[10|[]], 15}.一直往上递归回去,结果得到{[2,4,6,8,10], 15}.</p>\n<h3 id=\"mapfoldr/3\">mapfoldr/3</h3><p>与上面的执行结果一样,只不过foldr是从右边开始,不影响List2的顺序.</p>\n<h3 id=\"max/1\">max/1</h3><blockquote>\n<p>max(List) -&gt; Max</p>\n</blockquote>\n<p>返回第一个这个List中的最大数.<br>例子:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">54</span>&gt; lists:max([a,b,c]).</span><br><span class=\"line\">c</span><br><span class=\"line\"><span class=\"number\">55</span>&gt; lists:max([<span class=\"number\">100</span>,b,c]).</span><br><span class=\"line\">c</span><br><span class=\"line\"><span class=\"number\">56</span>&gt; lists:max([&#123;<span class=\"number\">100</span>&#125;,b,c]).</span><br><span class=\"line\">&#123;<span class=\"number\">100</span>&#125;</span><br><span class=\"line\"><span class=\"number\">57</span>&gt; lists:max([&#123;<span class=\"number\">100</span>&#125;,b,c,[<span class=\"number\">90</span>]]).</span><br><span class=\"line\"><span class=\"string\">&quot;Z&quot;</span></span><br><span class=\"line\"><span class=\"number\">58</span>&gt; lists:max([&#123;<span class=\"number\">100</span>&#125;,b,c,[<span class=\"number\">2</span>]]). </span><br><span class=\"line\">[<span class=\"number\">2</span>]</span><br><span class=\"line\"><span class=\"number\">59</span>&gt; lists:max([&#123;<span class=\"number\">100</span>&#125;,b,c,[<span class=\"number\">2</span>],&lt;&lt;<span class=\"number\">2</span>&gt;&gt;]).</span><br><span class=\"line\">&lt;&lt;<span class=\"number\">2</span>&gt;&gt;</span><br></pre></td></tr></table></figure></p>\n<p>这里注意下不同类型之间的比较顺序</p>\n<blockquote>\n<p>number &lt; atom &lt; reference &lt; fun &lt; port &lt; pid &lt; tuple &lt; list &lt; binary</p>\n</blockquote>\n<p>源码:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">max</span><span class=\"params\">([H|T])</span> -&gt;</span> max(T, H).</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">max</span><span class=\"params\">([H|T], Max)</span> <span class=\"title\">when</span> H &gt; M<span class=\"title\">ax</span> -&gt;</span> max(T, H);</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">max</span><span class=\"params\">([_|T], Max)</span>              -&gt;</span> max(T, Max);</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">max</span><span class=\"params\">([],    Max)</span>              -&gt;</span> Max.</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"member/2\">member/2</h3><blockquote>\n<p>member(Elem, List) -&gt; boolean()</p>\n</blockquote>\n<p>如果Elem是List中的元素就返回true, 否则返回false.BIF.源码是C写的.不贴了.</p>\n<h3 id=\"merge/1/2/3以及merge3/3\">merge/1/2/3以及merge3/3</h3><blockquote>\n<p>merge(ListOfLists) -&gt; List1.<br>merge(List1, List2) -&gt; List3.<br>merge(Fun, List1, List2) -&gt; List3.<br>merge3(List1, List2, List3) -&gt; List4</p>\n</blockquote>\n<p>暂且叫归并排序吧,merge/1,merge/2完成的就是合并并排序,顺序由小到大,merge3/3只不过可以合并3个列表.merge/3可以依据Fun更改顺序,排序依据是Fun(A, B)如果返回true,那么就是A在B的前面.<br>举几个例子:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">60</span>&gt; lists:merge([[<span class=\"number\">1</span>],[<span class=\"number\">4</span>],[<span class=\"number\">2</span>,<span class=\"number\">4</span>],[<span class=\"number\">3</span>]]).</span><br><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"number\">61</span>&gt; lists:merge([<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">6</span>],[<span class=\"number\">1</span>,<span class=\"number\">3</span>]).      </span><br><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">6</span>]</span><br><span class=\"line\"><span class=\"number\">62</span>&gt; lists:merge(<span class=\"keyword\">fun</span>(A,B) -&gt; A &gt; B <span class=\"keyword\">end</span>, [<span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">2</span>],[<span class=\"number\">8</span>,<span class=\"number\">3</span>,<span class=\"number\">1</span>]).</span><br><span class=\"line\">[<span class=\"number\">8</span>,<span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"number\">63</span>&gt; lists:merge(<span class=\"keyword\">fun</span>(A,B) -&gt; A &lt; B <span class=\"keyword\">end</span>, [<span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">2</span>],[<span class=\"number\">8</span>,<span class=\"number\">3</span>,<span class=\"number\">1</span>]).</span><br><span class=\"line\">[<span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">2</span>,<span class=\"number\">8</span>,<span class=\"number\">3</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"number\">64</span>&gt; lists:merge(<span class=\"keyword\">fun</span>(A,B) -&gt; A &lt; B <span class=\"keyword\">end</span>, [<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>],[<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">8</span>]).</span><br><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">8</span>]</span><br><span class=\"line\"><span class=\"number\">66</span>&gt; lists:merge3([<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">6</span>],[<span class=\"number\">1</span>,<span class=\"number\">3</span>],[<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>]).</span><br><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>]</span><br></pre></td></tr></table></figure></p>\n<p>所有的排序都要求每个子List在排序前都是排好序的,如63行,由于子列表没有排好序,所以排序结果不正确.<br>merge的源码比较多而且杂,感兴趣自己去lists.erl里面看.</p>\n<h3 id=\"min/1\">min/1</h3><blockquote>\n<p>min(List) -&gt; Min</p>\n</blockquote>\n<p>与max相反.</p>\n<h3 id=\"nth/2\">nth/2</h3><blockquote>\n<p>nth(N, List) -&gt; Elem</p>\n</blockquote>\n<p>返回第List的第N个元素.<br>例子:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">67</span>&gt; lists:nth(<span class=\"number\">2</span>,[<span class=\"string\">&quot;haha&quot;</span>,atom,<span class=\"number\">2</span>,&lt;&lt;<span class=\"string\">&quot;binary&quot;</span>&gt;&gt;]). </span><br><span class=\"line\">atom</span><br></pre></td></tr></table></figure><br>源码:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">nth</span><span class=\"params\">(<span class=\"number\">1</span>, [H|_])</span> -&gt;</span> H;</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">nth</span><span class=\"params\">(N, [_|T])</span> <span class=\"title\">when</span> N &gt; 1 -&gt;</span></span><br><span class=\"line\">    nth(N - <span class=\"number\">1</span>, T).</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"nthtail/2\">nthtail/2</h3><blockquote>\n<p>nthtail(N, List) -&gt; Tail</p>\n</blockquote>\n<p>返回List的第N个尾列表.<br>例子:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">68</span>&gt; lists:nthtail(<span class=\"number\">0</span>,[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]).</span><br><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"number\">69</span>&gt; lists:nthtail(<span class=\"number\">1</span>,[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]).</span><br><span class=\"line\">[<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"number\">70</span>&gt; lists:nthtail(<span class=\"number\">2</span>,[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]).</span><br><span class=\"line\">[<span class=\"number\">3</span>,<span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"number\">71</span>&gt; lists:nthtail(<span class=\"number\">4</span>,[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]).</span><br><span class=\"line\">[]</span><br></pre></td></tr></table></figure><br>源码:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">nthtail</span><span class=\"params\">(<span class=\"number\">1</span>, [_|T])</span> -&gt;</span> T;</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">nthtail</span><span class=\"params\">(N, [_|T])</span> <span class=\"title\">when</span> N &gt; 1 -&gt;</span></span><br><span class=\"line\">    nthtail(N - <span class=\"number\">1</span>, T);</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">nthtail</span><span class=\"params\">(<span class=\"number\">0</span>, L)</span> <span class=\"title\">when</span> <span class=\"title\">is_list</span><span class=\"params\">(L)</span> -&gt;</span> L.</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"partition/2\">partition/2</h3><blockquote>\n<p>partition(Fun, List1) -&gt; {List1, List2}.</p>\n</blockquote>\n<p>字面意思是区分开,将List1依据Fun返回的true和false分为两个列表.<br>例子:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">73</span>&gt; lists:partition(<span class=\"keyword\">fun</span>(X) -&gt; X&gt;<span class=\"number\">2</span> <span class=\"keyword\">end</span>, [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]).</span><br><span class=\"line\">&#123;[<span class=\"number\">3</span>,<span class=\"number\">4</span>],[<span class=\"number\">1</span>,<span class=\"number\">2</span>]&#125;</span><br></pre></td></tr></table></figure><br>源码<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">partition</span><span class=\"params\">(Pred, L)</span> -&gt;</span></span><br><span class=\"line\">    partition(Pred, L, [], []).</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">partition</span><span class=\"params\">(Pred, [H | T], As, Bs)</span> -&gt;</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> Pred(H) <span class=\"keyword\">of</span></span><br><span class=\"line\">\t<span class=\"literal\">true</span> -&gt; partition(Pred, T, [H | As], Bs);</span><br><span class=\"line\">\t<span class=\"literal\">false</span> -&gt; partition(Pred, T, As, [H | Bs])</span><br><span class=\"line\">    <span class=\"keyword\">end</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">partition</span><span class=\"params\">(Pred, [], As, Bs)</span> <span class=\"title\">when</span> <span class=\"title\">is_function</span><span class=\"params\">(Pred, <span class=\"number\">1</span>)</span> -&gt;</span></span><br><span class=\"line\">    &#123;reverse(As), reverse(Bs)&#125;.</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"prefix/2\">prefix/2</h3><blockquote>\n<p>prefix(List1, List2) -&gt; boolean().</p>\n</blockquote>\n<p>如果List1是List2的前缀则返回true,否则返回false<br>例子:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">74</span>&gt; lists:prefix([<span class=\"number\">1</span>,<span class=\"number\">2</span>],[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]).                </span><br><span class=\"line\"><span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"number\">75</span>&gt; lists:prefix([<span class=\"number\">1</span>,<span class=\"number\">2</span>],[<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]).  </span><br><span class=\"line\"><span class=\"literal\">false</span></span><br></pre></td></tr></table></figure><br>源码很好理解:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">prefix</span><span class=\"params\">([X|PreTail], [X|Tail])</span> -&gt;</span></span><br><span class=\"line\">    prefix(PreTail, Tail);</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">prefix</span><span class=\"params\">([], List)</span> <span class=\"title\">when</span> <span class=\"title\">is_list</span><span class=\"params\">(List)</span> -&gt;</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">prefix</span><span class=\"params\">([_|_], List)</span> <span class=\"title\">when</span> <span class=\"title\">is_list</span><span class=\"params\">(List)</span> -&gt;</span> <span class=\"literal\">false</span>.</span><br></pre></td></tr></table></figure></p>\n<p>如果第一元素都是X,则递归执行prefix,如果List1为[]了,那么返回true,如果遇到不相同的元素了就返回false.</p>\n<h3 id=\"reverse/1/2\">reverse/1/2</h3><blockquote>\n<p>reverse(List1) -&gt; List2.<br>reverse(List1, Tail) -&gt; List2.</p>\n</blockquote>\n<p>reverse/1返回的是逆序的List1. reverse/2返回的是逆序的List1并且append了Tail.<br>例子:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">76</span>&gt; lists:reverse([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]).</span><br><span class=\"line\">[<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"number\">77</span>&gt; lists:reverse([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>],[<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>]).</span><br><span class=\"line\">[<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>]</span><br></pre></td></tr></table></figure><br>源码:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">-spec</span> reverse<span class=\"params\">(List1)</span> -&gt; List2 when</span><br><span class=\"line\">      List1 :: [T],</span><br><span class=\"line\">      List2 :: [T],</span><br><span class=\"line\">      T :: term<span class=\"params\">()</span>.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">reverse</span><span class=\"params\">([] = L)</span> -&gt;</span></span><br><span class=\"line\">    L;</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">reverse</span><span class=\"params\">([_] = L)</span> -&gt;</span></span><br><span class=\"line\">    L;</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">reverse</span><span class=\"params\">([A, B])</span> -&gt;</span></span><br><span class=\"line\">    [B, A];</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">reverse</span><span class=\"params\">([A, B | L])</span> -&gt;</span></span><br><span class=\"line\">    lists:reverse(L, [B, A]).</span><br></pre></td></tr></table></figure></p>\n<p>注意这里比较神奇的是reverse/1调用的是reverse/2,我一直以为reverse/1是BIF,其实reverse/2才是BIF,而且reverse/2在各种merge函数中多次调用,调用reverse/2的次数非常多,估计所以才将reverse/2写成了BIF吧.</p>\n<h3 id=\"seq/2/3\">seq/2/3</h3><blockquote>\n<p>seq(From, To) -&gt; List1<br>seq(From, To, Incr) -&gt; List2</p>\n</blockquote>\n<p>用于生成From到To的列表,Incr是递增的值.这个函数通常只用于最简单的功能,但是还是需要注意一下,这个函数报错的条件比较苛刻.官方给的说明是在一下会发生error错误.</p>\n<ol>\n<li>To &lt; From - Incr 并且Incr是正数.</li>\n<li>To &gt; From - Incr 并且Incr是负数.</li>\n<li>Incr为0时,From 不等于 To<br>并且官方给出<blockquote>\n<p>length(lists:seq(From, To)) == To-From+1<br>length(lists:seq(From, To, Incr)) == (To-From+Incr) div Incr</p>\n</blockquote>\n</li>\n</ol>\n<p>涵盖了上面3种情况,因为length不能是负数,其实只要看<strong><em>To-From+Incr与Incr相除</em></strong>是正数或者0就不会报错.<br>以下是一些例子:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">78</span>&gt; lists:seq(<span class=\"number\">1</span>,<span class=\"number\">4</span>).</span><br><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"number\">79</span>&gt; lists:seq(<span class=\"number\">3</span>,<span class=\"number\">1</span>).</span><br><span class=\"line\">** exception error: no function clause matching lists:seq(<span class=\"number\">3</span>,<span class=\"number\">1</span>) (lists.erl, line <span class=\"number\">177</span>)</span><br><span class=\"line\"><span class=\"number\">80</span>&gt; lists:seq(<span class=\"number\">3</span>,<span class=\"number\">1</span>,-<span class=\"number\">1</span>).</span><br><span class=\"line\">[<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"number\">81</span>&gt; lists:seq(<span class=\"number\">3</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>). </span><br><span class=\"line\">** exception error: no <span class=\"literal\">true</span> branch found <span class=\"keyword\">when</span> evaluating an <span class=\"keyword\">if</span> expression</span><br><span class=\"line\">     in function  lists:seq/<span class=\"number\">3</span> (lists.erl, line <span class=\"number\">198</span>)</span><br><span class=\"line\"><span class=\"number\">82</span>&gt; lists:seq(<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>).</span><br><span class=\"line\">[]</span><br><span class=\"line\"><span class=\"number\">83</span>&gt; lists:seq(<span class=\"number\">10</span>,<span class=\"number\">6</span>,<span class=\"number\">1</span>).</span><br><span class=\"line\">** exception error: no <span class=\"literal\">true</span> branch found <span class=\"keyword\">when</span> evaluating an <span class=\"keyword\">if</span> expression</span><br><span class=\"line\">     in function  lists:seq/<span class=\"number\">3</span> (lists.erl, line <span class=\"number\">198</span>)</span><br><span class=\"line\"><span class=\"number\">84</span>&gt; lists:seq(<span class=\"number\">10</span>,<span class=\"number\">6</span>,<span class=\"number\">4</span>).</span><br><span class=\"line\">[]</span><br><span class=\"line\"><span class=\"number\">85</span>&gt; lists:seq(<span class=\"number\">10</span>,<span class=\"number\">6</span>,<span class=\"number\">5</span>).</span><br><span class=\"line\">[]</span><br><span class=\"line\"><span class=\"number\">86</span>&gt; lists:seq(<span class=\"number\">10</span>,<span class=\"number\">6</span>,<span class=\"number\">3</span>).</span><br><span class=\"line\">** exception error: no <span class=\"literal\">true</span> branch found <span class=\"keyword\">when</span> evaluating an <span class=\"keyword\">if</span> expression</span><br><span class=\"line\">     in function  lists:seq/<span class=\"number\">3</span> (lists.erl, line <span class=\"number\">198</span>)</span><br><span class=\"line\"><span class=\"number\">87</span>&gt; lists:seq(<span class=\"number\">1</span>,<span class=\"number\">4</span>).</span><br><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"number\">88</span>&gt; lists:seq(<span class=\"number\">1</span>,<span class=\"number\">0</span>).</span><br><span class=\"line\">[]</span><br><span class=\"line\"><span class=\"number\">89</span>&gt; lists:seq(<span class=\"number\">3</span>,<span class=\"number\">0</span>,-<span class=\"number\">1</span>).</span><br><span class=\"line\">[<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>]</span><br><span class=\"line\"><span class=\"number\">90</span>&gt; lists:seq(<span class=\"number\">10</span>,<span class=\"number\">6</span>,<span class=\"number\">4</span>).</span><br><span class=\"line\">[]</span><br><span class=\"line\"><span class=\"number\">91</span>&gt; lists:seq(<span class=\"number\">10</span>,<span class=\"number\">6</span>,<span class=\"number\">3</span>).</span><br><span class=\"line\">** exception error: no <span class=\"literal\">true</span> branch found <span class=\"keyword\">when</span> evaluating an <span class=\"keyword\">if</span> expression</span><br><span class=\"line\">     in function  lists:seq/<span class=\"number\">3</span> (lists.erl, line <span class=\"number\">198</span>)</span><br><span class=\"line\"><span class=\"number\">92</span>&gt; lists:seq(<span class=\"number\">6</span>,<span class=\"number\">8</span>,-<span class=\"number\">3</span>).</span><br><span class=\"line\">[]</span><br><span class=\"line\"><span class=\"number\">93</span>&gt; lists:seq(<span class=\"number\">6</span>,<span class=\"number\">10</span>,-<span class=\"number\">3</span>).</span><br><span class=\"line\">** exception error: no <span class=\"literal\">true</span> branch found <span class=\"keyword\">when</span> evaluating an <span class=\"keyword\">if</span> expression</span><br><span class=\"line\">     in function  lists:seq/<span class=\"number\">3</span> (lists.erl, line <span class=\"number\">198</span>)</span><br><span class=\"line\"><span class=\"number\">94</span>&gt; lists:seq(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">0</span>).  </span><br><span class=\"line\">** exception error: no <span class=\"literal\">true</span> branch found <span class=\"keyword\">when</span> evaluating an <span class=\"keyword\">if</span> expression</span><br><span class=\"line\">     in function  lists:seq/<span class=\"number\">3</span> (lists.erl, line <span class=\"number\">198</span>)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"sort/1/2\">sort/1/2</h3><blockquote>\n<p>sort(List1) -&gt; List2.<br>sort(Fun, List1) -&gt; List2</p>\n</blockquote>\n<p>排序函数,应熟记不同类型之间的大小顺序,如例子:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">95</span>&gt; Ref = make_ref().</span><br><span class=\"line\">#Ref&lt;<span class=\"number\">0.0</span>.<span class=\"number\">0.358</span>&gt;</span><br><span class=\"line\"><span class=\"number\">96</span>&gt; Fun = <span class=\"keyword\">fun</span>(X) -&gt; X <span class=\"keyword\">end</span>.</span><br><span class=\"line\">#Fun&lt;erl_eval.<span class=\"number\">6.111823515</span>&gt;</span><br><span class=\"line\"><span class=\"number\">97</span>&gt; &#123;ok, Port&#125;=gen_tcp:listen(<span class=\"number\">8011</span>,[]).</span><br><span class=\"line\">&#123;ok,#Port&lt;<span class=\"number\">0.619</span>&gt;&#125;</span><br><span class=\"line\"><span class=\"number\">98</span>&gt; Pid = spawn(lists, seq, [<span class=\"number\">1</span>,<span class=\"number\">100</span>]).</span><br><span class=\"line\">&lt;<span class=\"number\">0.151</span>.<span class=\"number\">0</span>&gt;</span><br><span class=\"line\"><span class=\"number\">99</span>&gt; lists:sort([&lt;&lt;<span class=\"number\">2</span>&gt;&gt;,[<span class=\"number\">3</span>],&#123;<span class=\"number\">4</span>&#125;,Pid,Port,Fun,Ref,atom,<span class=\"number\">5</span>]).</span><br><span class=\"line\">[<span class=\"number\">5</span>,atom,#Ref&lt;<span class=\"number\">0.0</span>.<span class=\"number\">0.358</span>&gt;,#Fun&lt;erl_eval.<span class=\"number\">6.111823515</span>&gt;,</span><br><span class=\"line\"> #Port&lt;<span class=\"number\">0.619</span>&gt;,&lt;<span class=\"number\">0.151</span>.<span class=\"number\">0</span>&gt;,</span><br><span class=\"line\"> &#123;<span class=\"number\">4</span>&#125;,</span><br><span class=\"line\"> [<span class=\"number\">3</span>],</span><br><span class=\"line\"> &lt;&lt;<span class=\"number\">2</span>&gt;&gt;]</span><br></pre></td></tr></table></figure></p>\n<p>我在max函数提到过这个顺序,上面的结果也是按照这个顺序来的</p>\n<blockquote>\n<p>number &lt; atom &lt; reference &lt; fun &lt; port &lt; pid &lt; tuple &lt; list &lt; binary</p>\n</blockquote>\n<p>sort/2大致如merge/3,其中Fun可以用来改变默认的由小到大.</p>\n<h3 id=\"split/2\">split/2</h3><blockquote>\n<p>split(N, List1) -&gt; {List2, List3}</p>\n</blockquote>\n<p>分割函数,将List1分割成前N个元素List2,和剩下的元素List3<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">100</span>&gt; lists:split(<span class=\"number\">3</span>,[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>]). </span><br><span class=\"line\">&#123;[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>],[<span class=\"number\">4</span>,<span class=\"number\">5</span>]&#125;</span><br></pre></td></tr></table></figure><br>源码:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">-spec</span> split<span class=\"params\">(N, List1)</span> -&gt; &#123;List2, List3&#125; when</span><br><span class=\"line\">      N :: non_neg_integer<span class=\"params\">()</span>,</span><br><span class=\"line\">      List1 :: [T],</span><br><span class=\"line\">      List2 :: [T],</span><br><span class=\"line\">      List3 :: [T],</span><br><span class=\"line\">      T :: term<span class=\"params\">()</span>.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">split</span><span class=\"params\">(N, List)</span> <span class=\"title\">when</span> <span class=\"title\">is_integer</span><span class=\"params\">(N)</span>, N &gt;= 0, <span class=\"title\">is_list</span><span class=\"params\">(List)</span> -&gt;</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> split(N, List, []) <span class=\"keyword\">of</span></span><br><span class=\"line\">\t&#123;_, _&#125; = Result -&gt; Result;</span><br><span class=\"line\">\tFault <span class=\"keyword\">when</span> is_atom(Fault) -&gt;</span><br><span class=\"line\">\t    erlang:error(Fault, [N,List])</span><br><span class=\"line\">    <span class=\"keyword\">end</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">split</span><span class=\"params\">(N, List)</span> -&gt;</span></span><br><span class=\"line\">    erlang:error(badarg, [N,List]).</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">split</span><span class=\"params\">(<span class=\"number\">0</span>, L, R)</span> -&gt;</span></span><br><span class=\"line\">    &#123;lists:reverse(R, []), L&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">split</span><span class=\"params\">(N, [H|T], R)</span> -&gt;</span></span><br><span class=\"line\">    split(N-<span class=\"number\">1</span>, T, [H|R]);</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">split</span><span class=\"params\">(_, [], _)</span> -&gt;</span></span><br><span class=\"line\">    badarg.</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"splitwith/2\">splitwith/2</h3><p>splitwith(Fun, List) -&gt; {List1, List2}</p>\n<p>Fun决定切割的规则,List1是在遇到Fun(X)为false之前的元素,List2是第一个Fun返回为false之后的列表.<br>例子:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">101</span>&gt; lists:splitwith(<span class=\"keyword\">fun</span>(X) -&gt; is_atom(X) <span class=\"keyword\">end</span>, [a,b,c,<span class=\"number\">2</span>,d,e,<span class=\"number\">4</span>]).</span><br><span class=\"line\">&#123;[a,b,c],[<span class=\"number\">2</span>,d,e,<span class=\"number\">4</span>]&#125;</span><br></pre></td></tr></table></figure><br>源码:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">-spec</span> splitwith<span class=\"params\">(Pred, List)</span> -&gt; &#123;List1, List2&#125; when</span><br><span class=\"line\">      Pred :: fun<span class=\"params\">((T)</span> -&gt; boolean<span class=\"params\">()</span>),</span><br><span class=\"line\">      List :: [T],</span><br><span class=\"line\">      List1 :: [T],</span><br><span class=\"line\">      List2 :: [T],</span><br><span class=\"line\">      T :: term<span class=\"params\">()</span>.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">splitwith</span><span class=\"params\">(Pred, List)</span> <span class=\"title\">when</span> <span class=\"title\">is_function</span><span class=\"params\">(Pred, <span class=\"number\">1</span>)</span> -&gt;</span></span><br><span class=\"line\">    splitwith(Pred, List, []).</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">splitwith</span><span class=\"params\">(Pred, [Hd|Tail], Taken)</span> -&gt;</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> Pred(Hd) <span class=\"keyword\">of</span></span><br><span class=\"line\">\t<span class=\"literal\">true</span> -&gt; splitwith(Pred, Tail, [Hd|Taken]);</span><br><span class=\"line\">\t<span class=\"literal\">false</span> -&gt; &#123;reverse(Taken), [Hd|Tail]&#125;</span><br><span class=\"line\">    <span class=\"keyword\">end</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">splitwith</span><span class=\"params\">(Pred, [], Taken)</span> <span class=\"title\">when</span> <span class=\"title\">is_function</span><span class=\"params\">(Pred, <span class=\"number\">1</span>)</span> -&gt;</span></span><br><span class=\"line\">    &#123;reverse(Taken),[]&#125;.</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"sublist/2/3\">sublist/2/3</h3><blockquote>\n<p>sublist(List1, Len) -&gt; List2<br>sublist(List1, Start, Len) -&gt; List2</p>\n</blockquote>\n<p>返回前List中前Len个元素,Len可以大于List的长度,这样整个List会返回.<br>Start可以决定起始位置.<br>例子:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">102</span>&gt; lists:sublist([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>],<span class=\"number\">2</span>).                                </span><br><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>]</span><br><span class=\"line\"><span class=\"number\">103</span>&gt; lists:sublist([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>],<span class=\"number\">2</span>,<span class=\"number\">2</span>).</span><br><span class=\"line\">[<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"number\">104</span>&gt; lists:sublist([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>],<span class=\"number\">5</span>).  </span><br><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"number\">105</span>&gt; lists:sublist([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>],<span class=\"number\">5</span>,<span class=\"number\">1</span>).</span><br><span class=\"line\">[]</span><br></pre></td></tr></table></figure><br>源码<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">sublist</span><span class=\"params\">(List, L)</span> <span class=\"title\">when</span> <span class=\"title\">is_integer</span><span class=\"params\">(L)</span>, <span class=\"title\">is_list</span><span class=\"params\">(List)</span> -&gt;</span></span><br><span class=\"line\">    sublist_2(List, L).</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">sublist_2</span><span class=\"params\">([H|T], L)</span> <span class=\"title\">when</span> L &gt; 0 -&gt;</span></span><br><span class=\"line\">    [H|sublist_2(T, L-<span class=\"number\">1</span>)];</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">sublist_2</span><span class=\"params\">(_, <span class=\"number\">0</span>)</span> -&gt;</span></span><br><span class=\"line\">    [];</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">sublist_2</span><span class=\"params\">(List, L)</span> <span class=\"title\">when</span> <span class=\"title\">is_list</span><span class=\"params\">(List)</span>, L &gt; 0 -&gt;</span></span><br><span class=\"line\">    [].</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">sublist</span><span class=\"params\">(List, S, L)</span> <span class=\"title\">when</span> <span class=\"title\">is_integer</span><span class=\"params\">(L)</span>, L &gt;= 0 -&gt;</span></span><br><span class=\"line\">    sublist(nthtail(S-<span class=\"number\">1</span>, List), L).</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"subtract/2\">subtract/2</h3><blockquote>\n<p>subtract(List1, List2) -&gt; List3</p>\n</blockquote>\n<p>规则是这样的:对于List2中的每一个元素,在List1第一个与这个元素相等的元素被删掉,而成为List3.<br>例如:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">107</span>&gt; lists:subtract([<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">1</span>],[<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>]). </span><br><span class=\"line\">[<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">1</span>]</span><br></pre></td></tr></table></figure><br>源码:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">-spec</span> subtract<span class=\"params\">(List1, List2)</span> -&gt; List3 when</span><br><span class=\"line\">      List1 :: [T],</span><br><span class=\"line\">      List2 :: [T],</span><br><span class=\"line\">      List3 :: [T],</span><br><span class=\"line\">      T :: term<span class=\"params\">()</span>.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">subtract</span><span class=\"params\">(L1, L2)</span> -&gt;</span> L1 -- L2.</span><br></pre></td></tr></table></figure></p>\n<p>很明显这个函数在最坏情况下,有length(List1)*length(List2)的复杂度,代价很高.官方给的建议是</p>\n<blockquote>\n<p>Using ordered lists and ordsets:subtract/2 is a much better choice if both lists are long.</p>\n</blockquote>\n<p>使用ordset中的subtract/2,前提是这两个List是排好序的.<br>源码:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">-spec</span> subtract<span class=\"params\">(Ordset1, Ordset2)</span> -&gt; Ordset3 when</span><br><span class=\"line\">      Ordset1 :: ordset<span class=\"params\">(_)</span>,</span><br><span class=\"line\">      Ordset2 :: ordset<span class=\"params\">(_)</span>,</span><br><span class=\"line\">      Ordset3 :: ordset<span class=\"params\">(_)</span>.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">subtract</span><span class=\"params\">([E1|Es1], [E2|_]=Set2)</span> <span class=\"title\">when</span> E1 &lt; E2 -&gt;</span></span><br><span class=\"line\">    [E1|subtract(Es1, Set2)];</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">subtract</span><span class=\"params\">([E1|_]=Set1, [E2|Es2])</span> <span class=\"title\">when</span> E1 &gt; E2 -&gt;</span></span><br><span class=\"line\">    subtract(Set1, Es2);</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">subtract</span><span class=\"params\">([_E1|Es1], [_E2|Es2])</span> -&gt;</span>\t\t<span class=\"comment\">%E1 == E2</span></span><br><span class=\"line\">    subtract(Es1, Es2);</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">subtract</span><span class=\"params\">([], _)</span> -&gt;</span> [];</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">subtract</span><span class=\"params\">(Es1, [])</span> -&gt;</span> Es1.</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"suffix/2\">suffix/2</h3><blockquote>\n<p>suffix(List1, List2) -&gt; boolean().</p>\n</blockquote>\n<p>如同prefix,如果List1是List2的后缀则返回true,否则返回false.<br>例子:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">108</span>&gt; lists:suffix([<span class=\"number\">3</span>,<span class=\"number\">1</span>],[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">1</span>]).                             </span><br><span class=\"line\"><span class=\"literal\">true</span></span><br></pre></td></tr></table></figure><br>源码:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">suffix</span><span class=\"params\">(Suffix, List)</span> -&gt;</span></span><br><span class=\"line\">    Delta = length(List) - length(Suffix),</span><br><span class=\"line\">    Delta &gt;= <span class=\"number\">0</span> <span class=\"keyword\">andalso</span> nthtail(Delta, List) =:= Suffix.</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"sum/1\">sum/1</h3><blockquote>\n<p>sum(List) -&gt; Sum</p>\n</blockquote>\n<p>得到一个List的和,注意List应为数字组成.否则抛错.<br>源码:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">sum</span><span class=\"params\">(L)</span>          -&gt;</span> sum(L, <span class=\"number\">0</span>).</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">sum</span><span class=\"params\">([H|T], Sum)</span> -&gt;</span> sum(T, Sum + H);</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">sum</span><span class=\"params\">([], Sum)</span>    -&gt;</span> Sum.</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"takewhile/2\">takewhile/2</h3><blockquote>\n<p>takewhile(Pred, List1) -&gt; List2</p>\n</blockquote>\n<p>从List1中取出满足Pred为true的元素,直到遇到第一个false.也就是取出满足Pred的前缀.<br>例子:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">109</span>&gt; lists:takewhile(<span class=\"keyword\">fun</span>(A) -&gt; A &lt; <span class=\"number\">3</span> <span class=\"keyword\">end</span>, [<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>]).</span><br><span class=\"line\">[<span class=\"number\">2</span>,<span class=\"number\">1</span>]</span><br></pre></td></tr></table></figure><br>源码:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">takewhile</span><span class=\"params\">(Pred, [Hd|Tail])</span> -&gt;</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> Pred(Hd) <span class=\"keyword\">of</span></span><br><span class=\"line\">\t<span class=\"literal\">true</span> -&gt; [Hd|takewhile(Pred, Tail)];</span><br><span class=\"line\">\t<span class=\"literal\">false</span> -&gt; []</span><br><span class=\"line\">    <span class=\"keyword\">end</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">takewhile</span><span class=\"params\">(Pred, [])</span> <span class=\"title\">when</span> <span class=\"title\">is_function</span><span class=\"params\">(Pred, <span class=\"number\">1</span>)</span> -&gt;</span> [].</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"ukeymerge/3\">ukeymerge/3</h3><blockquote>\n<p>ukeymerge(N, TupleList1, TupleList2) -&gt; TupleList3</p>\n</blockquote>\n<p>类似于keymerge,但是u的意思是unique的意思,就是当TupleList1和TupleList2中有相同key的Tuple时将会删掉TupleList2中的Tuple.而且要求TupleList1和TupleList2在执行函数前自己本身不含有相同key的Tuple,否则结果会只删除一个TupleLIst2中的Tuple.结果不如人意.<br>例子:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>&gt; lists:ukeymerge(<span class=\"number\">2</span>,[&#123;<span class=\"number\">1</span>,<span class=\"number\">10</span>&#125;,&#123;<span class=\"number\">2</span>,<span class=\"number\">20</span>&#125;,&#123;<span class=\"number\">5</span>,<span class=\"number\">50</span>&#125;],[&#123;<span class=\"number\">2</span>,<span class=\"number\">20</span>&#125;,&#123;<span class=\"number\">4</span>,<span class=\"number\">40</span>&#125;]).</span><br><span class=\"line\">[&#123;<span class=\"number\">1</span>,<span class=\"number\">10</span>&#125;,&#123;<span class=\"number\">2</span>,<span class=\"number\">20</span>&#125;,&#123;<span class=\"number\">4</span>,<span class=\"number\">40</span>&#125;,&#123;<span class=\"number\">5</span>,<span class=\"number\">50</span>&#125;]</span><br><span class=\"line\"><span class=\"number\">2</span>&gt; lists:keymerge(<span class=\"number\">2</span>,[&#123;<span class=\"number\">1</span>,<span class=\"number\">10</span>&#125;,&#123;<span class=\"number\">2</span>,<span class=\"number\">20</span>&#125;,&#123;<span class=\"number\">5</span>,<span class=\"number\">50</span>&#125;],[&#123;<span class=\"number\">2</span>,<span class=\"number\">20</span>&#125;,&#123;<span class=\"number\">4</span>,<span class=\"number\">40</span>&#125;]). </span><br><span class=\"line\">[&#123;<span class=\"number\">1</span>,<span class=\"number\">10</span>&#125;,&#123;<span class=\"number\">2</span>,<span class=\"number\">20</span>&#125;,&#123;<span class=\"number\">2</span>,<span class=\"number\">20</span>&#125;,&#123;<span class=\"number\">4</span>,<span class=\"number\">40</span>&#125;,&#123;<span class=\"number\">5</span>,<span class=\"number\">50</span>&#125;]</span><br><span class=\"line\"><span class=\"number\">3</span>&gt; lists:ukeymerge(<span class=\"number\">2</span>,[&#123;<span class=\"number\">1</span>,<span class=\"number\">10</span>&#125;,&#123;<span class=\"number\">2</span>,<span class=\"number\">20</span>&#125;,&#123;<span class=\"number\">5</span>,<span class=\"number\">50</span>&#125;],[&#123;<span class=\"number\">2</span>,<span class=\"number\">20</span>&#125;,&#123;<span class=\"number\">3</span>,<span class=\"number\">20</span>&#125;,&#123;<span class=\"number\">4</span>,<span class=\"number\">40</span>&#125;]).</span><br><span class=\"line\">[&#123;<span class=\"number\">1</span>,<span class=\"number\">10</span>&#125;,&#123;<span class=\"number\">2</span>,<span class=\"number\">20</span>&#125;,&#123;<span class=\"number\">3</span>,<span class=\"number\">20</span>&#125;,&#123;<span class=\"number\">4</span>,<span class=\"number\">40</span>&#125;,&#123;<span class=\"number\">5</span>,<span class=\"number\">50</span>&#125;]</span><br><span class=\"line\"><span class=\"number\">4</span>&gt; lists:ukeymerge(<span class=\"number\">2</span>,[&#123;<span class=\"number\">1</span>,<span class=\"number\">10</span>&#125;,&#123;<span class=\"number\">2</span>,<span class=\"number\">20</span>&#125;,&#123;<span class=\"number\">5</span>,<span class=\"number\">50</span>&#125;],[&#123;<span class=\"number\">2</span>,<span class=\"number\">20</span>&#125;,&#123;<span class=\"number\">2</span>,<span class=\"number\">20</span>&#125;,&#123;<span class=\"number\">4</span>,<span class=\"number\">40</span>&#125;]).</span><br><span class=\"line\">[&#123;<span class=\"number\">1</span>,<span class=\"number\">10</span>&#125;,&#123;<span class=\"number\">2</span>,<span class=\"number\">20</span>&#125;,&#123;<span class=\"number\">2</span>,<span class=\"number\">20</span>&#125;,&#123;<span class=\"number\">4</span>,<span class=\"number\">40</span>&#125;,&#123;<span class=\"number\">5</span>,<span class=\"number\">50</span>&#125;]</span><br></pre></td></tr></table></figure></p>\n<p>可以看到keymerge和ukeymerge的差别,而且第3行是在TupleList2中有相同Key的Tuple,倒是结果中也有相同的key,这时因为只删除了第一个与TupleList1中相同的Tuple即{2, 20}.<br>源码不贴了,凡是根merge有关的,都复杂而且长..</p>\n<h3 id=\"ukeysort/2\">ukeysort/2</h3><blockquote>\n<p>ukeysort(N, TupleList1) -&gt; TupleList2</p>\n</blockquote>\n<p>与keysort差不多,同样u也是唯一的意思,只保留一个keyTuple,如以下例子:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">5</span>&gt; lists:ukeysort(<span class=\"number\">2</span>, [&#123;<span class=\"number\">1</span>,<span class=\"number\">10</span>&#125;,&#123;<span class=\"number\">3</span>,<span class=\"number\">30</span>&#125;,&#123;<span class=\"number\">4</span>,<span class=\"number\">40</span>&#125;,&#123;<span class=\"number\">2</span>,<span class=\"number\">20</span>&#125;,&#123;<span class=\"number\">5</span>,<span class=\"number\">20</span>&#125;]).         </span><br><span class=\"line\">[&#123;<span class=\"number\">1</span>,<span class=\"number\">10</span>&#125;,&#123;<span class=\"number\">2</span>,<span class=\"number\">20</span>&#125;,&#123;<span class=\"number\">3</span>,<span class=\"number\">30</span>&#125;,&#123;<span class=\"number\">4</span>,<span class=\"number\">40</span>&#125;]</span><br><span class=\"line\"><span class=\"number\">6</span>&gt; lists:keysort(<span class=\"number\">2</span>, [&#123;<span class=\"number\">1</span>,<span class=\"number\">10</span>&#125;,&#123;<span class=\"number\">3</span>,<span class=\"number\">30</span>&#125;,&#123;<span class=\"number\">4</span>,<span class=\"number\">40</span>&#125;,&#123;<span class=\"number\">2</span>,<span class=\"number\">20</span>&#125;,&#123;<span class=\"number\">5</span>,<span class=\"number\">20</span>&#125;]). </span><br><span class=\"line\">[&#123;<span class=\"number\">1</span>,<span class=\"number\">10</span>&#125;,&#123;<span class=\"number\">2</span>,<span class=\"number\">20</span>&#125;,&#123;<span class=\"number\">5</span>,<span class=\"number\">20</span>&#125;,&#123;<span class=\"number\">3</span>,<span class=\"number\">30</span>&#125;,&#123;<span class=\"number\">4</span>,<span class=\"number\">40</span>&#125;]</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"umerge/1/2/3以及_umerge3/3\">umerge/1/2/3以及 umerge3/3</h3><p>参加merge,只不过只保留一个相同的key.</p>\n<h3 id=\"uzip/1以及uzip3/1\">uzip/1以及uzip3/1</h3><blockquote>\n<p>unzip(List1) -&gt; {List2, List3}<br>unzip3(List1) -&gt; {List2, List3, List4}</p>\n</blockquote>\n<p>用于分离TupleList中的每个Tuple的第一个元素进入List2,第二个元素进入List3.unzip3适用于3-Tuple的情况.<br>例子:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">7</span>&gt; lists:unzip([&#123;<span class=\"number\">10210221</span>, fubowen&#125;,&#123;<span class=\"number\">10210222</span>, yuyouqi&#125;, &#123;<span class=\"number\">10201223</span>, xuyue&#125;]).</span><br><span class=\"line\">&#123;[<span class=\"number\">10210221</span>,<span class=\"number\">10210222</span>,<span class=\"number\">10201223</span>],[fubowen,yuyouqi,xuyue]&#125;</span><br><span class=\"line\"><span class=\"number\">8</span>&gt; lists:unzip3([&#123;<span class=\"number\">10210221</span>, fubowen, <span class=\"number\">1</span>&#125;,&#123;<span class=\"number\">10210222</span>, yuyouqi, <span class=\"number\">1</span>&#125;, &#123;<span class=\"number\">102101001</span>, aya, <span class=\"number\">0</span>&#125;]).</span><br><span class=\"line\">&#123;[<span class=\"number\">10210221</span>,<span class=\"number\">10210222</span>,<span class=\"number\">102101001</span>],</span><br><span class=\"line\"> [fubowen,yuyouqi,aya],</span><br><span class=\"line\"> [<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>]&#125;</span><br></pre></td></tr></table></figure><br>源码:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">unzip</span><span class=\"params\">(Ts)</span> -&gt;</span> unzip(Ts, [], []).</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">unzip</span><span class=\"params\">([&#123;X, Y&#125; | Ts], Xs, Ys)</span> -&gt;</span> unzip(Ts, [X | Xs], [Y | Ys]);</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">unzip</span><span class=\"params\">([], Xs, Ys)</span> -&gt;</span> &#123;reverse(Xs), reverse(Ys)&#125;.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">unzip3</span><span class=\"params\">(Ts)</span> -&gt;</span> unzip3(Ts, [], [], []).</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">unzip3</span><span class=\"params\">([&#123;X, Y, Z&#125; | Ts], Xs, Ys, Zs)</span> -&gt;</span></span><br><span class=\"line\">    unzip3(Ts, [X | Xs], [Y | Ys], [Z | Zs]);</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">unzip3</span><span class=\"params\">([], Xs, Ys, Zs)</span> -&gt;</span></span><br><span class=\"line\">    &#123;reverse(Xs), reverse(Ys), reverse(Zs)&#125;.</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"zip/2以及zip3/3\">zip/2以及zip3/3</h3><blockquote>\n<p>zip(List1, List2) -&gt; List3<br>zip3(List1, List2, List3) -&gt; List4</p>\n</blockquote>\n<p>就是unzip的反过程.</p>\n<h3 id=\"usort/1和usort/2\">usort/1和usort/2</h3><blockquote>\n<p>usort(List1) -&gt; List2<br>usort(Fun, List1) -&gt; List2</p>\n</blockquote>\n<p>见sort,只不过只保留一个相同的值.<br>例子:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">10</span>&gt; lists:usort([<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">2</span>,<span class=\"number\">5</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>]).</span><br><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>]</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"zipwith/3以及zipwith3/4\">zipwith/3以及zipwith3/4</h3><blockquote>\n<p>zipwith(Combine, List1, List2) -&gt; List3<br>zipwith3(Combine, List1, List2, List3) -&gt; List4</p>\n</blockquote>\n<p>功能大致同zip/2,zip3/3相同,只不过多了个Combine Function,这个Combine决定了如何合并.<br>例子:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">11</span>&gt; lists:zipwith(<span class=\"keyword\">fun</span>(X,Y) -&gt; X+Y <span class=\"keyword\">end</span>, [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>], [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]).</span><br><span class=\"line\">[<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>]</span><br></pre></td></tr></table></figure></p>\n<p>至此,lists模块的函数全都介绍完毕,啊,好累,休息会.</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>个人感觉erlang里面lists模块用的地方非常多,因为erlang中没有for循环,很多函数功能多是靠lists的map,filter或者列表解析完成的,所以lists里面的函数非常重要</p>\n</blockquote>","more":"<!-- toc -->\n<ul>\n<li><a href=\"#all-2\">all/2</a></li>\n<li><a href=\"#any-2\">any/2</a></li>\n<li><a href=\"#append-1\">append/1</a></li>\n<li><a href=\"#append-2\">append/2</a></li>\n<li><a href=\"#concat-1\">concat/1</a></li>\n<li><a href=\"#delete-2\">delete/2</a></li>\n<li><a href=\"#dropwhile-2\">dropwhile/2</a></li>\n<li><a href=\"#duplicate-2\">duplicate/2</a></li>\n<li><a href=\"#filter-2\">filter/2</a></li>\n<li><a href=\"#flatlength-1\">flatlength/1</a></li>\n<li><a href=\"#flatten-1\">flatten/1</a></li>\n<li><a href=\"#flatten-2\">flatten/2</a></li>\n<li><a href=\"#flatmap-2\">flatmap/2</a></li>\n<li><a href=\"#foldl-3\">foldl/3</a></li>\n<li><a href=\"#foldr-3\">foldr/3</a></li>\n<li><a href=\"#map-2\">map/2</a></li>\n<li><a href=\"#foreach-2\">foreach/2</a></li>\n<li><a href=\"#keydelete-3\">keydelete/3</a></li>\n<li><a href=\"#keyfind-3\">keyfind/3</a></li>\n<li><a href=\"#keyserach-3\">keyserach/3</a></li>\n<li><a href=\"#keymember-3\">keymember/3</a></li>\n<li><a href=\"#keymap-3\">keymap/3</a></li>\n<li><a href=\"#keymerge-3\">keymerge/3</a></li>\n<li><a href=\"#keyreplace-4\">keyreplace/4</a></li>\n<li><a href=\"#keysort-2\">keysort/2</a></li>\n<li><a href=\"#keystore-4\">keystore/4</a></li>\n<li><a href=\"#keytake-3\">keytake/3</a></li>\n<li><a href=\"#last-1\">last/1</a></li>\n<li><a href=\"#mapfoldl-3\">mapfoldl/3</a></li>\n<li><a href=\"#mapfoldr-3\">mapfoldr/3</a></li>\n<li><a href=\"#max-1\">max/1</a></li>\n<li><a href=\"#member-2\">member/2</a></li>\n<li><a href=\"#merge-1-2-3--merge3-3\">merge/1/2/3以及merge3/3</a></li>\n<li><a href=\"#min-1\">min/1</a></li>\n<li><a href=\"#nth-2\">nth/2</a></li>\n<li><a href=\"#nthtail-2\">nthtail/2</a></li>\n<li><a href=\"#partition-2\">partition/2</a></li>\n<li><a href=\"#prefix-2\">prefix/2</a></li>\n<li><a href=\"#reverse-1-2\">reverse/1/2</a></li>\n<li><a href=\"#seq-2-3\">seq/2/3</a></li>\n<li><a href=\"#sort-1-2\">sort/1/2</a></li>\n<li><a href=\"#split-2\">split/2</a></li>\n<li><a href=\"#splitwith-2\">splitwith/2</a></li>\n<li><a href=\"#sublist-2-3\">sublist/2/3</a></li>\n<li><a href=\"#subtract-2\">subtract/2</a></li>\n<li><a href=\"#suffix-2\">suffix/2</a></li>\n<li><a href=\"#sum-1\">sum/1</a></li>\n<li><a href=\"#takewhile-2\">takewhile/2</a></li>\n<li><a href=\"#ukeymerge-3\">ukeymerge/3</a></li>\n<li><a href=\"#ukeysort-2\">ukeysort/2</a></li>\n<li><a href=\"#umerge-1-2-3---umerge3-3\">umerge/1/2/3以及 umerge3/3</a></li>\n<li><a href=\"#uzip-1--uzip3-1\">uzip/1以及uzip3/1</a></li>\n<li><a href=\"#zip-2--zip3-3\">zip/2以及zip3/3</a></li>\n<li><a href=\"#usort-1-usort-2\">usort/1和usort/2</a></li>\n<li><a href=\"#zipwith-3--zipwith3-4\">zipwith/3以及zipwith3/4</a></li>\n</ul>\n<!-- tocstop -->\n<h3 id=\"all/2\">all/2</h3><blockquote>\n<p>all(Func, List) -&gt; boolean()</p>\n</blockquote>\n<p>如果全员执行Func都返回true,则这个表达式返回true,否则返回false.</p>\n<figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2</span>&gt; lists:all(<span class=\"keyword\">fun</span>(X) -&gt; is_integer(X) <span class=\"keyword\">end</span>, [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]).</span><br><span class=\"line\"><span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"number\">3</span>&gt; lists:all(<span class=\"keyword\">fun</span>(X) -&gt; is_integer(X) <span class=\"keyword\">end</span>, [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"string\">&quot;haha&quot;</span>,<span class=\"number\">4</span>]).</span><br><span class=\"line\"><span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"any/2\">any/2</h3><blockquote>\n<p>any(Pred, List) -&gt; boolean()</p>\n</blockquote>\n<p>与all大致相同,如果有任意一个List中的元素返回true,则any返回true.</p>\n<h3 id=\"append/1\">append/1</h3><blockquote>\n<p>append(ListOfLists) -&gt; List1</p>\n</blockquote>\n<p>用于合并子列表,列表中元素最起码要有一层深度,而且append只能去掉一层的深度,如果子元素没有深度,就会抛错<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">5</span>&gt; lists:append([[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>],[<span class=\"number\">2</span>,<span class=\"number\">3</span>],[<span class=\"number\">1</span>],[<span class=\"number\">2</span>]]).</span><br><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>]</span><br><span class=\"line\"><span class=\"number\">7</span>&gt; lists:append([[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>],[<span class=\"number\">2</span>,<span class=\"number\">3</span>],[<span class=\"number\">1</span>],[[<span class=\"number\">1</span>,[<span class=\"number\">3</span>,<span class=\"number\">2</span>]],<span class=\"number\">2</span>]]).</span><br><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">1</span>,[<span class=\"number\">1</span>,[<span class=\"number\">3</span>,<span class=\"number\">2</span>]],<span class=\"number\">2</span>]</span><br><span class=\"line\"><span class=\"number\">8</span>&gt; lists:append([<span class=\"number\">1</span>,[<span class=\"number\">2</span>,<span class=\"number\">3</span>],[<span class=\"number\">3</span>]]).</span><br><span class=\"line\">** exception error: bad argument</span><br><span class=\"line\">     in operator  ++/<span class=\"number\">2</span></span><br><span class=\"line\">        called as <span class=\"number\">1</span> ++ [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">     in call from lists:append/<span class=\"number\">1</span> (lists.erl, line <span class=\"number\">74</span>)</span><br></pre></td></tr></table></figure></p>\n<p>因为在append的源码是:</p>\n<blockquote>\n<p>73 append([E]) -&gt; E;<br>  74 append([H|T]) -&gt; H ++ append(T);<br>  75 append([]) -&gt; []. </p>\n</blockquote>\n<p>所以上面说 <code>++</code>附近出错,因为1不是列表.</p>\n<h3 id=\"append/2\">append/2</h3><blockquote>\n<p>append(List1, List2) -&gt; List3</p>\n</blockquote>\n<p>源码</p>\n<blockquote>\n<p> append(L1, L2) -&gt; L1 ++ L2.</p>\n</blockquote>\n<p>用于合并两个列表,其实append实质就是++,所以需要注意效率,因为++是将左边的列表都一遍,因此在递归中要始终保持左边的列表要是最短的那个.<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">9</span>&gt; lists:append(<span class=\"string\">&quot;haha&quot;</span>,<span class=\"string\">&quot;heihei&quot;</span>).</span><br><span class=\"line\"><span class=\"string\">&quot;hahaheihei&quot;</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"concat/1\">concat/1</h3><blockquote>\n<p>concat([Things]) -&gt; string()</p>\n</blockquote>\n<p>Things可以使integer,float,atom,string, concat将他们转换成一个字符串,如果Things中含有list,可能会整体装换成list.<br>例如<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10&gt; lists:concat([&quot;haha&quot;,[1],3,3.14,atom]).</span><br><span class=\"line\">[104,97,104,97,1,51,51,46,49,52,48,48,48,48,48,48,48,48,48,</span><br><span class=\"line\"> 48,48,48,48,49,50,52,51,52,101|...]</span><br><span class=\"line\">11&gt; lists:concat([&quot;haha&quot;,3,3.14,atom]).    </span><br><span class=\"line\">&quot;haha33.14000000000000012434e+00atom&quot;</span><br></pre></td></tr></table></figure><br>源码:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">concat</span><span class=\"params\">(List)</span> -&gt;</span></span><br><span class=\"line\">    flatmap(fun thing_to_list/1, List).</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">thing_to_list</span><span class=\"params\">(X)</span> <span class=\"title\">when</span> <span class=\"title\">is_integer</span><span class=\"params\">(X)</span> -&gt;</span> integer_to_list(X);</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">thing_to_list</span><span class=\"params\">(X)</span> <span class=\"title\">when</span> <span class=\"title\">is_float</span><span class=\"params\">(X)</span>   -&gt;</span> float_to_list(X);</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">thing_to_list</span><span class=\"params\">(X)</span> <span class=\"title\">when</span> <span class=\"title\">is_atom</span><span class=\"params\">(X)</span>    -&gt;</span> atom_to_list(X);</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">thing_to_list</span><span class=\"params\">(X)</span> <span class=\"title\">when</span> <span class=\"title\">is_list</span><span class=\"params\">(X)</span>    -&gt;</span> X.\t<span class=\"comment\">%Assumed to be a string</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"delete/2\">delete/2</h3><blockquote>\n<p>delete(Elem, List) -&gt; List1</p>\n</blockquote>\n<p>删除List中第一个等于Elem的元素,返回一个新的list<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">12&gt; lists:delete(1,[1,2,1,3,4]).</span><br><span class=\"line\">[2,1,3,4]</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"dropwhile/2\">dropwhile/2</h3><blockquote>\n<p>dropwhile(Func, List) -&gt; List1</p>\n</blockquote>\n<p>从左边开始去掉List中Func返回值为true的元素,遇到第一个返回false的元素时终止,并返回剩下列表.<br>例子:<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">16&gt; lists:dropwhile(fun(X) -&gt; X rem 2 =:= 0  end, [2,4,3,5,6]).  </span><br><span class=\"line\">[3,5,6]</span><br></pre></td></tr></table></figure><br>源码实现:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">dropwhile</span><span class=\"params\">(Pred, [Hd|Tail]=Rest)</span> -&gt;</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> Pred(Hd) <span class=\"keyword\">of</span></span><br><span class=\"line\">\t<span class=\"literal\">true</span> -&gt; dropwhile(Pred, Tail);</span><br><span class=\"line\">\t<span class=\"literal\">false</span> -&gt; Rest</span><br><span class=\"line\">    <span class=\"keyword\">end</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">dropwhile</span><span class=\"params\">(Pred, [])</span> <span class=\"title\">when</span> <span class=\"title\">is_function</span><span class=\"params\">(Pred, <span class=\"number\">1</span>)</span> -&gt;</span> [].</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"duplicate/2\">duplicate/2</h3><blockquote>\n<p>duplicate(N, Elem) -&gt; List.</p>\n</blockquote>\n<p>生成N个Elem的列表.N不能使负数.原因可以看源码<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">-spec</span> duplicate<span class=\"params\">(N, Elem)</span> -&gt; List when</span><br><span class=\"line\">      N :: non_neg_integer<span class=\"params\">()</span>,</span><br><span class=\"line\">      Elem :: T,</span><br><span class=\"line\">      List :: [T],</span><br><span class=\"line\">      T :: term<span class=\"params\">()</span>.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">duplicate</span><span class=\"params\">(N, X)</span> <span class=\"title\">when</span> <span class=\"title\">is_integer</span><span class=\"params\">(N)</span>, N &gt;= 0 -&gt;</span> duplicate(N, X, []).</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">duplicate</span><span class=\"params\">(<span class=\"number\">0</span>, _, L)</span> -&gt;</span> L;</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">duplicate</span><span class=\"params\">(N, X, L)</span> -&gt;</span> duplicate(N-<span class=\"number\">1</span>, X, [X|L]).</span><br></pre></td></tr></table></figure><br>原理就是用列表构造,没添加一个H,N就-1,终止条件就是直到N=0,如果是负数则无法终止,所以不能为负<br>例子:<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">17&gt; lists:duplicate(3,&quot;haha&quot;).</span><br><span class=\"line\">[&quot;haha&quot;,&quot;haha&quot;,&quot;haha&quot;]</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"filter/2\">filter/2</h3><blockquote>\n<p>filter(Func, List) -&gt; List1</p>\n</blockquote>\n<p>过滤器,返回列表,元素是List中所有Func返回值为true的元素.这个在工程中经常用.<br>源码<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">-spec</span> filter<span class=\"params\">(Pred, List1)</span> -&gt; List2 when</span><br><span class=\"line\">      Pred :: fun<span class=\"params\">((Elem :: T)</span> -&gt; boolean<span class=\"params\">()</span>),</span><br><span class=\"line\">      List1 :: [T],</span><br><span class=\"line\">      List2 :: [T],</span><br><span class=\"line\">      T :: term<span class=\"params\">()</span>.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">filter</span><span class=\"params\">(Pred, List)</span> <span class=\"title\">when</span> <span class=\"title\">is_function</span><span class=\"params\">(Pred, <span class=\"number\">1</span>)</span> -&gt;</span></span><br><span class=\"line\">    [ E || E &lt;- List, Pred(E) ].</span><br></pre></td></tr></table></figure><br>可以看到,filter内部其实就是用列表解析实现的.<br>例子:<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">19&gt; lists:filter(fun(X) -&gt; X rem 2 =:= 0 end, [2,4,3,5,6]).</span><br><span class=\"line\">[2,4,6]</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"flatlength/1\">flatlength/1</h3><blockquote>\n<p>flatlength(DeepList) -&gt; integer</p>\n</blockquote>\n<p>该函数返回一个深度列表的长度,如果是深度为1的列表可以直接用length(List)返回长度,<br>官方doc这么说的</p>\n<blockquote>\n<p>Equivalent to length(flatten(DeepList)), but more efficient.</p>\n</blockquote>\n<p>等同于深度列表扁平化后在length,但是这个做更搞笑,原因很简单,这个函数只不过计算长度,并没有将列表扁平化<br>源码<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">-spec</span> flatlength<span class=\"params\">(DeepList)</span> -&gt; non_neg_integer<span class=\"params\">()</span> when</span><br><span class=\"line\">      DeepList :: [term<span class=\"params\">()</span> | DeepList].</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">flatlength</span><span class=\"params\">(List)</span> -&gt;</span></span><br><span class=\"line\">    flatlength(List, <span class=\"number\">0</span>).</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">flatlength</span><span class=\"params\">([H|T], L)</span> <span class=\"title\">when</span> <span class=\"title\">is_list</span><span class=\"params\">(H)</span> -&gt;</span></span><br><span class=\"line\">    flatlength(H, flatlength(T, L));</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">flatlength</span><span class=\"params\">([_|T], L)</span> -&gt;</span></span><br><span class=\"line\">    flatlength(T, L + <span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">flatlength</span><span class=\"params\">([], L)</span> -&gt;</span> L.</span><br></pre></td></tr></table></figure><br>例子:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; lists:flatlength([<span class=\"number\">1</span>,[<span class=\"number\">2</span>,[<span class=\"number\">3</span>],<span class=\"number\">4</span>,[<span class=\"number\">5</span>],<span class=\"number\">6</span>],[<span class=\"number\">7</span>,<span class=\"number\">8</span>]]).</span><br><span class=\"line\"><span class=\"number\">8</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"flatten/1\">flatten/1</h3><blockquote>\n<p>flatten(Deeplist) -&gt; List</p>\n</blockquote>\n<p>上面提到的flatten函数,用于扁平化一个深度列表,尽量少用,代价很高,甚至比++操作代价还高<br>源码<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">-spec</span> flatten<span class=\"params\">(DeepList)</span> -&gt; List when</span><br><span class=\"line\">      DeepList :: [term<span class=\"params\">()</span> | DeepList],</span><br><span class=\"line\">      List :: [term<span class=\"params\">()</span>].</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">flatten</span><span class=\"params\">(List)</span> <span class=\"title\">when</span> <span class=\"title\">is_list</span><span class=\"params\">(List)</span> -&gt;</span></span><br><span class=\"line\">    do_flatten(List, []).</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">-spec</span> flatten<span class=\"params\">(DeepList, Tail)</span> -&gt; List when</span><br><span class=\"line\">      DeepList :: [term<span class=\"params\">()</span> | DeepList],</span><br><span class=\"line\">      Tail :: [term<span class=\"params\">()</span>],</span><br><span class=\"line\">      List :: [term<span class=\"params\">()</span>].</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">flatten</span><span class=\"params\">(List, Tail)</span> <span class=\"title\">when</span> <span class=\"title\">is_list</span><span class=\"params\">(List)</span>, <span class=\"title\">is_list</span><span class=\"params\">(Tail)</span> -&gt;</span></span><br><span class=\"line\">    do_flatten(List, Tail).</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">do_flatten</span><span class=\"params\">([H|T], Tail)</span> <span class=\"title\">when</span> <span class=\"title\">is_list</span><span class=\"params\">(H)</span> -&gt;</span></span><br><span class=\"line\">    do_flatten(H, do_flatten(T, Tail));</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">do_flatten</span><span class=\"params\">([H|T], Tail)</span> -&gt;</span></span><br><span class=\"line\">    [H|do_flatten(T, Tail)];</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">do_flatten</span><span class=\"params\">([], Tail)</span> -&gt;</span></span><br><span class=\"line\">    Tail.</span><br></pre></td></tr></table></figure></p>\n<p>在递归中为了伪递归,如果第一个元素是list就递归调用do_flatten,如果不是就用构造器放在新列表的头,剩下的部分继续调用do_flatten.<br><strong>关于flatten的效率问题</strong><br>在官方doc的efficiency guide中有专门一块Deep and flat lists,<br>原文这么说</p>\n<blockquote>\n<p>lists:flatten/1 builds an entirely new list. Therefore, it is expensive, and even more expensive than the ++ (which copies its left argument, but not its right argument).<br>In the following situations, you can easily avoid calling lists:flatten/1:</p>\n<ol>\n<li>When sending data to a port. Ports understand deep lists so there is no reason to flatten the list before sending it to the port.</li>\n<li>When calling BIFs that accept deep lists, such as list_to_binary/1 or iolist_to_binary/1.</li>\n<li>When you know that your list is only one level deep, you can can use lists:append/1.</li>\n</ol>\n</blockquote>\n<p>因为flatten是完全重建一个列表,甚至比++(复制左边,而右边保留)更为低效,但是有3种情况可以不适用flatten</p>\n<ol>\n<li>往端口发送数据时,因为端口懂得深度列表</li>\n<li>诸如<code>list_to_binary</code>和<code>iolist_to_binary</code>的BIF,不需要扁平化<figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; list_to_binary([<span class=\"number\">1</span>,[<span class=\"number\">2</span>,[<span class=\"number\">3</span>,<span class=\"number\">4</span>]],<span class=\"number\">5</span>]).</span><br><span class=\"line\">&lt;&lt;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&gt;&gt;</span><br></pre></td></tr></table></figure></li>\n<li>如果我们知道列表深度只有一层,要用append代替flatten</li>\n</ol>\n<h3 id=\"flatten/2\">flatten/2</h3><blockquote>\n<p>flatten(DeepList, Tail) -&gt; List.</p>\n</blockquote>\n<p>就是上面flatten/1调用的子函数,flatten(DeepList) 就是flatten(DeepList, []).<br>函数在DeepList扁平化后append了一下Tail.<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">27</span>&gt; lists:flatten([<span class=\"number\">1</span>,[<span class=\"number\">3</span>,[<span class=\"number\">4</span>,<span class=\"number\">5</span>],<span class=\"number\">2</span>]],[<span class=\"number\">1</span>,[<span class=\"number\">2</span>,[<span class=\"number\">3</span>]]]).</span><br><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>,[<span class=\"number\">2</span>,[<span class=\"number\">3</span>]]]</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"flatmap/2\">flatmap/2</h3><blockquote>\n<p>flatmap(Func, List1) -&gt; List2</p>\n</blockquote>\n<p>官方的说法是</p>\n<blockquote>\n<p>That is, flatmap behaves as if it had been defined as follows:<br>flatmap(Fun, List1) -&gt;<br>    append(map(Fun, List1)).</p>\n</blockquote>\n<p>就是List1中每个元素执行Fun,一般Fun返回一个列表,最后将这些列表append一下.<br>例子:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">26</span>&gt; lists:flatmap(<span class=\"keyword\">fun</span>(X) -&gt; [X, X+<span class=\"number\">1</span>] <span class=\"keyword\">end</span>, [<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>]).</span><br><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>]</span><br></pre></td></tr></table></figure><br>源码:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">-spec</span> flatmap<span class=\"params\">(Fun, List1)</span> -&gt; List2 when</span><br><span class=\"line\">      Fun :: fun<span class=\"params\">((A)</span> -&gt; [B]),</span><br><span class=\"line\">      List1 :: [A],</span><br><span class=\"line\">      List2 :: [B],</span><br><span class=\"line\">      A :: term<span class=\"params\">()</span>,</span><br><span class=\"line\">      B :: term<span class=\"params\">()</span>.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">flatmap</span><span class=\"params\">(F, [Hd|Tail])</span> -&gt;</span></span><br><span class=\"line\">    F(Hd) ++ flatmap(F, Tail);</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">flatmap</span><span class=\"params\">(F, [])</span> <span class=\"title\">when</span> <span class=\"title\">is_function</span><span class=\"params\">(F, <span class=\"number\">1</span>)</span> -&gt;</span> [].</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"foldl/3\">foldl/3</h3><blockquote>\n<p>foldl(Fun, Acc0, List) -&gt; Acc1</p>\n</blockquote>\n<p>这个函数用的非常多,Fun是一个可接受2个参数的函数,例如fun(X, Sum) -&gt; X + Sum end.那么List中的第一个元素带入X,然后Acc0带入Sum,执行得结果Acc1,然后将List中第二个元素带入X,将Acc1带入Sum,以此类推,每回fun的第二个参数是上把的结果,第一个元素是List中的元素.下面例子是一个累加函数<br>例子:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">28</span>&gt; lists:foldl(<span class=\"keyword\">fun</span>(X, Sum) -&gt; X + Sum <span class=\"keyword\">end</span>, <span class=\"number\">0</span>, [<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">6</span>,<span class=\"number\">8</span>,<span class=\"number\">10</span>]).</span><br><span class=\"line\"><span class=\"number\">30</span></span><br></pre></td></tr></table></figure><br>源码:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">-spec</span> foldl<span class=\"params\">(Fun, Acc0, List)</span> -&gt; Acc1 when</span><br><span class=\"line\">      Fun :: fun<span class=\"params\">((Elem :: T, AccIn)</span> -&gt; AccOut),</span><br><span class=\"line\">      Acc0 :: term<span class=\"params\">()</span>,</span><br><span class=\"line\">      Acc1 :: term<span class=\"params\">()</span>,</span><br><span class=\"line\">      AccIn :: term<span class=\"params\">()</span>,</span><br><span class=\"line\">      AccOut :: term<span class=\"params\">()</span>,</span><br><span class=\"line\">      List :: [T],</span><br><span class=\"line\">      T :: term<span class=\"params\">()</span>.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">foldl</span><span class=\"params\">(F, Accu, [Hd|Tail])</span> -&gt;</span></span><br><span class=\"line\">    foldl(F, F(Hd, Accu), Tail);</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">foldl</span><span class=\"params\">(F, Accu, [])</span> <span class=\"title\">when</span> <span class=\"title\">is_function</span><span class=\"params\">(F, <span class=\"number\">2</span>)</span> -&gt;</span> Accu.</span><br></pre></td></tr></table></figure></p>\n<p>上面可以看到foldl的第二个参数就是F(Hd, Accu)的返回结果.</p>\n<h3 id=\"foldr/3\">foldr/3</h3><p>不说了,跟上面一样,只不过是从右边开始带入.</p>\n<h3 id=\"map/2\">map/2</h3><blockquote>\n<p>map(Fun, List1) -&gt; List2</p>\n</blockquote>\n<p>返回List1中每个元素执行Fun后的结果列表,官方doc上说执行顺序是运行时决定,这个和下面说的foreach不一样.<br>例子:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">34</span>&gt; lists:map(<span class=\"keyword\">fun</span>(X) -&gt; X*<span class=\"number\">2</span> <span class=\"keyword\">end</span>, [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>]).            </span><br><span class=\"line\">[<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">6</span>,<span class=\"number\">8</span>,<span class=\"number\">10</span>]</span><br></pre></td></tr></table></figure><br>源码:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">map</span><span class=\"params\">(F, [H|T])</span> -&gt;</span></span><br><span class=\"line\">    [F(H)|map(F, T)];</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">map</span><span class=\"params\">(F, [])</span> <span class=\"title\">when</span> <span class=\"title\">is_function</span><span class=\"params\">(F, <span class=\"number\">1</span>)</span> -&gt;</span> [].</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"foreach/2\">foreach/2</h3><blockquote>\n<p>foreach(Fun, List1) -&gt; ok.</p>\n</blockquote>\n<p>该函数和map很像,区别就是foreach只执行Fun函数却不保存结果,最后返回ok.<br>源码:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">foreach</span><span class=\"params\">(F, [Hd|Tail])</span> -&gt;</span></span><br><span class=\"line\">    F(Hd),</span><br><span class=\"line\">    foreach(F, Tail);</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">foreach</span><span class=\"params\">(F, [])</span> <span class=\"title\">when</span> <span class=\"title\">is_function</span><span class=\"params\">(F, <span class=\"number\">1</span>)</span> -&gt;</span> ok.</span><br></pre></td></tr></table></figure></p>\n<p>这里和map不同的是foreach的递归在执行完前一个元素的Fun函数后才会继续执行一下个元素的Fun函数,这里的执行顺序就是列表的顺序,官方doc上说:<code>this function is used for its side effects</code><br>我不是很理解具体有什么用...</p>\n<h3 id=\"keydelete/3\">keydelete/3</h3><blockquote>\n<p>keydelete(Key, N, TupleList) -&gt; TupleList1</p>\n</blockquote>\n<p>主要用于由{}tuple 组成的列表,删除Tuplelist中第一个第N个位置的值等于Key的tuple,N是tuple中key应该匹配的位置.这个也经常用,比如一个地图中存了{PlayerId, name, str, magic...}之类的tuplelist,如果玩家离开地图,可以让Key为PlayerId,然后keydelete这个玩家的信息,因为PlayerId一般都是唯一的.<br>例子:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">37</span>&gt; lists:keydelete(<span class=\"number\">2010211108</span>, <span class=\"number\">1</span>, [&#123;<span class=\"number\">2010211105</span>, sice, <span class=\"number\">5</span>&#125;,&#123;<span class=\"number\">2010211106</span>, sice, <span class=\"number\">6</span>&#125;,&#123;<span class=\"number\">2010211107</span>, sice, <span class=\"number\">7</span>&#125;,&#123;<span class=\"number\">2010211108</span>, <span class=\"number\">8</span>&#125;]).</span><br><span class=\"line\">[&#123;<span class=\"number\">2010211105</span>,sice,<span class=\"number\">5</span>&#125;,</span><br><span class=\"line\"> &#123;<span class=\"number\">2010211106</span>,sice,<span class=\"number\">6</span>&#125;,</span><br><span class=\"line\"> &#123;<span class=\"number\">2010211107</span>,sice,<span class=\"number\">7</span>&#125;]</span><br></pre></td></tr></table></figure><br>源码:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">keydelete</span><span class=\"params\">(K, N, L)</span> <span class=\"title\">when</span> <span class=\"title\">is_integer</span><span class=\"params\">(N)</span>, N &gt; 0 -&gt;</span></span><br><span class=\"line\">    keydelete3(K, N, L).</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">keydelete3</span><span class=\"params\">(Key, N, [H|T])</span> <span class=\"title\">when</span> <span class=\"title\">element</span><span class=\"params\">(N, H)</span> == K<span class=\"title\">ey</span> -&gt;</span> T;</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">keydelete3</span><span class=\"params\">(Key, N, [H|T])</span> -&gt;</span></span><br><span class=\"line\">    [H|keydelete3(Key, N, T)];</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">keydelete3</span><span class=\"params\">(_, _, [])</span> -&gt;</span> [].</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"keyfind/3\">keyfind/3</h3><blockquote>\n<p>keyfind(Key, N, TupleList) -&gt; Tuple | false</p>\n</blockquote>\n<p>大致同上,如字面意思,只不过不delete掉,没找到会返回false,不过这个是BIF,也就是说用c写的,在lists模块看不到实现方法,BIF的效率一般都很高.<br>例子:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">38</span>&gt; lists:keyfind(<span class=\"number\">2010211108</span>, <span class=\"number\">1</span>, [&#123;<span class=\"number\">2010211105</span>, sice, <span class=\"number\">5</span>&#125;,&#123;<span class=\"number\">2010211106</span>, sice, <span class=\"number\">6</span>&#125;,&#123;<span class=\"number\">2010211107</span>, sice, <span class=\"number\">7</span>&#125;]). </span><br><span class=\"line\"><span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"number\">39</span>&gt; lists:keyfind(<span class=\"number\">2010211106</span>, <span class=\"number\">1</span>, [&#123;<span class=\"number\">2010211105</span>, sice, <span class=\"number\">5</span>&#125;,&#123;<span class=\"number\">2010211106</span>, sice, <span class=\"number\">6</span>&#125;,&#123;<span class=\"number\">2010211107</span>, sice, <span class=\"number\">7</span>&#125;]).</span><br><span class=\"line\">&#123;<span class=\"number\">2010211106</span>,sice,<span class=\"number\">6</span>&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>BIF的源码可以把github上的<a href=\"https://github.com/erlang/otp\">erlang/otp</a>clone下来<br>然后在otp/erts/emulator/beam里面可以找到BIF的c代码,lists里面的BIF写在erl_bif_lists.c中<br>以下是keyfind的源码,以后的BIF代码就不贴了,感兴趣可以自己去找,不是那么好懂.</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">keyfind(<span class=\"keyword\">int</span> Bif, Process* p, Eterm Key, Eterm Pos, Eterm List)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> max_iter = <span class=\"number\">10</span> * CONTEXT_REDS;</span><br><span class=\"line\">    Sint pos;</span><br><span class=\"line\">    Eterm term;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!is_small(Pos) || (pos = signed_val(Pos)) &lt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">\tBIF_ERROR(p, BADARG);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (is_small(Key)) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">double</span> float_key = (<span class=\"keyword\">double</span>) signed_val(Key);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (is_list(List)) &#123;</span><br><span class=\"line\">\t    <span class=\"keyword\">if</span> (--max_iter &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\tBUMP_ALL_REDS(p);</span><br><span class=\"line\">\t\tBIF_TRAP3(bif_export[Bif], p, Key, Pos, List);</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t    term = CAR(list_val(List));</span><br><span class=\"line\">\t    List = CDR(list_val(List));</span><br><span class=\"line\">\t    <span class=\"keyword\">if</span> (is_tuple(term)) &#123;</span><br><span class=\"line\">\t\tEterm *tuple_ptr = tuple_val(term);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (pos &lt;= arityval(*tuple_ptr)) &#123;</span><br><span class=\"line\">\t\t    Eterm element = tuple_ptr[pos];</span><br><span class=\"line\">\t\t    <span class=\"keyword\">if</span> (Key == element) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> term;</span><br><span class=\"line\">\t\t    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (is_float(element)) &#123;</span><br><span class=\"line\">\t\t\tFloatDef f;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tGET_DOUBLE(element, f);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (f.fd == float_key) &#123;</span><br><span class=\"line\">\t\t\t    <span class=\"keyword\">return</span> term;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t    &#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (is_immed(Key)) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (is_list(List)) &#123;</span><br><span class=\"line\">\t    <span class=\"keyword\">if</span> (--max_iter &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\tBUMP_ALL_REDS(p);</span><br><span class=\"line\">\t\tBIF_TRAP3(bif_export[Bif], p, Key, Pos, List);</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t    term = CAR(list_val(List));</span><br><span class=\"line\">\t    List = CDR(list_val(List));</span><br><span class=\"line\">\t    <span class=\"keyword\">if</span> (is_tuple(term)) &#123;</span><br><span class=\"line\">\t\tEterm *tuple_ptr = tuple_val(term);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (pos &lt;= arityval(*tuple_ptr)) &#123;</span><br><span class=\"line\">\t\t    Eterm element = tuple_ptr[pos];</span><br><span class=\"line\">\t\t    <span class=\"keyword\">if</span> (Key == element) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> term;</span><br><span class=\"line\">\t\t    &#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (is_list(List)) &#123;</span><br><span class=\"line\">\t    <span class=\"keyword\">if</span> (--max_iter &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\tBUMP_ALL_REDS(p);</span><br><span class=\"line\">\t\tBIF_TRAP3(bif_export[Bif], p, Key, Pos, List);</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t    term = CAR(list_val(List));</span><br><span class=\"line\">\t    List = CDR(list_val(List));</span><br><span class=\"line\">\t    <span class=\"keyword\">if</span> (is_tuple(term)) &#123;</span><br><span class=\"line\">\t\tEterm *tuple_ptr = tuple_val(term);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (pos &lt;= arityval(*tuple_ptr)) &#123;</span><br><span class=\"line\">\t\t    Eterm element = tuple_ptr[pos];</span><br><span class=\"line\">\t\t    <span class=\"keyword\">if</span> (CMP(Key, element) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> term;</span><br><span class=\"line\">\t\t    &#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (is_not_nil(List))  &#123;</span><br><span class=\"line\">\tBIF_ERROR(p, BADARG);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> am_false;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>哎,跟这c代码比,还是erlang看起来舒服,简单.</p>\n<h3 id=\"keyserach/3\">keyserach/3</h3><blockquote>\n<p>keysearch(Key, N, TupleList) -&gt; {value, Tuple} | false</p>\n</blockquote>\n<p>与keyfind的功能相同,只不过返回值多了个value的标签,同样是BIF,lists.erl中没有源码,这个函数存在是为了向后兼容,keyfind用的更多些,但是keyfind是在R13B版本引入的,较老的版本用的是keysearch.</p>\n<h3 id=\"keymember/3\">keymember/3</h3><blockquote>\n<p>keymember(Key, N, Tuplelist) -&gt; boolean()</p>\n</blockquote>\n<p>功能和以上大致一样,也是BIF,只不过返回是true或false.</p>\n<h3 id=\"keymap/3\">keymap/3</h3><blockquote>\n<p>keymap(Fun, N, Tuplelist) -&gt; Tuplelist2</p>\n</blockquote>\n<p>用于将每个tuple的第N个元素替换为Fun(第N个元素)的执行结果.<br>例子:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">40</span>&gt; lists:keymap(<span class=\"keyword\">fun</span>(X) -&gt; atom_to_list(X) <span class=\"keyword\">end</span>, <span class=\"number\">2</span>, [&#123;<span class=\"number\">1</span>, john, boy&#125;,&#123;<span class=\"number\">2</span>, aya, girl&#125;, &#123;<span class=\"number\">3</span>, cameron, robot&#125;]).</span><br><span class=\"line\">[&#123;<span class=\"number\">1</span>,<span class=\"string\">&quot;john&quot;</span>,boy&#125;,&#123;<span class=\"number\">2</span>,<span class=\"string\">&quot;aya&quot;</span>,girl&#125;,&#123;<span class=\"number\">3</span>,<span class=\"string\">&quot;cameron&quot;</span>,robot&#125;]</span><br></pre></td></tr></table></figure><br>源码:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">keymap</span><span class=\"params\">(Fun, Index, [Tup|Tail])</span> -&gt;</span></span><br><span class=\"line\">   [setelement(Index, Tup, Fun(element(Index, Tup)))|keymap(Fun, Index, Tail)];</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">keymap</span><span class=\"params\">(Fun, Index, [])</span> <span class=\"title\">when</span> <span class=\"title\">is_integer</span><span class=\"params\">(Index)</span>, I<span class=\"title\">ndex</span> &gt;= 1, </span></span><br><span class=\"line\"><span class=\"function\">                            <span class=\"title\">is_function</span><span class=\"params\">(Fun, <span class=\"number\">1</span>)</span> -&gt;</span> [].</span><br></pre></td></tr></table></figure></p>\n<p>setelement从字面就可以看出是将Tup的 Index内容替换为Fun(element(Index, Tup)). 而,element就是返回Tup中第Index的值,这些东西都浓缩到一句代码实现,所以说erlang很有意思.</p>\n<h3 id=\"keymerge/3\">keymerge/3</h3><blockquote>\n<p>keymerge(N, TupleList1, TupleList2) -&gt; TupleList3</p>\n</blockquote>\n<p>将TupleList1和TupleList2合并并排序,其中N用来制定用Tuple中的第N元素为依据排序,注意,tuplelist1和tuplelist2在执行keymerge前需要是已经按N排好序,否则顺序可能不正确,如果tuplelist1有和tuplelist2中有第N元素相同的tuple,则Tuplelist1的在前面.<br>例子:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">42</span>&gt; lists:keymerge(<span class=\"number\">2</span>, [&#123;a,<span class=\"number\">1</span>&#125;,&#123;c,<span class=\"number\">3</span>&#125;],[&#123;b,<span class=\"number\">2</span>&#125;,&#123;d,<span class=\"number\">4</span>&#125;]).</span><br><span class=\"line\">[&#123;a,<span class=\"number\">1</span>&#125;,&#123;b,<span class=\"number\">2</span>&#125;,&#123;c,<span class=\"number\">3</span>&#125;,&#123;d,<span class=\"number\">4</span>&#125;]</span><br><span class=\"line\"><span class=\"comment\">%顺序出错</span></span><br><span class=\"line\"><span class=\"number\">43</span>&gt; lists:keymerge(<span class=\"number\">2</span>, [&#123;a,<span class=\"number\">1</span>&#125;,&#123;c,<span class=\"number\">3</span>&#125;],[&#123;d,<span class=\"number\">4</span>&#125;,&#123;b,<span class=\"number\">2</span>&#125;]).     </span><br><span class=\"line\">[&#123;a,<span class=\"number\">1</span>&#125;,&#123;c,<span class=\"number\">3</span>&#125;,&#123;d,<span class=\"number\">4</span>&#125;,&#123;b,<span class=\"number\">2</span>&#125;]  </span><br><span class=\"line\"><span class=\"comment\">%tuplelist1的在前面</span></span><br><span class=\"line\"><span class=\"number\">44</span>&gt; lists:keymerge(<span class=\"number\">2</span>, [&#123;a,<span class=\"number\">1</span>&#125;,&#123;c,<span class=\"number\">3</span>&#125;],[&#123;e,<span class=\"number\">3</span>&#125;,&#123;d,<span class=\"number\">4</span>&#125;]).</span><br><span class=\"line\">[&#123;a,<span class=\"number\">1</span>&#125;,&#123;c,<span class=\"number\">3</span>&#125;,&#123;e,<span class=\"number\">3</span>&#125;,&#123;d,<span class=\"number\">4</span>&#125;]</span><br></pre></td></tr></table></figure></p>\n<p>源码不放了,这个比较复杂,太长了,感兴趣的自己去找吧.</p>\n<h3 id=\"keyreplace/4\">keyreplace/4</h3><blockquote>\n<p>keyreplace(Key, N, TupleList1, NewTuple) -&gt; TupleList2</p>\n</blockquote>\n<p>如字面意思,用于替换,将TupleList1中第N个值等于Key的tuple替换为NewTuple.只替换第一个.<br>例子:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">46</span>&gt; lists:keyreplace(name2, <span class=\"number\">2</span>, [&#123;player1, name1, career1&#125;,&#123;player2, name2, career2&#125;,&#123;player3, name3, career3&#125;], &#123;player4, name4, career4&#125;).</span><br><span class=\"line\">[&#123;player1,name1,career1&#125;,</span><br><span class=\"line\"> &#123;player4,name4,career4&#125;,</span><br><span class=\"line\"> &#123;player3,name3,career3&#125;]</span><br></pre></td></tr></table></figure><br>源码:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">keyreplace</span><span class=\"params\">(K, N, L, New)</span> <span class=\"title\">when</span> <span class=\"title\">is_integer</span><span class=\"params\">(N)</span>, N &gt; 0, <span class=\"title\">is_tuple</span><span class=\"params\">(New)</span> -&gt;</span></span><br><span class=\"line\">    keyreplace3(K, N, L, New).</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">keyreplace3</span><span class=\"params\">(Key, Pos, [Tup|Tail], New)</span> <span class=\"title\">when</span> <span class=\"title\">element</span><span class=\"params\">(Pos, Tup)</span> == K<span class=\"title\">ey</span> -&gt;</span></span><br><span class=\"line\">    [New|Tail];</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">keyreplace3</span><span class=\"params\">(Key, Pos, [H|T], New)</span> -&gt;</span></span><br><span class=\"line\">    [H|keyreplace3(Key, Pos, T, New)];</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">keyreplace3</span><span class=\"params\">(_, _, [], _)</span> -&gt;</span> [].</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"keysort/2\">keysort/2</h3><blockquote>\n<p>keysort(N, TupleList1) -&gt; TupleList2.</p>\n</blockquote>\n<p>example:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">47</span>&gt; lists:keysort(<span class=\"number\">1</span>,[&#123;<span class=\"number\">3</span>,name3&#125;,&#123;<span class=\"number\">2</span>, name2&#125;, &#123;<span class=\"number\">4</span>,name4&#125;,&#123;<span class=\"number\">1</span>,name1&#125;]).</span><br><span class=\"line\">[&#123;<span class=\"number\">1</span>,name1&#125;,&#123;<span class=\"number\">2</span>,name2&#125;,&#123;<span class=\"number\">3</span>,name3&#125;,&#123;<span class=\"number\">4</span>,name4&#125;]</span><br></pre></td></tr></table></figure></p>\n<p>源码不贴了,这个函数的源码很长.</p>\n<h3 id=\"keystore/4\">keystore/4</h3><blockquote>\n<p>keystore(Key, N, TupleList1, NewTuple) -&gt; TupleList2.</p>\n</blockquote>\n<p>功能和keyreplace差不多,只不过当TupleList1中没有与Key相同的Tuple时,keyreplace返回的是原来的TupleList,而keystore是将NewTuple append在原TupleList上.<br>例子;<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">48</span>&gt; lists:keyreplace(name5, <span class=\"number\">2</span>, [&#123;player1, name1, career1&#125;,&#123;player2, name2, career2&#125;,&#123;player3, name3, career3&#125;], &#123;player4, name4, career4&#125;).</span><br><span class=\"line\">[&#123;player1,name1,career1&#125;,</span><br><span class=\"line\"> &#123;player2,name2,career2&#125;,</span><br><span class=\"line\"> &#123;player3,name3,career3&#125;]</span><br><span class=\"line\"><span class=\"number\">49</span>&gt; lists:keystore(name5, <span class=\"number\">2</span>, [&#123;player1, name1, career1&#125;,&#123;player2, name2, career2&#125;,&#123;player3, name3, career3&#125;], &#123;player4, name4, career4&#125;).  </span><br><span class=\"line\">[&#123;player1,name1,career1&#125;,</span><br><span class=\"line\"> &#123;player2,name2,career2&#125;,</span><br><span class=\"line\"> &#123;player3,name3,career3&#125;,</span><br><span class=\"line\"> &#123;player4,name4,career4&#125;]</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"keytake/3\">keytake/3</h3><blockquote>\n<p>keytake(Key, N, TupleList1) -&gt; {value, Tuple, TupleList2} | false</p>\n</blockquote>\n<p>与大多数key打头的函数相同,字面意思是从TupleList中拿出第N个值和Key相等的Tuple,如果有的话,返回{value, Tuple, TupleList2},Tuple是想的Tuple,TupleList2是去掉Tuple后的新的TupleList.如果没找到则返回false.<br>example:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">50</span>&gt; lists:keytake(name2, <span class=\"number\">2</span>, [&#123;player1, name1, career1&#125;,&#123;player2, name2, career2&#125;,&#123;player3, name3, career3&#125;]).                            </span><br><span class=\"line\">&#123;value,&#123;player2,name2,career2&#125;,</span><br><span class=\"line\">       [&#123;player1,name1,career1&#125;,&#123;player3,name3,career3&#125;]&#125;</span><br></pre></td></tr></table></figure><br>源码:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">keytake</span><span class=\"params\">(Key, N, L)</span> <span class=\"title\">when</span> <span class=\"title\">is_integer</span><span class=\"params\">(N)</span>, N &gt; 0 -&gt;</span></span><br><span class=\"line\">    keytake(Key, N, L, []).</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">keytake</span><span class=\"params\">(Key, N, [H|T], L)</span> <span class=\"title\">when</span> <span class=\"title\">element</span><span class=\"params\">(N, H)</span> == K<span class=\"title\">ey</span> -&gt;</span></span><br><span class=\"line\">    &#123;value, H, lists:reverse(L, T)&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">keytake</span><span class=\"params\">(Key, N, [H|T], L)</span> -&gt;</span></span><br><span class=\"line\">    keytake(Key, N, T, [H|L]);</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">keytake</span><span class=\"params\">(_K, _N, [], _L)</span> -&gt;</span> <span class=\"literal\">false</span>.</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"last/1\">last/1</h3><blockquote>\n<p>last(List) -&gt; Last</p>\n</blockquote>\n<p>返回List中最后一个元素.<br>源码:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">last</span><span class=\"params\">([E|Es])</span> -&gt;</span> last(E, Es).</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">last</span><span class=\"params\">(_, [E|Es])</span> -&gt;</span> last(E, Es);</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">last</span><span class=\"params\">(E, [])</span> -&gt;</span> E.</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"mapfoldl/3\">mapfoldl/3</h3><blockquote>\n<p>mapfoldl(Fun, Acc0, List1) -&gt; {List2, Acc1}.</p>\n</blockquote>\n<p>官方的解释就是同时具有map和foldl的功能.直白点就是map完成List1-&gt;List2的变化,foldl完成 Acc0 -&gt; Acc1的变化.<br>因为foldl只能返回一个由List1得到的记过Acc1,而不能多List1本身得到新的List2,而map不能得到Acc1,却能完成List1到List2的变化.所以mapfoldl完成了两者的功能.看源码会比较清晰的理解下.<br>源码:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">-spec</span> mapfoldl<span class=\"params\">(Fun, Acc0, List1)</span> -&gt; &#123;List2, Acc1&#125; when</span><br><span class=\"line\">      Fun :: fun<span class=\"params\">((A, AccIn)</span> -&gt; &#123;B, AccOut&#125;),</span><br><span class=\"line\">      Acc0 :: term<span class=\"params\">()</span>,</span><br><span class=\"line\">      Acc1 :: term<span class=\"params\">()</span>,</span><br><span class=\"line\">      AccIn :: term<span class=\"params\">()</span>,</span><br><span class=\"line\">      AccOut :: term<span class=\"params\">()</span>,</span><br><span class=\"line\">      List1 :: [A],</span><br><span class=\"line\">      List2 :: [B],</span><br><span class=\"line\">      A :: term<span class=\"params\">()</span>,</span><br><span class=\"line\">      B :: term<span class=\"params\">()</span>.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">mapfoldl</span><span class=\"params\">(F, Accu0, [Hd|Tail])</span> -&gt;</span></span><br><span class=\"line\">    &#123;R,Accu1&#125; = F(Hd, Accu0),</span><br><span class=\"line\">    &#123;Rs,Accu2&#125; = mapfoldl(F, Accu1, Tail),</span><br><span class=\"line\">    &#123;[R|Rs],Accu2&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">mapfoldl</span><span class=\"params\">(F, Accu, [])</span> <span class=\"title\">when</span> <span class=\"title\">is_function</span><span class=\"params\">(F, <span class=\"number\">2</span>)</span> -&gt;</span> &#123;[],Accu&#125;.</span><br></pre></td></tr></table></figure><br>注意,这里面的Fun返回的是{B, AccOut}的形式,而foldl的Fun是<code>Fun :: fun((Elem :: T, AccIn) -&gt; AccOut),</code>这里是最本质的区别.结合例子说下<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">52</span>&gt; lists:mapfoldl(<span class=\"keyword\">fun</span>(X, Sum) -&gt; &#123;X*<span class=\"number\">2</span>, X + Sum&#125; <span class=\"keyword\">end</span>, <span class=\"number\">0</span>, [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>]).</span><br><span class=\"line\">&#123;[<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">6</span>,<span class=\"number\">8</span>,<span class=\"number\">10</span>],<span class=\"number\">15</span>&#125;</span><br></pre></td></tr></table></figure></p>\n<p>首先第一轮得到的{R, Accu1} = {2, 1},而{Rs, Accu2}需要递归执行mapfoldl,那么第二轮得到一个{R&#39;,Accu1&#39;} = {4, 3},我们每轮能确切知道的只有{R, Accu1},但是mapfoldl要返回的是{[R|Rs],Accu2},所以需要一直递归下去,那么第三轮得到{6, 6},第四轮{8, 10},第五轮得到{10, 15},这时{10, 15}仍然是{R, Accu1},但是接下来由于Tail变成了空列表[],根据模式匹配,这次执行的是第二个mapfoldl函数,那么相当于执行mapfoldl{F, 15, []),得到最底层的{Rs, Accu2} = {[], 15},那么返回的{[R|Rs], Accu2}为{[10|[]], 15}.一直往上递归回去,结果得到{[2,4,6,8,10], 15}.</p>\n<h3 id=\"mapfoldr/3\">mapfoldr/3</h3><p>与上面的执行结果一样,只不过foldr是从右边开始,不影响List2的顺序.</p>\n<h3 id=\"max/1\">max/1</h3><blockquote>\n<p>max(List) -&gt; Max</p>\n</blockquote>\n<p>返回第一个这个List中的最大数.<br>例子:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">54</span>&gt; lists:max([a,b,c]).</span><br><span class=\"line\">c</span><br><span class=\"line\"><span class=\"number\">55</span>&gt; lists:max([<span class=\"number\">100</span>,b,c]).</span><br><span class=\"line\">c</span><br><span class=\"line\"><span class=\"number\">56</span>&gt; lists:max([&#123;<span class=\"number\">100</span>&#125;,b,c]).</span><br><span class=\"line\">&#123;<span class=\"number\">100</span>&#125;</span><br><span class=\"line\"><span class=\"number\">57</span>&gt; lists:max([&#123;<span class=\"number\">100</span>&#125;,b,c,[<span class=\"number\">90</span>]]).</span><br><span class=\"line\"><span class=\"string\">&quot;Z&quot;</span></span><br><span class=\"line\"><span class=\"number\">58</span>&gt; lists:max([&#123;<span class=\"number\">100</span>&#125;,b,c,[<span class=\"number\">2</span>]]). </span><br><span class=\"line\">[<span class=\"number\">2</span>]</span><br><span class=\"line\"><span class=\"number\">59</span>&gt; lists:max([&#123;<span class=\"number\">100</span>&#125;,b,c,[<span class=\"number\">2</span>],&lt;&lt;<span class=\"number\">2</span>&gt;&gt;]).</span><br><span class=\"line\">&lt;&lt;<span class=\"number\">2</span>&gt;&gt;</span><br></pre></td></tr></table></figure></p>\n<p>这里注意下不同类型之间的比较顺序</p>\n<blockquote>\n<p>number &lt; atom &lt; reference &lt; fun &lt; port &lt; pid &lt; tuple &lt; list &lt; binary</p>\n</blockquote>\n<p>源码:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">max</span><span class=\"params\">([H|T])</span> -&gt;</span> max(T, H).</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">max</span><span class=\"params\">([H|T], Max)</span> <span class=\"title\">when</span> H &gt; M<span class=\"title\">ax</span> -&gt;</span> max(T, H);</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">max</span><span class=\"params\">([_|T], Max)</span>              -&gt;</span> max(T, Max);</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">max</span><span class=\"params\">([],    Max)</span>              -&gt;</span> Max.</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"member/2\">member/2</h3><blockquote>\n<p>member(Elem, List) -&gt; boolean()</p>\n</blockquote>\n<p>如果Elem是List中的元素就返回true, 否则返回false.BIF.源码是C写的.不贴了.</p>\n<h3 id=\"merge/1/2/3以及merge3/3\">merge/1/2/3以及merge3/3</h3><blockquote>\n<p>merge(ListOfLists) -&gt; List1.<br>merge(List1, List2) -&gt; List3.<br>merge(Fun, List1, List2) -&gt; List3.<br>merge3(List1, List2, List3) -&gt; List4</p>\n</blockquote>\n<p>暂且叫归并排序吧,merge/1,merge/2完成的就是合并并排序,顺序由小到大,merge3/3只不过可以合并3个列表.merge/3可以依据Fun更改顺序,排序依据是Fun(A, B)如果返回true,那么就是A在B的前面.<br>举几个例子:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">60</span>&gt; lists:merge([[<span class=\"number\">1</span>],[<span class=\"number\">4</span>],[<span class=\"number\">2</span>,<span class=\"number\">4</span>],[<span class=\"number\">3</span>]]).</span><br><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"number\">61</span>&gt; lists:merge([<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">6</span>],[<span class=\"number\">1</span>,<span class=\"number\">3</span>]).      </span><br><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">6</span>]</span><br><span class=\"line\"><span class=\"number\">62</span>&gt; lists:merge(<span class=\"keyword\">fun</span>(A,B) -&gt; A &gt; B <span class=\"keyword\">end</span>, [<span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">2</span>],[<span class=\"number\">8</span>,<span class=\"number\">3</span>,<span class=\"number\">1</span>]).</span><br><span class=\"line\">[<span class=\"number\">8</span>,<span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"number\">63</span>&gt; lists:merge(<span class=\"keyword\">fun</span>(A,B) -&gt; A &lt; B <span class=\"keyword\">end</span>, [<span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">2</span>],[<span class=\"number\">8</span>,<span class=\"number\">3</span>,<span class=\"number\">1</span>]).</span><br><span class=\"line\">[<span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">2</span>,<span class=\"number\">8</span>,<span class=\"number\">3</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"number\">64</span>&gt; lists:merge(<span class=\"keyword\">fun</span>(A,B) -&gt; A &lt; B <span class=\"keyword\">end</span>, [<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>],[<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">8</span>]).</span><br><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">8</span>]</span><br><span class=\"line\"><span class=\"number\">66</span>&gt; lists:merge3([<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">6</span>],[<span class=\"number\">1</span>,<span class=\"number\">3</span>],[<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>]).</span><br><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>]</span><br></pre></td></tr></table></figure></p>\n<p>所有的排序都要求每个子List在排序前都是排好序的,如63行,由于子列表没有排好序,所以排序结果不正确.<br>merge的源码比较多而且杂,感兴趣自己去lists.erl里面看.</p>\n<h3 id=\"min/1\">min/1</h3><blockquote>\n<p>min(List) -&gt; Min</p>\n</blockquote>\n<p>与max相反.</p>\n<h3 id=\"nth/2\">nth/2</h3><blockquote>\n<p>nth(N, List) -&gt; Elem</p>\n</blockquote>\n<p>返回第List的第N个元素.<br>例子:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">67</span>&gt; lists:nth(<span class=\"number\">2</span>,[<span class=\"string\">&quot;haha&quot;</span>,atom,<span class=\"number\">2</span>,&lt;&lt;<span class=\"string\">&quot;binary&quot;</span>&gt;&gt;]). </span><br><span class=\"line\">atom</span><br></pre></td></tr></table></figure><br>源码:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">nth</span><span class=\"params\">(<span class=\"number\">1</span>, [H|_])</span> -&gt;</span> H;</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">nth</span><span class=\"params\">(N, [_|T])</span> <span class=\"title\">when</span> N &gt; 1 -&gt;</span></span><br><span class=\"line\">    nth(N - <span class=\"number\">1</span>, T).</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"nthtail/2\">nthtail/2</h3><blockquote>\n<p>nthtail(N, List) -&gt; Tail</p>\n</blockquote>\n<p>返回List的第N个尾列表.<br>例子:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">68</span>&gt; lists:nthtail(<span class=\"number\">0</span>,[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]).</span><br><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"number\">69</span>&gt; lists:nthtail(<span class=\"number\">1</span>,[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]).</span><br><span class=\"line\">[<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"number\">70</span>&gt; lists:nthtail(<span class=\"number\">2</span>,[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]).</span><br><span class=\"line\">[<span class=\"number\">3</span>,<span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"number\">71</span>&gt; lists:nthtail(<span class=\"number\">4</span>,[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]).</span><br><span class=\"line\">[]</span><br></pre></td></tr></table></figure><br>源码:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">nthtail</span><span class=\"params\">(<span class=\"number\">1</span>, [_|T])</span> -&gt;</span> T;</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">nthtail</span><span class=\"params\">(N, [_|T])</span> <span class=\"title\">when</span> N &gt; 1 -&gt;</span></span><br><span class=\"line\">    nthtail(N - <span class=\"number\">1</span>, T);</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">nthtail</span><span class=\"params\">(<span class=\"number\">0</span>, L)</span> <span class=\"title\">when</span> <span class=\"title\">is_list</span><span class=\"params\">(L)</span> -&gt;</span> L.</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"partition/2\">partition/2</h3><blockquote>\n<p>partition(Fun, List1) -&gt; {List1, List2}.</p>\n</blockquote>\n<p>字面意思是区分开,将List1依据Fun返回的true和false分为两个列表.<br>例子:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">73</span>&gt; lists:partition(<span class=\"keyword\">fun</span>(X) -&gt; X&gt;<span class=\"number\">2</span> <span class=\"keyword\">end</span>, [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]).</span><br><span class=\"line\">&#123;[<span class=\"number\">3</span>,<span class=\"number\">4</span>],[<span class=\"number\">1</span>,<span class=\"number\">2</span>]&#125;</span><br></pre></td></tr></table></figure><br>源码<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">partition</span><span class=\"params\">(Pred, L)</span> -&gt;</span></span><br><span class=\"line\">    partition(Pred, L, [], []).</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">partition</span><span class=\"params\">(Pred, [H | T], As, Bs)</span> -&gt;</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> Pred(H) <span class=\"keyword\">of</span></span><br><span class=\"line\">\t<span class=\"literal\">true</span> -&gt; partition(Pred, T, [H | As], Bs);</span><br><span class=\"line\">\t<span class=\"literal\">false</span> -&gt; partition(Pred, T, As, [H | Bs])</span><br><span class=\"line\">    <span class=\"keyword\">end</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">partition</span><span class=\"params\">(Pred, [], As, Bs)</span> <span class=\"title\">when</span> <span class=\"title\">is_function</span><span class=\"params\">(Pred, <span class=\"number\">1</span>)</span> -&gt;</span></span><br><span class=\"line\">    &#123;reverse(As), reverse(Bs)&#125;.</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"prefix/2\">prefix/2</h3><blockquote>\n<p>prefix(List1, List2) -&gt; boolean().</p>\n</blockquote>\n<p>如果List1是List2的前缀则返回true,否则返回false<br>例子:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">74</span>&gt; lists:prefix([<span class=\"number\">1</span>,<span class=\"number\">2</span>],[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]).                </span><br><span class=\"line\"><span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"number\">75</span>&gt; lists:prefix([<span class=\"number\">1</span>,<span class=\"number\">2</span>],[<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]).  </span><br><span class=\"line\"><span class=\"literal\">false</span></span><br></pre></td></tr></table></figure><br>源码很好理解:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">prefix</span><span class=\"params\">([X|PreTail], [X|Tail])</span> -&gt;</span></span><br><span class=\"line\">    prefix(PreTail, Tail);</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">prefix</span><span class=\"params\">([], List)</span> <span class=\"title\">when</span> <span class=\"title\">is_list</span><span class=\"params\">(List)</span> -&gt;</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">prefix</span><span class=\"params\">([_|_], List)</span> <span class=\"title\">when</span> <span class=\"title\">is_list</span><span class=\"params\">(List)</span> -&gt;</span> <span class=\"literal\">false</span>.</span><br></pre></td></tr></table></figure></p>\n<p>如果第一元素都是X,则递归执行prefix,如果List1为[]了,那么返回true,如果遇到不相同的元素了就返回false.</p>\n<h3 id=\"reverse/1/2\">reverse/1/2</h3><blockquote>\n<p>reverse(List1) -&gt; List2.<br>reverse(List1, Tail) -&gt; List2.</p>\n</blockquote>\n<p>reverse/1返回的是逆序的List1. reverse/2返回的是逆序的List1并且append了Tail.<br>例子:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">76</span>&gt; lists:reverse([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]).</span><br><span class=\"line\">[<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"number\">77</span>&gt; lists:reverse([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>],[<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>]).</span><br><span class=\"line\">[<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>]</span><br></pre></td></tr></table></figure><br>源码:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">-spec</span> reverse<span class=\"params\">(List1)</span> -&gt; List2 when</span><br><span class=\"line\">      List1 :: [T],</span><br><span class=\"line\">      List2 :: [T],</span><br><span class=\"line\">      T :: term<span class=\"params\">()</span>.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">reverse</span><span class=\"params\">([] = L)</span> -&gt;</span></span><br><span class=\"line\">    L;</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">reverse</span><span class=\"params\">([_] = L)</span> -&gt;</span></span><br><span class=\"line\">    L;</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">reverse</span><span class=\"params\">([A, B])</span> -&gt;</span></span><br><span class=\"line\">    [B, A];</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">reverse</span><span class=\"params\">([A, B | L])</span> -&gt;</span></span><br><span class=\"line\">    lists:reverse(L, [B, A]).</span><br></pre></td></tr></table></figure></p>\n<p>注意这里比较神奇的是reverse/1调用的是reverse/2,我一直以为reverse/1是BIF,其实reverse/2才是BIF,而且reverse/2在各种merge函数中多次调用,调用reverse/2的次数非常多,估计所以才将reverse/2写成了BIF吧.</p>\n<h3 id=\"seq/2/3\">seq/2/3</h3><blockquote>\n<p>seq(From, To) -&gt; List1<br>seq(From, To, Incr) -&gt; List2</p>\n</blockquote>\n<p>用于生成From到To的列表,Incr是递增的值.这个函数通常只用于最简单的功能,但是还是需要注意一下,这个函数报错的条件比较苛刻.官方给的说明是在一下会发生error错误.</p>\n<ol>\n<li>To &lt; From - Incr 并且Incr是正数.</li>\n<li>To &gt; From - Incr 并且Incr是负数.</li>\n<li>Incr为0时,From 不等于 To<br>并且官方给出<blockquote>\n<p>length(lists:seq(From, To)) == To-From+1<br>length(lists:seq(From, To, Incr)) == (To-From+Incr) div Incr</p>\n</blockquote>\n</li>\n</ol>\n<p>涵盖了上面3种情况,因为length不能是负数,其实只要看<strong><em>To-From+Incr与Incr相除</em></strong>是正数或者0就不会报错.<br>以下是一些例子:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">78</span>&gt; lists:seq(<span class=\"number\">1</span>,<span class=\"number\">4</span>).</span><br><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"number\">79</span>&gt; lists:seq(<span class=\"number\">3</span>,<span class=\"number\">1</span>).</span><br><span class=\"line\">** exception error: no function clause matching lists:seq(<span class=\"number\">3</span>,<span class=\"number\">1</span>) (lists.erl, line <span class=\"number\">177</span>)</span><br><span class=\"line\"><span class=\"number\">80</span>&gt; lists:seq(<span class=\"number\">3</span>,<span class=\"number\">1</span>,-<span class=\"number\">1</span>).</span><br><span class=\"line\">[<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"number\">81</span>&gt; lists:seq(<span class=\"number\">3</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>). </span><br><span class=\"line\">** exception error: no <span class=\"literal\">true</span> branch found <span class=\"keyword\">when</span> evaluating an <span class=\"keyword\">if</span> expression</span><br><span class=\"line\">     in function  lists:seq/<span class=\"number\">3</span> (lists.erl, line <span class=\"number\">198</span>)</span><br><span class=\"line\"><span class=\"number\">82</span>&gt; lists:seq(<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>).</span><br><span class=\"line\">[]</span><br><span class=\"line\"><span class=\"number\">83</span>&gt; lists:seq(<span class=\"number\">10</span>,<span class=\"number\">6</span>,<span class=\"number\">1</span>).</span><br><span class=\"line\">** exception error: no <span class=\"literal\">true</span> branch found <span class=\"keyword\">when</span> evaluating an <span class=\"keyword\">if</span> expression</span><br><span class=\"line\">     in function  lists:seq/<span class=\"number\">3</span> (lists.erl, line <span class=\"number\">198</span>)</span><br><span class=\"line\"><span class=\"number\">84</span>&gt; lists:seq(<span class=\"number\">10</span>,<span class=\"number\">6</span>,<span class=\"number\">4</span>).</span><br><span class=\"line\">[]</span><br><span class=\"line\"><span class=\"number\">85</span>&gt; lists:seq(<span class=\"number\">10</span>,<span class=\"number\">6</span>,<span class=\"number\">5</span>).</span><br><span class=\"line\">[]</span><br><span class=\"line\"><span class=\"number\">86</span>&gt; lists:seq(<span class=\"number\">10</span>,<span class=\"number\">6</span>,<span class=\"number\">3</span>).</span><br><span class=\"line\">** exception error: no <span class=\"literal\">true</span> branch found <span class=\"keyword\">when</span> evaluating an <span class=\"keyword\">if</span> expression</span><br><span class=\"line\">     in function  lists:seq/<span class=\"number\">3</span> (lists.erl, line <span class=\"number\">198</span>)</span><br><span class=\"line\"><span class=\"number\">87</span>&gt; lists:seq(<span class=\"number\">1</span>,<span class=\"number\">4</span>).</span><br><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"number\">88</span>&gt; lists:seq(<span class=\"number\">1</span>,<span class=\"number\">0</span>).</span><br><span class=\"line\">[]</span><br><span class=\"line\"><span class=\"number\">89</span>&gt; lists:seq(<span class=\"number\">3</span>,<span class=\"number\">0</span>,-<span class=\"number\">1</span>).</span><br><span class=\"line\">[<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>]</span><br><span class=\"line\"><span class=\"number\">90</span>&gt; lists:seq(<span class=\"number\">10</span>,<span class=\"number\">6</span>,<span class=\"number\">4</span>).</span><br><span class=\"line\">[]</span><br><span class=\"line\"><span class=\"number\">91</span>&gt; lists:seq(<span class=\"number\">10</span>,<span class=\"number\">6</span>,<span class=\"number\">3</span>).</span><br><span class=\"line\">** exception error: no <span class=\"literal\">true</span> branch found <span class=\"keyword\">when</span> evaluating an <span class=\"keyword\">if</span> expression</span><br><span class=\"line\">     in function  lists:seq/<span class=\"number\">3</span> (lists.erl, line <span class=\"number\">198</span>)</span><br><span class=\"line\"><span class=\"number\">92</span>&gt; lists:seq(<span class=\"number\">6</span>,<span class=\"number\">8</span>,-<span class=\"number\">3</span>).</span><br><span class=\"line\">[]</span><br><span class=\"line\"><span class=\"number\">93</span>&gt; lists:seq(<span class=\"number\">6</span>,<span class=\"number\">10</span>,-<span class=\"number\">3</span>).</span><br><span class=\"line\">** exception error: no <span class=\"literal\">true</span> branch found <span class=\"keyword\">when</span> evaluating an <span class=\"keyword\">if</span> expression</span><br><span class=\"line\">     in function  lists:seq/<span class=\"number\">3</span> (lists.erl, line <span class=\"number\">198</span>)</span><br><span class=\"line\"><span class=\"number\">94</span>&gt; lists:seq(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">0</span>).  </span><br><span class=\"line\">** exception error: no <span class=\"literal\">true</span> branch found <span class=\"keyword\">when</span> evaluating an <span class=\"keyword\">if</span> expression</span><br><span class=\"line\">     in function  lists:seq/<span class=\"number\">3</span> (lists.erl, line <span class=\"number\">198</span>)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"sort/1/2\">sort/1/2</h3><blockquote>\n<p>sort(List1) -&gt; List2.<br>sort(Fun, List1) -&gt; List2</p>\n</blockquote>\n<p>排序函数,应熟记不同类型之间的大小顺序,如例子:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">95</span>&gt; Ref = make_ref().</span><br><span class=\"line\">#Ref&lt;<span class=\"number\">0.0</span>.<span class=\"number\">0.358</span>&gt;</span><br><span class=\"line\"><span class=\"number\">96</span>&gt; Fun = <span class=\"keyword\">fun</span>(X) -&gt; X <span class=\"keyword\">end</span>.</span><br><span class=\"line\">#Fun&lt;erl_eval.<span class=\"number\">6.111823515</span>&gt;</span><br><span class=\"line\"><span class=\"number\">97</span>&gt; &#123;ok, Port&#125;=gen_tcp:listen(<span class=\"number\">8011</span>,[]).</span><br><span class=\"line\">&#123;ok,#Port&lt;<span class=\"number\">0.619</span>&gt;&#125;</span><br><span class=\"line\"><span class=\"number\">98</span>&gt; Pid = spawn(lists, seq, [<span class=\"number\">1</span>,<span class=\"number\">100</span>]).</span><br><span class=\"line\">&lt;<span class=\"number\">0.151</span>.<span class=\"number\">0</span>&gt;</span><br><span class=\"line\"><span class=\"number\">99</span>&gt; lists:sort([&lt;&lt;<span class=\"number\">2</span>&gt;&gt;,[<span class=\"number\">3</span>],&#123;<span class=\"number\">4</span>&#125;,Pid,Port,Fun,Ref,atom,<span class=\"number\">5</span>]).</span><br><span class=\"line\">[<span class=\"number\">5</span>,atom,#Ref&lt;<span class=\"number\">0.0</span>.<span class=\"number\">0.358</span>&gt;,#Fun&lt;erl_eval.<span class=\"number\">6.111823515</span>&gt;,</span><br><span class=\"line\"> #Port&lt;<span class=\"number\">0.619</span>&gt;,&lt;<span class=\"number\">0.151</span>.<span class=\"number\">0</span>&gt;,</span><br><span class=\"line\"> &#123;<span class=\"number\">4</span>&#125;,</span><br><span class=\"line\"> [<span class=\"number\">3</span>],</span><br><span class=\"line\"> &lt;&lt;<span class=\"number\">2</span>&gt;&gt;]</span><br></pre></td></tr></table></figure></p>\n<p>我在max函数提到过这个顺序,上面的结果也是按照这个顺序来的</p>\n<blockquote>\n<p>number &lt; atom &lt; reference &lt; fun &lt; port &lt; pid &lt; tuple &lt; list &lt; binary</p>\n</blockquote>\n<p>sort/2大致如merge/3,其中Fun可以用来改变默认的由小到大.</p>\n<h3 id=\"split/2\">split/2</h3><blockquote>\n<p>split(N, List1) -&gt; {List2, List3}</p>\n</blockquote>\n<p>分割函数,将List1分割成前N个元素List2,和剩下的元素List3<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">100</span>&gt; lists:split(<span class=\"number\">3</span>,[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>]). </span><br><span class=\"line\">&#123;[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>],[<span class=\"number\">4</span>,<span class=\"number\">5</span>]&#125;</span><br></pre></td></tr></table></figure><br>源码:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">-spec</span> split<span class=\"params\">(N, List1)</span> -&gt; &#123;List2, List3&#125; when</span><br><span class=\"line\">      N :: non_neg_integer<span class=\"params\">()</span>,</span><br><span class=\"line\">      List1 :: [T],</span><br><span class=\"line\">      List2 :: [T],</span><br><span class=\"line\">      List3 :: [T],</span><br><span class=\"line\">      T :: term<span class=\"params\">()</span>.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">split</span><span class=\"params\">(N, List)</span> <span class=\"title\">when</span> <span class=\"title\">is_integer</span><span class=\"params\">(N)</span>, N &gt;= 0, <span class=\"title\">is_list</span><span class=\"params\">(List)</span> -&gt;</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> split(N, List, []) <span class=\"keyword\">of</span></span><br><span class=\"line\">\t&#123;_, _&#125; = Result -&gt; Result;</span><br><span class=\"line\">\tFault <span class=\"keyword\">when</span> is_atom(Fault) -&gt;</span><br><span class=\"line\">\t    erlang:error(Fault, [N,List])</span><br><span class=\"line\">    <span class=\"keyword\">end</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">split</span><span class=\"params\">(N, List)</span> -&gt;</span></span><br><span class=\"line\">    erlang:error(badarg, [N,List]).</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">split</span><span class=\"params\">(<span class=\"number\">0</span>, L, R)</span> -&gt;</span></span><br><span class=\"line\">    &#123;lists:reverse(R, []), L&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">split</span><span class=\"params\">(N, [H|T], R)</span> -&gt;</span></span><br><span class=\"line\">    split(N-<span class=\"number\">1</span>, T, [H|R]);</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">split</span><span class=\"params\">(_, [], _)</span> -&gt;</span></span><br><span class=\"line\">    badarg.</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"splitwith/2\">splitwith/2</h3><p>splitwith(Fun, List) -&gt; {List1, List2}</p>\n<p>Fun决定切割的规则,List1是在遇到Fun(X)为false之前的元素,List2是第一个Fun返回为false之后的列表.<br>例子:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">101</span>&gt; lists:splitwith(<span class=\"keyword\">fun</span>(X) -&gt; is_atom(X) <span class=\"keyword\">end</span>, [a,b,c,<span class=\"number\">2</span>,d,e,<span class=\"number\">4</span>]).</span><br><span class=\"line\">&#123;[a,b,c],[<span class=\"number\">2</span>,d,e,<span class=\"number\">4</span>]&#125;</span><br></pre></td></tr></table></figure><br>源码:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">-spec</span> splitwith<span class=\"params\">(Pred, List)</span> -&gt; &#123;List1, List2&#125; when</span><br><span class=\"line\">      Pred :: fun<span class=\"params\">((T)</span> -&gt; boolean<span class=\"params\">()</span>),</span><br><span class=\"line\">      List :: [T],</span><br><span class=\"line\">      List1 :: [T],</span><br><span class=\"line\">      List2 :: [T],</span><br><span class=\"line\">      T :: term<span class=\"params\">()</span>.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">splitwith</span><span class=\"params\">(Pred, List)</span> <span class=\"title\">when</span> <span class=\"title\">is_function</span><span class=\"params\">(Pred, <span class=\"number\">1</span>)</span> -&gt;</span></span><br><span class=\"line\">    splitwith(Pred, List, []).</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">splitwith</span><span class=\"params\">(Pred, [Hd|Tail], Taken)</span> -&gt;</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> Pred(Hd) <span class=\"keyword\">of</span></span><br><span class=\"line\">\t<span class=\"literal\">true</span> -&gt; splitwith(Pred, Tail, [Hd|Taken]);</span><br><span class=\"line\">\t<span class=\"literal\">false</span> -&gt; &#123;reverse(Taken), [Hd|Tail]&#125;</span><br><span class=\"line\">    <span class=\"keyword\">end</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">splitwith</span><span class=\"params\">(Pred, [], Taken)</span> <span class=\"title\">when</span> <span class=\"title\">is_function</span><span class=\"params\">(Pred, <span class=\"number\">1</span>)</span> -&gt;</span></span><br><span class=\"line\">    &#123;reverse(Taken),[]&#125;.</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"sublist/2/3\">sublist/2/3</h3><blockquote>\n<p>sublist(List1, Len) -&gt; List2<br>sublist(List1, Start, Len) -&gt; List2</p>\n</blockquote>\n<p>返回前List中前Len个元素,Len可以大于List的长度,这样整个List会返回.<br>Start可以决定起始位置.<br>例子:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">102</span>&gt; lists:sublist([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>],<span class=\"number\">2</span>).                                </span><br><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>]</span><br><span class=\"line\"><span class=\"number\">103</span>&gt; lists:sublist([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>],<span class=\"number\">2</span>,<span class=\"number\">2</span>).</span><br><span class=\"line\">[<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"number\">104</span>&gt; lists:sublist([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>],<span class=\"number\">5</span>).  </span><br><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"number\">105</span>&gt; lists:sublist([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>],<span class=\"number\">5</span>,<span class=\"number\">1</span>).</span><br><span class=\"line\">[]</span><br></pre></td></tr></table></figure><br>源码<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">sublist</span><span class=\"params\">(List, L)</span> <span class=\"title\">when</span> <span class=\"title\">is_integer</span><span class=\"params\">(L)</span>, <span class=\"title\">is_list</span><span class=\"params\">(List)</span> -&gt;</span></span><br><span class=\"line\">    sublist_2(List, L).</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">sublist_2</span><span class=\"params\">([H|T], L)</span> <span class=\"title\">when</span> L &gt; 0 -&gt;</span></span><br><span class=\"line\">    [H|sublist_2(T, L-<span class=\"number\">1</span>)];</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">sublist_2</span><span class=\"params\">(_, <span class=\"number\">0</span>)</span> -&gt;</span></span><br><span class=\"line\">    [];</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">sublist_2</span><span class=\"params\">(List, L)</span> <span class=\"title\">when</span> <span class=\"title\">is_list</span><span class=\"params\">(List)</span>, L &gt; 0 -&gt;</span></span><br><span class=\"line\">    [].</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">sublist</span><span class=\"params\">(List, S, L)</span> <span class=\"title\">when</span> <span class=\"title\">is_integer</span><span class=\"params\">(L)</span>, L &gt;= 0 -&gt;</span></span><br><span class=\"line\">    sublist(nthtail(S-<span class=\"number\">1</span>, List), L).</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"subtract/2\">subtract/2</h3><blockquote>\n<p>subtract(List1, List2) -&gt; List3</p>\n</blockquote>\n<p>规则是这样的:对于List2中的每一个元素,在List1第一个与这个元素相等的元素被删掉,而成为List3.<br>例如:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">107</span>&gt; lists:subtract([<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">1</span>],[<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>]). </span><br><span class=\"line\">[<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">1</span>]</span><br></pre></td></tr></table></figure><br>源码:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">-spec</span> subtract<span class=\"params\">(List1, List2)</span> -&gt; List3 when</span><br><span class=\"line\">      List1 :: [T],</span><br><span class=\"line\">      List2 :: [T],</span><br><span class=\"line\">      List3 :: [T],</span><br><span class=\"line\">      T :: term<span class=\"params\">()</span>.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">subtract</span><span class=\"params\">(L1, L2)</span> -&gt;</span> L1 -- L2.</span><br></pre></td></tr></table></figure></p>\n<p>很明显这个函数在最坏情况下,有length(List1)*length(List2)的复杂度,代价很高.官方给的建议是</p>\n<blockquote>\n<p>Using ordered lists and ordsets:subtract/2 is a much better choice if both lists are long.</p>\n</blockquote>\n<p>使用ordset中的subtract/2,前提是这两个List是排好序的.<br>源码:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">-spec</span> subtract<span class=\"params\">(Ordset1, Ordset2)</span> -&gt; Ordset3 when</span><br><span class=\"line\">      Ordset1 :: ordset<span class=\"params\">(_)</span>,</span><br><span class=\"line\">      Ordset2 :: ordset<span class=\"params\">(_)</span>,</span><br><span class=\"line\">      Ordset3 :: ordset<span class=\"params\">(_)</span>.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">subtract</span><span class=\"params\">([E1|Es1], [E2|_]=Set2)</span> <span class=\"title\">when</span> E1 &lt; E2 -&gt;</span></span><br><span class=\"line\">    [E1|subtract(Es1, Set2)];</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">subtract</span><span class=\"params\">([E1|_]=Set1, [E2|Es2])</span> <span class=\"title\">when</span> E1 &gt; E2 -&gt;</span></span><br><span class=\"line\">    subtract(Set1, Es2);</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">subtract</span><span class=\"params\">([_E1|Es1], [_E2|Es2])</span> -&gt;</span>\t\t<span class=\"comment\">%E1 == E2</span></span><br><span class=\"line\">    subtract(Es1, Es2);</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">subtract</span><span class=\"params\">([], _)</span> -&gt;</span> [];</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">subtract</span><span class=\"params\">(Es1, [])</span> -&gt;</span> Es1.</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"suffix/2\">suffix/2</h3><blockquote>\n<p>suffix(List1, List2) -&gt; boolean().</p>\n</blockquote>\n<p>如同prefix,如果List1是List2的后缀则返回true,否则返回false.<br>例子:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">108</span>&gt; lists:suffix([<span class=\"number\">3</span>,<span class=\"number\">1</span>],[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">1</span>]).                             </span><br><span class=\"line\"><span class=\"literal\">true</span></span><br></pre></td></tr></table></figure><br>源码:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">suffix</span><span class=\"params\">(Suffix, List)</span> -&gt;</span></span><br><span class=\"line\">    Delta = length(List) - length(Suffix),</span><br><span class=\"line\">    Delta &gt;= <span class=\"number\">0</span> <span class=\"keyword\">andalso</span> nthtail(Delta, List) =:= Suffix.</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"sum/1\">sum/1</h3><blockquote>\n<p>sum(List) -&gt; Sum</p>\n</blockquote>\n<p>得到一个List的和,注意List应为数字组成.否则抛错.<br>源码:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">sum</span><span class=\"params\">(L)</span>          -&gt;</span> sum(L, <span class=\"number\">0</span>).</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">sum</span><span class=\"params\">([H|T], Sum)</span> -&gt;</span> sum(T, Sum + H);</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">sum</span><span class=\"params\">([], Sum)</span>    -&gt;</span> Sum.</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"takewhile/2\">takewhile/2</h3><blockquote>\n<p>takewhile(Pred, List1) -&gt; List2</p>\n</blockquote>\n<p>从List1中取出满足Pred为true的元素,直到遇到第一个false.也就是取出满足Pred的前缀.<br>例子:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">109</span>&gt; lists:takewhile(<span class=\"keyword\">fun</span>(A) -&gt; A &lt; <span class=\"number\">3</span> <span class=\"keyword\">end</span>, [<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>]).</span><br><span class=\"line\">[<span class=\"number\">2</span>,<span class=\"number\">1</span>]</span><br></pre></td></tr></table></figure><br>源码:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">takewhile</span><span class=\"params\">(Pred, [Hd|Tail])</span> -&gt;</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> Pred(Hd) <span class=\"keyword\">of</span></span><br><span class=\"line\">\t<span class=\"literal\">true</span> -&gt; [Hd|takewhile(Pred, Tail)];</span><br><span class=\"line\">\t<span class=\"literal\">false</span> -&gt; []</span><br><span class=\"line\">    <span class=\"keyword\">end</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">takewhile</span><span class=\"params\">(Pred, [])</span> <span class=\"title\">when</span> <span class=\"title\">is_function</span><span class=\"params\">(Pred, <span class=\"number\">1</span>)</span> -&gt;</span> [].</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"ukeymerge/3\">ukeymerge/3</h3><blockquote>\n<p>ukeymerge(N, TupleList1, TupleList2) -&gt; TupleList3</p>\n</blockquote>\n<p>类似于keymerge,但是u的意思是unique的意思,就是当TupleList1和TupleList2中有相同key的Tuple时将会删掉TupleList2中的Tuple.而且要求TupleList1和TupleList2在执行函数前自己本身不含有相同key的Tuple,否则结果会只删除一个TupleLIst2中的Tuple.结果不如人意.<br>例子:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>&gt; lists:ukeymerge(<span class=\"number\">2</span>,[&#123;<span class=\"number\">1</span>,<span class=\"number\">10</span>&#125;,&#123;<span class=\"number\">2</span>,<span class=\"number\">20</span>&#125;,&#123;<span class=\"number\">5</span>,<span class=\"number\">50</span>&#125;],[&#123;<span class=\"number\">2</span>,<span class=\"number\">20</span>&#125;,&#123;<span class=\"number\">4</span>,<span class=\"number\">40</span>&#125;]).</span><br><span class=\"line\">[&#123;<span class=\"number\">1</span>,<span class=\"number\">10</span>&#125;,&#123;<span class=\"number\">2</span>,<span class=\"number\">20</span>&#125;,&#123;<span class=\"number\">4</span>,<span class=\"number\">40</span>&#125;,&#123;<span class=\"number\">5</span>,<span class=\"number\">50</span>&#125;]</span><br><span class=\"line\"><span class=\"number\">2</span>&gt; lists:keymerge(<span class=\"number\">2</span>,[&#123;<span class=\"number\">1</span>,<span class=\"number\">10</span>&#125;,&#123;<span class=\"number\">2</span>,<span class=\"number\">20</span>&#125;,&#123;<span class=\"number\">5</span>,<span class=\"number\">50</span>&#125;],[&#123;<span class=\"number\">2</span>,<span class=\"number\">20</span>&#125;,&#123;<span class=\"number\">4</span>,<span class=\"number\">40</span>&#125;]). </span><br><span class=\"line\">[&#123;<span class=\"number\">1</span>,<span class=\"number\">10</span>&#125;,&#123;<span class=\"number\">2</span>,<span class=\"number\">20</span>&#125;,&#123;<span class=\"number\">2</span>,<span class=\"number\">20</span>&#125;,&#123;<span class=\"number\">4</span>,<span class=\"number\">40</span>&#125;,&#123;<span class=\"number\">5</span>,<span class=\"number\">50</span>&#125;]</span><br><span class=\"line\"><span class=\"number\">3</span>&gt; lists:ukeymerge(<span class=\"number\">2</span>,[&#123;<span class=\"number\">1</span>,<span class=\"number\">10</span>&#125;,&#123;<span class=\"number\">2</span>,<span class=\"number\">20</span>&#125;,&#123;<span class=\"number\">5</span>,<span class=\"number\">50</span>&#125;],[&#123;<span class=\"number\">2</span>,<span class=\"number\">20</span>&#125;,&#123;<span class=\"number\">3</span>,<span class=\"number\">20</span>&#125;,&#123;<span class=\"number\">4</span>,<span class=\"number\">40</span>&#125;]).</span><br><span class=\"line\">[&#123;<span class=\"number\">1</span>,<span class=\"number\">10</span>&#125;,&#123;<span class=\"number\">2</span>,<span class=\"number\">20</span>&#125;,&#123;<span class=\"number\">3</span>,<span class=\"number\">20</span>&#125;,&#123;<span class=\"number\">4</span>,<span class=\"number\">40</span>&#125;,&#123;<span class=\"number\">5</span>,<span class=\"number\">50</span>&#125;]</span><br><span class=\"line\"><span class=\"number\">4</span>&gt; lists:ukeymerge(<span class=\"number\">2</span>,[&#123;<span class=\"number\">1</span>,<span class=\"number\">10</span>&#125;,&#123;<span class=\"number\">2</span>,<span class=\"number\">20</span>&#125;,&#123;<span class=\"number\">5</span>,<span class=\"number\">50</span>&#125;],[&#123;<span class=\"number\">2</span>,<span class=\"number\">20</span>&#125;,&#123;<span class=\"number\">2</span>,<span class=\"number\">20</span>&#125;,&#123;<span class=\"number\">4</span>,<span class=\"number\">40</span>&#125;]).</span><br><span class=\"line\">[&#123;<span class=\"number\">1</span>,<span class=\"number\">10</span>&#125;,&#123;<span class=\"number\">2</span>,<span class=\"number\">20</span>&#125;,&#123;<span class=\"number\">2</span>,<span class=\"number\">20</span>&#125;,&#123;<span class=\"number\">4</span>,<span class=\"number\">40</span>&#125;,&#123;<span class=\"number\">5</span>,<span class=\"number\">50</span>&#125;]</span><br></pre></td></tr></table></figure></p>\n<p>可以看到keymerge和ukeymerge的差别,而且第3行是在TupleList2中有相同Key的Tuple,倒是结果中也有相同的key,这时因为只删除了第一个与TupleList1中相同的Tuple即{2, 20}.<br>源码不贴了,凡是根merge有关的,都复杂而且长..</p>\n<h3 id=\"ukeysort/2\">ukeysort/2</h3><blockquote>\n<p>ukeysort(N, TupleList1) -&gt; TupleList2</p>\n</blockquote>\n<p>与keysort差不多,同样u也是唯一的意思,只保留一个keyTuple,如以下例子:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">5</span>&gt; lists:ukeysort(<span class=\"number\">2</span>, [&#123;<span class=\"number\">1</span>,<span class=\"number\">10</span>&#125;,&#123;<span class=\"number\">3</span>,<span class=\"number\">30</span>&#125;,&#123;<span class=\"number\">4</span>,<span class=\"number\">40</span>&#125;,&#123;<span class=\"number\">2</span>,<span class=\"number\">20</span>&#125;,&#123;<span class=\"number\">5</span>,<span class=\"number\">20</span>&#125;]).         </span><br><span class=\"line\">[&#123;<span class=\"number\">1</span>,<span class=\"number\">10</span>&#125;,&#123;<span class=\"number\">2</span>,<span class=\"number\">20</span>&#125;,&#123;<span class=\"number\">3</span>,<span class=\"number\">30</span>&#125;,&#123;<span class=\"number\">4</span>,<span class=\"number\">40</span>&#125;]</span><br><span class=\"line\"><span class=\"number\">6</span>&gt; lists:keysort(<span class=\"number\">2</span>, [&#123;<span class=\"number\">1</span>,<span class=\"number\">10</span>&#125;,&#123;<span class=\"number\">3</span>,<span class=\"number\">30</span>&#125;,&#123;<span class=\"number\">4</span>,<span class=\"number\">40</span>&#125;,&#123;<span class=\"number\">2</span>,<span class=\"number\">20</span>&#125;,&#123;<span class=\"number\">5</span>,<span class=\"number\">20</span>&#125;]). </span><br><span class=\"line\">[&#123;<span class=\"number\">1</span>,<span class=\"number\">10</span>&#125;,&#123;<span class=\"number\">2</span>,<span class=\"number\">20</span>&#125;,&#123;<span class=\"number\">5</span>,<span class=\"number\">20</span>&#125;,&#123;<span class=\"number\">3</span>,<span class=\"number\">30</span>&#125;,&#123;<span class=\"number\">4</span>,<span class=\"number\">40</span>&#125;]</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"umerge/1/2/3以及_umerge3/3\">umerge/1/2/3以及 umerge3/3</h3><p>参加merge,只不过只保留一个相同的key.</p>\n<h3 id=\"uzip/1以及uzip3/1\">uzip/1以及uzip3/1</h3><blockquote>\n<p>unzip(List1) -&gt; {List2, List3}<br>unzip3(List1) -&gt; {List2, List3, List4}</p>\n</blockquote>\n<p>用于分离TupleList中的每个Tuple的第一个元素进入List2,第二个元素进入List3.unzip3适用于3-Tuple的情况.<br>例子:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">7</span>&gt; lists:unzip([&#123;<span class=\"number\">10210221</span>, fubowen&#125;,&#123;<span class=\"number\">10210222</span>, yuyouqi&#125;, &#123;<span class=\"number\">10201223</span>, xuyue&#125;]).</span><br><span class=\"line\">&#123;[<span class=\"number\">10210221</span>,<span class=\"number\">10210222</span>,<span class=\"number\">10201223</span>],[fubowen,yuyouqi,xuyue]&#125;</span><br><span class=\"line\"><span class=\"number\">8</span>&gt; lists:unzip3([&#123;<span class=\"number\">10210221</span>, fubowen, <span class=\"number\">1</span>&#125;,&#123;<span class=\"number\">10210222</span>, yuyouqi, <span class=\"number\">1</span>&#125;, &#123;<span class=\"number\">102101001</span>, aya, <span class=\"number\">0</span>&#125;]).</span><br><span class=\"line\">&#123;[<span class=\"number\">10210221</span>,<span class=\"number\">10210222</span>,<span class=\"number\">102101001</span>],</span><br><span class=\"line\"> [fubowen,yuyouqi,aya],</span><br><span class=\"line\"> [<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>]&#125;</span><br></pre></td></tr></table></figure><br>源码:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">unzip</span><span class=\"params\">(Ts)</span> -&gt;</span> unzip(Ts, [], []).</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">unzip</span><span class=\"params\">([&#123;X, Y&#125; | Ts], Xs, Ys)</span> -&gt;</span> unzip(Ts, [X | Xs], [Y | Ys]);</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">unzip</span><span class=\"params\">([], Xs, Ys)</span> -&gt;</span> &#123;reverse(Xs), reverse(Ys)&#125;.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">unzip3</span><span class=\"params\">(Ts)</span> -&gt;</span> unzip3(Ts, [], [], []).</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">unzip3</span><span class=\"params\">([&#123;X, Y, Z&#125; | Ts], Xs, Ys, Zs)</span> -&gt;</span></span><br><span class=\"line\">    unzip3(Ts, [X | Xs], [Y | Ys], [Z | Zs]);</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">unzip3</span><span class=\"params\">([], Xs, Ys, Zs)</span> -&gt;</span></span><br><span class=\"line\">    &#123;reverse(Xs), reverse(Ys), reverse(Zs)&#125;.</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"zip/2以及zip3/3\">zip/2以及zip3/3</h3><blockquote>\n<p>zip(List1, List2) -&gt; List3<br>zip3(List1, List2, List3) -&gt; List4</p>\n</blockquote>\n<p>就是unzip的反过程.</p>\n<h3 id=\"usort/1和usort/2\">usort/1和usort/2</h3><blockquote>\n<p>usort(List1) -&gt; List2<br>usort(Fun, List1) -&gt; List2</p>\n</blockquote>\n<p>见sort,只不过只保留一个相同的值.<br>例子:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">10</span>&gt; lists:usort([<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">2</span>,<span class=\"number\">5</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>]).</span><br><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>]</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"zipwith/3以及zipwith3/4\">zipwith/3以及zipwith3/4</h3><blockquote>\n<p>zipwith(Combine, List1, List2) -&gt; List3<br>zipwith3(Combine, List1, List2, List3) -&gt; List4</p>\n</blockquote>\n<p>功能大致同zip/2,zip3/3相同,只不过多了个Combine Function,这个Combine决定了如何合并.<br>例子:<br><figure class=\"highlight erlang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">11</span>&gt; lists:zipwith(<span class=\"keyword\">fun</span>(X,Y) -&gt; X+Y <span class=\"keyword\">end</span>, [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>], [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]).</span><br><span class=\"line\">[<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>]</span><br></pre></td></tr></table></figure></p>\n<p>至此,lists模块的函数全都介绍完毕,啊,好累,休息会.</p>"},{"title":"Erlang中的位语法(bit syntax)","date":"2014-07-01T10:03:23.000Z","_content":"\n记得第一天来实习的时候,我师傅给我展示了一个命令\n![](http://youthy-picture.qiniudn.com/%E9%80%89%E5%8C%BA_018.png)\n然后耍下一句话:\"**erlang中的数字是没有大小限制的,它取决于你的内存**\"\n\n<!--more-->\n\n当时我就斯巴达了,完全就是这个表情\n![](http://youthy-picture.qiniudn.com/9345d688d43f8794da4c2d44d01b0ef41bd53a2c.jpg)\n\n后来才明白上面的意思(`bsl`是`bit shift left`,上面是将1左移2000位,相当于2^2000方).\nerlang中对位数据的处理很简单高效,这也是为什么erlang非常适合开往网络应用,因为套接字传来的都是二进制流.\n******\n\n位语法基本格式\n> &lt;&lt;Value>>\n  &lt;&lt;Value:Size>>\n  &lt;&lt;Value/TypeSpecifierList>>\n  &lt;&lt;Value:Size/TypeSpecifierList>>\n\n##构造\n  * Value是数值,可以是数,也可以是变量,也可以是返回值为数的表达式,同时也可以是文本串.\n  * Size给Value分配N个`type`类型的空间,Size为`type`默认数值的整数倍,`type`未指定时为`integer`.此时size默认为8\n  * TypeSpecifierList是`Type-Signedess-Endianess-Unit`的形式,\n      *  Type可以为`integer`,`float`,`binary`,`bytes`,`bitstring`,`bits`,`utf8`,`utf16`,`utf32`.其中`bytes`是`binary`的缩写`bits`是`bitstring`的缩写.\n      *  Signedess可以是`signed`和`unsigned`,只有`type`为`integer`时有效\n      *  Endianess可以为`big`,`little`,`native`,这个类似于大端和小端存储的概念,默认是`big`,`native`是让程序在运行时根据计算机决定使用哪种方式.\n      * Uint:形式通常是`<<Value:Size/unit:integer`>>,integer的范围是1~256.系统会给Value分配Size X integer的空间.\n\n![](../../../../img/test.png)\n       \n\n上面是简单的二进制流构造,不过位语法的最大用处不在构造,而是erlang中无处不在的matching,模式匹配.\n*****\n##模式匹配\n>    Color = 16#32F682.\n我们在上面定义了一个Color变量,这时我们常见的16进制色彩数据,玩过ps的人应该经常遇到.假如我们需要提取出Color中的RGB分量各是多少,应该怎么做呢?\n这在erlang中非常容易:\n\n![](../../../../img/24.png)\n\n如上所见,我们用R匹配Color前8位,G匹配中间8位,B匹配最后8位.那么R,G,B就是Color的红色,绿色和蓝色分量了.\n如果只需要红色,我们可以用\n    \n![](../../../../img/选区_025.png)\n    \n/binary放在末尾可以匹配剩下的所有二进制流,但是需要注意的是/binary只有放在末尾才可以不指定size.\n\n![](../../../../img/选区_026.png)\n\n> 需要注意的是`binary`与默认`integer`的size的差别,`integer`默认是8,`binary`的1其实相当于占用`integer`的8一样的空间.而且`binary`的返回值不再是整数,而是一个二进制流.\n\n![](http://youthy-picture.qiniudn.com/7_23.gif)\n如上是TCP的报文格式,我们可以用模式匹配轻松得到这些数据.\n\n>  &lt;&lt;SourcePort:16, DestinationPort:16,PosNumber:32,AckNumber:32,DataOffset:4, _Reserved:4, Flags:8, WindowSize:16,CheckSum: 16, UrgentPointer:16,Payload/binary>> = TcpPackage.\n\n先到这,改天想起来在补充.\n>  参考:\n[learn you some erlang](http://learnyousomeerlang.com/starting-out-for-real#bit-syntax)\n        [Erlang官方文档](http://www.erlang.org/doc/reference_manual/expressions.html#bit_syntax)\n（http://www.cnblogs.com/me-sa/archive/2011/12/25/erlang0024.html）\n（http://www.cnblogs.com/zhongwencool/p/erlang_binary.html）\n","source":"_posts/Erlang中的位语法(bit-syntax).md","raw":"title: 'Erlang中的位语法(bit syntax)'\ndate: 2014-07-01 18:03:23\ntags: erlang\ncategories: Erlang\n---\n\n记得第一天来实习的时候,我师傅给我展示了一个命令\n![](http://youthy-picture.qiniudn.com/%E9%80%89%E5%8C%BA_018.png)\n然后耍下一句话:\"**erlang中的数字是没有大小限制的,它取决于你的内存**\"\n\n<!--more-->\n\n当时我就斯巴达了,完全就是这个表情\n![](http://youthy-picture.qiniudn.com/9345d688d43f8794da4c2d44d01b0ef41bd53a2c.jpg)\n\n后来才明白上面的意思(`bsl`是`bit shift left`,上面是将1左移2000位,相当于2^2000方).\nerlang中对位数据的处理很简单高效,这也是为什么erlang非常适合开往网络应用,因为套接字传来的都是二进制流.\n******\n\n位语法基本格式\n> &lt;&lt;Value>>\n  &lt;&lt;Value:Size>>\n  &lt;&lt;Value/TypeSpecifierList>>\n  &lt;&lt;Value:Size/TypeSpecifierList>>\n\n##构造\n  * Value是数值,可以是数,也可以是变量,也可以是返回值为数的表达式,同时也可以是文本串.\n  * Size给Value分配N个`type`类型的空间,Size为`type`默认数值的整数倍,`type`未指定时为`integer`.此时size默认为8\n  * TypeSpecifierList是`Type-Signedess-Endianess-Unit`的形式,\n      *  Type可以为`integer`,`float`,`binary`,`bytes`,`bitstring`,`bits`,`utf8`,`utf16`,`utf32`.其中`bytes`是`binary`的缩写`bits`是`bitstring`的缩写.\n      *  Signedess可以是`signed`和`unsigned`,只有`type`为`integer`时有效\n      *  Endianess可以为`big`,`little`,`native`,这个类似于大端和小端存储的概念,默认是`big`,`native`是让程序在运行时根据计算机决定使用哪种方式.\n      * Uint:形式通常是`<<Value:Size/unit:integer`>>,integer的范围是1~256.系统会给Value分配Size X integer的空间.\n\n![](../../../../img/test.png)\n       \n\n上面是简单的二进制流构造,不过位语法的最大用处不在构造,而是erlang中无处不在的matching,模式匹配.\n*****\n##模式匹配\n>    Color = 16#32F682.\n我们在上面定义了一个Color变量,这时我们常见的16进制色彩数据,玩过ps的人应该经常遇到.假如我们需要提取出Color中的RGB分量各是多少,应该怎么做呢?\n这在erlang中非常容易:\n\n![](../../../../img/24.png)\n\n如上所见,我们用R匹配Color前8位,G匹配中间8位,B匹配最后8位.那么R,G,B就是Color的红色,绿色和蓝色分量了.\n如果只需要红色,我们可以用\n    \n![](../../../../img/选区_025.png)\n    \n/binary放在末尾可以匹配剩下的所有二进制流,但是需要注意的是/binary只有放在末尾才可以不指定size.\n\n![](../../../../img/选区_026.png)\n\n> 需要注意的是`binary`与默认`integer`的size的差别,`integer`默认是8,`binary`的1其实相当于占用`integer`的8一样的空间.而且`binary`的返回值不再是整数,而是一个二进制流.\n\n![](http://youthy-picture.qiniudn.com/7_23.gif)\n如上是TCP的报文格式,我们可以用模式匹配轻松得到这些数据.\n\n>  &lt;&lt;SourcePort:16, DestinationPort:16,PosNumber:32,AckNumber:32,DataOffset:4, _Reserved:4, Flags:8, WindowSize:16,CheckSum: 16, UrgentPointer:16,Payload/binary>> = TcpPackage.\n\n先到这,改天想起来在补充.\n>  参考:\n[learn you some erlang](http://learnyousomeerlang.com/starting-out-for-real#bit-syntax)\n        [Erlang官方文档](http://www.erlang.org/doc/reference_manual/expressions.html#bit_syntax)\n（http://www.cnblogs.com/me-sa/archive/2011/12/25/erlang0024.html）\n（http://www.cnblogs.com/zhongwencool/p/erlang_binary.html）\n","slug":"Erlang中的位语法(bit-syntax)","published":1,"updated":"2018-06-26T09:49:27.733Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqw7jdvm00076f1r6xsnbrjt","content":"<p>记得第一天来实习的时候,我师傅给我展示了一个命令<br><img src=\"http://youthy-picture.qiniudn.com/%E9%80%89%E5%8C%BA_018.png\" alt=\"\"><br>然后耍下一句话:&quot;<strong>erlang中的数字是没有大小限制的,它取决于你的内存</strong>&quot;</p>\n<span id=\"more\"></span>\n<p>当时我就斯巴达了,完全就是这个表情<br><img src=\"http://youthy-picture.qiniudn.com/9345d688d43f8794da4c2d44d01b0ef41bd53a2c.jpg\" alt=\"\"></p>\n<p>后来才明白上面的意思(<code>bsl</code>是<code>bit shift left</code>,上面是将1左移2000位,相当于2^2000方).<br>erlang中对位数据的处理很简单高效,这也是为什么erlang非常适合开往网络应用,因为套接字传来的都是二进制流.</p>\n<hr>\n<p>位语法基本格式</p>\n<blockquote>\n<p>&lt;&lt;Value&gt;&gt;<br>  &lt;&lt;Value:Size&gt;&gt;<br>  &lt;&lt;Value/TypeSpecifierList&gt;&gt;<br>  &lt;&lt;Value:Size/TypeSpecifierList&gt;&gt;</p>\n</blockquote>\n<p>##构造</p>\n<ul>\n<li>Value是数值,可以是数,也可以是变量,也可以是返回值为数的表达式,同时也可以是文本串.</li>\n<li>Size给Value分配N个<code>type</code>类型的空间,Size为<code>type</code>默认数值的整数倍,<code>type</code>未指定时为<code>integer</code>.此时size默认为8</li>\n<li>TypeSpecifierList是<code>Type-Signedess-Endianess-Unit</code>的形式,<ul>\n<li>Type可以为<code>integer</code>,<code>float</code>,<code>binary</code>,<code>bytes</code>,<code>bitstring</code>,<code>bits</code>,<code>utf8</code>,<code>utf16</code>,<code>utf32</code>.其中<code>bytes</code>是<code>binary</code>的缩写<code>bits</code>是<code>bitstring</code>的缩写.</li>\n<li>Signedess可以是<code>signed</code>和<code>unsigned</code>,只有<code>type</code>为<code>integer</code>时有效</li>\n<li>Endianess可以为<code>big</code>,<code>little</code>,<code>native</code>,这个类似于大端和小端存储的概念,默认是<code>big</code>,<code>native</code>是让程序在运行时根据计算机决定使用哪种方式.</li>\n<li>Uint:形式通常是<code>&lt;&lt;Value:Size/unit:integer</code>&gt;&gt;,integer的范围是1~256.系统会给Value分配Size X integer的空间.</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"../../../../img/test.png\" alt=\"\"></p>\n<p>上面是简单的二进制流构造,不过位语法的最大用处不在构造,而是erlang中无处不在的matching,模式匹配.</p>\n<hr>\n<p>##模式匹配</p>\n<blockquote>\n<p>   Color = 16#32F682.<br>我们在上面定义了一个Color变量,这时我们常见的16进制色彩数据,玩过ps的人应该经常遇到.假如我们需要提取出Color中的RGB分量各是多少,应该怎么做呢?<br>这在erlang中非常容易:</p>\n</blockquote>\n<p><img src=\"../../../../img/24.png\" alt=\"\"></p>\n<p>如上所见,我们用R匹配Color前8位,G匹配中间8位,B匹配最后8位.那么R,G,B就是Color的红色,绿色和蓝色分量了.<br>如果只需要红色,我们可以用</p>\n<p><img src=\"../../../../img/选区_025.png\" alt=\"\"></p>\n<p>/binary放在末尾可以匹配剩下的所有二进制流,但是需要注意的是/binary只有放在末尾才可以不指定size.</p>\n<p><img src=\"../../../../img/选区_026.png\" alt=\"\"></p>\n<blockquote>\n<p>需要注意的是<code>binary</code>与默认<code>integer</code>的size的差别,<code>integer</code>默认是8,<code>binary</code>的1其实相当于占用<code>integer</code>的8一样的空间.而且<code>binary</code>的返回值不再是整数,而是一个二进制流.</p>\n</blockquote>\n<p><img src=\"http://youthy-picture.qiniudn.com/7_23.gif\" alt=\"\"><br>如上是TCP的报文格式,我们可以用模式匹配轻松得到这些数据.</p>\n<blockquote>\n<p> &lt;&lt;SourcePort:16, DestinationPort:16,PosNumber:32,AckNumber:32,DataOffset:4, _Reserved:4, Flags:8, WindowSize:16,CheckSum: 16, UrgentPointer:16,Payload/binary&gt;&gt; = TcpPackage.</p>\n</blockquote>\n<p>先到这,改天想起来在补充.</p>\n<blockquote>\n<p> 参考:<br><a href=\"http://learnyousomeerlang.com/starting-out-for-real#bit-syntax\">learn you some erlang</a><br>        <a href=\"http://www.erlang.org/doc/reference_manual/expressions.html#bit_syntax\">Erlang官方文档</a><br>（<a href=\"http://www.cnblogs.com/me-sa/archive/2011/12/25/erlang0024.html）\">http://www.cnblogs.com/me-sa/archive/2011/12/25/erlang0024.html）</a><br>（<a href=\"http://www.cnblogs.com/zhongwencool/p/erlang_binary.html）\">http://www.cnblogs.com/zhongwencool/p/erlang_binary.html）</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>记得第一天来实习的时候,我师傅给我展示了一个命令<br><img src=\"http://youthy-picture.qiniudn.com/%E9%80%89%E5%8C%BA_018.png\" alt=\"\"><br>然后耍下一句话:&quot;<strong>erlang中的数字是没有大小限制的,它取决于你的内存</strong>&quot;</p>","more":"<p>当时我就斯巴达了,完全就是这个表情<br><img src=\"http://youthy-picture.qiniudn.com/9345d688d43f8794da4c2d44d01b0ef41bd53a2c.jpg\" alt=\"\"></p>\n<p>后来才明白上面的意思(<code>bsl</code>是<code>bit shift left</code>,上面是将1左移2000位,相当于2^2000方).<br>erlang中对位数据的处理很简单高效,这也是为什么erlang非常适合开往网络应用,因为套接字传来的都是二进制流.</p>\n<hr>\n<p>位语法基本格式</p>\n<blockquote>\n<p>&lt;&lt;Value&gt;&gt;<br>  &lt;&lt;Value:Size&gt;&gt;<br>  &lt;&lt;Value/TypeSpecifierList&gt;&gt;<br>  &lt;&lt;Value:Size/TypeSpecifierList&gt;&gt;</p>\n</blockquote>\n<p>##构造</p>\n<ul>\n<li>Value是数值,可以是数,也可以是变量,也可以是返回值为数的表达式,同时也可以是文本串.</li>\n<li>Size给Value分配N个<code>type</code>类型的空间,Size为<code>type</code>默认数值的整数倍,<code>type</code>未指定时为<code>integer</code>.此时size默认为8</li>\n<li>TypeSpecifierList是<code>Type-Signedess-Endianess-Unit</code>的形式,<ul>\n<li>Type可以为<code>integer</code>,<code>float</code>,<code>binary</code>,<code>bytes</code>,<code>bitstring</code>,<code>bits</code>,<code>utf8</code>,<code>utf16</code>,<code>utf32</code>.其中<code>bytes</code>是<code>binary</code>的缩写<code>bits</code>是<code>bitstring</code>的缩写.</li>\n<li>Signedess可以是<code>signed</code>和<code>unsigned</code>,只有<code>type</code>为<code>integer</code>时有效</li>\n<li>Endianess可以为<code>big</code>,<code>little</code>,<code>native</code>,这个类似于大端和小端存储的概念,默认是<code>big</code>,<code>native</code>是让程序在运行时根据计算机决定使用哪种方式.</li>\n<li>Uint:形式通常是<code>&lt;&lt;Value:Size/unit:integer</code>&gt;&gt;,integer的范围是1~256.系统会给Value分配Size X integer的空间.</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"../../../../img/test.png\" alt=\"\"></p>\n<p>上面是简单的二进制流构造,不过位语法的最大用处不在构造,而是erlang中无处不在的matching,模式匹配.</p>\n<hr>\n<p>##模式匹配</p>\n<blockquote>\n<p>   Color = 16#32F682.<br>我们在上面定义了一个Color变量,这时我们常见的16进制色彩数据,玩过ps的人应该经常遇到.假如我们需要提取出Color中的RGB分量各是多少,应该怎么做呢?<br>这在erlang中非常容易:</p>\n</blockquote>\n<p><img src=\"../../../../img/24.png\" alt=\"\"></p>\n<p>如上所见,我们用R匹配Color前8位,G匹配中间8位,B匹配最后8位.那么R,G,B就是Color的红色,绿色和蓝色分量了.<br>如果只需要红色,我们可以用</p>\n<p><img src=\"../../../../img/选区_025.png\" alt=\"\"></p>\n<p>/binary放在末尾可以匹配剩下的所有二进制流,但是需要注意的是/binary只有放在末尾才可以不指定size.</p>\n<p><img src=\"../../../../img/选区_026.png\" alt=\"\"></p>\n<blockquote>\n<p>需要注意的是<code>binary</code>与默认<code>integer</code>的size的差别,<code>integer</code>默认是8,<code>binary</code>的1其实相当于占用<code>integer</code>的8一样的空间.而且<code>binary</code>的返回值不再是整数,而是一个二进制流.</p>\n</blockquote>\n<p><img src=\"http://youthy-picture.qiniudn.com/7_23.gif\" alt=\"\"><br>如上是TCP的报文格式,我们可以用模式匹配轻松得到这些数据.</p>\n<blockquote>\n<p> &lt;&lt;SourcePort:16, DestinationPort:16,PosNumber:32,AckNumber:32,DataOffset:4, _Reserved:4, Flags:8, WindowSize:16,CheckSum: 16, UrgentPointer:16,Payload/binary&gt;&gt; = TcpPackage.</p>\n</blockquote>\n<p>先到这,改天想起来在补充.</p>\n<blockquote>\n<p> 参考:<br><a href=\"http://learnyousomeerlang.com/starting-out-for-real#bit-syntax\">learn you some erlang</a><br>        <a href=\"http://www.erlang.org/doc/reference_manual/expressions.html#bit_syntax\">Erlang官方文档</a><br>（<a href=\"http://www.cnblogs.com/me-sa/archive/2011/12/25/erlang0024.html）\">http://www.cnblogs.com/me-sa/archive/2011/12/25/erlang0024.html）</a><br>（<a href=\"http://www.cnblogs.com/zhongwencool/p/erlang_binary.html）\">http://www.cnblogs.com/zhongwencool/p/erlang_binary.html）</a></p>\n</blockquote>"},{"title":"Linux下代理实现:shadowsocks","date":"2014-06-28T11:52:47.000Z","_content":"\n#linux下的代理:shadowsocks \n\n---\n之前为了玩舰娘,从淘宝上买了个日本ip的ssh,用ssh过了一段翻墙的日子,后来舰娘玩的少了,ssh没怎么用,再后来一上ssh竟然无效了.反正也没多大需求了后来就没管它.再后来当我要用到stackoverflow查阅些东西时,发现竟然加载奇慢.\n其实并不是stackoverflow被墙了.而是它调用的一些服务被墙了.\n\n<!--more-->\n##测试阶段\n打开chrome,我们按ctrl+shift+I调出network这个审查面板(也可以按右键选择\"审查元素\").然后在地址栏输入`stackoverflow.com`我们可以看到究竟是什么东西加载的这么慢.\n![](http://youthy-picture.qiniudn.com/%E9%80%89%E5%8C%BA_008.png)\n可以看到红名的那个加载项.相比大家心里清楚什么原因....毕竟最近google的服务根本没法用....\n所以我需要\n> 1. shadowsocks代理客户端\n2. 一个shadowsocks账号\n3. chrome switchysharp插件\n\n***\n\n##shadowsocks账号\n可以从淘宝买,很便宜,3块一个月2G流量,8元一个月40G流量,足够用了.如果没有账号,接下来的部分就不用看了.\n##shadowsock安装\n我推荐用shadowsock-gui这个图形界面.\n[github地址](https://github.com/shadowsocks/shadowsocks-gui)\n上面安装方法写的很详细了.可以选择直接DOWNLOAD的方法,下载一个tar.gz的包,然后在终端运行\n\n `tar -xvzf shadowsocks-gui-0.1.3-linux-ia32.tar.gz(我下载的版本)`\n\n解压出来就可以了.\n喜欢鼓捣的人可以用DEVELOP的方法安装.\n无论怎么安装,最后进入shadowsock的根目录,直接双击nw这个文件就可以,或者用终端`cd`到所在目录,执行`./nw`都可以打开shadowsock-gui.\n界面如下\n![](http://youthy-picture.qiniudn.com/%E9%80%89%E5%8C%BA_009.png)\n\n> **注意**:如果双击nw无反应,或者`./nw`后报了错:\n`error while loading shared libraries: libudev.so.0: can not open shared object  file:No such file or directory`\n说明我们的这个库程序找不到.\n在终端中执行 `locate libudev.so`\n![](http://youthy-picture.qiniudn.com/%E9%80%89%E5%8C%BA_011.png)\n可以看到libudev.so在lib/i386-linux-gnu下,我们需要执行一下软连接命令\n`sudo ln -s /lib/i386-linux-gnu/libudev.so.1 /lib/i386-linux-gnu/libudev.so.0`\n这样nw就可以正常运行了.\n\n****\n\n##switchysharp\nswitchysharp的教程太多了,不管使用ssh还是shadowssocks,或者是goagent等各种代理都要用到它.教程一搜一大堆.\n这里就不多说,仅给出我的设置.\n在shadowsocks里面save好账号信息后,在chrome的switchysharp里做如下设置.\n![](http://youthy-picture.qiniudn.com/%E9%80%89%E5%8C%BA_012.png)\n主要将对应的端口写成shadowsocks的本地端口(我的是1080).\n如果使用自动切换模式需要改下下面的自动切换规则.我把googleapis和google-analytics加入了进去.\n![](http://youthy-picture.qiniudn.com/%E9%80%89%E5%8C%BA_013.png)\n顺便把stackoverflow和另外一个stackoverflow调用的但是耗时长的网址加了进去\n![](http://youthy-picture.qiniudn.com/%E9%80%89%E5%8C%BA_014.png)\n保存后就基本完工了.\n##我们可以看到googleapis的加载速度一下子提升了很多\n![](http://youthy-picture.qiniudn.com/%E9%80%89%E5%8C%BA_015.png)\n可以顺畅了浏览stackoverflow了,\n顺便玩玩舰娘...\n\n","source":"_posts/Linux下代理实现shadowsocks.md","raw":"title: 'Linux下代理实现:shadowsocks'\ndate: 2014-06-28 19:52:47\ntags: linux\ncategories: 教程\n---\n\n#linux下的代理:shadowsocks \n\n---\n之前为了玩舰娘,从淘宝上买了个日本ip的ssh,用ssh过了一段翻墙的日子,后来舰娘玩的少了,ssh没怎么用,再后来一上ssh竟然无效了.反正也没多大需求了后来就没管它.再后来当我要用到stackoverflow查阅些东西时,发现竟然加载奇慢.\n其实并不是stackoverflow被墙了.而是它调用的一些服务被墙了.\n\n<!--more-->\n##测试阶段\n打开chrome,我们按ctrl+shift+I调出network这个审查面板(也可以按右键选择\"审查元素\").然后在地址栏输入`stackoverflow.com`我们可以看到究竟是什么东西加载的这么慢.\n![](http://youthy-picture.qiniudn.com/%E9%80%89%E5%8C%BA_008.png)\n可以看到红名的那个加载项.相比大家心里清楚什么原因....毕竟最近google的服务根本没法用....\n所以我需要\n> 1. shadowsocks代理客户端\n2. 一个shadowsocks账号\n3. chrome switchysharp插件\n\n***\n\n##shadowsocks账号\n可以从淘宝买,很便宜,3块一个月2G流量,8元一个月40G流量,足够用了.如果没有账号,接下来的部分就不用看了.\n##shadowsock安装\n我推荐用shadowsock-gui这个图形界面.\n[github地址](https://github.com/shadowsocks/shadowsocks-gui)\n上面安装方法写的很详细了.可以选择直接DOWNLOAD的方法,下载一个tar.gz的包,然后在终端运行\n\n `tar -xvzf shadowsocks-gui-0.1.3-linux-ia32.tar.gz(我下载的版本)`\n\n解压出来就可以了.\n喜欢鼓捣的人可以用DEVELOP的方法安装.\n无论怎么安装,最后进入shadowsock的根目录,直接双击nw这个文件就可以,或者用终端`cd`到所在目录,执行`./nw`都可以打开shadowsock-gui.\n界面如下\n![](http://youthy-picture.qiniudn.com/%E9%80%89%E5%8C%BA_009.png)\n\n> **注意**:如果双击nw无反应,或者`./nw`后报了错:\n`error while loading shared libraries: libudev.so.0: can not open shared object  file:No such file or directory`\n说明我们的这个库程序找不到.\n在终端中执行 `locate libudev.so`\n![](http://youthy-picture.qiniudn.com/%E9%80%89%E5%8C%BA_011.png)\n可以看到libudev.so在lib/i386-linux-gnu下,我们需要执行一下软连接命令\n`sudo ln -s /lib/i386-linux-gnu/libudev.so.1 /lib/i386-linux-gnu/libudev.so.0`\n这样nw就可以正常运行了.\n\n****\n\n##switchysharp\nswitchysharp的教程太多了,不管使用ssh还是shadowssocks,或者是goagent等各种代理都要用到它.教程一搜一大堆.\n这里就不多说,仅给出我的设置.\n在shadowsocks里面save好账号信息后,在chrome的switchysharp里做如下设置.\n![](http://youthy-picture.qiniudn.com/%E9%80%89%E5%8C%BA_012.png)\n主要将对应的端口写成shadowsocks的本地端口(我的是1080).\n如果使用自动切换模式需要改下下面的自动切换规则.我把googleapis和google-analytics加入了进去.\n![](http://youthy-picture.qiniudn.com/%E9%80%89%E5%8C%BA_013.png)\n顺便把stackoverflow和另外一个stackoverflow调用的但是耗时长的网址加了进去\n![](http://youthy-picture.qiniudn.com/%E9%80%89%E5%8C%BA_014.png)\n保存后就基本完工了.\n##我们可以看到googleapis的加载速度一下子提升了很多\n![](http://youthy-picture.qiniudn.com/%E9%80%89%E5%8C%BA_015.png)\n可以顺畅了浏览stackoverflow了,\n顺便玩玩舰娘...\n\n","slug":"Linux下代理实现shadowsocks","published":1,"updated":"2018-06-26T09:49:27.733Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqw7jdvn00086f1rfp6360jp","content":"<p>#linux下的代理:shadowsocks </p>\n<hr>\n<p>之前为了玩舰娘,从淘宝上买了个日本ip的ssh,用ssh过了一段翻墙的日子,后来舰娘玩的少了,ssh没怎么用,再后来一上ssh竟然无效了.反正也没多大需求了后来就没管它.再后来当我要用到stackoverflow查阅些东西时,发现竟然加载奇慢.<br>其实并不是stackoverflow被墙了.而是它调用的一些服务被墙了.</p>\n<span id=\"more\"></span>\n<p>##测试阶段<br>打开chrome,我们按ctrl+shift+I调出network这个审查面板(也可以按右键选择&quot;审查元素&quot;).然后在地址栏输入<code>stackoverflow.com</code>我们可以看到究竟是什么东西加载的这么慢.<br><img src=\"http://youthy-picture.qiniudn.com/%E9%80%89%E5%8C%BA_008.png\" alt=\"\"><br>可以看到红名的那个加载项.相比大家心里清楚什么原因....毕竟最近google的服务根本没法用....<br>所以我需要</p>\n<blockquote>\n<ol>\n<li>shadowsocks代理客户端</li>\n<li>一个shadowsocks账号</li>\n<li>chrome switchysharp插件</li>\n</ol>\n</blockquote>\n<hr>\n<p>##shadowsocks账号<br>可以从淘宝买,很便宜,3块一个月2G流量,8元一个月40G流量,足够用了.如果没有账号,接下来的部分就不用看了.</p>\n<p>##shadowsock安装<br>我推荐用shadowsock-gui这个图形界面.<br><a href=\"https://github.com/shadowsocks/shadowsocks-gui\">github地址</a><br>上面安装方法写的很详细了.可以选择直接DOWNLOAD的方法,下载一个tar.gz的包,然后在终端运行</p>\n<p> <code>tar -xvzf shadowsocks-gui-0.1.3-linux-ia32.tar.gz(我下载的版本)</code></p>\n<p>解压出来就可以了.<br>喜欢鼓捣的人可以用DEVELOP的方法安装.<br>无论怎么安装,最后进入shadowsock的根目录,直接双击nw这个文件就可以,或者用终端<code>cd</code>到所在目录,执行<code>./nw</code>都可以打开shadowsock-gui.<br>界面如下<br><img src=\"http://youthy-picture.qiniudn.com/%E9%80%89%E5%8C%BA_009.png\" alt=\"\"></p>\n<blockquote>\n<p><strong>注意</strong>:如果双击nw无反应,或者<code>./nw</code>后报了错:<br><code>error while loading shared libraries: libudev.so.0: can not open shared object  file:No such file or directory</code><br>说明我们的这个库程序找不到.<br>在终端中执行 <code>locate libudev.so</code><br><img src=\"http://youthy-picture.qiniudn.com/%E9%80%89%E5%8C%BA_011.png\" alt=\"\"><br>可以看到libudev.so在lib/i386-linux-gnu下,我们需要执行一下软连接命令<br><code>sudo ln -s /lib/i386-linux-gnu/libudev.so.1 /lib/i386-linux-gnu/libudev.so.0</code><br>这样nw就可以正常运行了.</p>\n</blockquote>\n<hr>\n<p>##switchysharp<br>switchysharp的教程太多了,不管使用ssh还是shadowssocks,或者是goagent等各种代理都要用到它.教程一搜一大堆.<br>这里就不多说,仅给出我的设置.<br>在shadowsocks里面save好账号信息后,在chrome的switchysharp里做如下设置.<br><img src=\"http://youthy-picture.qiniudn.com/%E9%80%89%E5%8C%BA_012.png\" alt=\"\"><br>主要将对应的端口写成shadowsocks的本地端口(我的是1080).<br>如果使用自动切换模式需要改下下面的自动切换规则.我把googleapis和google-analytics加入了进去.<br><img src=\"http://youthy-picture.qiniudn.com/%E9%80%89%E5%8C%BA_013.png\" alt=\"\"><br>顺便把stackoverflow和另外一个stackoverflow调用的但是耗时长的网址加了进去<br><img src=\"http://youthy-picture.qiniudn.com/%E9%80%89%E5%8C%BA_014.png\" alt=\"\"><br>保存后就基本完工了.</p>\n<p>##我们可以看到googleapis的加载速度一下子提升了很多<br><img src=\"http://youthy-picture.qiniudn.com/%E9%80%89%E5%8C%BA_015.png\" alt=\"\"><br>可以顺畅了浏览stackoverflow了,<br>顺便玩玩舰娘...</p>\n","site":{"data":{}},"excerpt":"<p>#linux下的代理:shadowsocks </p>\n<hr>\n<p>之前为了玩舰娘,从淘宝上买了个日本ip的ssh,用ssh过了一段翻墙的日子,后来舰娘玩的少了,ssh没怎么用,再后来一上ssh竟然无效了.反正也没多大需求了后来就没管它.再后来当我要用到stackoverflow查阅些东西时,发现竟然加载奇慢.<br>其实并不是stackoverflow被墙了.而是它调用的一些服务被墙了.</p>","more":"<p>##测试阶段<br>打开chrome,我们按ctrl+shift+I调出network这个审查面板(也可以按右键选择&quot;审查元素&quot;).然后在地址栏输入<code>stackoverflow.com</code>我们可以看到究竟是什么东西加载的这么慢.<br><img src=\"http://youthy-picture.qiniudn.com/%E9%80%89%E5%8C%BA_008.png\" alt=\"\"><br>可以看到红名的那个加载项.相比大家心里清楚什么原因....毕竟最近google的服务根本没法用....<br>所以我需要</p>\n<blockquote>\n<ol>\n<li>shadowsocks代理客户端</li>\n<li>一个shadowsocks账号</li>\n<li>chrome switchysharp插件</li>\n</ol>\n</blockquote>\n<hr>\n<p>##shadowsocks账号<br>可以从淘宝买,很便宜,3块一个月2G流量,8元一个月40G流量,足够用了.如果没有账号,接下来的部分就不用看了.</p>\n<p>##shadowsock安装<br>我推荐用shadowsock-gui这个图形界面.<br><a href=\"https://github.com/shadowsocks/shadowsocks-gui\">github地址</a><br>上面安装方法写的很详细了.可以选择直接DOWNLOAD的方法,下载一个tar.gz的包,然后在终端运行</p>\n<p> <code>tar -xvzf shadowsocks-gui-0.1.3-linux-ia32.tar.gz(我下载的版本)</code></p>\n<p>解压出来就可以了.<br>喜欢鼓捣的人可以用DEVELOP的方法安装.<br>无论怎么安装,最后进入shadowsock的根目录,直接双击nw这个文件就可以,或者用终端<code>cd</code>到所在目录,执行<code>./nw</code>都可以打开shadowsock-gui.<br>界面如下<br><img src=\"http://youthy-picture.qiniudn.com/%E9%80%89%E5%8C%BA_009.png\" alt=\"\"></p>\n<blockquote>\n<p><strong>注意</strong>:如果双击nw无反应,或者<code>./nw</code>后报了错:<br><code>error while loading shared libraries: libudev.so.0: can not open shared object  file:No such file or directory</code><br>说明我们的这个库程序找不到.<br>在终端中执行 <code>locate libudev.so</code><br><img src=\"http://youthy-picture.qiniudn.com/%E9%80%89%E5%8C%BA_011.png\" alt=\"\"><br>可以看到libudev.so在lib/i386-linux-gnu下,我们需要执行一下软连接命令<br><code>sudo ln -s /lib/i386-linux-gnu/libudev.so.1 /lib/i386-linux-gnu/libudev.so.0</code><br>这样nw就可以正常运行了.</p>\n</blockquote>\n<hr>\n<p>##switchysharp<br>switchysharp的教程太多了,不管使用ssh还是shadowssocks,或者是goagent等各种代理都要用到它.教程一搜一大堆.<br>这里就不多说,仅给出我的设置.<br>在shadowsocks里面save好账号信息后,在chrome的switchysharp里做如下设置.<br><img src=\"http://youthy-picture.qiniudn.com/%E9%80%89%E5%8C%BA_012.png\" alt=\"\"><br>主要将对应的端口写成shadowsocks的本地端口(我的是1080).<br>如果使用自动切换模式需要改下下面的自动切换规则.我把googleapis和google-analytics加入了进去.<br><img src=\"http://youthy-picture.qiniudn.com/%E9%80%89%E5%8C%BA_013.png\" alt=\"\"><br>顺便把stackoverflow和另外一个stackoverflow调用的但是耗时长的网址加了进去<br><img src=\"http://youthy-picture.qiniudn.com/%E9%80%89%E5%8C%BA_014.png\" alt=\"\"><br>保存后就基本完工了.</p>\n<p>##我们可以看到googleapis的加载速度一下子提升了很多<br><img src=\"http://youthy-picture.qiniudn.com/%E9%80%89%E5%8C%BA_015.png\" alt=\"\"><br>可以顺畅了浏览stackoverflow了,<br>顺便玩玩舰娘...</p>"},{"title":"Markdown所能识别代码高亮的语言","date":"2014-06-26T12:33:52.000Z","_content":"##markdown能识别大约41语言,以下是一些例子\n\n\n****\n\n##支持的语言列表\n<!--more-->\n|Python |Ruby |Haml |Perl|PHP |Scala|Go|XML|HTML|Lasso|Markdown|AscllDoc|\n\n|Django|Handlebars|CSS|SCSS|JSON|JavaScript|CoffeScript|ActionScript|VBScript|\n\n|VB.NET|HTTP|Lua|AppleScript|Delphi|Oxygene|Java|C++|objectivec|Vala|C#|\n\n|F#|OCaml|D|rsl|rib|MEL|GLSL|SQL|SmallTalk|Lisp|Clojure|\n\n|ini|Apache|nginx|Diff|dos|bash|makefile|cmake|axapta|ruleslanguage|\n\n|1c|avrasm|vhdl|parser3|livecodeserver|tex|brainfuck|haskell|erlang|\n\n|erlang-repl|rust|matlab|scllab|r|mizar|mathematica|autohotkey|fix|\n　\n##Python\n```Python\ndef somefunc(param1='', param2=0):\n    r'''A docstring'''\n    if param1 > param2: # interesting\n        print 'Gre\\'ater'\n    return (param2 - param1 + 1 + 0b10l) or None\n\nclass SomeClass:\n    pass\n\n>>> message = '''interpreter\n... prompt'''\n```\n\n##Ruby\n```Ruby\nclass A < B; def self.create(object = User) object end end\nclass Zebra; def inspect; \"X#{2 + self.object_id}\" end end\nmodule ABC::DEF\n  include Comparable\n  # @param test\n  # @return [String] nothing\n  def foo(test)\n    Thread.new do |blockvar|\n      ABC::DEF.reverse(:a_symbol, :'a symbol', :<=>, 'test' + ?\\012)\n      answer = valid?4 && valid?CONST && ?A && ?A.ord\n    end.join\n  end\n```\n\n##Perl\n```Perl\nsub load\n{\n  my $flds = $c->db_load($id,@_) || do {\n    Carp::carp \"Can`t load (class: $c, id: $id): '$!'\"; return undef\n  };\n  my $o = $c->_perl_new();\n  $id12 = $id / 24 / 3600;\n  $o->{'ID'} = $id12 + 123;\n  #$o->{'SHCUT'} = $flds->{'SHCUT'};\n  my $p = $o->props;\n  my $vt;\n  $string =~ m/^sought_text$/;\n  $items = split //, 'abc';\n  $string //= \"bar\";\n  for my $key (keys %$p)\n  {\n    if(${$vt.'::property'}) {\n      $o->{$key . '_real'} = $flds->{$key};\n      tie $o->{$key}, 'CMSBuilder::Property', $o, $key;\n    }\n  }\n  $o->save if delete $o->{'_save_after_load'};\n  return $o;\n}\n```\n\n##PHP\n```PHP\nrequire_once 'Zend/Uri/Http.php';\n\nnamespace Location\\Web;\n\ninterface Factory\n{\n    static function _factory();\n}\n\nabstract class URI extends BaseURI implements Factory\n{\n    abstract function test();\n\n    /**\n     * Returns a URI\n     *\n     * @return URI\n     */\n    static public function _factory($stats = array(), $uri = 'http')\n    {\n        echo __METHOD__;\n        $uri = explode(':', $uri, 0b10);\n        $schemeSpecific = isset($uri[1]) ? $uri[1] : '';\n        $desc = 'Multi\nline description';\n\n        // Security check\n        if (!ctype_alnum($scheme)) {\n            throw new Zend_Uri_Exception('Illegal scheme');\n        }\n\n        return [\n            'uri'   => $uri,\n            'value' => null,\n        ];\n    }\n}\n```\n\n#Scala\n```Scala\nobject abstractTypes extends Application {\n  abstract class SeqBuffer {\n    type T; val element: Seq[T]; def length = element.length\n  }\n}\n\n/** Turn command line arguments to uppercase */\nobject Main {\n  def main(args: Array[String]) {\n    val res = for (a <- args) yield a.toUpperCase\n    println(\"Arguments: \" + res.toString)\n  }\n}\n```\n","source":"_posts/Markdown所能识别代码高亮的语言.md","raw":"title: Markdown所能识别代码高亮的语言\ndate: 2014-06-26 20:33:52\ntags: markdown\ncategories: markdown\n---\n##markdown能识别大约41语言,以下是一些例子\n\n\n****\n\n##支持的语言列表\n<!--more-->\n|Python |Ruby |Haml |Perl|PHP |Scala|Go|XML|HTML|Lasso|Markdown|AscllDoc|\n\n|Django|Handlebars|CSS|SCSS|JSON|JavaScript|CoffeScript|ActionScript|VBScript|\n\n|VB.NET|HTTP|Lua|AppleScript|Delphi|Oxygene|Java|C++|objectivec|Vala|C#|\n\n|F#|OCaml|D|rsl|rib|MEL|GLSL|SQL|SmallTalk|Lisp|Clojure|\n\n|ini|Apache|nginx|Diff|dos|bash|makefile|cmake|axapta|ruleslanguage|\n\n|1c|avrasm|vhdl|parser3|livecodeserver|tex|brainfuck|haskell|erlang|\n\n|erlang-repl|rust|matlab|scllab|r|mizar|mathematica|autohotkey|fix|\n　\n##Python\n```Python\ndef somefunc(param1='', param2=0):\n    r'''A docstring'''\n    if param1 > param2: # interesting\n        print 'Gre\\'ater'\n    return (param2 - param1 + 1 + 0b10l) or None\n\nclass SomeClass:\n    pass\n\n>>> message = '''interpreter\n... prompt'''\n```\n\n##Ruby\n```Ruby\nclass A < B; def self.create(object = User) object end end\nclass Zebra; def inspect; \"X#{2 + self.object_id}\" end end\nmodule ABC::DEF\n  include Comparable\n  # @param test\n  # @return [String] nothing\n  def foo(test)\n    Thread.new do |blockvar|\n      ABC::DEF.reverse(:a_symbol, :'a symbol', :<=>, 'test' + ?\\012)\n      answer = valid?4 && valid?CONST && ?A && ?A.ord\n    end.join\n  end\n```\n\n##Perl\n```Perl\nsub load\n{\n  my $flds = $c->db_load($id,@_) || do {\n    Carp::carp \"Can`t load (class: $c, id: $id): '$!'\"; return undef\n  };\n  my $o = $c->_perl_new();\n  $id12 = $id / 24 / 3600;\n  $o->{'ID'} = $id12 + 123;\n  #$o->{'SHCUT'} = $flds->{'SHCUT'};\n  my $p = $o->props;\n  my $vt;\n  $string =~ m/^sought_text$/;\n  $items = split //, 'abc';\n  $string //= \"bar\";\n  for my $key (keys %$p)\n  {\n    if(${$vt.'::property'}) {\n      $o->{$key . '_real'} = $flds->{$key};\n      tie $o->{$key}, 'CMSBuilder::Property', $o, $key;\n    }\n  }\n  $o->save if delete $o->{'_save_after_load'};\n  return $o;\n}\n```\n\n##PHP\n```PHP\nrequire_once 'Zend/Uri/Http.php';\n\nnamespace Location\\Web;\n\ninterface Factory\n{\n    static function _factory();\n}\n\nabstract class URI extends BaseURI implements Factory\n{\n    abstract function test();\n\n    /**\n     * Returns a URI\n     *\n     * @return URI\n     */\n    static public function _factory($stats = array(), $uri = 'http')\n    {\n        echo __METHOD__;\n        $uri = explode(':', $uri, 0b10);\n        $schemeSpecific = isset($uri[1]) ? $uri[1] : '';\n        $desc = 'Multi\nline description';\n\n        // Security check\n        if (!ctype_alnum($scheme)) {\n            throw new Zend_Uri_Exception('Illegal scheme');\n        }\n\n        return [\n            'uri'   => $uri,\n            'value' => null,\n        ];\n    }\n}\n```\n\n#Scala\n```Scala\nobject abstractTypes extends Application {\n  abstract class SeqBuffer {\n    type T; val element: Seq[T]; def length = element.length\n  }\n}\n\n/** Turn command line arguments to uppercase */\nobject Main {\n  def main(args: Array[String]) {\n    val res = for (a <- args) yield a.toUpperCase\n    println(\"Arguments: \" + res.toString)\n  }\n}\n```\n","slug":"Markdown所能识别代码高亮的语言","published":1,"updated":"2018-06-26T09:49:27.733Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqw7jdvo00096f1rf2az3t5m","content":"<p>##markdown能识别大约41语言,以下是一些例子</p>\n<hr>\n<p>##支持的语言列表<br><span id=\"more\"></span><br>|Python |Ruby |Haml |Perl|PHP |Scala|Go|XML|HTML|Lasso|Markdown|AscllDoc|</p>\n<p>|Django|Handlebars|CSS|SCSS|JSON|JavaScript|CoffeScript|ActionScript|VBScript|</p>\n<p>|VB.NET|HTTP|Lua|AppleScript|Delphi|Oxygene|Java|C++|objectivec|Vala|C#|</p>\n<p>|F#|OCaml|D|rsl|rib|MEL|GLSL|SQL|SmallTalk|Lisp|Clojure|</p>\n<p>|ini|Apache|nginx|Diff|dos|bash|makefile|cmake|axapta|ruleslanguage|</p>\n<p>|1c|avrasm|vhdl|parser3|livecodeserver|tex|brainfuck|haskell|erlang|</p>\n<p>|erlang-repl|rust|matlab|scllab|r|mizar|mathematica|autohotkey|fix|\n　</p>\n<p>##Python<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">somefunc</span>(<span class=\"params\">param1=<span class=\"string\">&#x27;&#x27;</span>, param2=<span class=\"number\">0</span></span>):</span></span><br><span class=\"line\">    <span class=\"string\">r&#x27;&#x27;&#x27;A docstring&#x27;&#x27;&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> param1 &gt; param2: <span class=\"comment\"># interesting</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span> <span class=\"string\">&#x27;Gre\\&#x27;ater&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (param2 - param1 + <span class=\"number\">1</span> + <span class=\"number\">0b10l</span>) <span class=\"keyword\">or</span> <span class=\"literal\">None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeClass</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>message = <span class=\"string\">&#x27;&#x27;&#x27;interpreter</span></span><br><span class=\"line\"><span class=\"string\"><span class=\"meta\">... </span>prompt&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></p>\n<p>##Ruby<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> &lt; B;</span> def <span class=\"keyword\">self</span>.create(object = User) object <span class=\"keyword\">end</span> <span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Zebra</span>;</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">inspect</span>;</span> <span class=\"string\">&quot;X<span class=\"subst\">#&#123;<span class=\"number\">2</span> + <span class=\"keyword\">self</span>.object_id&#125;</span>&quot;</span> <span class=\"keyword\">end</span> <span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">module</span> <span class=\"title\">ABC::DEF</span></span></span><br><span class=\"line\">  <span class=\"keyword\">include</span> Comparable</span><br><span class=\"line\">  <span class=\"comment\"># <span class=\"doctag\">@param</span> test</span></span><br><span class=\"line\">  <span class=\"comment\"># <span class=\"doctag\">@return</span> [String] nothing</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">foo</span><span class=\"params\">(test)</span></span></span><br><span class=\"line\">    Thread.new <span class=\"keyword\">do</span> <span class=\"params\">|blockvar|</span></span><br><span class=\"line\">      ABC::DEF.reverse(<span class=\"symbol\">:a_symbol</span>, <span class=\"symbol\">:<span class=\"string\">&#x27;a symbol&#x27;</span></span>, <span class=\"symbol\">:&lt;=&gt;</span>, <span class=\"string\">&#x27;test&#x27;</span> + <span class=\"string\">?\\012</span>)</span><br><span class=\"line\">      answer = valid?<span class=\"number\">4</span> &amp;&amp; valid?CONST &amp;&amp; <span class=\"string\">?A</span> &amp;&amp; <span class=\"string\">?A</span>.ord</span><br><span class=\"line\">    <span class=\"keyword\">end</span>.join</span><br><span class=\"line\">  <span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure></p>\n<p>##Perl<br><figure class=\"highlight perl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">sub</span> <span class=\"title\">load</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">my</span> $flds = $c-&gt;db_load($id,@_) || <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">    Carp::carp <span class=\"string\">&quot;Can`t load (class: $c, id: $id): &#x27;$!&#x27;&quot;</span>; <span class=\"keyword\">return</span> <span class=\"keyword\">undef</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">my</span> $o = $c-&gt;_perl_new();</span><br><span class=\"line\">  $id12 = $id / <span class=\"number\">24</span> / <span class=\"number\">3600</span>;</span><br><span class=\"line\">  $o-&gt;&#123;<span class=\"string\">&#x27;ID&#x27;</span>&#125; = $id12 + <span class=\"number\">123</span>;</span><br><span class=\"line\">  <span class=\"comment\">#$o-&gt;&#123;&#x27;SHCUT&#x27;&#125; = $flds-&gt;&#123;&#x27;SHCUT&#x27;&#125;;</span></span><br><span class=\"line\">  <span class=\"keyword\">my</span> $p = $o-&gt;props;</span><br><span class=\"line\">  <span class=\"keyword\">my</span> $vt;</span><br><span class=\"line\">  $string =~ <span class=\"regexp\">m/^sought_text$/</span>;</span><br><span class=\"line\">  $items = <span class=\"keyword\">split</span> <span class=\"regexp\">//</span>, <span class=\"string\">&#x27;abc&#x27;</span>;</span><br><span class=\"line\">  $string //= <span class=\"string\">&quot;bar&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> <span class=\"keyword\">my</span> $key (<span class=\"keyword\">keys</span> %$p)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>($&#123;$vt.<span class=\"string\">&#x27;::property&#x27;</span>&#125;) &#123;</span><br><span class=\"line\">      $o-&gt;&#123;$key . <span class=\"string\">&#x27;_real&#x27;</span>&#125; = $flds-&gt;&#123;$key&#125;;</span><br><span class=\"line\">      <span class=\"keyword\">tie</span> $o-&gt;&#123;$key&#125;, <span class=\"string\">&#x27;CMSBuilder::Property&#x27;</span>, $o, $key;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  $o-&gt;save <span class=\"keyword\">if</span> <span class=\"keyword\">delete</span> $o-&gt;&#123;<span class=\"string\">&#x27;_save_after_load&#x27;</span>&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> $o;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>##PHP<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">require_once</span> <span class=\"string\">&#x27;Zend/Uri/Http.php&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title\">Location</span>\\<span class=\"title\">Web</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Factory</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">static</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_factory</span>(<span class=\"params\"></span>)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">URI</span> <span class=\"keyword\">extends</span> <span class=\"title\">BaseURI</span> <span class=\"keyword\">implements</span> <span class=\"title\">Factory</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Returns a URI</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> URI</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"built_in\">static</span> <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_factory</span>(<span class=\"params\"><span class=\"variable\">$stats</span> = <span class=\"keyword\">array</span>(<span class=\"params\"></span>), <span class=\"variable\">$uri</span> = <span class=\"string\">&#x27;http&#x27;</span></span>)</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">echo</span> <span class=\"keyword\">__METHOD__</span>;</span><br><span class=\"line\">        <span class=\"variable\">$uri</span> = explode(<span class=\"string\">&#x27;:&#x27;</span>, <span class=\"variable\">$uri</span>, <span class=\"number\">0b10</span>);</span><br><span class=\"line\">        <span class=\"variable\">$schemeSpecific</span> = <span class=\"keyword\">isset</span>(<span class=\"variable\">$uri</span>[<span class=\"number\">1</span>]) ? <span class=\"variable\">$uri</span>[<span class=\"number\">1</span>] : <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">        <span class=\"variable\">$desc</span> = <span class=\"string\">&#x27;Multi</span></span><br><span class=\"line\"><span class=\"string\">line description&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Security check</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!ctype_alnum(<span class=\"variable\">$scheme</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Zend_Uri_Exception(<span class=\"string\">&#x27;Illegal scheme&#x27;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> [</span><br><span class=\"line\">            <span class=\"string\">&#x27;uri&#x27;</span>   =&gt; <span class=\"variable\">$uri</span>,</span><br><span class=\"line\">            <span class=\"string\">&#x27;value&#x27;</span> =&gt; <span class=\"literal\">null</span>,</span><br><span class=\"line\">        ];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>#Scala<br><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">abstractTypes</span> <span class=\"keyword\">extends</span> <span class=\"title\">Application</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SeqBuffer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">T</span></span>; <span class=\"keyword\">val</span> element: <span class=\"type\">Seq</span>[<span class=\"type\">T</span>]; <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">length</span> </span>= element.length</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** Turn command line arguments to uppercase */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> res = <span class=\"keyword\">for</span> (a &lt;- args) <span class=\"keyword\">yield</span> a.toUpperCase</span><br><span class=\"line\">    println(<span class=\"string\">&quot;Arguments: &quot;</span> + res.toString)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>##markdown能识别大约41语言,以下是一些例子</p>\n<hr>\n<p>##支持的语言列表<br>","more":"<br>|Python |Ruby |Haml |Perl|PHP |Scala|Go|XML|HTML|Lasso|Markdown|AscllDoc|</p>\n<p>|Django|Handlebars|CSS|SCSS|JSON|JavaScript|CoffeScript|ActionScript|VBScript|</p>\n<p>|VB.NET|HTTP|Lua|AppleScript|Delphi|Oxygene|Java|C++|objectivec|Vala|C#|</p>\n<p>|F#|OCaml|D|rsl|rib|MEL|GLSL|SQL|SmallTalk|Lisp|Clojure|</p>\n<p>|ini|Apache|nginx|Diff|dos|bash|makefile|cmake|axapta|ruleslanguage|</p>\n<p>|1c|avrasm|vhdl|parser3|livecodeserver|tex|brainfuck|haskell|erlang|</p>\n<p>|erlang-repl|rust|matlab|scllab|r|mizar|mathematica|autohotkey|fix|\n　</p>\n<p>##Python<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">somefunc</span>(<span class=\"params\">param1=<span class=\"string\">&#x27;&#x27;</span>, param2=<span class=\"number\">0</span></span>):</span></span><br><span class=\"line\">    <span class=\"string\">r&#x27;&#x27;&#x27;A docstring&#x27;&#x27;&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> param1 &gt; param2: <span class=\"comment\"># interesting</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span> <span class=\"string\">&#x27;Gre\\&#x27;ater&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (param2 - param1 + <span class=\"number\">1</span> + <span class=\"number\">0b10l</span>) <span class=\"keyword\">or</span> <span class=\"literal\">None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeClass</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>message = <span class=\"string\">&#x27;&#x27;&#x27;interpreter</span></span><br><span class=\"line\"><span class=\"string\"><span class=\"meta\">... </span>prompt&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></p>\n<p>##Ruby<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> &lt; B;</span> def <span class=\"keyword\">self</span>.create(object = User) object <span class=\"keyword\">end</span> <span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Zebra</span>;</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">inspect</span>;</span> <span class=\"string\">&quot;X<span class=\"subst\">#&#123;<span class=\"number\">2</span> + <span class=\"keyword\">self</span>.object_id&#125;</span>&quot;</span> <span class=\"keyword\">end</span> <span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">module</span> <span class=\"title\">ABC::DEF</span></span></span><br><span class=\"line\">  <span class=\"keyword\">include</span> Comparable</span><br><span class=\"line\">  <span class=\"comment\"># <span class=\"doctag\">@param</span> test</span></span><br><span class=\"line\">  <span class=\"comment\"># <span class=\"doctag\">@return</span> [String] nothing</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">foo</span><span class=\"params\">(test)</span></span></span><br><span class=\"line\">    Thread.new <span class=\"keyword\">do</span> <span class=\"params\">|blockvar|</span></span><br><span class=\"line\">      ABC::DEF.reverse(<span class=\"symbol\">:a_symbol</span>, <span class=\"symbol\">:<span class=\"string\">&#x27;a symbol&#x27;</span></span>, <span class=\"symbol\">:&lt;=&gt;</span>, <span class=\"string\">&#x27;test&#x27;</span> + <span class=\"string\">?\\012</span>)</span><br><span class=\"line\">      answer = valid?<span class=\"number\">4</span> &amp;&amp; valid?CONST &amp;&amp; <span class=\"string\">?A</span> &amp;&amp; <span class=\"string\">?A</span>.ord</span><br><span class=\"line\">    <span class=\"keyword\">end</span>.join</span><br><span class=\"line\">  <span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure></p>\n<p>##Perl<br><figure class=\"highlight perl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">sub</span> <span class=\"title\">load</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">my</span> $flds = $c-&gt;db_load($id,@_) || <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">    Carp::carp <span class=\"string\">&quot;Can`t load (class: $c, id: $id): &#x27;$!&#x27;&quot;</span>; <span class=\"keyword\">return</span> <span class=\"keyword\">undef</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">my</span> $o = $c-&gt;_perl_new();</span><br><span class=\"line\">  $id12 = $id / <span class=\"number\">24</span> / <span class=\"number\">3600</span>;</span><br><span class=\"line\">  $o-&gt;&#123;<span class=\"string\">&#x27;ID&#x27;</span>&#125; = $id12 + <span class=\"number\">123</span>;</span><br><span class=\"line\">  <span class=\"comment\">#$o-&gt;&#123;&#x27;SHCUT&#x27;&#125; = $flds-&gt;&#123;&#x27;SHCUT&#x27;&#125;;</span></span><br><span class=\"line\">  <span class=\"keyword\">my</span> $p = $o-&gt;props;</span><br><span class=\"line\">  <span class=\"keyword\">my</span> $vt;</span><br><span class=\"line\">  $string =~ <span class=\"regexp\">m/^sought_text$/</span>;</span><br><span class=\"line\">  $items = <span class=\"keyword\">split</span> <span class=\"regexp\">//</span>, <span class=\"string\">&#x27;abc&#x27;</span>;</span><br><span class=\"line\">  $string //= <span class=\"string\">&quot;bar&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> <span class=\"keyword\">my</span> $key (<span class=\"keyword\">keys</span> %$p)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>($&#123;$vt.<span class=\"string\">&#x27;::property&#x27;</span>&#125;) &#123;</span><br><span class=\"line\">      $o-&gt;&#123;$key . <span class=\"string\">&#x27;_real&#x27;</span>&#125; = $flds-&gt;&#123;$key&#125;;</span><br><span class=\"line\">      <span class=\"keyword\">tie</span> $o-&gt;&#123;$key&#125;, <span class=\"string\">&#x27;CMSBuilder::Property&#x27;</span>, $o, $key;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  $o-&gt;save <span class=\"keyword\">if</span> <span class=\"keyword\">delete</span> $o-&gt;&#123;<span class=\"string\">&#x27;_save_after_load&#x27;</span>&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> $o;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>##PHP<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">require_once</span> <span class=\"string\">&#x27;Zend/Uri/Http.php&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title\">Location</span>\\<span class=\"title\">Web</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Factory</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">static</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_factory</span>(<span class=\"params\"></span>)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">URI</span> <span class=\"keyword\">extends</span> <span class=\"title\">BaseURI</span> <span class=\"keyword\">implements</span> <span class=\"title\">Factory</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Returns a URI</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> URI</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"built_in\">static</span> <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_factory</span>(<span class=\"params\"><span class=\"variable\">$stats</span> = <span class=\"keyword\">array</span>(<span class=\"params\"></span>), <span class=\"variable\">$uri</span> = <span class=\"string\">&#x27;http&#x27;</span></span>)</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">echo</span> <span class=\"keyword\">__METHOD__</span>;</span><br><span class=\"line\">        <span class=\"variable\">$uri</span> = explode(<span class=\"string\">&#x27;:&#x27;</span>, <span class=\"variable\">$uri</span>, <span class=\"number\">0b10</span>);</span><br><span class=\"line\">        <span class=\"variable\">$schemeSpecific</span> = <span class=\"keyword\">isset</span>(<span class=\"variable\">$uri</span>[<span class=\"number\">1</span>]) ? <span class=\"variable\">$uri</span>[<span class=\"number\">1</span>] : <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">        <span class=\"variable\">$desc</span> = <span class=\"string\">&#x27;Multi</span></span><br><span class=\"line\"><span class=\"string\">line description&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Security check</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!ctype_alnum(<span class=\"variable\">$scheme</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Zend_Uri_Exception(<span class=\"string\">&#x27;Illegal scheme&#x27;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> [</span><br><span class=\"line\">            <span class=\"string\">&#x27;uri&#x27;</span>   =&gt; <span class=\"variable\">$uri</span>,</span><br><span class=\"line\">            <span class=\"string\">&#x27;value&#x27;</span> =&gt; <span class=\"literal\">null</span>,</span><br><span class=\"line\">        ];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>#Scala<br><figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">abstractTypes</span> <span class=\"keyword\">extends</span> <span class=\"title\">Application</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SeqBuffer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">T</span></span>; <span class=\"keyword\">val</span> element: <span class=\"type\">Seq</span>[<span class=\"type\">T</span>]; <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">length</span> </span>= element.length</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** Turn command line arguments to uppercase */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span></span>(args: <span class=\"type\">Array</span>[<span class=\"type\">String</span>]) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">val</span> res = <span class=\"keyword\">for</span> (a &lt;- args) <span class=\"keyword\">yield</span> a.toUpperCase</span><br><span class=\"line\">    println(<span class=\"string\">&quot;Arguments: &quot;</span> + res.toString)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>"},{"title":"Regex 正则表达式","date":"2016-05-06T07:56:24.000Z","_content":"\n1. \"regex\" 精确的匹配 regex这个词\n2. 上面可能会把\"regex2\"这种词的前面也匹配到。此时需要\"\\bregex\\b\" \n\n<!--more-->\n> \\b是正则表达式规定的一个特殊代码（好吧，某些人叫它元字符，metacharacter），代表着单词的开头或结尾，也就是单词的分界处。虽然通常英文的单词是由空格，标点符号或者换行来分隔的，但是\\b并不匹配这些单词分隔字符中的任何一个，它只匹配一个位置。\n\n**erlang中需要用`\\\\` 代表 `\\`**\n> The Erlang literal syntax for strings uses the \"\\\" (backslash) character as an escape code. You need to escape backslashes in literal strings, both in your code and in the shell, with an additional backslash, i.e.: \"\\\\\".\n\n```\n14> re:run(\"hey hi hihi\", \"hi\", [global]).\n{match,[[{4,2}],[{7,2}],[{9,2}]]}\n15> re:run(\"hey hi hihi\", \"\\\\bhi\\\\b\", [global]).\n{match,[[{4,2}]]}\n```\n\n3. `.` 表示匹配出了换行的任意字符 `*` 表示任意数量。 表示`*`前面的字符可以重复任意个 比如\".*\", \"h*\", \"2*\" 匹配任意字符，任意个h，任意个2\n\n4. `\\d` 匹配数字。 `\"4\\d\\d\\d\\d\\d\\d\\d\"` 匹配4开头的8位数字。也可以写成`\"4\\d{7}\"`  \"\\d{7, 10}\" 表示7到10个不等\n\\d在erlang中同样需要换成`\\\\d`\n\n\n>.\t匹配除换行符以外的任意字符\n\\w\t匹配字母或数字或下划线或汉字\n\\s\t匹配任意的空白符\n\\d\t匹配数字\n\\b\t匹配单词的开始或结束\n^\t匹配字符串的开始\n$\t匹配字符串的结束\n\n\n> 表2.常用的限定符\n代码/语法\t说明\n*\t重复零次或更多次\n+\t重复一次或更多次\n?\t重复零次或一次\n{n}\t重复n次\n{n,}\t重复n次或更多次\n{n,m}\t重复n到m次\n\n5. \"[aeiou]\" 规定一个字符集。 比如\"[0-9]\"就与\"\\d\"一致。\n6. 分组 \"(2[0-4]\\d){2,3}\" 括号扩起来的部分是一组。重复2,3次。\n7. 反义\n> 表3.常用的反义代码\n代码/语法\t说明\n\\W\t匹配任意不是字母，数字，下划线，汉字的字符\n\\S\t匹配任意不是空白符的字符\n\\D\t匹配任意非数字的字符\n\\B\t匹配不是单词开头或结束的位置\n[^x]\t匹配除了x以外的任意字符\n[^aeiou]\t匹配除了aeiou这几个字母以外的任意字符\n\n8. 后向引用 可以给分组命名 通过\"\\1\"或\"\\name\"再次匹配这个分组\n> 表4.常用分组语法\n分类\t代码/语法\t说明\n捕获\t(exp)\t匹配exp,并捕获文本到自动命名的组里\n(?<name>exp)\t匹配exp,并捕获文本到名称为name的组里，也可以写成(?'name'exp)\n(?:exp)\t匹配exp,不捕获匹配的文本，也不给此分组分配组号\n零宽断言\t(?=exp)\t匹配exp前面的位置\n(?<=exp)\t匹配exp后面的位置\n(?!exp)\t匹配后面跟的不是exp的位置\n(?<!exp)\t匹配前面不是exp的位置\n注释\t(?#comment)\t这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读\n\n9. 懒惰匹配\n默认情况下 \"h.*p\" 匹配最长的开头为h尾部为p的中间为任意个字符的字符串 称贪婪匹配\n\"happy\" => \"happ\"\n如果使用\"h.*?p\" 将匹配得到的最短的字符串。称为懒惰匹配\n\"happy\" => \"hap\"\n`?`可以放在任意限定符的后面比如\n>表5.懒惰限定符\n代码/语法\t说明\n*?\t重复任意次，但尽可能少重复\n+?\t重复1次或更多次，但尽可能少重复\n??\t重复0次或1次，但尽可能少重复\n{n,m}?\t重复n到m次，但尽可能少重复\n{n,}?\t重复n次以上，但尽可能少重复\n","source":"_posts/Regex-正则表达式.md","raw":"title: Regex 正则表达式\ndate: 2016-05-06 15:56:24\ntags: [erlang, vim]\n\n---\n\n1. \"regex\" 精确的匹配 regex这个词\n2. 上面可能会把\"regex2\"这种词的前面也匹配到。此时需要\"\\bregex\\b\" \n\n<!--more-->\n> \\b是正则表达式规定的一个特殊代码（好吧，某些人叫它元字符，metacharacter），代表着单词的开头或结尾，也就是单词的分界处。虽然通常英文的单词是由空格，标点符号或者换行来分隔的，但是\\b并不匹配这些单词分隔字符中的任何一个，它只匹配一个位置。\n\n**erlang中需要用`\\\\` 代表 `\\`**\n> The Erlang literal syntax for strings uses the \"\\\" (backslash) character as an escape code. You need to escape backslashes in literal strings, both in your code and in the shell, with an additional backslash, i.e.: \"\\\\\".\n\n```\n14> re:run(\"hey hi hihi\", \"hi\", [global]).\n{match,[[{4,2}],[{7,2}],[{9,2}]]}\n15> re:run(\"hey hi hihi\", \"\\\\bhi\\\\b\", [global]).\n{match,[[{4,2}]]}\n```\n\n3. `.` 表示匹配出了换行的任意字符 `*` 表示任意数量。 表示`*`前面的字符可以重复任意个 比如\".*\", \"h*\", \"2*\" 匹配任意字符，任意个h，任意个2\n\n4. `\\d` 匹配数字。 `\"4\\d\\d\\d\\d\\d\\d\\d\"` 匹配4开头的8位数字。也可以写成`\"4\\d{7}\"`  \"\\d{7, 10}\" 表示7到10个不等\n\\d在erlang中同样需要换成`\\\\d`\n\n\n>.\t匹配除换行符以外的任意字符\n\\w\t匹配字母或数字或下划线或汉字\n\\s\t匹配任意的空白符\n\\d\t匹配数字\n\\b\t匹配单词的开始或结束\n^\t匹配字符串的开始\n$\t匹配字符串的结束\n\n\n> 表2.常用的限定符\n代码/语法\t说明\n*\t重复零次或更多次\n+\t重复一次或更多次\n?\t重复零次或一次\n{n}\t重复n次\n{n,}\t重复n次或更多次\n{n,m}\t重复n到m次\n\n5. \"[aeiou]\" 规定一个字符集。 比如\"[0-9]\"就与\"\\d\"一致。\n6. 分组 \"(2[0-4]\\d){2,3}\" 括号扩起来的部分是一组。重复2,3次。\n7. 反义\n> 表3.常用的反义代码\n代码/语法\t说明\n\\W\t匹配任意不是字母，数字，下划线，汉字的字符\n\\S\t匹配任意不是空白符的字符\n\\D\t匹配任意非数字的字符\n\\B\t匹配不是单词开头或结束的位置\n[^x]\t匹配除了x以外的任意字符\n[^aeiou]\t匹配除了aeiou这几个字母以外的任意字符\n\n8. 后向引用 可以给分组命名 通过\"\\1\"或\"\\name\"再次匹配这个分组\n> 表4.常用分组语法\n分类\t代码/语法\t说明\n捕获\t(exp)\t匹配exp,并捕获文本到自动命名的组里\n(?<name>exp)\t匹配exp,并捕获文本到名称为name的组里，也可以写成(?'name'exp)\n(?:exp)\t匹配exp,不捕获匹配的文本，也不给此分组分配组号\n零宽断言\t(?=exp)\t匹配exp前面的位置\n(?<=exp)\t匹配exp后面的位置\n(?!exp)\t匹配后面跟的不是exp的位置\n(?<!exp)\t匹配前面不是exp的位置\n注释\t(?#comment)\t这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读\n\n9. 懒惰匹配\n默认情况下 \"h.*p\" 匹配最长的开头为h尾部为p的中间为任意个字符的字符串 称贪婪匹配\n\"happy\" => \"happ\"\n如果使用\"h.*?p\" 将匹配得到的最短的字符串。称为懒惰匹配\n\"happy\" => \"hap\"\n`?`可以放在任意限定符的后面比如\n>表5.懒惰限定符\n代码/语法\t说明\n*?\t重复任意次，但尽可能少重复\n+?\t重复1次或更多次，但尽可能少重复\n??\t重复0次或1次，但尽可能少重复\n{n,m}?\t重复n到m次，但尽可能少重复\n{n,}?\t重复n次以上，但尽可能少重复\n","slug":"Regex-正则表达式","published":1,"updated":"2018-06-26T09:49:27.733Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqw7jdvq000d6f1rgwgjhwv1","content":"<ol>\n<li>&quot;regex&quot; 精确的匹配 regex这个词</li>\n<li>上面可能会把&quot;regex2&quot;这种词的前面也匹配到。此时需要&quot;\\bregex\\b&quot; </li>\n</ol>\n<span id=\"more\"></span>\n<blockquote>\n<p>\\b是正则表达式规定的一个特殊代码（好吧，某些人叫它元字符，metacharacter），代表着单词的开头或结尾，也就是单词的分界处。虽然通常英文的单词是由空格，标点符号或者换行来分隔的，但是\\b并不匹配这些单词分隔字符中的任何一个，它只匹配一个位置。</p>\n</blockquote>\n<p><strong>erlang中需要用<code>\\\\</code> 代表 <code>\\</code></strong></p>\n<blockquote>\n<p>The Erlang literal syntax for strings uses the &quot;\\&quot; (backslash) character as an escape code. You need to escape backslashes in literal strings, both in your code and in the shell, with an additional backslash, i.e.: &quot;\\&quot;.</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">14&gt; re:run(&quot;hey hi hihi&quot;, &quot;hi&quot;, [global]).</span><br><span class=\"line\">&#123;match,[[&#123;4,2&#125;],[&#123;7,2&#125;],[&#123;9,2&#125;]]&#125;</span><br><span class=\"line\">15&gt; re:run(&quot;hey hi hihi&quot;, &quot;\\\\bhi\\\\b&quot;, [global]).</span><br><span class=\"line\">&#123;match,[[&#123;4,2&#125;]]&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li><p><code>.</code> 表示匹配出了换行的任意字符 <code>*</code> 表示任意数量。 表示<code>*</code>前面的字符可以重复任意个 比如&quot;.<em>&quot;, &quot;h</em>&quot;, &quot;2*&quot; 匹配任意字符，任意个h，任意个2</p>\n</li>\n<li><p><code>\\d</code> 匹配数字。 <code>&quot;4\\d\\d\\d\\d\\d\\d\\d&quot;</code> 匹配4开头的8位数字。也可以写成<code>&quot;4\\d&#123;7&#125;&quot;</code>  &quot;\\d{7, 10}&quot; 表示7到10个不等<br>\\d在erlang中同样需要换成<code>\\\\d</code></p>\n</li>\n</ol>\n<blockquote>\n<p>.    匹配除换行符以外的任意字符<br>\\w    匹配字母或数字或下划线或汉字<br>\\s    匹配任意的空白符<br>\\d    匹配数字<br>\\b    匹配单词的开始或结束<br>^    匹配字符串的开始<br>$    匹配字符串的结束</p>\n</blockquote>\n<blockquote>\n<p>表2.常用的限定符<br>代码/语法    说明</p>\n<ul>\n<li>重复零次或更多次</li>\n</ul>\n<ul>\n<li>重复一次或更多次<br>?    重复零次或一次<br>{n}    重复n次<br>{n,}    重复n次或更多次<br>{n,m}    重复n到m次</li>\n</ul>\n</blockquote>\n<ol start=\"5\">\n<li>&quot;[aeiou]&quot; 规定一个字符集。 比如&quot;[0-9]&quot;就与&quot;\\d&quot;一致。</li>\n<li>分组 &quot;(2[0-4]\\d){2,3}&quot; 括号扩起来的部分是一组。重复2,3次。</li>\n<li><p>反义</p>\n<blockquote>\n<p>表3.常用的反义代码<br>代码/语法    说明<br>\\W    匹配任意不是字母，数字，下划线，汉字的字符<br>\\S    匹配任意不是空白符的字符<br>\\D    匹配任意非数字的字符<br>\\B    匹配不是单词开头或结束的位置<br>[^x]    匹配除了x以外的任意字符<br>[^aeiou]    匹配除了aeiou这几个字母以外的任意字符</p>\n</blockquote>\n</li>\n<li><p>后向引用 可以给分组命名 通过&quot;\\1&quot;或&quot;\\name&quot;再次匹配这个分组</p>\n<blockquote>\n<p>表4.常用分组语法<br>分类    代码/语法    说明<br>捕获    (exp)    匹配exp,并捕获文本到自动命名的组里<br>(?<name>exp)    匹配exp,并捕获文本到名称为name的组里，也可以写成(?&#39;name&#39;exp)<br>(?:exp)    匹配exp,不捕获匹配的文本，也不给此分组分配组号<br>零宽断言    (?=exp)    匹配exp前面的位置<br>(?&lt;=exp)    匹配exp后面的位置<br>(?!exp)    匹配后面跟的不是exp的位置<br>(?&lt;!exp)    匹配前面不是exp的位置<br>注释    (?#comment)    这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读</p>\n</blockquote>\n</li>\n<li><p>懒惰匹配<br>默认情况下 &quot;h.<em>p&quot; 匹配最长的开头为h尾部为p的中间为任意个字符的字符串 称贪婪匹配<br>&quot;happy&quot; =&gt; &quot;happ&quot;<br>如果使用&quot;h.</em>?p&quot; 将匹配得到的最短的字符串。称为懒惰匹配<br>&quot;happy&quot; =&gt; &quot;hap&quot;<br><code>?</code>可以放在任意限定符的后面比如</p>\n<blockquote>\n<p>表5.懒惰限定符<br>代码/语法    说明<br>*?    重复任意次，但尽可能少重复<br>+?    重复1次或更多次，但尽可能少重复<br>??    重复0次或1次，但尽可能少重复<br>{n,m}?    重复n到m次，但尽可能少重复<br>{n,}?    重复n次以上，但尽可能少重复</p>\n</blockquote>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<ol>\n<li>&quot;regex&quot; 精确的匹配 regex这个词</li>\n<li>上面可能会把&quot;regex2&quot;这种词的前面也匹配到。此时需要&quot;\\bregex\\b&quot; </li>\n</ol>","more":"<blockquote>\n<p>\\b是正则表达式规定的一个特殊代码（好吧，某些人叫它元字符，metacharacter），代表着单词的开头或结尾，也就是单词的分界处。虽然通常英文的单词是由空格，标点符号或者换行来分隔的，但是\\b并不匹配这些单词分隔字符中的任何一个，它只匹配一个位置。</p>\n</blockquote>\n<p><strong>erlang中需要用<code>\\\\</code> 代表 <code>\\</code></strong></p>\n<blockquote>\n<p>The Erlang literal syntax for strings uses the &quot;\\&quot; (backslash) character as an escape code. You need to escape backslashes in literal strings, both in your code and in the shell, with an additional backslash, i.e.: &quot;\\&quot;.</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">14&gt; re:run(&quot;hey hi hihi&quot;, &quot;hi&quot;, [global]).</span><br><span class=\"line\">&#123;match,[[&#123;4,2&#125;],[&#123;7,2&#125;],[&#123;9,2&#125;]]&#125;</span><br><span class=\"line\">15&gt; re:run(&quot;hey hi hihi&quot;, &quot;\\\\bhi\\\\b&quot;, [global]).</span><br><span class=\"line\">&#123;match,[[&#123;4,2&#125;]]&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li><p><code>.</code> 表示匹配出了换行的任意字符 <code>*</code> 表示任意数量。 表示<code>*</code>前面的字符可以重复任意个 比如&quot;.<em>&quot;, &quot;h</em>&quot;, &quot;2*&quot; 匹配任意字符，任意个h，任意个2</p>\n</li>\n<li><p><code>\\d</code> 匹配数字。 <code>&quot;4\\d\\d\\d\\d\\d\\d\\d&quot;</code> 匹配4开头的8位数字。也可以写成<code>&quot;4\\d&#123;7&#125;&quot;</code>  &quot;\\d{7, 10}&quot; 表示7到10个不等<br>\\d在erlang中同样需要换成<code>\\\\d</code></p>\n</li>\n</ol>\n<blockquote>\n<p>.    匹配除换行符以外的任意字符<br>\\w    匹配字母或数字或下划线或汉字<br>\\s    匹配任意的空白符<br>\\d    匹配数字<br>\\b    匹配单词的开始或结束<br>^    匹配字符串的开始<br>$    匹配字符串的结束</p>\n</blockquote>\n<blockquote>\n<p>表2.常用的限定符<br>代码/语法    说明</p>\n<ul>\n<li>重复零次或更多次</li>\n</ul>\n<ul>\n<li>重复一次或更多次<br>?    重复零次或一次<br>{n}    重复n次<br>{n,}    重复n次或更多次<br>{n,m}    重复n到m次</li>\n</ul>\n</blockquote>\n<ol start=\"5\">\n<li>&quot;[aeiou]&quot; 规定一个字符集。 比如&quot;[0-9]&quot;就与&quot;\\d&quot;一致。</li>\n<li>分组 &quot;(2[0-4]\\d){2,3}&quot; 括号扩起来的部分是一组。重复2,3次。</li>\n<li><p>反义</p>\n<blockquote>\n<p>表3.常用的反义代码<br>代码/语法    说明<br>\\W    匹配任意不是字母，数字，下划线，汉字的字符<br>\\S    匹配任意不是空白符的字符<br>\\D    匹配任意非数字的字符<br>\\B    匹配不是单词开头或结束的位置<br>[^x]    匹配除了x以外的任意字符<br>[^aeiou]    匹配除了aeiou这几个字母以外的任意字符</p>\n</blockquote>\n</li>\n<li><p>后向引用 可以给分组命名 通过&quot;\\1&quot;或&quot;\\name&quot;再次匹配这个分组</p>\n<blockquote>\n<p>表4.常用分组语法<br>分类    代码/语法    说明<br>捕获    (exp)    匹配exp,并捕获文本到自动命名的组里<br>(?<name>exp)    匹配exp,并捕获文本到名称为name的组里，也可以写成(?&#39;name&#39;exp)<br>(?:exp)    匹配exp,不捕获匹配的文本，也不给此分组分配组号<br>零宽断言    (?=exp)    匹配exp前面的位置<br>(?&lt;=exp)    匹配exp后面的位置<br>(?!exp)    匹配后面跟的不是exp的位置<br>(?&lt;!exp)    匹配前面不是exp的位置<br>注释    (?#comment)    这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读</p>\n</blockquote>\n</li>\n<li><p>懒惰匹配<br>默认情况下 &quot;h.<em>p&quot; 匹配最长的开头为h尾部为p的中间为任意个字符的字符串 称贪婪匹配<br>&quot;happy&quot; =&gt; &quot;happ&quot;<br>如果使用&quot;h.</em>?p&quot; 将匹配得到的最短的字符串。称为懒惰匹配<br>&quot;happy&quot; =&gt; &quot;hap&quot;<br><code>?</code>可以放在任意限定符的后面比如</p>\n<blockquote>\n<p>表5.懒惰限定符<br>代码/语法    说明<br>*?    重复任意次，但尽可能少重复<br>+?    重复1次或更多次，但尽可能少重复<br>??    重复0次或1次，但尽可能少重复<br>{n,m}?    重复n到m次，但尽可能少重复<br>{n,}?    重复n次以上，但尽可能少重复</p>\n</blockquote>\n</li>\n</ol>"},{"title":"[erlang_question]gen_server and init","date":"2015-07-31T08:11:50.000Z","_content":"\n\n\n\n<!-- toc -->\n\n<!--more-->\n## 小技巧?\n这两天复习了一下[Erlang and OTP in action](http://zh.scribd.com/doc/87376094/Erlang-and-OTP-in-Action#scribd)\n其中讲到gen_server的时候，作者用了个小技巧。如下。\n![](http://storage4.static.itmages.com/i/15/0731/h_1438311976_3257184_46c6e8b7c0.png)\n\n![](http://storage1.static.itmages.com/i/15/0731/h_1438312022_8979746_d612eb6d7f.png)\n\n![](http://storage4.static.itmages.com/i/15/0731/h_1438311785_2601988_b290e0c784.png)\n> 第三章图片的引用里handle_call应该是handle_info,此处有错误\n\n作者的意思时如果在init的返回中设置了timeout参数为0，会在init结束后会立即向自己发送一个timeout参数。并且由handle_info(timeout...)处理。意思是可以让一些耗时高的初始化操作在handle_info(timeout。。）里面处理，而让init尽快返回。\n**本以为是个不错的小技巧，结果却有些隐患**\n\n## Question\n这两天的mailist正好有人遇到了这个问题。\n[[erlang_question]gen_server and init](http://erlang.org/pipermail/erlang-questions/2015-July/085314.html)\n问题如下：\n>***Matthew Evans***:\nHi,\nWe have used this pattern in gen_servers for a long time now:\ninit(_) ->   %% Some stuff   {ok, #state{}, 0}.\n%%%%%%\nhandle_info(timeout, State) ->    %% Init stuff    {noreply,State}\nBasically the idea is to prevent init from blocking and to have init/1 return with a timeout of 0 causing an immediate timeout message to be invoked in the handle_info.\nHere's what's odd. Sometimes this timeout does not fire. It doesn't appear that any message is getting sent, but I would imagine that since it's a registered gen_server there is no way that can happen.\nDoes anyone have any ideas?\nWe are running vsn 17.1, and ntp is enabled on the host (Linux).\nThanks \t\t \t   \t\t  \n\n提问者与作者的思路一样，想要在timeout里面做些初始化操作。然而却没想到timeout并没有触发。\n以下摘取一些回答。\n## Answers:\n### ***Sergej Jurečko***:\n>If something is in the message queue before init is done executing, that timeout will never get called. Timeout means execute only if nothing else happens during. You should be using self() ! timeout \n如果在init没有完成之前消息队列里面存在消息，timeout将永远不会调用。应该使用self()!timeout这种方式\n\n### ***Loïc Hoguin***(cowboy 作者）\n>This and sending yourself a message is a bad idea. It will usually work, \nuntil it doesn't, and you will have a very hard time figuring out why.\nInstead, start the process using proc_lib:spawn_link or \nproc_lib:start_link (depending on whether it needs to be synchronous or \nnot), then perform your initialization (calling proc_lib:init_ack where \nappropriate), and finally calling gen_server:enter_loop.\nWhat this gives you is pretty much the ability to customize the \ninitialization of your gen_server process.\nThis is the correct way to do it. Your solution can fail if you receive \na message. Sending yourself a message is subject to race conditions \nwhere you receive a message before you could init.\n大体意思说这个方式是bad idea。应该使用proc_lib:spawn_link, proc_lib:start_link, proc_lib:init_ack, gen_server:enter_loop等。\n\n### ***Max Lapshin***\n>Loic is right, but you should understand that you can receive message\nbefore your  \"self() ! init\" message only if you explicitly tell your pid\nsomeone in init()  because before the end of init your pid is unknown to\nothers.\nLoic是对的～但是你应该明白除非你在init的过程中将自己的pid告诉其他进程才会在init返回之前接到消息，因为init没有完成之前，pid对其他是未知的。\n\n### ***Loïc Hoguin***\n>(Had problems pasting so hope it's all OK!)\n\n>I'm not sure what you wrote there but I can give you two scenarios where \nit can fail off the top of my head. The first is very unlikely and can \nonly fail if you use the 0 timeout, while the second is actually much \neasier to observe and can fail with both methods:\n\n>P1 calls start_link\nP2 init (returns 0 timeout)\nP2 yields before calling receive\nP1 returns from start_link and sends P2 a message\nP2 receives message\n\n>And:\n\n>P1 calls start_link\nP2 in init subscribes to some kind of pubsub PS\nPS sends P2 message(s)\nP2 returns from init and receive those messages\n\n>I'm not sure why your tool doesn't catch the first case, Concuerror \n*definitely does*, and without needing to write all this weird code too. :-)\n\n>Here is the module:\n```\n-module(z).\n-behaviour(gen_server).\n\n-export([start_link/0]).\n\n%% Operational API\n-export([read/0]).\n\n%% gen_server API\n-export([\n          init/1,\n          handle_cast/2,\n          handle_call/3,\n          terminate/2,\n          code_change/3,\n          handle_info/2,\n\t\t test/0\n]).\n\ntest() ->\n\tstart_link(),\n\tready = read(),\n\tstop().\n\n%% API\nstart_link() ->\n     gen_server:start({local, ?MODULE}, ?MODULE, [], []).\n\nread() ->\n     gen_server:call(?MODULE, read).\n\nstop() ->\n\tgen_server:call(?MODULE, stop).\n\n%% Callbacks\ninit([]) ->\n     {ok, initializing, 0}.\n\nhandle_call(read, _From, State) ->\n     {reply, State, State};\nhandle_call(stop, _, State) ->\n\t{stop, normal, ok, stop}.\n\nhandle_cast(_M, State) ->\n     {noreply, State}.\n\nhandle_info(timeout, _State) ->\n     {noreply, ready}.\n\nterminate(_How, _State) ->\n     ok.\n\ncode_change(_OldVsn, State, _Extra) ->\n     {ok, State}.\n```\n（注：handle_call(stop, _, State)的State应该是_State, 否则编译不过).\n\n## Test\nLoic给出了一个module，用concuerror进行了测试，这个模块的init中指定timeout为0，然后handle_info(timeout。。。）并没有触发。\nconcuerror是一个用来测试erlang中一些看起来没有问题的程序，但是在并行情况下可能发生的问题的工具。\n参考\n[官网](http://concuerror.com/)\n[concuerror tutorial](http://concuerror.com/tutorials/poolboy-example/)\n[github](https://github.com/parapluu/Concuerror)\n以下是我运行的结果。\n```\nyouthy@youthy:~/code/Concuerror$ ./concuerror -f \"../etest/z.erl\" -m z -t test --after_timeout 1000 \nconcuerror: WARNING: file ../etest/z.erl shadows the default ./z.beam\nConcuerror started at 31 Jul 2015 07:21:55\nWriting results in concuerror_report.txt\n\nInfo: Instrumented z\nInfo: Instrumented io_lib\nInfo: Instrumented gen_server\nInfo: Instrumented gen\nInfo: Instrumented proc_lib\nInfo: Instrumented erlang\nInfo: Instrumented init\nInfo: Instrumented sys\nInfo: You can see pairs of racing instructions (in the report and --graph) with '--show_races true'\nError: Stop testing on first error. (Check '-h keep_going').\n\nDone! (Exit status: warning)\n  Summary: 1 errors, 4/4 interleavings explored\nyouthy@youthy:~/code/Concuerror$ vim concuerror_report.txt \n```\n\nconcuerror_report.txt:\n```\nErroneous interleaving 1:\n* At step 23 process P exited abnormally\n    Reason:\n      {{badmatch,initializing},\n       [{z,test,0,[{file,\"../etest/z.erl\"},{line,22}]}]}\n    Stacktrace:\n      [{z,test,0,[{file,\"../etest/z.erl\"},{line,22}]}]\n* Blocked at a 'receive' (when all other processes have exited):\n    P.1 in gen_server.erl line 348\n--------------------------------------------------------------------------------\n\nInterleaving info:\n   1: P: undefined = erlang:whereis(z)\n    in gen.erl line 277\n   2: P: [] = erlang:process_info(P, registered_name)\n    in proc_lib.erl line 648\n   3: P: P.1 = erlang:spawn_opt({proc_lib,init_p,[P,[],gen,init_it,[gen_server,P,self,{local,z},z,[],[]]],[]})\n    in erlang.erl line 249\n   4: P.1: undefined = erlang:put('$ancestors', [P])\n    in proc_lib.erl line 221\n   5: P.1: undefined = erlang:put('$initial_call', {z,init,1})\n    in proc_lib.erl line 222\n   6: P.1: true = erlang:register(z, P.1)\n    in gen.erl line 280\n   7: P.1: {P.1,{get_argument,generic_debug}} = init ! {P.1,{get_argument,generic_debug}}\n    in init.erl line 145\n   8: Message ({P.1,{get_argument,generic_debug}}) from P.1 reaches init\n   9: Message ({init,error}) from init reaches P.1\n  10: P.1: receives message ({init,error})\n    in init.erl line 146\n  11: P.1: {ack,P.1,{ok,P.1}} = P ! {ack,P.1,{ok,P.1}}\n    in proc_lib.erl line 348\n  12: Message ({ack,P.1,{ok,P.1}}) from P.1 reaches P\n  13: P: receives message ({ack,P.1,{ok,P.1}})\n    in proc_lib.erl line 321\n  14: P: P.1 = erlang:whereis(z)\n    in gen.erl line 154\n  15: P: #Ref<0.0.0.176> = erlang:monitor(process, P.1)\n    in gen.erl line 204\n  16: P: {'$gen_call',{P,#Ref<0.0.0.176>},read} = erlang:send(P.1, {'$gen_call',{P,#Ref<0.0.0.176>},read}, [noconnect])\n    in gen.erl line 215\n  17: Message ({'$gen_call',{P,#Ref<0.0.0.176>},read}) from P reaches P.1\n  18: P.1: receives message ({'$gen_call',{P,#Ref<0.0.0.176>},read})\n    in gen_server.erl line 348\n  19: P.1: {#Ref<0.0.0.176>,initializing} = P ! {#Ref<0.0.0.176>,initializing}\n    in gen_server.erl line 214\n  20: Message ({#Ref<0.0.0.176>,initializing}) from P.1 reaches P\n  21: P: receives message ({#Ref<0.0.0.176>,initializing})\n    in gen.erl line 217\n  22: P: true = erlang:demonitor(#Ref<0.0.0.176>, [flush])\n    in gen.erl line 219\n  23: P: exits abnormally ({{badmatch,initializing},[{z,test,0,[{file,[46,46,47,101,116,101,115,116,47|...]},{line,22}]}]})\n```\n\n报告显示P进程（父进程)在第23步的时候崩溃了，错误原因时badmatch，z.erl的22行，即\n```\nready = read(),\n```\n\n此处read()返回的不是ready而是intiallizing，也就是handle_info(timeout...)并没有执行。\n上面的１～２３步显示了gen_server的创建过程.以及消息传递过程。十分详细。不过需要挖掘下gen_server的源码才能看懂。\n\n## gen_server的创建过程\n下面分析下gen_server的创建过程。假设我们创建一个{local, test}的进程，并传入Args作为初始化参数，Opts为进程的设置参数.\n\n### gen_server:\n```\nstart_link({local, test}, test, Args, Opts) ->\n   gen:start(gen_server,  link, {local, test}, test, Args, Opts).\n```\n\n### gen:\n```\nstart(gen_server, link, {local, test}, test, Args, Opts) ->\n     case where({local, test}) of %检测名字是否注册\n       undefined ->\n          do_spawn(gen_server, link, {local, test}, test, Args, Opts);\n        Pid ->\n           {error, {already_started, Pid}}\n      end.\n```\n```\ndo_spawn(gen_server, link, {local, test}, test, Args, Opts) ->\n        Time = somefun(Opts) % 提取出Opt中的timeout参数, \n        proc_lib:start_link(gen, init_it, \n        [gen_server, self(), self(), {local, test}, test, Args, Opts], Time, spawn_opts(Opts)).\n```\n\n> 此处spawn_opts的作用时查找Opts中有没有spawn_opt这个选项，否则为[].\n\n### proc_lib:\n上面self()一般情况下为supervisor的Pid。\n```\nstart_link(gen, init_it, [gen_server, Sup, Sup, {local, test}, test, Args, Opts], Timeout, Opts|[]) ->\n  Pid = proc_lib:spawn_opt(gen, init_it, [gen_server, SelfPid, SelfPid, {local, test}, test, Args, Opts|[]], ensure_link(Opts|[])), %ensure_link尝试将link加入Opts\n  sync_wait(Pid, Timeout).\n```\n\n```\nspawn_opt(gen, init_it, [gen_server, selfPid, SelfPid, {local, test}, test, Args, Opts], [link]|[link, Opts]) ->\n   Parent = ......%获取当前进程registername为父进程\n   Ancestors = ....% 获取进程字典中的$ancestors的值\n   check_for_monitor([link]|[link,Opts])....% 检测monitor这个参数在不在其中，在的话直接抛出错误。 \n   erlang:spawn_opt(proc_lib, init_p, [Parent, Ancestors, gen, init_it, [gen_server, SelfPid....Opts],[link]|[link, Opts]).\n```\n\n```\nsync_wait(Pid, TimeOut) ->\n  receive \n  {ack, Pid, Return} ->\n    Return;\n  {'EXIT', Pid, Reason} ->\n    {error, Reason}\n  after TimeOut ->\n    unlink(Pid),\n    exit(Pid, kill),\n    flush(Pid),\n    {error, timeout}\n   end.\n```\n\nerlang:spawn_opt与spawn类似，只不过支持一些option。所以调用的还是proc_lib的init_p。\n```\ninit_p(Parent, Ancestors, gen, init_it, [gen_server, Sup, Sup, {local, test}, test, Args, Opts|[]], [link|[link, Opts]) ->\n  put('ancestors', [Parent|Ancestors]),\n  put('initial_call', trans_init(gen, init_it, [gen_server, Sup.....])),\n  init_p_do_apply(gen, init_it, [gen_server, Sup, Sup....]).\n```\n\n其中trans_init的结果返回为{Module, init, 1} 即 {test, init, 1}.\n```\ninit_p_do_apply(gen, init_it, [gen_server, Sup, Sup, {local, test}, test, Args, Opts|[]]) ->\n    try\n\tapply(gen, init_it, [gen_server, Sup... Opts]) \n    catch\n\tClass:Reason ->\n\t    exit_p(Class, Reason)\n    end.\n```\n\nexit_p里面格式化一些错误信息，并用error_logger输出\n\n### gen\n```\ninit_it(gen_server, Sup, Sup, {local, test}, test, Args, Opts|[]) ->\n    case name_register({local, test}) of\n\ttrue ->\n\t    init_it2(gen_server, Sup, Sup, {local, test}, test, Args, Opts|[]);\n\t{false, Pid} ->\n\t    proc_lib:init_ack(Sup, {error, {already_started, Pid}})\n    end.\n```\n\n```\nname_register({local, Name} = LN) ->\n    try register(Name, self()) of\n\ttrue -> true\n    catch\n\terror:_ ->\n\t    {false, where(LN)}\n    end;\n```\n\n```\ninit_it2(gen_server, Sup, Sup, {local, test}, test, Args, Opts|[]) ->\n   gen_server:init_it(Sup, Sup, {local, test}, test, Args, Opts|[]).\n```\n\n### gen_server:\n```\ninit_it(Sup, Sup, {local, test}, test, Args, Opts|[]) ->\n    test = name({local, test}),\n    Debug = debug_options(Name, Opts|[]),\n    case catch test:init(Args) of\n\t{ok, State} ->\n\t    proc_lib:init_ack(Sup, {ok, self()}), \t    \n\t    loop(Sup, test, State, test, infinity, Debug);\n\t{ok, State, Timeout} ->\n\t    proc_lib:init_ack(Sup, {ok, self()}), \t    \n\t    loop(Sup, test, State, test, Timeout, Debug);\n\t{stop, Reason} ->\n\t    unregister_name(test),\n\t    proc_lib:init_ack(Sup, {error, Reason}),\n\t    exit(Reason);\n\tignore ->\n\t    unregister_name(test),\n\t    proc_lib:init_ack(Sup, ignore),\n\t    exit(normal);\n\t{'EXIT', Reason} ->\n\t    unregister_name(test),\n\t    proc_lib:init_ack(Sup, {error, Reason}),\n\t    exit(Reason);\n\tElse ->\n\t    Error = {bad_return_value, Else},\n\t    proc_lib:init_ack(Sup, {error, Error}),\n\t    exit(Error)\n    end.\n```\n\n### proc_lib\n```\ninit_ack(Sup, {ok, Pid}|{error, already_exited}) ->\n    Parent ! {ack, self(), {ok, Pid}}|{error, already_exited}},\n    ok.\n```\n\n```\nloop(Sup, test, State, test, Timeout, Debug) ->\n    Msg = receive\n\t      Input ->\n\t\t    Input\n\t  after Time ->\n\t\t  timeout\n\t  end,\n    decode_msg(Msg, Parent, Name, State, Mod, Time, Debug, false).\n```\n至此gen_server初始化完成。\n。\n由此得知。gen_server再调用test：init之前，主要做了\n1. 判断名字是否被占用，否则报{error, already_exited}\n2. 写入ancestors和initial call\n\nOpts中的timeout参数主要用来衡量创建进程的time，超时回结束进程并返回。而{ok， State， Timeout}的timeout参数用来参与loop循环，在进程创建后timeout时间内没有接到消息，就会像自己发送timeout这个消息。 而且这个参数在之后的handle_call, handle_cast,handle_info等回调中，使可以修改timeout的数值。参考源码：\n```\nhandle_msg({'$gen_call', From, Msg}, Parent, Name, State, Mod, Debug) ->\n    case catch Mod:handle_call(Msg, From, State) of\n\t{reply, Reply, NState} ->\n\t    Debug1 = reply(Name, From, Reply, NState, Debug),\n\t    loop(Parent, Name, NState, Mod, infinity, Debug1);\n\t{reply, Reply, NState, Time1} ->\n\t    Debug1 = reply(Name, From, Reply, NState, Debug),\n\t    loop(Parent, Name, NState, Mod, Time1, Debug1);\n\t{noreply, NState} ->\n\t    Debug1 = sys:handle_debug(Debug, fun print_event/3, Name,\n\t\t\t\t      {noreply, NState}),\n\t    loop(Parent, Name, NState, Mod, infinity, Debug1);\n\t{noreply, NState, Time1} ->\n\t    Debug1 = sys:handle_debug(Debug, fun print_event/3, Name,\n\t\t\t\t      {noreply, NState}),\n\t    loop(Parent, Name, NState, Mod, Time1, Debug1);\n\t{stop, Reason, Reply, NState} ->\n\t    {'EXIT', R} = \n\t\t(catch terminate(Reason, Name, Msg, Mod, NState, Debug)),\n\t    reply(Name, From, Reply, NState, Debug),\n\t    exit(R);\n\tOther ->\n\t    handle_common_reply(Other, Parent, Name, Msg, Mod, State, Debug)\n    end;\n```\n\n可见handle_call的返回值如果包含Time1，就会修改loop的Timeout参数。\n\n## where is the point?\n问题出现在\n```\n\t{ok, State, Timeout} ->\n\t    proc_lib:init_ack(Sup, {ok, self()}), \t    \n\t    loop(Sup, test, State, test, Timeout, Debug);\n```\n\nＰ进程创建Ｐ.1进程，然后进入receive，期待一个{ack, Pid, Return}的回复。在init结束返回{ok, State, Timeout}后，proc_lib:init_ack完成了向P发送{ack, Pid, Return}的任务。然后进入ｌｏｏｐ循环。但这时Ｐ进程接到消息后立刻发送了read.导致timeout并没有发送出去。造成badmatch的结果。\n\n在一种情况，其实在name_register的时候名字和Ｐｉｄ就已经注册好了。但此时甚至没有进入ｉｎｉｔ函数，如果有其他进程朝test名字的ｓｅｒｖｅｒ发送消息，自然会导致ｔｉｍｅｏｕｔ的失效。\n\n\n","source":"_posts/erlang-question-gen-server-and-init.md","raw":"title: '[erlang_question]gen_server and init'\ndate: 2015-07-31 16:11:50\ntags: erlang\n---\n\n\n\n\n<!-- toc -->\n\n<!--more-->\n## 小技巧?\n这两天复习了一下[Erlang and OTP in action](http://zh.scribd.com/doc/87376094/Erlang-and-OTP-in-Action#scribd)\n其中讲到gen_server的时候，作者用了个小技巧。如下。\n![](http://storage4.static.itmages.com/i/15/0731/h_1438311976_3257184_46c6e8b7c0.png)\n\n![](http://storage1.static.itmages.com/i/15/0731/h_1438312022_8979746_d612eb6d7f.png)\n\n![](http://storage4.static.itmages.com/i/15/0731/h_1438311785_2601988_b290e0c784.png)\n> 第三章图片的引用里handle_call应该是handle_info,此处有错误\n\n作者的意思时如果在init的返回中设置了timeout参数为0，会在init结束后会立即向自己发送一个timeout参数。并且由handle_info(timeout...)处理。意思是可以让一些耗时高的初始化操作在handle_info(timeout。。）里面处理，而让init尽快返回。\n**本以为是个不错的小技巧，结果却有些隐患**\n\n## Question\n这两天的mailist正好有人遇到了这个问题。\n[[erlang_question]gen_server and init](http://erlang.org/pipermail/erlang-questions/2015-July/085314.html)\n问题如下：\n>***Matthew Evans***:\nHi,\nWe have used this pattern in gen_servers for a long time now:\ninit(_) ->   %% Some stuff   {ok, #state{}, 0}.\n%%%%%%\nhandle_info(timeout, State) ->    %% Init stuff    {noreply,State}\nBasically the idea is to prevent init from blocking and to have init/1 return with a timeout of 0 causing an immediate timeout message to be invoked in the handle_info.\nHere's what's odd. Sometimes this timeout does not fire. It doesn't appear that any message is getting sent, but I would imagine that since it's a registered gen_server there is no way that can happen.\nDoes anyone have any ideas?\nWe are running vsn 17.1, and ntp is enabled on the host (Linux).\nThanks \t\t \t   \t\t  \n\n提问者与作者的思路一样，想要在timeout里面做些初始化操作。然而却没想到timeout并没有触发。\n以下摘取一些回答。\n## Answers:\n### ***Sergej Jurečko***:\n>If something is in the message queue before init is done executing, that timeout will never get called. Timeout means execute only if nothing else happens during. You should be using self() ! timeout \n如果在init没有完成之前消息队列里面存在消息，timeout将永远不会调用。应该使用self()!timeout这种方式\n\n### ***Loïc Hoguin***(cowboy 作者）\n>This and sending yourself a message is a bad idea. It will usually work, \nuntil it doesn't, and you will have a very hard time figuring out why.\nInstead, start the process using proc_lib:spawn_link or \nproc_lib:start_link (depending on whether it needs to be synchronous or \nnot), then perform your initialization (calling proc_lib:init_ack where \nappropriate), and finally calling gen_server:enter_loop.\nWhat this gives you is pretty much the ability to customize the \ninitialization of your gen_server process.\nThis is the correct way to do it. Your solution can fail if you receive \na message. Sending yourself a message is subject to race conditions \nwhere you receive a message before you could init.\n大体意思说这个方式是bad idea。应该使用proc_lib:spawn_link, proc_lib:start_link, proc_lib:init_ack, gen_server:enter_loop等。\n\n### ***Max Lapshin***\n>Loic is right, but you should understand that you can receive message\nbefore your  \"self() ! init\" message only if you explicitly tell your pid\nsomeone in init()  because before the end of init your pid is unknown to\nothers.\nLoic是对的～但是你应该明白除非你在init的过程中将自己的pid告诉其他进程才会在init返回之前接到消息，因为init没有完成之前，pid对其他是未知的。\n\n### ***Loïc Hoguin***\n>(Had problems pasting so hope it's all OK!)\n\n>I'm not sure what you wrote there but I can give you two scenarios where \nit can fail off the top of my head. The first is very unlikely and can \nonly fail if you use the 0 timeout, while the second is actually much \neasier to observe and can fail with both methods:\n\n>P1 calls start_link\nP2 init (returns 0 timeout)\nP2 yields before calling receive\nP1 returns from start_link and sends P2 a message\nP2 receives message\n\n>And:\n\n>P1 calls start_link\nP2 in init subscribes to some kind of pubsub PS\nPS sends P2 message(s)\nP2 returns from init and receive those messages\n\n>I'm not sure why your tool doesn't catch the first case, Concuerror \n*definitely does*, and without needing to write all this weird code too. :-)\n\n>Here is the module:\n```\n-module(z).\n-behaviour(gen_server).\n\n-export([start_link/0]).\n\n%% Operational API\n-export([read/0]).\n\n%% gen_server API\n-export([\n          init/1,\n          handle_cast/2,\n          handle_call/3,\n          terminate/2,\n          code_change/3,\n          handle_info/2,\n\t\t test/0\n]).\n\ntest() ->\n\tstart_link(),\n\tready = read(),\n\tstop().\n\n%% API\nstart_link() ->\n     gen_server:start({local, ?MODULE}, ?MODULE, [], []).\n\nread() ->\n     gen_server:call(?MODULE, read).\n\nstop() ->\n\tgen_server:call(?MODULE, stop).\n\n%% Callbacks\ninit([]) ->\n     {ok, initializing, 0}.\n\nhandle_call(read, _From, State) ->\n     {reply, State, State};\nhandle_call(stop, _, State) ->\n\t{stop, normal, ok, stop}.\n\nhandle_cast(_M, State) ->\n     {noreply, State}.\n\nhandle_info(timeout, _State) ->\n     {noreply, ready}.\n\nterminate(_How, _State) ->\n     ok.\n\ncode_change(_OldVsn, State, _Extra) ->\n     {ok, State}.\n```\n（注：handle_call(stop, _, State)的State应该是_State, 否则编译不过).\n\n## Test\nLoic给出了一个module，用concuerror进行了测试，这个模块的init中指定timeout为0，然后handle_info(timeout。。。）并没有触发。\nconcuerror是一个用来测试erlang中一些看起来没有问题的程序，但是在并行情况下可能发生的问题的工具。\n参考\n[官网](http://concuerror.com/)\n[concuerror tutorial](http://concuerror.com/tutorials/poolboy-example/)\n[github](https://github.com/parapluu/Concuerror)\n以下是我运行的结果。\n```\nyouthy@youthy:~/code/Concuerror$ ./concuerror -f \"../etest/z.erl\" -m z -t test --after_timeout 1000 \nconcuerror: WARNING: file ../etest/z.erl shadows the default ./z.beam\nConcuerror started at 31 Jul 2015 07:21:55\nWriting results in concuerror_report.txt\n\nInfo: Instrumented z\nInfo: Instrumented io_lib\nInfo: Instrumented gen_server\nInfo: Instrumented gen\nInfo: Instrumented proc_lib\nInfo: Instrumented erlang\nInfo: Instrumented init\nInfo: Instrumented sys\nInfo: You can see pairs of racing instructions (in the report and --graph) with '--show_races true'\nError: Stop testing on first error. (Check '-h keep_going').\n\nDone! (Exit status: warning)\n  Summary: 1 errors, 4/4 interleavings explored\nyouthy@youthy:~/code/Concuerror$ vim concuerror_report.txt \n```\n\nconcuerror_report.txt:\n```\nErroneous interleaving 1:\n* At step 23 process P exited abnormally\n    Reason:\n      {{badmatch,initializing},\n       [{z,test,0,[{file,\"../etest/z.erl\"},{line,22}]}]}\n    Stacktrace:\n      [{z,test,0,[{file,\"../etest/z.erl\"},{line,22}]}]\n* Blocked at a 'receive' (when all other processes have exited):\n    P.1 in gen_server.erl line 348\n--------------------------------------------------------------------------------\n\nInterleaving info:\n   1: P: undefined = erlang:whereis(z)\n    in gen.erl line 277\n   2: P: [] = erlang:process_info(P, registered_name)\n    in proc_lib.erl line 648\n   3: P: P.1 = erlang:spawn_opt({proc_lib,init_p,[P,[],gen,init_it,[gen_server,P,self,{local,z},z,[],[]]],[]})\n    in erlang.erl line 249\n   4: P.1: undefined = erlang:put('$ancestors', [P])\n    in proc_lib.erl line 221\n   5: P.1: undefined = erlang:put('$initial_call', {z,init,1})\n    in proc_lib.erl line 222\n   6: P.1: true = erlang:register(z, P.1)\n    in gen.erl line 280\n   7: P.1: {P.1,{get_argument,generic_debug}} = init ! {P.1,{get_argument,generic_debug}}\n    in init.erl line 145\n   8: Message ({P.1,{get_argument,generic_debug}}) from P.1 reaches init\n   9: Message ({init,error}) from init reaches P.1\n  10: P.1: receives message ({init,error})\n    in init.erl line 146\n  11: P.1: {ack,P.1,{ok,P.1}} = P ! {ack,P.1,{ok,P.1}}\n    in proc_lib.erl line 348\n  12: Message ({ack,P.1,{ok,P.1}}) from P.1 reaches P\n  13: P: receives message ({ack,P.1,{ok,P.1}})\n    in proc_lib.erl line 321\n  14: P: P.1 = erlang:whereis(z)\n    in gen.erl line 154\n  15: P: #Ref<0.0.0.176> = erlang:monitor(process, P.1)\n    in gen.erl line 204\n  16: P: {'$gen_call',{P,#Ref<0.0.0.176>},read} = erlang:send(P.1, {'$gen_call',{P,#Ref<0.0.0.176>},read}, [noconnect])\n    in gen.erl line 215\n  17: Message ({'$gen_call',{P,#Ref<0.0.0.176>},read}) from P reaches P.1\n  18: P.1: receives message ({'$gen_call',{P,#Ref<0.0.0.176>},read})\n    in gen_server.erl line 348\n  19: P.1: {#Ref<0.0.0.176>,initializing} = P ! {#Ref<0.0.0.176>,initializing}\n    in gen_server.erl line 214\n  20: Message ({#Ref<0.0.0.176>,initializing}) from P.1 reaches P\n  21: P: receives message ({#Ref<0.0.0.176>,initializing})\n    in gen.erl line 217\n  22: P: true = erlang:demonitor(#Ref<0.0.0.176>, [flush])\n    in gen.erl line 219\n  23: P: exits abnormally ({{badmatch,initializing},[{z,test,0,[{file,[46,46,47,101,116,101,115,116,47|...]},{line,22}]}]})\n```\n\n报告显示P进程（父进程)在第23步的时候崩溃了，错误原因时badmatch，z.erl的22行，即\n```\nready = read(),\n```\n\n此处read()返回的不是ready而是intiallizing，也就是handle_info(timeout...)并没有执行。\n上面的１～２３步显示了gen_server的创建过程.以及消息传递过程。十分详细。不过需要挖掘下gen_server的源码才能看懂。\n\n## gen_server的创建过程\n下面分析下gen_server的创建过程。假设我们创建一个{local, test}的进程，并传入Args作为初始化参数，Opts为进程的设置参数.\n\n### gen_server:\n```\nstart_link({local, test}, test, Args, Opts) ->\n   gen:start(gen_server,  link, {local, test}, test, Args, Opts).\n```\n\n### gen:\n```\nstart(gen_server, link, {local, test}, test, Args, Opts) ->\n     case where({local, test}) of %检测名字是否注册\n       undefined ->\n          do_spawn(gen_server, link, {local, test}, test, Args, Opts);\n        Pid ->\n           {error, {already_started, Pid}}\n      end.\n```\n```\ndo_spawn(gen_server, link, {local, test}, test, Args, Opts) ->\n        Time = somefun(Opts) % 提取出Opt中的timeout参数, \n        proc_lib:start_link(gen, init_it, \n        [gen_server, self(), self(), {local, test}, test, Args, Opts], Time, spawn_opts(Opts)).\n```\n\n> 此处spawn_opts的作用时查找Opts中有没有spawn_opt这个选项，否则为[].\n\n### proc_lib:\n上面self()一般情况下为supervisor的Pid。\n```\nstart_link(gen, init_it, [gen_server, Sup, Sup, {local, test}, test, Args, Opts], Timeout, Opts|[]) ->\n  Pid = proc_lib:spawn_opt(gen, init_it, [gen_server, SelfPid, SelfPid, {local, test}, test, Args, Opts|[]], ensure_link(Opts|[])), %ensure_link尝试将link加入Opts\n  sync_wait(Pid, Timeout).\n```\n\n```\nspawn_opt(gen, init_it, [gen_server, selfPid, SelfPid, {local, test}, test, Args, Opts], [link]|[link, Opts]) ->\n   Parent = ......%获取当前进程registername为父进程\n   Ancestors = ....% 获取进程字典中的$ancestors的值\n   check_for_monitor([link]|[link,Opts])....% 检测monitor这个参数在不在其中，在的话直接抛出错误。 \n   erlang:spawn_opt(proc_lib, init_p, [Parent, Ancestors, gen, init_it, [gen_server, SelfPid....Opts],[link]|[link, Opts]).\n```\n\n```\nsync_wait(Pid, TimeOut) ->\n  receive \n  {ack, Pid, Return} ->\n    Return;\n  {'EXIT', Pid, Reason} ->\n    {error, Reason}\n  after TimeOut ->\n    unlink(Pid),\n    exit(Pid, kill),\n    flush(Pid),\n    {error, timeout}\n   end.\n```\n\nerlang:spawn_opt与spawn类似，只不过支持一些option。所以调用的还是proc_lib的init_p。\n```\ninit_p(Parent, Ancestors, gen, init_it, [gen_server, Sup, Sup, {local, test}, test, Args, Opts|[]], [link|[link, Opts]) ->\n  put('ancestors', [Parent|Ancestors]),\n  put('initial_call', trans_init(gen, init_it, [gen_server, Sup.....])),\n  init_p_do_apply(gen, init_it, [gen_server, Sup, Sup....]).\n```\n\n其中trans_init的结果返回为{Module, init, 1} 即 {test, init, 1}.\n```\ninit_p_do_apply(gen, init_it, [gen_server, Sup, Sup, {local, test}, test, Args, Opts|[]]) ->\n    try\n\tapply(gen, init_it, [gen_server, Sup... Opts]) \n    catch\n\tClass:Reason ->\n\t    exit_p(Class, Reason)\n    end.\n```\n\nexit_p里面格式化一些错误信息，并用error_logger输出\n\n### gen\n```\ninit_it(gen_server, Sup, Sup, {local, test}, test, Args, Opts|[]) ->\n    case name_register({local, test}) of\n\ttrue ->\n\t    init_it2(gen_server, Sup, Sup, {local, test}, test, Args, Opts|[]);\n\t{false, Pid} ->\n\t    proc_lib:init_ack(Sup, {error, {already_started, Pid}})\n    end.\n```\n\n```\nname_register({local, Name} = LN) ->\n    try register(Name, self()) of\n\ttrue -> true\n    catch\n\terror:_ ->\n\t    {false, where(LN)}\n    end;\n```\n\n```\ninit_it2(gen_server, Sup, Sup, {local, test}, test, Args, Opts|[]) ->\n   gen_server:init_it(Sup, Sup, {local, test}, test, Args, Opts|[]).\n```\n\n### gen_server:\n```\ninit_it(Sup, Sup, {local, test}, test, Args, Opts|[]) ->\n    test = name({local, test}),\n    Debug = debug_options(Name, Opts|[]),\n    case catch test:init(Args) of\n\t{ok, State} ->\n\t    proc_lib:init_ack(Sup, {ok, self()}), \t    \n\t    loop(Sup, test, State, test, infinity, Debug);\n\t{ok, State, Timeout} ->\n\t    proc_lib:init_ack(Sup, {ok, self()}), \t    \n\t    loop(Sup, test, State, test, Timeout, Debug);\n\t{stop, Reason} ->\n\t    unregister_name(test),\n\t    proc_lib:init_ack(Sup, {error, Reason}),\n\t    exit(Reason);\n\tignore ->\n\t    unregister_name(test),\n\t    proc_lib:init_ack(Sup, ignore),\n\t    exit(normal);\n\t{'EXIT', Reason} ->\n\t    unregister_name(test),\n\t    proc_lib:init_ack(Sup, {error, Reason}),\n\t    exit(Reason);\n\tElse ->\n\t    Error = {bad_return_value, Else},\n\t    proc_lib:init_ack(Sup, {error, Error}),\n\t    exit(Error)\n    end.\n```\n\n### proc_lib\n```\ninit_ack(Sup, {ok, Pid}|{error, already_exited}) ->\n    Parent ! {ack, self(), {ok, Pid}}|{error, already_exited}},\n    ok.\n```\n\n```\nloop(Sup, test, State, test, Timeout, Debug) ->\n    Msg = receive\n\t      Input ->\n\t\t    Input\n\t  after Time ->\n\t\t  timeout\n\t  end,\n    decode_msg(Msg, Parent, Name, State, Mod, Time, Debug, false).\n```\n至此gen_server初始化完成。\n。\n由此得知。gen_server再调用test：init之前，主要做了\n1. 判断名字是否被占用，否则报{error, already_exited}\n2. 写入ancestors和initial call\n\nOpts中的timeout参数主要用来衡量创建进程的time，超时回结束进程并返回。而{ok， State， Timeout}的timeout参数用来参与loop循环，在进程创建后timeout时间内没有接到消息，就会像自己发送timeout这个消息。 而且这个参数在之后的handle_call, handle_cast,handle_info等回调中，使可以修改timeout的数值。参考源码：\n```\nhandle_msg({'$gen_call', From, Msg}, Parent, Name, State, Mod, Debug) ->\n    case catch Mod:handle_call(Msg, From, State) of\n\t{reply, Reply, NState} ->\n\t    Debug1 = reply(Name, From, Reply, NState, Debug),\n\t    loop(Parent, Name, NState, Mod, infinity, Debug1);\n\t{reply, Reply, NState, Time1} ->\n\t    Debug1 = reply(Name, From, Reply, NState, Debug),\n\t    loop(Parent, Name, NState, Mod, Time1, Debug1);\n\t{noreply, NState} ->\n\t    Debug1 = sys:handle_debug(Debug, fun print_event/3, Name,\n\t\t\t\t      {noreply, NState}),\n\t    loop(Parent, Name, NState, Mod, infinity, Debug1);\n\t{noreply, NState, Time1} ->\n\t    Debug1 = sys:handle_debug(Debug, fun print_event/3, Name,\n\t\t\t\t      {noreply, NState}),\n\t    loop(Parent, Name, NState, Mod, Time1, Debug1);\n\t{stop, Reason, Reply, NState} ->\n\t    {'EXIT', R} = \n\t\t(catch terminate(Reason, Name, Msg, Mod, NState, Debug)),\n\t    reply(Name, From, Reply, NState, Debug),\n\t    exit(R);\n\tOther ->\n\t    handle_common_reply(Other, Parent, Name, Msg, Mod, State, Debug)\n    end;\n```\n\n可见handle_call的返回值如果包含Time1，就会修改loop的Timeout参数。\n\n## where is the point?\n问题出现在\n```\n\t{ok, State, Timeout} ->\n\t    proc_lib:init_ack(Sup, {ok, self()}), \t    \n\t    loop(Sup, test, State, test, Timeout, Debug);\n```\n\nＰ进程创建Ｐ.1进程，然后进入receive，期待一个{ack, Pid, Return}的回复。在init结束返回{ok, State, Timeout}后，proc_lib:init_ack完成了向P发送{ack, Pid, Return}的任务。然后进入ｌｏｏｐ循环。但这时Ｐ进程接到消息后立刻发送了read.导致timeout并没有发送出去。造成badmatch的结果。\n\n在一种情况，其实在name_register的时候名字和Ｐｉｄ就已经注册好了。但此时甚至没有进入ｉｎｉｔ函数，如果有其他进程朝test名字的ｓｅｒｖｅｒ发送消息，自然会导致ｔｉｍｅｏｕｔ的失效。\n\n\n","slug":"erlang-question-gen-server-and-init","published":1,"updated":"2018-06-26T09:49:27.734Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqw7jdvr000e6f1r085e51j7","content":"<!-- toc -->\n<ul>\n<li><a href=\"#----\">小技巧?</a></li>\n<li><a href=\"#question\">Question</a></li>\n<li><a href=\"#answers-\">Answers:</a><ul>\n<li><a href=\"#---sergej-jure-ko----\"><strong><em>Sergej Jurečko</em></strong>:</a></li>\n<li><a href=\"#---lo-c-hoguin----cowboy----\"><strong><em>Loïc Hoguin</em></strong>(cowboy 作者）</a></li>\n<li><a href=\"#---max-lapshin---\"><strong><em>Max Lapshin</em></strong></a></li>\n<li><a href=\"#---lo-c-hoguin---\"><strong><em>Loïc Hoguin</em></strong></a></li>\n</ul>\n</li>\n<li><a href=\"#test\">Test</a></li>\n<li><a href=\"#gen-server-----\">gen_server的创建过程</a><ul>\n<li><a href=\"#gen-server-\">gen_server:</a></li>\n<li><a href=\"#gen-\">gen:</a></li>\n<li><a href=\"#proc-lib-\">proc_lib:</a></li>\n<li><a href=\"#gen\">gen</a></li>\n<li><a href=\"#gen-server-\">gen_server:</a></li>\n<li><a href=\"#proc-lib\">proc_lib</a></li>\n</ul>\n</li>\n<li><a href=\"#where-is-the-point-\">where is the point?</a></li>\n</ul>\n<!-- tocstop -->\n<span id=\"more\"></span>\n<h2 id=\"小技巧?\">小技巧?</h2><p>这两天复习了一下<a href=\"http://zh.scribd.com/doc/87376094/Erlang-and-OTP-in-Action#scribd\">Erlang and OTP in action</a><br>其中讲到gen_server的时候，作者用了个小技巧。如下。<br><img src=\"http://storage4.static.itmages.com/i/15/0731/h_1438311976_3257184_46c6e8b7c0.png\" alt=\"\"></p>\n<p><img src=\"http://storage1.static.itmages.com/i/15/0731/h_1438312022_8979746_d612eb6d7f.png\" alt=\"\"></p>\n<p><img src=\"http://storage4.static.itmages.com/i/15/0731/h_1438311785_2601988_b290e0c784.png\" alt=\"\"></p>\n<blockquote>\n<p>第三章图片的引用里handle_call应该是handle_info,此处有错误</p>\n</blockquote>\n<p>作者的意思时如果在init的返回中设置了timeout参数为0，会在init结束后会立即向自己发送一个timeout参数。并且由handle_info(timeout...)处理。意思是可以让一些耗时高的初始化操作在handle_info(timeout。。）里面处理，而让init尽快返回。<br><strong>本以为是个不错的小技巧，结果却有些隐患</strong></p>\n<h2 id=\"Question\">Question</h2><p>这两天的mailist正好有人遇到了这个问题。<br><a href=\"http://erlang.org/pipermail/erlang-questions/2015-July/085314.html\">[erlang_question]gen_server and init</a><br>问题如下：</p>\n<blockquote>\n<p><strong><em>Matthew Evans</em></strong>:<br>Hi,<br>We have used this pattern in gen_servers for a long time now:<br>init(_) -&gt;   %% Some stuff   {ok, #state{}, 0}.<br>%%%%%%<br>handle_info(timeout, State) -&gt;    %% Init stuff    {noreply,State}<br>Basically the idea is to prevent init from blocking and to have init/1 return with a timeout of 0 causing an immediate timeout message to be invoked in the handle_info.<br>Here&#39;s what&#39;s odd. Sometimes this timeout does not fire. It doesn&#39;t appear that any message is getting sent, but I would imagine that since it&#39;s a registered gen_server there is no way that can happen.<br>Does anyone have any ideas?<br>We are running vsn 17.1, and ntp is enabled on the host (Linux).<br>Thanks                           </p>\n</blockquote>\n<p>提问者与作者的思路一样，想要在timeout里面做些初始化操作。然而却没想到timeout并没有触发。<br>以下摘取一些回答。</p>\n<h2 id=\"Answers:\">Answers:</h2><h3 id=\"Sergej_Jurečko:\"><strong><em>Sergej Jurečko</em></strong>:</h3><blockquote>\n<p>If something is in the message queue before init is done executing, that timeout will never get called. Timeout means execute only if nothing else happens during. You should be using self() ! timeout<br>如果在init没有完成之前消息队列里面存在消息，timeout将永远不会调用。应该使用self()!timeout这种方式</p>\n</blockquote>\n<h3 id=\"Loïc_Hoguin(cowboy_作者）\"><strong><em>Loïc Hoguin</em></strong>(cowboy 作者）</h3><blockquote>\n<p>This and sending yourself a message is a bad idea. It will usually work,<br>until it doesn&#39;t, and you will have a very hard time figuring out why.<br>Instead, start the process using proc_lib:spawn_link or<br>proc_lib:start_link (depending on whether it needs to be synchronous or<br>not), then perform your initialization (calling proc_lib:init_ack where<br>appropriate), and finally calling gen_server:enter_loop.<br>What this gives you is pretty much the ability to customize the<br>initialization of your gen_server process.<br>This is the correct way to do it. Your solution can fail if you receive<br>a message. Sending yourself a message is subject to race conditions<br>where you receive a message before you could init.<br>大体意思说这个方式是bad idea。应该使用proc_lib:spawn_link, proc_lib:start_link, proc_lib:init_ack, gen_server:enter_loop等。</p>\n</blockquote>\n<h3 id=\"Max_Lapshin\"><strong><em>Max Lapshin</em></strong></h3><blockquote>\n<p>Loic is right, but you should understand that you can receive message<br>before your  &quot;self() ! init&quot; message only if you explicitly tell your pid<br>someone in init()  because before the end of init your pid is unknown to<br>others.<br>Loic是对的～但是你应该明白除非你在init的过程中将自己的pid告诉其他进程才会在init返回之前接到消息，因为init没有完成之前，pid对其他是未知的。</p>\n</blockquote>\n<h3 id=\"Loïc_Hoguin\"><strong><em>Loïc Hoguin</em></strong></h3><blockquote>\n<p>(Had problems pasting so hope it&#39;s all OK!)</p>\n</blockquote>\n<blockquote>\n<p>I&#39;m not sure what you wrote there but I can give you two scenarios where<br>it can fail off the top of my head. The first is very unlikely and can<br>only fail if you use the 0 timeout, while the second is actually much<br>easier to observe and can fail with both methods:</p>\n</blockquote>\n<blockquote>\n<p>P1 calls start_link<br>P2 init (returns 0 timeout)<br>P2 yields before calling receive<br>P1 returns from start_link and sends P2 a message<br>P2 receives message</p>\n</blockquote>\n<blockquote>\n<p>And:</p>\n</blockquote>\n<blockquote>\n<p>P1 calls start_link<br>P2 in init subscribes to some kind of pubsub PS<br>PS sends P2 message(s)<br>P2 returns from init and receive those messages</p>\n</blockquote>\n<blockquote>\n<p>I&#39;m not sure why your tool doesn&#39;t catch the first case, Concuerror<br><em>definitely does</em>, and without needing to write all this weird code too. :-)</p>\n</blockquote>\n<blockquote>\n<p>Here is the module:<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-module(z).</span><br><span class=\"line\">-behaviour(gen_server).</span><br><span class=\"line\"></span><br><span class=\"line\">-export([start_link/0]).</span><br><span class=\"line\"></span><br><span class=\"line\">%% Operational API</span><br><span class=\"line\">-export([read/0]).</span><br><span class=\"line\"></span><br><span class=\"line\">%% gen_server API</span><br><span class=\"line\">-export([</span><br><span class=\"line\">          init/1,</span><br><span class=\"line\">          handle_cast/2,</span><br><span class=\"line\">          handle_call/3,</span><br><span class=\"line\">          terminate/2,</span><br><span class=\"line\">          code_change/3,</span><br><span class=\"line\">          handle_info/2,</span><br><span class=\"line\">\t\t test/0</span><br><span class=\"line\">]).</span><br><span class=\"line\"></span><br><span class=\"line\">test() -&gt;</span><br><span class=\"line\">\tstart_link(),</span><br><span class=\"line\">\tready = read(),</span><br><span class=\"line\">\tstop().</span><br><span class=\"line\"></span><br><span class=\"line\">%% API</span><br><span class=\"line\">start_link() -&gt;</span><br><span class=\"line\">     gen_server:start(&#123;local, ?MODULE&#125;, ?MODULE, [], []).</span><br><span class=\"line\"></span><br><span class=\"line\">read() -&gt;</span><br><span class=\"line\">     gen_server:call(?MODULE, read).</span><br><span class=\"line\"></span><br><span class=\"line\">stop() -&gt;</span><br><span class=\"line\">\tgen_server:call(?MODULE, stop).</span><br><span class=\"line\"></span><br><span class=\"line\">%% Callbacks</span><br><span class=\"line\">init([]) -&gt;</span><br><span class=\"line\">     &#123;ok, initializing, 0&#125;.</span><br><span class=\"line\"></span><br><span class=\"line\">handle_call(read, _From, State) -&gt;</span><br><span class=\"line\">     &#123;reply, State, State&#125;;</span><br><span class=\"line\">handle_call(stop, _, State) -&gt;</span><br><span class=\"line\">\t&#123;stop, normal, ok, stop&#125;.</span><br><span class=\"line\"></span><br><span class=\"line\">handle_cast(_M, State) -&gt;</span><br><span class=\"line\">     &#123;noreply, State&#125;.</span><br><span class=\"line\"></span><br><span class=\"line\">handle_info(timeout, _State) -&gt;</span><br><span class=\"line\">     &#123;noreply, ready&#125;.</span><br><span class=\"line\"></span><br><span class=\"line\">terminate(_How, _State) -&gt;</span><br><span class=\"line\">     ok.</span><br><span class=\"line\"></span><br><span class=\"line\">code_change(_OldVsn, State, _Extra) -&gt;</span><br><span class=\"line\">     &#123;ok, State&#125;.</span><br></pre></td></tr></table></figure><br>（注：handle_call(stop, _, State)的State应该是_State, 否则编译不过).</p>\n</blockquote>\n<h2 id=\"Test\">Test</h2><p>Loic给出了一个module，用concuerror进行了测试，这个模块的init中指定timeout为0，然后handle_info(timeout。。。）并没有触发。<br>concuerror是一个用来测试erlang中一些看起来没有问题的程序，但是在并行情况下可能发生的问题的工具。<br>参考<br><a href=\"http://concuerror.com/\">官网</a><br><a href=\"http://concuerror.com/tutorials/poolboy-example/\">concuerror tutorial</a><br><a href=\"https://github.com/parapluu/Concuerror\">github</a><br>以下是我运行的结果。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">youthy@youthy:~/code/Concuerror$ ./concuerror -f &quot;../etest/z.erl&quot; -m z -t test --after_timeout 1000 </span><br><span class=\"line\">concuerror: WARNING: file ../etest/z.erl shadows the default ./z.beam</span><br><span class=\"line\">Concuerror started at 31 Jul 2015 07:21:55</span><br><span class=\"line\">Writing results in concuerror_report.txt</span><br><span class=\"line\"></span><br><span class=\"line\">Info: Instrumented z</span><br><span class=\"line\">Info: Instrumented io_lib</span><br><span class=\"line\">Info: Instrumented gen_server</span><br><span class=\"line\">Info: Instrumented gen</span><br><span class=\"line\">Info: Instrumented proc_lib</span><br><span class=\"line\">Info: Instrumented erlang</span><br><span class=\"line\">Info: Instrumented init</span><br><span class=\"line\">Info: Instrumented sys</span><br><span class=\"line\">Info: You can see pairs of racing instructions (in the report and --graph) with &#x27;--show_races true&#x27;</span><br><span class=\"line\">Error: Stop testing on first error. (Check &#x27;-h keep_going&#x27;).</span><br><span class=\"line\"></span><br><span class=\"line\">Done! (Exit status: warning)</span><br><span class=\"line\">  Summary: 1 errors, 4/4 interleavings explored</span><br><span class=\"line\">youthy@youthy:~/code/Concuerror$ vim concuerror_report.txt </span><br></pre></td></tr></table></figure></p>\n<p>concuerror_report.txt:<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Erroneous interleaving 1:</span><br><span class=\"line\">* At step 23 process P exited abnormally</span><br><span class=\"line\">    Reason:</span><br><span class=\"line\">      &#123;&#123;badmatch,initializing&#125;,</span><br><span class=\"line\">       [&#123;z,test,0,[&#123;file,&quot;../etest/z.erl&quot;&#125;,&#123;line,22&#125;]&#125;]&#125;</span><br><span class=\"line\">    Stacktrace:</span><br><span class=\"line\">      [&#123;z,test,0,[&#123;file,&quot;../etest/z.erl&quot;&#125;,&#123;line,22&#125;]&#125;]</span><br><span class=\"line\">* Blocked at a &#x27;receive&#x27; (when all other processes have exited):</span><br><span class=\"line\">    P.1 in gen_server.erl line 348</span><br><span class=\"line\">--------------------------------------------------------------------------------</span><br><span class=\"line\"></span><br><span class=\"line\">Interleaving info:</span><br><span class=\"line\">   1: P: undefined = erlang:whereis(z)</span><br><span class=\"line\">    in gen.erl line 277</span><br><span class=\"line\">   2: P: [] = erlang:process_info(P, registered_name)</span><br><span class=\"line\">    in proc_lib.erl line 648</span><br><span class=\"line\">   3: P: P.1 = erlang:spawn_opt(&#123;proc_lib,init_p,[P,[],gen,init_it,[gen_server,P,self,&#123;local,z&#125;,z,[],[]]],[]&#125;)</span><br><span class=\"line\">    in erlang.erl line 249</span><br><span class=\"line\">   4: P.1: undefined = erlang:put(&#x27;$ancestors&#x27;, [P])</span><br><span class=\"line\">    in proc_lib.erl line 221</span><br><span class=\"line\">   5: P.1: undefined = erlang:put(&#x27;$initial_call&#x27;, &#123;z,init,1&#125;)</span><br><span class=\"line\">    in proc_lib.erl line 222</span><br><span class=\"line\">   6: P.1: true = erlang:register(z, P.1)</span><br><span class=\"line\">    in gen.erl line 280</span><br><span class=\"line\">   7: P.1: &#123;P.1,&#123;get_argument,generic_debug&#125;&#125; = init ! &#123;P.1,&#123;get_argument,generic_debug&#125;&#125;</span><br><span class=\"line\">    in init.erl line 145</span><br><span class=\"line\">   8: Message (&#123;P.1,&#123;get_argument,generic_debug&#125;&#125;) from P.1 reaches init</span><br><span class=\"line\">   9: Message (&#123;init,error&#125;) from init reaches P.1</span><br><span class=\"line\">  10: P.1: receives message (&#123;init,error&#125;)</span><br><span class=\"line\">    in init.erl line 146</span><br><span class=\"line\">  11: P.1: &#123;ack,P.1,&#123;ok,P.1&#125;&#125; = P ! &#123;ack,P.1,&#123;ok,P.1&#125;&#125;</span><br><span class=\"line\">    in proc_lib.erl line 348</span><br><span class=\"line\">  12: Message (&#123;ack,P.1,&#123;ok,P.1&#125;&#125;) from P.1 reaches P</span><br><span class=\"line\">  13: P: receives message (&#123;ack,P.1,&#123;ok,P.1&#125;&#125;)</span><br><span class=\"line\">    in proc_lib.erl line 321</span><br><span class=\"line\">  14: P: P.1 = erlang:whereis(z)</span><br><span class=\"line\">    in gen.erl line 154</span><br><span class=\"line\">  15: P: #Ref&lt;0.0.0.176&gt; = erlang:monitor(process, P.1)</span><br><span class=\"line\">    in gen.erl line 204</span><br><span class=\"line\">  16: P: &#123;&#x27;$gen_call&#x27;,&#123;P,#Ref&lt;0.0.0.176&gt;&#125;,read&#125; = erlang:send(P.1, &#123;&#x27;$gen_call&#x27;,&#123;P,#Ref&lt;0.0.0.176&gt;&#125;,read&#125;, [noconnect])</span><br><span class=\"line\">    in gen.erl line 215</span><br><span class=\"line\">  17: Message (&#123;&#x27;$gen_call&#x27;,&#123;P,#Ref&lt;0.0.0.176&gt;&#125;,read&#125;) from P reaches P.1</span><br><span class=\"line\">  18: P.1: receives message (&#123;&#x27;$gen_call&#x27;,&#123;P,#Ref&lt;0.0.0.176&gt;&#125;,read&#125;)</span><br><span class=\"line\">    in gen_server.erl line 348</span><br><span class=\"line\">  19: P.1: &#123;#Ref&lt;0.0.0.176&gt;,initializing&#125; = P ! &#123;#Ref&lt;0.0.0.176&gt;,initializing&#125;</span><br><span class=\"line\">    in gen_server.erl line 214</span><br><span class=\"line\">  20: Message (&#123;#Ref&lt;0.0.0.176&gt;,initializing&#125;) from P.1 reaches P</span><br><span class=\"line\">  21: P: receives message (&#123;#Ref&lt;0.0.0.176&gt;,initializing&#125;)</span><br><span class=\"line\">    in gen.erl line 217</span><br><span class=\"line\">  22: P: true = erlang:demonitor(#Ref&lt;0.0.0.176&gt;, [flush])</span><br><span class=\"line\">    in gen.erl line 219</span><br><span class=\"line\">  23: P: exits abnormally (&#123;&#123;badmatch,initializing&#125;,[&#123;z,test,0,[&#123;file,[46,46,47,101,116,101,115,116,47|...]&#125;,&#123;line,22&#125;]&#125;]&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>报告显示P进程（父进程)在第23步的时候崩溃了，错误原因时badmatch，z.erl的22行，即<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ready = read(),</span><br></pre></td></tr></table></figure></p>\n<p>此处read()返回的不是ready而是intiallizing，也就是handle_info(timeout...)并没有执行。<br>上面的１～２３步显示了gen_server的创建过程.以及消息传递过程。十分详细。不过需要挖掘下gen_server的源码才能看懂。</p>\n<h2 id=\"gen_server的创建过程\">gen_server的创建过程</h2><p>下面分析下gen_server的创建过程。假设我们创建一个{local, test}的进程，并传入Args作为初始化参数，Opts为进程的设置参数.</p>\n<h3 id=\"gen_server:\">gen_server:</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start_link(&#123;local, test&#125;, test, Args, Opts) -&gt;</span><br><span class=\"line\">   gen:start(gen_server,  link, &#123;local, test&#125;, test, Args, Opts).</span><br></pre></td></tr></table></figure>\n<h3 id=\"gen:\">gen:</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start(gen_server, link, &#123;local, test&#125;, test, Args, Opts) -&gt;</span><br><span class=\"line\">     case where(&#123;local, test&#125;) of %检测名字是否注册</span><br><span class=\"line\">       undefined -&gt;</span><br><span class=\"line\">          do_spawn(gen_server, link, &#123;local, test&#125;, test, Args, Opts);</span><br><span class=\"line\">        Pid -&gt;</span><br><span class=\"line\">           &#123;error, &#123;already_started, Pid&#125;&#125;</span><br><span class=\"line\">      end.</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">do_spawn(gen_server, link, &#123;local, test&#125;, test, Args, Opts) -&gt;</span><br><span class=\"line\">        Time = somefun(Opts) % 提取出Opt中的timeout参数, </span><br><span class=\"line\">        proc_lib:start_link(gen, init_it, </span><br><span class=\"line\">        [gen_server, self(), self(), &#123;local, test&#125;, test, Args, Opts], Time, spawn_opts(Opts)).</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>此处spawn_opts的作用时查找Opts中有没有spawn_opt这个选项，否则为[].</p>\n</blockquote>\n<h3 id=\"proc_lib:\">proc_lib:</h3><p>上面self()一般情况下为supervisor的Pid。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start_link(gen, init_it, [gen_server, Sup, Sup, &#123;local, test&#125;, test, Args, Opts], Timeout, Opts|[]) -&gt;</span><br><span class=\"line\">  Pid = proc_lib:spawn_opt(gen, init_it, [gen_server, SelfPid, SelfPid, &#123;local, test&#125;, test, Args, Opts|[]], ensure_link(Opts|[])), %ensure_link尝试将link加入Opts</span><br><span class=\"line\">  sync_wait(Pid, Timeout).</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spawn_opt(gen, init_it, [gen_server, selfPid, SelfPid, &#123;local, test&#125;, test, Args, Opts], [link]|[link, Opts]) -&gt;</span><br><span class=\"line\">   Parent = ......%获取当前进程registername为父进程</span><br><span class=\"line\">   Ancestors = ....% 获取进程字典中的$ancestors的值</span><br><span class=\"line\">   check_for_monitor([link]|[link,Opts])....% 检测monitor这个参数在不在其中，在的话直接抛出错误。 </span><br><span class=\"line\">   erlang:spawn_opt(proc_lib, init_p, [Parent, Ancestors, gen, init_it, [gen_server, SelfPid....Opts],[link]|[link, Opts]).</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sync_wait(Pid, TimeOut) -&gt;</span><br><span class=\"line\">  receive </span><br><span class=\"line\">  &#123;ack, Pid, Return&#125; -&gt;</span><br><span class=\"line\">    Return;</span><br><span class=\"line\">  &#123;&#x27;EXIT&#x27;, Pid, Reason&#125; -&gt;</span><br><span class=\"line\">    &#123;error, Reason&#125;</span><br><span class=\"line\">  after TimeOut -&gt;</span><br><span class=\"line\">    unlink(Pid),</span><br><span class=\"line\">    exit(Pid, kill),</span><br><span class=\"line\">    flush(Pid),</span><br><span class=\"line\">    &#123;error, timeout&#125;</span><br><span class=\"line\">   end.</span><br></pre></td></tr></table></figure>\n<p>erlang:spawn_opt与spawn类似，只不过支持一些option。所以调用的还是proc_lib的init_p。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">init_p(Parent, Ancestors, gen, init_it, [gen_server, Sup, Sup, &#123;local, test&#125;, test, Args, Opts|[]], [link|[link, Opts]) -&gt;</span><br><span class=\"line\">  put(&#x27;ancestors&#x27;, [Parent|Ancestors]),</span><br><span class=\"line\">  put(&#x27;initial_call&#x27;, trans_init(gen, init_it, [gen_server, Sup.....])),</span><br><span class=\"line\">  init_p_do_apply(gen, init_it, [gen_server, Sup, Sup....]).</span><br></pre></td></tr></table></figure></p>\n<p>其中trans_init的结果返回为{Module, init, 1} 即 {test, init, 1}.<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">init_p_do_apply(gen, init_it, [gen_server, Sup, Sup, &#123;local, test&#125;, test, Args, Opts|[]]) -&gt;</span><br><span class=\"line\">    try</span><br><span class=\"line\">\tapply(gen, init_it, [gen_server, Sup... Opts]) </span><br><span class=\"line\">    catch</span><br><span class=\"line\">\tClass:Reason -&gt;</span><br><span class=\"line\">\t    exit_p(Class, Reason)</span><br><span class=\"line\">    end.</span><br></pre></td></tr></table></figure></p>\n<p>exit_p里面格式化一些错误信息，并用error_logger输出</p>\n<h3 id=\"gen\">gen</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">init_it(gen_server, Sup, Sup, &#123;local, test&#125;, test, Args, Opts|[]) -&gt;</span><br><span class=\"line\">    case name_register(&#123;local, test&#125;) of</span><br><span class=\"line\">\ttrue -&gt;</span><br><span class=\"line\">\t    init_it2(gen_server, Sup, Sup, &#123;local, test&#125;, test, Args, Opts|[]);</span><br><span class=\"line\">\t&#123;false, Pid&#125; -&gt;</span><br><span class=\"line\">\t    proc_lib:init_ack(Sup, &#123;error, &#123;already_started, Pid&#125;&#125;)</span><br><span class=\"line\">    end.</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name_register(&#123;local, Name&#125; = LN) -&gt;</span><br><span class=\"line\">    try register(Name, self()) of</span><br><span class=\"line\">\ttrue -&gt; true</span><br><span class=\"line\">    catch</span><br><span class=\"line\">\terror:_ -&gt;</span><br><span class=\"line\">\t    &#123;false, where(LN)&#125;</span><br><span class=\"line\">    end;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">init_it2(gen_server, Sup, Sup, &#123;local, test&#125;, test, Args, Opts|[]) -&gt;</span><br><span class=\"line\">   gen_server:init_it(Sup, Sup, &#123;local, test&#125;, test, Args, Opts|[]).</span><br></pre></td></tr></table></figure>\n<h3 id=\"gen_server:-1\">gen_server:</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">init_it(Sup, Sup, &#123;local, test&#125;, test, Args, Opts|[]) -&gt;</span><br><span class=\"line\">    test = name(&#123;local, test&#125;),</span><br><span class=\"line\">    Debug = debug_options(Name, Opts|[]),</span><br><span class=\"line\">    case catch test:init(Args) of</span><br><span class=\"line\">\t&#123;ok, State&#125; -&gt;</span><br><span class=\"line\">\t    proc_lib:init_ack(Sup, &#123;ok, self()&#125;), \t    </span><br><span class=\"line\">\t    loop(Sup, test, State, test, infinity, Debug);</span><br><span class=\"line\">\t&#123;ok, State, Timeout&#125; -&gt;</span><br><span class=\"line\">\t    proc_lib:init_ack(Sup, &#123;ok, self()&#125;), \t    </span><br><span class=\"line\">\t    loop(Sup, test, State, test, Timeout, Debug);</span><br><span class=\"line\">\t&#123;stop, Reason&#125; -&gt;</span><br><span class=\"line\">\t    unregister_name(test),</span><br><span class=\"line\">\t    proc_lib:init_ack(Sup, &#123;error, Reason&#125;),</span><br><span class=\"line\">\t    exit(Reason);</span><br><span class=\"line\">\tignore -&gt;</span><br><span class=\"line\">\t    unregister_name(test),</span><br><span class=\"line\">\t    proc_lib:init_ack(Sup, ignore),</span><br><span class=\"line\">\t    exit(normal);</span><br><span class=\"line\">\t&#123;&#x27;EXIT&#x27;, Reason&#125; -&gt;</span><br><span class=\"line\">\t    unregister_name(test),</span><br><span class=\"line\">\t    proc_lib:init_ack(Sup, &#123;error, Reason&#125;),</span><br><span class=\"line\">\t    exit(Reason);</span><br><span class=\"line\">\tElse -&gt;</span><br><span class=\"line\">\t    Error = &#123;bad_return_value, Else&#125;,</span><br><span class=\"line\">\t    proc_lib:init_ack(Sup, &#123;error, Error&#125;),</span><br><span class=\"line\">\t    exit(Error)</span><br><span class=\"line\">    end.</span><br></pre></td></tr></table></figure>\n<h3 id=\"proc_lib\">proc_lib</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">init_ack(Sup, &#123;ok, Pid&#125;|&#123;error, already_exited&#125;) -&gt;</span><br><span class=\"line\">    Parent ! &#123;ack, self(), &#123;ok, Pid&#125;&#125;|&#123;error, already_exited&#125;&#125;,</span><br><span class=\"line\">    ok.</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loop(Sup, test, State, test, Timeout, Debug) -&gt;</span><br><span class=\"line\">    Msg = receive</span><br><span class=\"line\">\t      Input -&gt;</span><br><span class=\"line\">\t\t    Input</span><br><span class=\"line\">\t  after Time -&gt;</span><br><span class=\"line\">\t\t  timeout</span><br><span class=\"line\">\t  end,</span><br><span class=\"line\">    decode_msg(Msg, Parent, Name, State, Mod, Time, Debug, false).</span><br></pre></td></tr></table></figure>\n<p>至此gen_server初始化完成。<br>。<br>由此得知。gen_server再调用test：init之前，主要做了</p>\n<ol>\n<li>判断名字是否被占用，否则报{error, already_exited}</li>\n<li>写入ancestors和initial call</li>\n</ol>\n<p>Opts中的timeout参数主要用来衡量创建进程的time，超时回结束进程并返回。而{ok， State， Timeout}的timeout参数用来参与loop循环，在进程创建后timeout时间内没有接到消息，就会像自己发送timeout这个消息。 而且这个参数在之后的handle_call, handle_cast,handle_info等回调中，使可以修改timeout的数值。参考源码：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">handle_msg(&#123;&#x27;$gen_call&#x27;, From, Msg&#125;, Parent, Name, State, Mod, Debug) -&gt;</span><br><span class=\"line\">    case catch Mod:handle_call(Msg, From, State) of</span><br><span class=\"line\">\t&#123;reply, Reply, NState&#125; -&gt;</span><br><span class=\"line\">\t    Debug1 = reply(Name, From, Reply, NState, Debug),</span><br><span class=\"line\">\t    loop(Parent, Name, NState, Mod, infinity, Debug1);</span><br><span class=\"line\">\t&#123;reply, Reply, NState, Time1&#125; -&gt;</span><br><span class=\"line\">\t    Debug1 = reply(Name, From, Reply, NState, Debug),</span><br><span class=\"line\">\t    loop(Parent, Name, NState, Mod, Time1, Debug1);</span><br><span class=\"line\">\t&#123;noreply, NState&#125; -&gt;</span><br><span class=\"line\">\t    Debug1 = sys:handle_debug(Debug, fun print_event/3, Name,</span><br><span class=\"line\">\t\t\t\t      &#123;noreply, NState&#125;),</span><br><span class=\"line\">\t    loop(Parent, Name, NState, Mod, infinity, Debug1);</span><br><span class=\"line\">\t&#123;noreply, NState, Time1&#125; -&gt;</span><br><span class=\"line\">\t    Debug1 = sys:handle_debug(Debug, fun print_event/3, Name,</span><br><span class=\"line\">\t\t\t\t      &#123;noreply, NState&#125;),</span><br><span class=\"line\">\t    loop(Parent, Name, NState, Mod, Time1, Debug1);</span><br><span class=\"line\">\t&#123;stop, Reason, Reply, NState&#125; -&gt;</span><br><span class=\"line\">\t    &#123;&#x27;EXIT&#x27;, R&#125; = </span><br><span class=\"line\">\t\t(catch terminate(Reason, Name, Msg, Mod, NState, Debug)),</span><br><span class=\"line\">\t    reply(Name, From, Reply, NState, Debug),</span><br><span class=\"line\">\t    exit(R);</span><br><span class=\"line\">\tOther -&gt;</span><br><span class=\"line\">\t    handle_common_reply(Other, Parent, Name, Msg, Mod, State, Debug)</span><br><span class=\"line\">    end;</span><br></pre></td></tr></table></figure></p>\n<p>可见handle_call的返回值如果包含Time1，就会修改loop的Timeout参数。</p>\n<h2 id=\"where_is_the_point?\">where is the point?</h2><p>问题出现在<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;ok, State, Timeout&#125; -&gt;</span><br><span class=\"line\">    proc_lib:init_ack(Sup, &#123;ok, self()&#125;), \t    </span><br><span class=\"line\">    loop(Sup, test, State, test, Timeout, Debug);</span><br></pre></td></tr></table></figure></p>\n<p>Ｐ进程创建Ｐ.1进程，然后进入receive，期待一个{ack, Pid, Return}的回复。在init结束返回{ok, State, Timeout}后，proc_lib:init_ack完成了向P发送{ack, Pid, Return}的任务。然后进入ｌｏｏｐ循环。但这时Ｐ进程接到消息后立刻发送了read.导致timeout并没有发送出去。造成badmatch的结果。</p>\n<p>在一种情况，其实在name_register的时候名字和Ｐｉｄ就已经注册好了。但此时甚至没有进入ｉｎｉｔ函数，如果有其他进程朝test名字的ｓｅｒｖｅｒ发送消息，自然会导致ｔｉｍｅｏｕｔ的失效。</p>\n","site":{"data":{}},"excerpt":"<!-- toc -->\n<ul>\n<li><a href=\"#----\">小技巧?</a></li>\n<li><a href=\"#question\">Question</a></li>\n<li><a href=\"#answers-\">Answers:</a><ul>\n<li><a href=\"#---sergej-jure-ko----\"><strong><em>Sergej Jurečko</em></strong>:</a></li>\n<li><a href=\"#---lo-c-hoguin----cowboy----\"><strong><em>Loïc Hoguin</em></strong>(cowboy 作者）</a></li>\n<li><a href=\"#---max-lapshin---\"><strong><em>Max Lapshin</em></strong></a></li>\n<li><a href=\"#---lo-c-hoguin---\"><strong><em>Loïc Hoguin</em></strong></a></li>\n</ul>\n</li>\n<li><a href=\"#test\">Test</a></li>\n<li><a href=\"#gen-server-----\">gen_server的创建过程</a><ul>\n<li><a href=\"#gen-server-\">gen_server:</a></li>\n<li><a href=\"#gen-\">gen:</a></li>\n<li><a href=\"#proc-lib-\">proc_lib:</a></li>\n<li><a href=\"#gen\">gen</a></li>\n<li><a href=\"#gen-server-\">gen_server:</a></li>\n<li><a href=\"#proc-lib\">proc_lib</a></li>\n</ul>\n</li>\n<li><a href=\"#where-is-the-point-\">where is the point?</a></li>\n</ul>\n<!-- tocstop -->","more":"<h2 id=\"小技巧?\">小技巧?</h2><p>这两天复习了一下<a href=\"http://zh.scribd.com/doc/87376094/Erlang-and-OTP-in-Action#scribd\">Erlang and OTP in action</a><br>其中讲到gen_server的时候，作者用了个小技巧。如下。<br><img src=\"http://storage4.static.itmages.com/i/15/0731/h_1438311976_3257184_46c6e8b7c0.png\" alt=\"\"></p>\n<p><img src=\"http://storage1.static.itmages.com/i/15/0731/h_1438312022_8979746_d612eb6d7f.png\" alt=\"\"></p>\n<p><img src=\"http://storage4.static.itmages.com/i/15/0731/h_1438311785_2601988_b290e0c784.png\" alt=\"\"></p>\n<blockquote>\n<p>第三章图片的引用里handle_call应该是handle_info,此处有错误</p>\n</blockquote>\n<p>作者的意思时如果在init的返回中设置了timeout参数为0，会在init结束后会立即向自己发送一个timeout参数。并且由handle_info(timeout...)处理。意思是可以让一些耗时高的初始化操作在handle_info(timeout。。）里面处理，而让init尽快返回。<br><strong>本以为是个不错的小技巧，结果却有些隐患</strong></p>\n<h2 id=\"Question\">Question</h2><p>这两天的mailist正好有人遇到了这个问题。<br><a href=\"http://erlang.org/pipermail/erlang-questions/2015-July/085314.html\">[erlang_question]gen_server and init</a><br>问题如下：</p>\n<blockquote>\n<p><strong><em>Matthew Evans</em></strong>:<br>Hi,<br>We have used this pattern in gen_servers for a long time now:<br>init(_) -&gt;   %% Some stuff   {ok, #state{}, 0}.<br>%%%%%%<br>handle_info(timeout, State) -&gt;    %% Init stuff    {noreply,State}<br>Basically the idea is to prevent init from blocking and to have init/1 return with a timeout of 0 causing an immediate timeout message to be invoked in the handle_info.<br>Here&#39;s what&#39;s odd. Sometimes this timeout does not fire. It doesn&#39;t appear that any message is getting sent, but I would imagine that since it&#39;s a registered gen_server there is no way that can happen.<br>Does anyone have any ideas?<br>We are running vsn 17.1, and ntp is enabled on the host (Linux).<br>Thanks                           </p>\n</blockquote>\n<p>提问者与作者的思路一样，想要在timeout里面做些初始化操作。然而却没想到timeout并没有触发。<br>以下摘取一些回答。</p>\n<h2 id=\"Answers:\">Answers:</h2><h3 id=\"Sergej_Jurečko:\"><strong><em>Sergej Jurečko</em></strong>:</h3><blockquote>\n<p>If something is in the message queue before init is done executing, that timeout will never get called. Timeout means execute only if nothing else happens during. You should be using self() ! timeout<br>如果在init没有完成之前消息队列里面存在消息，timeout将永远不会调用。应该使用self()!timeout这种方式</p>\n</blockquote>\n<h3 id=\"Loïc_Hoguin(cowboy_作者）\"><strong><em>Loïc Hoguin</em></strong>(cowboy 作者）</h3><blockquote>\n<p>This and sending yourself a message is a bad idea. It will usually work,<br>until it doesn&#39;t, and you will have a very hard time figuring out why.<br>Instead, start the process using proc_lib:spawn_link or<br>proc_lib:start_link (depending on whether it needs to be synchronous or<br>not), then perform your initialization (calling proc_lib:init_ack where<br>appropriate), and finally calling gen_server:enter_loop.<br>What this gives you is pretty much the ability to customize the<br>initialization of your gen_server process.<br>This is the correct way to do it. Your solution can fail if you receive<br>a message. Sending yourself a message is subject to race conditions<br>where you receive a message before you could init.<br>大体意思说这个方式是bad idea。应该使用proc_lib:spawn_link, proc_lib:start_link, proc_lib:init_ack, gen_server:enter_loop等。</p>\n</blockquote>\n<h3 id=\"Max_Lapshin\"><strong><em>Max Lapshin</em></strong></h3><blockquote>\n<p>Loic is right, but you should understand that you can receive message<br>before your  &quot;self() ! init&quot; message only if you explicitly tell your pid<br>someone in init()  because before the end of init your pid is unknown to<br>others.<br>Loic是对的～但是你应该明白除非你在init的过程中将自己的pid告诉其他进程才会在init返回之前接到消息，因为init没有完成之前，pid对其他是未知的。</p>\n</blockquote>\n<h3 id=\"Loïc_Hoguin\"><strong><em>Loïc Hoguin</em></strong></h3><blockquote>\n<p>(Had problems pasting so hope it&#39;s all OK!)</p>\n</blockquote>\n<blockquote>\n<p>I&#39;m not sure what you wrote there but I can give you two scenarios where<br>it can fail off the top of my head. The first is very unlikely and can<br>only fail if you use the 0 timeout, while the second is actually much<br>easier to observe and can fail with both methods:</p>\n</blockquote>\n<blockquote>\n<p>P1 calls start_link<br>P2 init (returns 0 timeout)<br>P2 yields before calling receive<br>P1 returns from start_link and sends P2 a message<br>P2 receives message</p>\n</blockquote>\n<blockquote>\n<p>And:</p>\n</blockquote>\n<blockquote>\n<p>P1 calls start_link<br>P2 in init subscribes to some kind of pubsub PS<br>PS sends P2 message(s)<br>P2 returns from init and receive those messages</p>\n</blockquote>\n<blockquote>\n<p>I&#39;m not sure why your tool doesn&#39;t catch the first case, Concuerror<br><em>definitely does</em>, and without needing to write all this weird code too. :-)</p>\n</blockquote>\n<blockquote>\n<p>Here is the module:<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-module(z).</span><br><span class=\"line\">-behaviour(gen_server).</span><br><span class=\"line\"></span><br><span class=\"line\">-export([start_link/0]).</span><br><span class=\"line\"></span><br><span class=\"line\">%% Operational API</span><br><span class=\"line\">-export([read/0]).</span><br><span class=\"line\"></span><br><span class=\"line\">%% gen_server API</span><br><span class=\"line\">-export([</span><br><span class=\"line\">          init/1,</span><br><span class=\"line\">          handle_cast/2,</span><br><span class=\"line\">          handle_call/3,</span><br><span class=\"line\">          terminate/2,</span><br><span class=\"line\">          code_change/3,</span><br><span class=\"line\">          handle_info/2,</span><br><span class=\"line\">\t\t test/0</span><br><span class=\"line\">]).</span><br><span class=\"line\"></span><br><span class=\"line\">test() -&gt;</span><br><span class=\"line\">\tstart_link(),</span><br><span class=\"line\">\tready = read(),</span><br><span class=\"line\">\tstop().</span><br><span class=\"line\"></span><br><span class=\"line\">%% API</span><br><span class=\"line\">start_link() -&gt;</span><br><span class=\"line\">     gen_server:start(&#123;local, ?MODULE&#125;, ?MODULE, [], []).</span><br><span class=\"line\"></span><br><span class=\"line\">read() -&gt;</span><br><span class=\"line\">     gen_server:call(?MODULE, read).</span><br><span class=\"line\"></span><br><span class=\"line\">stop() -&gt;</span><br><span class=\"line\">\tgen_server:call(?MODULE, stop).</span><br><span class=\"line\"></span><br><span class=\"line\">%% Callbacks</span><br><span class=\"line\">init([]) -&gt;</span><br><span class=\"line\">     &#123;ok, initializing, 0&#125;.</span><br><span class=\"line\"></span><br><span class=\"line\">handle_call(read, _From, State) -&gt;</span><br><span class=\"line\">     &#123;reply, State, State&#125;;</span><br><span class=\"line\">handle_call(stop, _, State) -&gt;</span><br><span class=\"line\">\t&#123;stop, normal, ok, stop&#125;.</span><br><span class=\"line\"></span><br><span class=\"line\">handle_cast(_M, State) -&gt;</span><br><span class=\"line\">     &#123;noreply, State&#125;.</span><br><span class=\"line\"></span><br><span class=\"line\">handle_info(timeout, _State) -&gt;</span><br><span class=\"line\">     &#123;noreply, ready&#125;.</span><br><span class=\"line\"></span><br><span class=\"line\">terminate(_How, _State) -&gt;</span><br><span class=\"line\">     ok.</span><br><span class=\"line\"></span><br><span class=\"line\">code_change(_OldVsn, State, _Extra) -&gt;</span><br><span class=\"line\">     &#123;ok, State&#125;.</span><br></pre></td></tr></table></figure><br>（注：handle_call(stop, _, State)的State应该是_State, 否则编译不过).</p>\n</blockquote>\n<h2 id=\"Test\">Test</h2><p>Loic给出了一个module，用concuerror进行了测试，这个模块的init中指定timeout为0，然后handle_info(timeout。。。）并没有触发。<br>concuerror是一个用来测试erlang中一些看起来没有问题的程序，但是在并行情况下可能发生的问题的工具。<br>参考<br><a href=\"http://concuerror.com/\">官网</a><br><a href=\"http://concuerror.com/tutorials/poolboy-example/\">concuerror tutorial</a><br><a href=\"https://github.com/parapluu/Concuerror\">github</a><br>以下是我运行的结果。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">youthy@youthy:~/code/Concuerror$ ./concuerror -f &quot;../etest/z.erl&quot; -m z -t test --after_timeout 1000 </span><br><span class=\"line\">concuerror: WARNING: file ../etest/z.erl shadows the default ./z.beam</span><br><span class=\"line\">Concuerror started at 31 Jul 2015 07:21:55</span><br><span class=\"line\">Writing results in concuerror_report.txt</span><br><span class=\"line\"></span><br><span class=\"line\">Info: Instrumented z</span><br><span class=\"line\">Info: Instrumented io_lib</span><br><span class=\"line\">Info: Instrumented gen_server</span><br><span class=\"line\">Info: Instrumented gen</span><br><span class=\"line\">Info: Instrumented proc_lib</span><br><span class=\"line\">Info: Instrumented erlang</span><br><span class=\"line\">Info: Instrumented init</span><br><span class=\"line\">Info: Instrumented sys</span><br><span class=\"line\">Info: You can see pairs of racing instructions (in the report and --graph) with &#x27;--show_races true&#x27;</span><br><span class=\"line\">Error: Stop testing on first error. (Check &#x27;-h keep_going&#x27;).</span><br><span class=\"line\"></span><br><span class=\"line\">Done! (Exit status: warning)</span><br><span class=\"line\">  Summary: 1 errors, 4/4 interleavings explored</span><br><span class=\"line\">youthy@youthy:~/code/Concuerror$ vim concuerror_report.txt </span><br></pre></td></tr></table></figure></p>\n<p>concuerror_report.txt:<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Erroneous interleaving 1:</span><br><span class=\"line\">* At step 23 process P exited abnormally</span><br><span class=\"line\">    Reason:</span><br><span class=\"line\">      &#123;&#123;badmatch,initializing&#125;,</span><br><span class=\"line\">       [&#123;z,test,0,[&#123;file,&quot;../etest/z.erl&quot;&#125;,&#123;line,22&#125;]&#125;]&#125;</span><br><span class=\"line\">    Stacktrace:</span><br><span class=\"line\">      [&#123;z,test,0,[&#123;file,&quot;../etest/z.erl&quot;&#125;,&#123;line,22&#125;]&#125;]</span><br><span class=\"line\">* Blocked at a &#x27;receive&#x27; (when all other processes have exited):</span><br><span class=\"line\">    P.1 in gen_server.erl line 348</span><br><span class=\"line\">--------------------------------------------------------------------------------</span><br><span class=\"line\"></span><br><span class=\"line\">Interleaving info:</span><br><span class=\"line\">   1: P: undefined = erlang:whereis(z)</span><br><span class=\"line\">    in gen.erl line 277</span><br><span class=\"line\">   2: P: [] = erlang:process_info(P, registered_name)</span><br><span class=\"line\">    in proc_lib.erl line 648</span><br><span class=\"line\">   3: P: P.1 = erlang:spawn_opt(&#123;proc_lib,init_p,[P,[],gen,init_it,[gen_server,P,self,&#123;local,z&#125;,z,[],[]]],[]&#125;)</span><br><span class=\"line\">    in erlang.erl line 249</span><br><span class=\"line\">   4: P.1: undefined = erlang:put(&#x27;$ancestors&#x27;, [P])</span><br><span class=\"line\">    in proc_lib.erl line 221</span><br><span class=\"line\">   5: P.1: undefined = erlang:put(&#x27;$initial_call&#x27;, &#123;z,init,1&#125;)</span><br><span class=\"line\">    in proc_lib.erl line 222</span><br><span class=\"line\">   6: P.1: true = erlang:register(z, P.1)</span><br><span class=\"line\">    in gen.erl line 280</span><br><span class=\"line\">   7: P.1: &#123;P.1,&#123;get_argument,generic_debug&#125;&#125; = init ! &#123;P.1,&#123;get_argument,generic_debug&#125;&#125;</span><br><span class=\"line\">    in init.erl line 145</span><br><span class=\"line\">   8: Message (&#123;P.1,&#123;get_argument,generic_debug&#125;&#125;) from P.1 reaches init</span><br><span class=\"line\">   9: Message (&#123;init,error&#125;) from init reaches P.1</span><br><span class=\"line\">  10: P.1: receives message (&#123;init,error&#125;)</span><br><span class=\"line\">    in init.erl line 146</span><br><span class=\"line\">  11: P.1: &#123;ack,P.1,&#123;ok,P.1&#125;&#125; = P ! &#123;ack,P.1,&#123;ok,P.1&#125;&#125;</span><br><span class=\"line\">    in proc_lib.erl line 348</span><br><span class=\"line\">  12: Message (&#123;ack,P.1,&#123;ok,P.1&#125;&#125;) from P.1 reaches P</span><br><span class=\"line\">  13: P: receives message (&#123;ack,P.1,&#123;ok,P.1&#125;&#125;)</span><br><span class=\"line\">    in proc_lib.erl line 321</span><br><span class=\"line\">  14: P: P.1 = erlang:whereis(z)</span><br><span class=\"line\">    in gen.erl line 154</span><br><span class=\"line\">  15: P: #Ref&lt;0.0.0.176&gt; = erlang:monitor(process, P.1)</span><br><span class=\"line\">    in gen.erl line 204</span><br><span class=\"line\">  16: P: &#123;&#x27;$gen_call&#x27;,&#123;P,#Ref&lt;0.0.0.176&gt;&#125;,read&#125; = erlang:send(P.1, &#123;&#x27;$gen_call&#x27;,&#123;P,#Ref&lt;0.0.0.176&gt;&#125;,read&#125;, [noconnect])</span><br><span class=\"line\">    in gen.erl line 215</span><br><span class=\"line\">  17: Message (&#123;&#x27;$gen_call&#x27;,&#123;P,#Ref&lt;0.0.0.176&gt;&#125;,read&#125;) from P reaches P.1</span><br><span class=\"line\">  18: P.1: receives message (&#123;&#x27;$gen_call&#x27;,&#123;P,#Ref&lt;0.0.0.176&gt;&#125;,read&#125;)</span><br><span class=\"line\">    in gen_server.erl line 348</span><br><span class=\"line\">  19: P.1: &#123;#Ref&lt;0.0.0.176&gt;,initializing&#125; = P ! &#123;#Ref&lt;0.0.0.176&gt;,initializing&#125;</span><br><span class=\"line\">    in gen_server.erl line 214</span><br><span class=\"line\">  20: Message (&#123;#Ref&lt;0.0.0.176&gt;,initializing&#125;) from P.1 reaches P</span><br><span class=\"line\">  21: P: receives message (&#123;#Ref&lt;0.0.0.176&gt;,initializing&#125;)</span><br><span class=\"line\">    in gen.erl line 217</span><br><span class=\"line\">  22: P: true = erlang:demonitor(#Ref&lt;0.0.0.176&gt;, [flush])</span><br><span class=\"line\">    in gen.erl line 219</span><br><span class=\"line\">  23: P: exits abnormally (&#123;&#123;badmatch,initializing&#125;,[&#123;z,test,0,[&#123;file,[46,46,47,101,116,101,115,116,47|...]&#125;,&#123;line,22&#125;]&#125;]&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>报告显示P进程（父进程)在第23步的时候崩溃了，错误原因时badmatch，z.erl的22行，即<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ready = read(),</span><br></pre></td></tr></table></figure></p>\n<p>此处read()返回的不是ready而是intiallizing，也就是handle_info(timeout...)并没有执行。<br>上面的１～２３步显示了gen_server的创建过程.以及消息传递过程。十分详细。不过需要挖掘下gen_server的源码才能看懂。</p>\n<h2 id=\"gen_server的创建过程\">gen_server的创建过程</h2><p>下面分析下gen_server的创建过程。假设我们创建一个{local, test}的进程，并传入Args作为初始化参数，Opts为进程的设置参数.</p>\n<h3 id=\"gen_server:\">gen_server:</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start_link(&#123;local, test&#125;, test, Args, Opts) -&gt;</span><br><span class=\"line\">   gen:start(gen_server,  link, &#123;local, test&#125;, test, Args, Opts).</span><br></pre></td></tr></table></figure>\n<h3 id=\"gen:\">gen:</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start(gen_server, link, &#123;local, test&#125;, test, Args, Opts) -&gt;</span><br><span class=\"line\">     case where(&#123;local, test&#125;) of %检测名字是否注册</span><br><span class=\"line\">       undefined -&gt;</span><br><span class=\"line\">          do_spawn(gen_server, link, &#123;local, test&#125;, test, Args, Opts);</span><br><span class=\"line\">        Pid -&gt;</span><br><span class=\"line\">           &#123;error, &#123;already_started, Pid&#125;&#125;</span><br><span class=\"line\">      end.</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">do_spawn(gen_server, link, &#123;local, test&#125;, test, Args, Opts) -&gt;</span><br><span class=\"line\">        Time = somefun(Opts) % 提取出Opt中的timeout参数, </span><br><span class=\"line\">        proc_lib:start_link(gen, init_it, </span><br><span class=\"line\">        [gen_server, self(), self(), &#123;local, test&#125;, test, Args, Opts], Time, spawn_opts(Opts)).</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>此处spawn_opts的作用时查找Opts中有没有spawn_opt这个选项，否则为[].</p>\n</blockquote>\n<h3 id=\"proc_lib:\">proc_lib:</h3><p>上面self()一般情况下为supervisor的Pid。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start_link(gen, init_it, [gen_server, Sup, Sup, &#123;local, test&#125;, test, Args, Opts], Timeout, Opts|[]) -&gt;</span><br><span class=\"line\">  Pid = proc_lib:spawn_opt(gen, init_it, [gen_server, SelfPid, SelfPid, &#123;local, test&#125;, test, Args, Opts|[]], ensure_link(Opts|[])), %ensure_link尝试将link加入Opts</span><br><span class=\"line\">  sync_wait(Pid, Timeout).</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spawn_opt(gen, init_it, [gen_server, selfPid, SelfPid, &#123;local, test&#125;, test, Args, Opts], [link]|[link, Opts]) -&gt;</span><br><span class=\"line\">   Parent = ......%获取当前进程registername为父进程</span><br><span class=\"line\">   Ancestors = ....% 获取进程字典中的$ancestors的值</span><br><span class=\"line\">   check_for_monitor([link]|[link,Opts])....% 检测monitor这个参数在不在其中，在的话直接抛出错误。 </span><br><span class=\"line\">   erlang:spawn_opt(proc_lib, init_p, [Parent, Ancestors, gen, init_it, [gen_server, SelfPid....Opts],[link]|[link, Opts]).</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sync_wait(Pid, TimeOut) -&gt;</span><br><span class=\"line\">  receive </span><br><span class=\"line\">  &#123;ack, Pid, Return&#125; -&gt;</span><br><span class=\"line\">    Return;</span><br><span class=\"line\">  &#123;&#x27;EXIT&#x27;, Pid, Reason&#125; -&gt;</span><br><span class=\"line\">    &#123;error, Reason&#125;</span><br><span class=\"line\">  after TimeOut -&gt;</span><br><span class=\"line\">    unlink(Pid),</span><br><span class=\"line\">    exit(Pid, kill),</span><br><span class=\"line\">    flush(Pid),</span><br><span class=\"line\">    &#123;error, timeout&#125;</span><br><span class=\"line\">   end.</span><br></pre></td></tr></table></figure>\n<p>erlang:spawn_opt与spawn类似，只不过支持一些option。所以调用的还是proc_lib的init_p。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">init_p(Parent, Ancestors, gen, init_it, [gen_server, Sup, Sup, &#123;local, test&#125;, test, Args, Opts|[]], [link|[link, Opts]) -&gt;</span><br><span class=\"line\">  put(&#x27;ancestors&#x27;, [Parent|Ancestors]),</span><br><span class=\"line\">  put(&#x27;initial_call&#x27;, trans_init(gen, init_it, [gen_server, Sup.....])),</span><br><span class=\"line\">  init_p_do_apply(gen, init_it, [gen_server, Sup, Sup....]).</span><br></pre></td></tr></table></figure></p>\n<p>其中trans_init的结果返回为{Module, init, 1} 即 {test, init, 1}.<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">init_p_do_apply(gen, init_it, [gen_server, Sup, Sup, &#123;local, test&#125;, test, Args, Opts|[]]) -&gt;</span><br><span class=\"line\">    try</span><br><span class=\"line\">\tapply(gen, init_it, [gen_server, Sup... Opts]) </span><br><span class=\"line\">    catch</span><br><span class=\"line\">\tClass:Reason -&gt;</span><br><span class=\"line\">\t    exit_p(Class, Reason)</span><br><span class=\"line\">    end.</span><br></pre></td></tr></table></figure></p>\n<p>exit_p里面格式化一些错误信息，并用error_logger输出</p>\n<h3 id=\"gen\">gen</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">init_it(gen_server, Sup, Sup, &#123;local, test&#125;, test, Args, Opts|[]) -&gt;</span><br><span class=\"line\">    case name_register(&#123;local, test&#125;) of</span><br><span class=\"line\">\ttrue -&gt;</span><br><span class=\"line\">\t    init_it2(gen_server, Sup, Sup, &#123;local, test&#125;, test, Args, Opts|[]);</span><br><span class=\"line\">\t&#123;false, Pid&#125; -&gt;</span><br><span class=\"line\">\t    proc_lib:init_ack(Sup, &#123;error, &#123;already_started, Pid&#125;&#125;)</span><br><span class=\"line\">    end.</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name_register(&#123;local, Name&#125; = LN) -&gt;</span><br><span class=\"line\">    try register(Name, self()) of</span><br><span class=\"line\">\ttrue -&gt; true</span><br><span class=\"line\">    catch</span><br><span class=\"line\">\terror:_ -&gt;</span><br><span class=\"line\">\t    &#123;false, where(LN)&#125;</span><br><span class=\"line\">    end;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">init_it2(gen_server, Sup, Sup, &#123;local, test&#125;, test, Args, Opts|[]) -&gt;</span><br><span class=\"line\">   gen_server:init_it(Sup, Sup, &#123;local, test&#125;, test, Args, Opts|[]).</span><br></pre></td></tr></table></figure>\n<h3 id=\"gen_server:-1\">gen_server:</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">init_it(Sup, Sup, &#123;local, test&#125;, test, Args, Opts|[]) -&gt;</span><br><span class=\"line\">    test = name(&#123;local, test&#125;),</span><br><span class=\"line\">    Debug = debug_options(Name, Opts|[]),</span><br><span class=\"line\">    case catch test:init(Args) of</span><br><span class=\"line\">\t&#123;ok, State&#125; -&gt;</span><br><span class=\"line\">\t    proc_lib:init_ack(Sup, &#123;ok, self()&#125;), \t    </span><br><span class=\"line\">\t    loop(Sup, test, State, test, infinity, Debug);</span><br><span class=\"line\">\t&#123;ok, State, Timeout&#125; -&gt;</span><br><span class=\"line\">\t    proc_lib:init_ack(Sup, &#123;ok, self()&#125;), \t    </span><br><span class=\"line\">\t    loop(Sup, test, State, test, Timeout, Debug);</span><br><span class=\"line\">\t&#123;stop, Reason&#125; -&gt;</span><br><span class=\"line\">\t    unregister_name(test),</span><br><span class=\"line\">\t    proc_lib:init_ack(Sup, &#123;error, Reason&#125;),</span><br><span class=\"line\">\t    exit(Reason);</span><br><span class=\"line\">\tignore -&gt;</span><br><span class=\"line\">\t    unregister_name(test),</span><br><span class=\"line\">\t    proc_lib:init_ack(Sup, ignore),</span><br><span class=\"line\">\t    exit(normal);</span><br><span class=\"line\">\t&#123;&#x27;EXIT&#x27;, Reason&#125; -&gt;</span><br><span class=\"line\">\t    unregister_name(test),</span><br><span class=\"line\">\t    proc_lib:init_ack(Sup, &#123;error, Reason&#125;),</span><br><span class=\"line\">\t    exit(Reason);</span><br><span class=\"line\">\tElse -&gt;</span><br><span class=\"line\">\t    Error = &#123;bad_return_value, Else&#125;,</span><br><span class=\"line\">\t    proc_lib:init_ack(Sup, &#123;error, Error&#125;),</span><br><span class=\"line\">\t    exit(Error)</span><br><span class=\"line\">    end.</span><br></pre></td></tr></table></figure>\n<h3 id=\"proc_lib\">proc_lib</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">init_ack(Sup, &#123;ok, Pid&#125;|&#123;error, already_exited&#125;) -&gt;</span><br><span class=\"line\">    Parent ! &#123;ack, self(), &#123;ok, Pid&#125;&#125;|&#123;error, already_exited&#125;&#125;,</span><br><span class=\"line\">    ok.</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loop(Sup, test, State, test, Timeout, Debug) -&gt;</span><br><span class=\"line\">    Msg = receive</span><br><span class=\"line\">\t      Input -&gt;</span><br><span class=\"line\">\t\t    Input</span><br><span class=\"line\">\t  after Time -&gt;</span><br><span class=\"line\">\t\t  timeout</span><br><span class=\"line\">\t  end,</span><br><span class=\"line\">    decode_msg(Msg, Parent, Name, State, Mod, Time, Debug, false).</span><br></pre></td></tr></table></figure>\n<p>至此gen_server初始化完成。<br>。<br>由此得知。gen_server再调用test：init之前，主要做了</p>\n<ol>\n<li>判断名字是否被占用，否则报{error, already_exited}</li>\n<li>写入ancestors和initial call</li>\n</ol>\n<p>Opts中的timeout参数主要用来衡量创建进程的time，超时回结束进程并返回。而{ok， State， Timeout}的timeout参数用来参与loop循环，在进程创建后timeout时间内没有接到消息，就会像自己发送timeout这个消息。 而且这个参数在之后的handle_call, handle_cast,handle_info等回调中，使可以修改timeout的数值。参考源码：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">handle_msg(&#123;&#x27;$gen_call&#x27;, From, Msg&#125;, Parent, Name, State, Mod, Debug) -&gt;</span><br><span class=\"line\">    case catch Mod:handle_call(Msg, From, State) of</span><br><span class=\"line\">\t&#123;reply, Reply, NState&#125; -&gt;</span><br><span class=\"line\">\t    Debug1 = reply(Name, From, Reply, NState, Debug),</span><br><span class=\"line\">\t    loop(Parent, Name, NState, Mod, infinity, Debug1);</span><br><span class=\"line\">\t&#123;reply, Reply, NState, Time1&#125; -&gt;</span><br><span class=\"line\">\t    Debug1 = reply(Name, From, Reply, NState, Debug),</span><br><span class=\"line\">\t    loop(Parent, Name, NState, Mod, Time1, Debug1);</span><br><span class=\"line\">\t&#123;noreply, NState&#125; -&gt;</span><br><span class=\"line\">\t    Debug1 = sys:handle_debug(Debug, fun print_event/3, Name,</span><br><span class=\"line\">\t\t\t\t      &#123;noreply, NState&#125;),</span><br><span class=\"line\">\t    loop(Parent, Name, NState, Mod, infinity, Debug1);</span><br><span class=\"line\">\t&#123;noreply, NState, Time1&#125; -&gt;</span><br><span class=\"line\">\t    Debug1 = sys:handle_debug(Debug, fun print_event/3, Name,</span><br><span class=\"line\">\t\t\t\t      &#123;noreply, NState&#125;),</span><br><span class=\"line\">\t    loop(Parent, Name, NState, Mod, Time1, Debug1);</span><br><span class=\"line\">\t&#123;stop, Reason, Reply, NState&#125; -&gt;</span><br><span class=\"line\">\t    &#123;&#x27;EXIT&#x27;, R&#125; = </span><br><span class=\"line\">\t\t(catch terminate(Reason, Name, Msg, Mod, NState, Debug)),</span><br><span class=\"line\">\t    reply(Name, From, Reply, NState, Debug),</span><br><span class=\"line\">\t    exit(R);</span><br><span class=\"line\">\tOther -&gt;</span><br><span class=\"line\">\t    handle_common_reply(Other, Parent, Name, Msg, Mod, State, Debug)</span><br><span class=\"line\">    end;</span><br></pre></td></tr></table></figure></p>\n<p>可见handle_call的返回值如果包含Time1，就会修改loop的Timeout参数。</p>\n<h2 id=\"where_is_the_point?\">where is the point?</h2><p>问题出现在<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;ok, State, Timeout&#125; -&gt;</span><br><span class=\"line\">    proc_lib:init_ack(Sup, &#123;ok, self()&#125;), \t    </span><br><span class=\"line\">    loop(Sup, test, State, test, Timeout, Debug);</span><br></pre></td></tr></table></figure></p>\n<p>Ｐ进程创建Ｐ.1进程，然后进入receive，期待一个{ack, Pid, Return}的回复。在init结束返回{ok, State, Timeout}后，proc_lib:init_ack完成了向P发送{ack, Pid, Return}的任务。然后进入ｌｏｏｐ循环。但这时Ｐ进程接到消息后立刻发送了read.导致timeout并没有发送出去。造成badmatch的结果。</p>\n<p>在一种情况，其实在name_register的时候名字和Ｐｉｄ就已经注册好了。但此时甚至没有进入ｉｎｉｔ函数，如果有其他进程朝test名字的ｓｅｒｖｅｒ发送消息，自然会导致ｔｉｍｅｏｕｔ的失效。</p>"},{"title":"erlang_mysql_driver 源码分析(一)","date":"2015-06-08T12:13:07.000Z","_content":"\n这两天抽时间看了看erlang_mysql_driver这个项目，用来建立管理服务器端mysql方面的处理。听说emysql也不错，过两天看看对比下。\n这个项目主体有这么几个文件\n> mysql.erl\nmysql_auth.erl\nmysql_conn.erl\nmysql_recv.erl\n\n<!--more-->\n#mysql:start_link\n主要接口在mysql里面。\nmysql文件头有作者写的功能使用注释\n> %%% Usage:\n%%%\n%%%\n%%% Call one of the start-functions before any call to fetch/2\n%%%\n%%%   start_link(PoolId, Host, User, Password, Database)\n%%%   start_link(PoolId, Host, Port, User, Password, Database)\n%%%   start_link(PoolId, Host, User, Password, Database, LogFun)\n%%%   start_link(PoolId, Host, Port, User, Password, Database, LogFun)\n%%%\n%%% (These functions also have non-linking coutnerparts.)\n\n\n让我们在使用任何fetch之前先start_link,如果不需要link，同时提供了start接口。\n好，找到start_link.\n```\nstart_link(PoolId, Host, User, Password, Database) ->\n    start_link(PoolId, Host, ?PORT, User, Password, Database).\n\nstart_link(PoolId, Host, Port, User, Password, Database) ->\n    start_link(PoolId, Host, Port, User, Password, Database, undefined,\n\t       undefined).\n\nstart_link(PoolId, Host, undefined, User, Password, Database, LogFun) ->\n    start_link(PoolId, Host, ?PORT, User, Password, Database, LogFun,\n\t       undefined);\nstart_link(PoolId, Host, Port, User, Password, Database, LogFun) ->\n    start_link(PoolId, Host, Port, User, Password, Database, LogFun,\n\t       undefined).\n\nstart_link(PoolId, Host, undefined, User, Password, Database, LogFun,\n\t   Encoding) ->\n    start1(PoolId, Host, ?PORT, User, Password, Database, LogFun, Encoding,\n\t   start_link);\nstart_link(PoolId, Host, Port, User, Password, Database, LogFun, Encoding) ->\n    start1(PoolId, Host, Port, User, Password, Database, LogFun, Encoding,\n\t   start_link).\n```\n\nstart与start_link大致相同，只不过最后参数是start不是start_link\n```\n...\nstart(PoolId, Host, undefined, User, Password, Database, LogFun, Encoding) ->\n    start1(PoolId, Host, ?PORT, User, Password, Database, LogFun, Encoding,\n\t   start);\nstart(PoolId, Host, Port, User, Password, Database, LogFun, Encoding) ->\n    start1(PoolId, Host, Port, User, Password, Database, LogFun, Encoding,\n\t   start).\n```\n\n其中\n> PoolId: 这个进程的id，随便起，比如my_sql_game.\nHost: 目标ip, 本机写\"127.0.0.1\"\nPort: 端口号，不改的话默认是3306\nUser: 数据库的用户名：比如 youthy\nPassword：密码\nDatabase:数据库名\nLogFun:日志输出函数，如果undefined则会用默认的输出\nEncoding:编码方式，我们这里用utf8.\n\n然后转入start1这个函数\n```\nstart1(PoolId, Host, Port, User, Password, Database, LogFun, Encoding,\n       StartFunc) ->\n    crypto:start(),\n    gen_server:StartFunc(\n      {local, ?SERVER}, ?MODULE,\n      [PoolId, Host, Port, User, Password, Database, LogFun, Encoding], []).\n```\n\ncrypto是之后需要一些加密算法， 比如md5，sha等，使用前必须先start。\n而后就是再熟悉不过的gen_server,这里面根据方式不同，分别调用start_link, start,然后找到init函数\n```\ninit([PoolId, Host, Port, User, Password, Database, LogFun, Encoding]) ->\n    erlang:process_flag(priority, high),\n    LogFun1 = if LogFun == undefined -> fun log/4; true -> LogFun end,\n    case mysql_conn:start(Host, Port, User, Password, Database, LogFun1,\n\t\t\t  Encoding, PoolId) of\n\t{ok, ConnPid} ->\n\t    Conn = new_conn(PoolId, ConnPid, true, Host, Port, User, Password,\n\t\t\t    Database, Encoding),\n\t    State = #state{log_fun = LogFun1},\n\t    {ok, add_conn(Conn, State)};\n\t{error, Reason} ->\n\t    ?Log(LogFun1, error,\n\t\t \"failed starting first MySQL connection handler, \"\n\t\t \"exiting\"),\n\t    {stop, {error, Reason}}\n    end.\n```\n\n首先用process_flag将优先级设为高。之后调用mysql_conn:start/8,等会再进去看它内部，我们只知道它返回一个ConnPid,或者出错，然后将这个Pid用new_conn生成一个Conn。然后用add_conn将Conn加入State中，返回，至此这个gen_server创建完毕。名字是\"my_sql_game\"（随便取）。我们看一下new_conn和add_conn这两个函数\n```\nnew_conn(PoolId, ConnPid, Reconnect, Host, Port, User, Password, Database,\n\t Encoding) ->\n    case Reconnect of\n\ttrue ->\n\t    #conn{pool_id = PoolId,\n\t\t  pid = ConnPid,\n\t\t  reconnect = true,\n\t\t  host = Host,\n\t\t  port = Port,\n\t\t  user = User,\n\t\t  password = Password,\n\t\t  database = Database,\n\t\t  encoding = Encoding\n\t\t };\n\tfalse ->                        \n\t    #conn{pool_id = PoolId,\n\t\t  pid = ConnPid,\n\t\t  reconnect = false}\n    end.\n---------\nadd_conn(Conn, State) ->\n    Pid = Conn#conn.pid,\n    erlang:monitor(process, Conn#conn.pid),\n    PoolId = Conn#conn.pool_id,\n    ConnPools = State#state.conn_pools,\n    NewPool = \n\tcase gb_trees:lookup(PoolId, ConnPools) of\n\t    none ->\n\t\t{[Conn],[]};\n\t    {value, {Unused, Used}} ->\n\t\t{[Conn | Unused], Used}\n\tend,\n    State#state{conn_pools =\n\t\tgb_trees:enter(PoolId, NewPool,\n\t\t\t       ConnPools),\n\t\tpids_pools = gb_trees:enter(Pid, PoolId,\n\t\t\t\t\t    State#state.pids_pools)}.\n```\n\n这里涉及了两个结构\n```\n-record(conn, {\n\t  pool_id,      %% atom(), the pool's id\n\t  pid,          %% pid(), mysql_conn process\t \n\t  reconnect,\t%% true | false, should mysql_dispatcher try\n                        \n\t  host,\t\t%% string()\n\t  port,\t\t%% integer()\n\t  user,\t\t%% string()\n\t  password,\t%% string()\n\t  database,\t%% string()\n\t  encoding\n\t }).\n\t \n-record(state, {\n\t\n\t  conn_pools = gb_trees:empty(), \n\n\n\t  pids_pools = gb_trees:empty(),                               \n\n\t  log_fun,\t\n\n\t  prepares = gb_trees:empty()\n\t }).\n```\n\nconn这个结构大部分就是把函数参数存了起来，其中只有pid需要注意下，它就是mysql_conn:start返回的Pid，new_conn这个函数将参数转成了#conn这个record，然后通过add_conn将#conn存入了#state的conn_pools.字面理解就是链接池。值得注意的是my_sql_game这个gen_server的state用了3个gb_trees这个存储结构。也就是二叉查找树。erlang:monitor(process, Conn#conn.pid).\n> monitor(Type, Item) -> MonitorRef\nTypes:\nType = process\nItem = pid() | {RegName, Node} | RegName\n RegName = atom()\n Node = node()\nMonitorRef = reference()\n\n目前Type只接受process这个参数，这个函数字面理解就是监控，让这个gen_server监控之前建立的conn进程，被监控进程如果崩溃了，一条{'DOWN', MonitorRef, Type, Object，Info}\n消息会发往监控者，这时可以被handle_info处理。\n```\nhandle_info({'DOWN', _MonitorRef, process, Pid, Info}, State) ->\n    LogFun = State#state.log_fun,\n    case remove_conn(Pid, State) of\n\t{ok, Conn, NewState} ->\n\t    LogLevel = case Info of\n\t\t\t   normal -> normal;\n\t\t\t   _ -> error\n\t\t       end,\n\t    ?Log2(LogFun, LogLevel,\n\t\t\"connection pid ~p exited : ~p\", [Pid, Info]),\n\t    case Conn#conn.reconnect of\n\t\ttrue ->\n\t\t    start_reconnect(Conn, LogFun);\n\t\tfalse ->\n\t\t    ok\n\t    end,\n\t    {noreply, NewState};\n\terror ->\n\t    ?Log2(LogFun, error,\n\t\t  \"received 'DOWN' signal from pid ~p not in my list\", [Pid]),\n\t    {noreply, State}\n    end;\n```\n\n可以看出主要是讲state里面的conn_pool里面把这个崩掉的进程conn移除，然后如果这个链接conn的属性是reconnect，那么会重新start_reconnect。先不展开，以机会再说，要不init的过程就跑远了。\n回到erlang:monitor.(还有个对应的函数是demonitor，可以取消监控)\n```\nNewPool = \n\tcase gb_trees:lookup(PoolId, ConnPools) of\n\t    none ->\n\t\t{[Conn],[]};\n\t    {value, {Unused, Used}} ->\n\t\t{[Conn | Unused], Used}\n\tend,\n```\n\n从ConnPool中找到PoolId的结点，由case可见这个结点存的是{Unused， Used}的形式。\ngb_tree的结构是{Size, Tree}.Size表示这个tree有多少个结点。tree的结构是{key, Value, Smaller, Biger}.\n\n```\n1> gb_trees:empty().\n{0,nil}\n2> gb_trees:insert(5, v0, v(1)).\n{1,{5,v0,nil,nil}}\n3> gb_trees:insert(8, v1, v(2)).\n{2,{5,v0,nil,{8,v1,nil,nil}}}\n4> gb_trees:insert(3, v2, v(3)).\n{3,{5,v0,{3,v2,nil,nil},{8,v1,nil,nil}}}\n5> gb_trees:insert(7, v3, v(4)).\n{4,{5,v0,{3,v2,nil,nil},{8,v1,{7,v3,nil,nil},nil}}}\n6> gb_trees:insert(1, v4, v(5)).\n{5,\n {5,v0,{3,v2,{1,v4,nil,nil},nil},{8,v1,{7,v3,nil,nil},nil}}}\n```\n\n上面演示了一个gb_tree的建立，gb_tree的大小判断是基于key的。二叉树数据结构都学过。\n我们可以看一下state里面的结构究竟是什么样子\n```\nmysql:613: state:{state,\n                     {1,\n                      {my_sql_game,\n                          {[{conn,my_sql_game,<0.62.0>,true,\"127.0.0.1\",3306,\n                                \"aries\",\"arig\",\"aries_game\",utf8},\n                            {conn,my_sql_game,<0.58.0>,true,\"127.0.0.1\",3306,\n                                \"aries\",\"arig\",\"aries_game\",utf8},\n                            {conn,my_sql_game,<0.54.0>,true,\"127.0.0.1\",3306,\n                                \"aries\",\"arig\",\"aries_game\",utf8}],\n                           [{conn,my_sql_game,<0.41.0>,true,\"127.0.0.1\",3306,\n                                \"aries\",\"arig\",\"aries_game\",utf8}]},\n                          nil,nil}},\n                     {4,\n                      {<0.41.0>,my_sql_game,nil,\n                       {<0.54.0>,my_sql_game,nil,\n                        {<0.58.0>,my_sql_game,nil,\n                         {<0.62.0>,my_sql_game,nil,nil}}}}},\n                     #Fun<mysql.0.74618748>,\n                     {0,nil}}\n```\n\n可见我们my_sql_game的conn_pool的size始终为1，\n因为我们在add_conn函数中的最后总是将conn enter进poolId为my_sql_game的链接池，之后又以pid为key，enter进pid_pool,因为pid不是唯一的，所以pid_pool的size会不断变大。至此我们了解了my_sql_game这个gen_server的创建过程。下篇看一下之前没看到部分。\n相关参考\n> [gb_trees(坚强2002博客）](http://www.cnblogs.com/me-sa/archive/2012/06/23/erlang-gb_trees.html)\n[A Short Visit to Common Data Structures(推荐！)](http://learnyousomeerlang.com/a-short-visit-to-common-data-structures)\n[gb_trees(官方doc)](http://www.erlang.org/doc/man/gb_trees.html)\n","source":"_posts/erlang_mysql_driver.md","raw":"title: erlang_mysql_driver 源码分析(一)\ndate: 2015-06-08 20:13:07\ntags: erlang\ncategories: erlang\n---\n\n这两天抽时间看了看erlang_mysql_driver这个项目，用来建立管理服务器端mysql方面的处理。听说emysql也不错，过两天看看对比下。\n这个项目主体有这么几个文件\n> mysql.erl\nmysql_auth.erl\nmysql_conn.erl\nmysql_recv.erl\n\n<!--more-->\n#mysql:start_link\n主要接口在mysql里面。\nmysql文件头有作者写的功能使用注释\n> %%% Usage:\n%%%\n%%%\n%%% Call one of the start-functions before any call to fetch/2\n%%%\n%%%   start_link(PoolId, Host, User, Password, Database)\n%%%   start_link(PoolId, Host, Port, User, Password, Database)\n%%%   start_link(PoolId, Host, User, Password, Database, LogFun)\n%%%   start_link(PoolId, Host, Port, User, Password, Database, LogFun)\n%%%\n%%% (These functions also have non-linking coutnerparts.)\n\n\n让我们在使用任何fetch之前先start_link,如果不需要link，同时提供了start接口。\n好，找到start_link.\n```\nstart_link(PoolId, Host, User, Password, Database) ->\n    start_link(PoolId, Host, ?PORT, User, Password, Database).\n\nstart_link(PoolId, Host, Port, User, Password, Database) ->\n    start_link(PoolId, Host, Port, User, Password, Database, undefined,\n\t       undefined).\n\nstart_link(PoolId, Host, undefined, User, Password, Database, LogFun) ->\n    start_link(PoolId, Host, ?PORT, User, Password, Database, LogFun,\n\t       undefined);\nstart_link(PoolId, Host, Port, User, Password, Database, LogFun) ->\n    start_link(PoolId, Host, Port, User, Password, Database, LogFun,\n\t       undefined).\n\nstart_link(PoolId, Host, undefined, User, Password, Database, LogFun,\n\t   Encoding) ->\n    start1(PoolId, Host, ?PORT, User, Password, Database, LogFun, Encoding,\n\t   start_link);\nstart_link(PoolId, Host, Port, User, Password, Database, LogFun, Encoding) ->\n    start1(PoolId, Host, Port, User, Password, Database, LogFun, Encoding,\n\t   start_link).\n```\n\nstart与start_link大致相同，只不过最后参数是start不是start_link\n```\n...\nstart(PoolId, Host, undefined, User, Password, Database, LogFun, Encoding) ->\n    start1(PoolId, Host, ?PORT, User, Password, Database, LogFun, Encoding,\n\t   start);\nstart(PoolId, Host, Port, User, Password, Database, LogFun, Encoding) ->\n    start1(PoolId, Host, Port, User, Password, Database, LogFun, Encoding,\n\t   start).\n```\n\n其中\n> PoolId: 这个进程的id，随便起，比如my_sql_game.\nHost: 目标ip, 本机写\"127.0.0.1\"\nPort: 端口号，不改的话默认是3306\nUser: 数据库的用户名：比如 youthy\nPassword：密码\nDatabase:数据库名\nLogFun:日志输出函数，如果undefined则会用默认的输出\nEncoding:编码方式，我们这里用utf8.\n\n然后转入start1这个函数\n```\nstart1(PoolId, Host, Port, User, Password, Database, LogFun, Encoding,\n       StartFunc) ->\n    crypto:start(),\n    gen_server:StartFunc(\n      {local, ?SERVER}, ?MODULE,\n      [PoolId, Host, Port, User, Password, Database, LogFun, Encoding], []).\n```\n\ncrypto是之后需要一些加密算法， 比如md5，sha等，使用前必须先start。\n而后就是再熟悉不过的gen_server,这里面根据方式不同，分别调用start_link, start,然后找到init函数\n```\ninit([PoolId, Host, Port, User, Password, Database, LogFun, Encoding]) ->\n    erlang:process_flag(priority, high),\n    LogFun1 = if LogFun == undefined -> fun log/4; true -> LogFun end,\n    case mysql_conn:start(Host, Port, User, Password, Database, LogFun1,\n\t\t\t  Encoding, PoolId) of\n\t{ok, ConnPid} ->\n\t    Conn = new_conn(PoolId, ConnPid, true, Host, Port, User, Password,\n\t\t\t    Database, Encoding),\n\t    State = #state{log_fun = LogFun1},\n\t    {ok, add_conn(Conn, State)};\n\t{error, Reason} ->\n\t    ?Log(LogFun1, error,\n\t\t \"failed starting first MySQL connection handler, \"\n\t\t \"exiting\"),\n\t    {stop, {error, Reason}}\n    end.\n```\n\n首先用process_flag将优先级设为高。之后调用mysql_conn:start/8,等会再进去看它内部，我们只知道它返回一个ConnPid,或者出错，然后将这个Pid用new_conn生成一个Conn。然后用add_conn将Conn加入State中，返回，至此这个gen_server创建完毕。名字是\"my_sql_game\"（随便取）。我们看一下new_conn和add_conn这两个函数\n```\nnew_conn(PoolId, ConnPid, Reconnect, Host, Port, User, Password, Database,\n\t Encoding) ->\n    case Reconnect of\n\ttrue ->\n\t    #conn{pool_id = PoolId,\n\t\t  pid = ConnPid,\n\t\t  reconnect = true,\n\t\t  host = Host,\n\t\t  port = Port,\n\t\t  user = User,\n\t\t  password = Password,\n\t\t  database = Database,\n\t\t  encoding = Encoding\n\t\t };\n\tfalse ->                        \n\t    #conn{pool_id = PoolId,\n\t\t  pid = ConnPid,\n\t\t  reconnect = false}\n    end.\n---------\nadd_conn(Conn, State) ->\n    Pid = Conn#conn.pid,\n    erlang:monitor(process, Conn#conn.pid),\n    PoolId = Conn#conn.pool_id,\n    ConnPools = State#state.conn_pools,\n    NewPool = \n\tcase gb_trees:lookup(PoolId, ConnPools) of\n\t    none ->\n\t\t{[Conn],[]};\n\t    {value, {Unused, Used}} ->\n\t\t{[Conn | Unused], Used}\n\tend,\n    State#state{conn_pools =\n\t\tgb_trees:enter(PoolId, NewPool,\n\t\t\t       ConnPools),\n\t\tpids_pools = gb_trees:enter(Pid, PoolId,\n\t\t\t\t\t    State#state.pids_pools)}.\n```\n\n这里涉及了两个结构\n```\n-record(conn, {\n\t  pool_id,      %% atom(), the pool's id\n\t  pid,          %% pid(), mysql_conn process\t \n\t  reconnect,\t%% true | false, should mysql_dispatcher try\n                        \n\t  host,\t\t%% string()\n\t  port,\t\t%% integer()\n\t  user,\t\t%% string()\n\t  password,\t%% string()\n\t  database,\t%% string()\n\t  encoding\n\t }).\n\t \n-record(state, {\n\t\n\t  conn_pools = gb_trees:empty(), \n\n\n\t  pids_pools = gb_trees:empty(),                               \n\n\t  log_fun,\t\n\n\t  prepares = gb_trees:empty()\n\t }).\n```\n\nconn这个结构大部分就是把函数参数存了起来，其中只有pid需要注意下，它就是mysql_conn:start返回的Pid，new_conn这个函数将参数转成了#conn这个record，然后通过add_conn将#conn存入了#state的conn_pools.字面理解就是链接池。值得注意的是my_sql_game这个gen_server的state用了3个gb_trees这个存储结构。也就是二叉查找树。erlang:monitor(process, Conn#conn.pid).\n> monitor(Type, Item) -> MonitorRef\nTypes:\nType = process\nItem = pid() | {RegName, Node} | RegName\n RegName = atom()\n Node = node()\nMonitorRef = reference()\n\n目前Type只接受process这个参数，这个函数字面理解就是监控，让这个gen_server监控之前建立的conn进程，被监控进程如果崩溃了，一条{'DOWN', MonitorRef, Type, Object，Info}\n消息会发往监控者，这时可以被handle_info处理。\n```\nhandle_info({'DOWN', _MonitorRef, process, Pid, Info}, State) ->\n    LogFun = State#state.log_fun,\n    case remove_conn(Pid, State) of\n\t{ok, Conn, NewState} ->\n\t    LogLevel = case Info of\n\t\t\t   normal -> normal;\n\t\t\t   _ -> error\n\t\t       end,\n\t    ?Log2(LogFun, LogLevel,\n\t\t\"connection pid ~p exited : ~p\", [Pid, Info]),\n\t    case Conn#conn.reconnect of\n\t\ttrue ->\n\t\t    start_reconnect(Conn, LogFun);\n\t\tfalse ->\n\t\t    ok\n\t    end,\n\t    {noreply, NewState};\n\terror ->\n\t    ?Log2(LogFun, error,\n\t\t  \"received 'DOWN' signal from pid ~p not in my list\", [Pid]),\n\t    {noreply, State}\n    end;\n```\n\n可以看出主要是讲state里面的conn_pool里面把这个崩掉的进程conn移除，然后如果这个链接conn的属性是reconnect，那么会重新start_reconnect。先不展开，以机会再说，要不init的过程就跑远了。\n回到erlang:monitor.(还有个对应的函数是demonitor，可以取消监控)\n```\nNewPool = \n\tcase gb_trees:lookup(PoolId, ConnPools) of\n\t    none ->\n\t\t{[Conn],[]};\n\t    {value, {Unused, Used}} ->\n\t\t{[Conn | Unused], Used}\n\tend,\n```\n\n从ConnPool中找到PoolId的结点，由case可见这个结点存的是{Unused， Used}的形式。\ngb_tree的结构是{Size, Tree}.Size表示这个tree有多少个结点。tree的结构是{key, Value, Smaller, Biger}.\n\n```\n1> gb_trees:empty().\n{0,nil}\n2> gb_trees:insert(5, v0, v(1)).\n{1,{5,v0,nil,nil}}\n3> gb_trees:insert(8, v1, v(2)).\n{2,{5,v0,nil,{8,v1,nil,nil}}}\n4> gb_trees:insert(3, v2, v(3)).\n{3,{5,v0,{3,v2,nil,nil},{8,v1,nil,nil}}}\n5> gb_trees:insert(7, v3, v(4)).\n{4,{5,v0,{3,v2,nil,nil},{8,v1,{7,v3,nil,nil},nil}}}\n6> gb_trees:insert(1, v4, v(5)).\n{5,\n {5,v0,{3,v2,{1,v4,nil,nil},nil},{8,v1,{7,v3,nil,nil},nil}}}\n```\n\n上面演示了一个gb_tree的建立，gb_tree的大小判断是基于key的。二叉树数据结构都学过。\n我们可以看一下state里面的结构究竟是什么样子\n```\nmysql:613: state:{state,\n                     {1,\n                      {my_sql_game,\n                          {[{conn,my_sql_game,<0.62.0>,true,\"127.0.0.1\",3306,\n                                \"aries\",\"arig\",\"aries_game\",utf8},\n                            {conn,my_sql_game,<0.58.0>,true,\"127.0.0.1\",3306,\n                                \"aries\",\"arig\",\"aries_game\",utf8},\n                            {conn,my_sql_game,<0.54.0>,true,\"127.0.0.1\",3306,\n                                \"aries\",\"arig\",\"aries_game\",utf8}],\n                           [{conn,my_sql_game,<0.41.0>,true,\"127.0.0.1\",3306,\n                                \"aries\",\"arig\",\"aries_game\",utf8}]},\n                          nil,nil}},\n                     {4,\n                      {<0.41.0>,my_sql_game,nil,\n                       {<0.54.0>,my_sql_game,nil,\n                        {<0.58.0>,my_sql_game,nil,\n                         {<0.62.0>,my_sql_game,nil,nil}}}}},\n                     #Fun<mysql.0.74618748>,\n                     {0,nil}}\n```\n\n可见我们my_sql_game的conn_pool的size始终为1，\n因为我们在add_conn函数中的最后总是将conn enter进poolId为my_sql_game的链接池，之后又以pid为key，enter进pid_pool,因为pid不是唯一的，所以pid_pool的size会不断变大。至此我们了解了my_sql_game这个gen_server的创建过程。下篇看一下之前没看到部分。\n相关参考\n> [gb_trees(坚强2002博客）](http://www.cnblogs.com/me-sa/archive/2012/06/23/erlang-gb_trees.html)\n[A Short Visit to Common Data Structures(推荐！)](http://learnyousomeerlang.com/a-short-visit-to-common-data-structures)\n[gb_trees(官方doc)](http://www.erlang.org/doc/man/gb_trees.html)\n","slug":"erlang_mysql_driver","published":1,"updated":"2018-06-26T09:49:27.734Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqw7jdvt000j6f1r7fli2tmn","content":"<p>这两天抽时间看了看erlang_mysql_driver这个项目，用来建立管理服务器端mysql方面的处理。听说emysql也不错，过两天看看对比下。<br>这个项目主体有这么几个文件</p>\n<blockquote>\n<p>mysql.erl<br>mysql_auth.erl<br>mysql_conn.erl<br>mysql_recv.erl</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>#mysql:start_link<br>主要接口在mysql里面。<br>mysql文件头有作者写的功能使用注释</p>\n<blockquote>\n<p>%%% Usage:<br>%%%<br>%%%<br>%%% Call one of the start-functions before any call to fetch/2<br>%%%<br>%%%   start_link(PoolId, Host, User, Password, Database)<br>%%%   start_link(PoolId, Host, Port, User, Password, Database)<br>%%%   start_link(PoolId, Host, User, Password, Database, LogFun)<br>%%%   start_link(PoolId, Host, Port, User, Password, Database, LogFun)<br>%%%<br>%%% (These functions also have non-linking coutnerparts.)</p>\n</blockquote>\n<p>让我们在使用任何fetch之前先start_link,如果不需要link，同时提供了start接口。<br>好，找到start_link.<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start_link(PoolId, Host, User, Password, Database) -&gt;</span><br><span class=\"line\">    start_link(PoolId, Host, ?PORT, User, Password, Database).</span><br><span class=\"line\"></span><br><span class=\"line\">start_link(PoolId, Host, Port, User, Password, Database) -&gt;</span><br><span class=\"line\">    start_link(PoolId, Host, Port, User, Password, Database, undefined,</span><br><span class=\"line\">\t       undefined).</span><br><span class=\"line\"></span><br><span class=\"line\">start_link(PoolId, Host, undefined, User, Password, Database, LogFun) -&gt;</span><br><span class=\"line\">    start_link(PoolId, Host, ?PORT, User, Password, Database, LogFun,</span><br><span class=\"line\">\t       undefined);</span><br><span class=\"line\">start_link(PoolId, Host, Port, User, Password, Database, LogFun) -&gt;</span><br><span class=\"line\">    start_link(PoolId, Host, Port, User, Password, Database, LogFun,</span><br><span class=\"line\">\t       undefined).</span><br><span class=\"line\"></span><br><span class=\"line\">start_link(PoolId, Host, undefined, User, Password, Database, LogFun,</span><br><span class=\"line\">\t   Encoding) -&gt;</span><br><span class=\"line\">    start1(PoolId, Host, ?PORT, User, Password, Database, LogFun, Encoding,</span><br><span class=\"line\">\t   start_link);</span><br><span class=\"line\">start_link(PoolId, Host, Port, User, Password, Database, LogFun, Encoding) -&gt;</span><br><span class=\"line\">    start1(PoolId, Host, Port, User, Password, Database, LogFun, Encoding,</span><br><span class=\"line\">\t   start_link).</span><br></pre></td></tr></table></figure></p>\n<p>start与start_link大致相同，只不过最后参数是start不是start_link<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">start(PoolId, Host, undefined, User, Password, Database, LogFun, Encoding) -&gt;</span><br><span class=\"line\">    start1(PoolId, Host, ?PORT, User, Password, Database, LogFun, Encoding,</span><br><span class=\"line\">\t   start);</span><br><span class=\"line\">start(PoolId, Host, Port, User, Password, Database, LogFun, Encoding) -&gt;</span><br><span class=\"line\">    start1(PoolId, Host, Port, User, Password, Database, LogFun, Encoding,</span><br><span class=\"line\">\t   start).</span><br></pre></td></tr></table></figure></p>\n<p>其中</p>\n<blockquote>\n<p>PoolId: 这个进程的id，随便起，比如my_sql_game.<br>Host: 目标ip, 本机写&quot;127.0.0.1&quot;<br>Port: 端口号，不改的话默认是3306<br>User: 数据库的用户名：比如 youthy<br>Password：密码<br>Database:数据库名<br>LogFun:日志输出函数，如果undefined则会用默认的输出<br>Encoding:编码方式，我们这里用utf8.</p>\n</blockquote>\n<p>然后转入start1这个函数<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start1(PoolId, Host, Port, User, Password, Database, LogFun, Encoding,</span><br><span class=\"line\">       StartFunc) -&gt;</span><br><span class=\"line\">    crypto:start(),</span><br><span class=\"line\">    gen_server:StartFunc(</span><br><span class=\"line\">      &#123;local, ?SERVER&#125;, ?MODULE,</span><br><span class=\"line\">      [PoolId, Host, Port, User, Password, Database, LogFun, Encoding], []).</span><br></pre></td></tr></table></figure></p>\n<p>crypto是之后需要一些加密算法， 比如md5，sha等，使用前必须先start。<br>而后就是再熟悉不过的gen_server,这里面根据方式不同，分别调用start_link, start,然后找到init函数<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">init([PoolId, Host, Port, User, Password, Database, LogFun, Encoding]) -&gt;</span><br><span class=\"line\">    erlang:process_flag(priority, high),</span><br><span class=\"line\">    LogFun1 = if LogFun == undefined -&gt; fun log/4; true -&gt; LogFun end,</span><br><span class=\"line\">    case mysql_conn:start(Host, Port, User, Password, Database, LogFun1,</span><br><span class=\"line\">\t\t\t  Encoding, PoolId) of</span><br><span class=\"line\">\t&#123;ok, ConnPid&#125; -&gt;</span><br><span class=\"line\">\t    Conn = new_conn(PoolId, ConnPid, true, Host, Port, User, Password,</span><br><span class=\"line\">\t\t\t    Database, Encoding),</span><br><span class=\"line\">\t    State = #state&#123;log_fun = LogFun1&#125;,</span><br><span class=\"line\">\t    &#123;ok, add_conn(Conn, State)&#125;;</span><br><span class=\"line\">\t&#123;error, Reason&#125; -&gt;</span><br><span class=\"line\">\t    ?Log(LogFun1, error,</span><br><span class=\"line\">\t\t &quot;failed starting first MySQL connection handler, &quot;</span><br><span class=\"line\">\t\t &quot;exiting&quot;),</span><br><span class=\"line\">\t    &#123;stop, &#123;error, Reason&#125;&#125;</span><br><span class=\"line\">    end.</span><br></pre></td></tr></table></figure></p>\n<p>首先用process_flag将优先级设为高。之后调用mysql_conn:start/8,等会再进去看它内部，我们只知道它返回一个ConnPid,或者出错，然后将这个Pid用new_conn生成一个Conn。然后用add_conn将Conn加入State中，返回，至此这个gen_server创建完毕。名字是&quot;my_sql_game&quot;（随便取）。我们看一下new_conn和add_conn这两个函数<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new_conn(PoolId, ConnPid, Reconnect, Host, Port, User, Password, Database,</span><br><span class=\"line\">\t Encoding) -&gt;</span><br><span class=\"line\">    case Reconnect of</span><br><span class=\"line\">\ttrue -&gt;</span><br><span class=\"line\">\t    #conn&#123;pool_id = PoolId,</span><br><span class=\"line\">\t\t  pid = ConnPid,</span><br><span class=\"line\">\t\t  reconnect = true,</span><br><span class=\"line\">\t\t  host = Host,</span><br><span class=\"line\">\t\t  port = Port,</span><br><span class=\"line\">\t\t  user = User,</span><br><span class=\"line\">\t\t  password = Password,</span><br><span class=\"line\">\t\t  database = Database,</span><br><span class=\"line\">\t\t  encoding = Encoding</span><br><span class=\"line\">\t\t &#125;;</span><br><span class=\"line\">\tfalse -&gt;                        </span><br><span class=\"line\">\t    #conn&#123;pool_id = PoolId,</span><br><span class=\"line\">\t\t  pid = ConnPid,</span><br><span class=\"line\">\t\t  reconnect = false&#125;</span><br><span class=\"line\">    end.</span><br><span class=\"line\">---------</span><br><span class=\"line\">add_conn(Conn, State) -&gt;</span><br><span class=\"line\">    Pid = Conn#conn.pid,</span><br><span class=\"line\">    erlang:monitor(process, Conn#conn.pid),</span><br><span class=\"line\">    PoolId = Conn#conn.pool_id,</span><br><span class=\"line\">    ConnPools = State#state.conn_pools,</span><br><span class=\"line\">    NewPool = </span><br><span class=\"line\">\tcase gb_trees:lookup(PoolId, ConnPools) of</span><br><span class=\"line\">\t    none -&gt;</span><br><span class=\"line\">\t\t&#123;[Conn],[]&#125;;</span><br><span class=\"line\">\t    &#123;value, &#123;Unused, Used&#125;&#125; -&gt;</span><br><span class=\"line\">\t\t&#123;[Conn | Unused], Used&#125;</span><br><span class=\"line\">\tend,</span><br><span class=\"line\">    State#state&#123;conn_pools =</span><br><span class=\"line\">\t\tgb_trees:enter(PoolId, NewPool,</span><br><span class=\"line\">\t\t\t       ConnPools),</span><br><span class=\"line\">\t\tpids_pools = gb_trees:enter(Pid, PoolId,</span><br><span class=\"line\">\t\t\t\t\t    State#state.pids_pools)&#125;.</span><br></pre></td></tr></table></figure></p>\n<p>这里涉及了两个结构<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-record(conn, &#123;</span><br><span class=\"line\">\t  pool_id,      %% atom(), the pool&#x27;s id</span><br><span class=\"line\">\t  pid,          %% pid(), mysql_conn process\t </span><br><span class=\"line\">\t  reconnect,\t%% true | false, should mysql_dispatcher try</span><br><span class=\"line\">                        </span><br><span class=\"line\">\t  host,\t\t%% string()</span><br><span class=\"line\">\t  port,\t\t%% integer()</span><br><span class=\"line\">\t  user,\t\t%% string()</span><br><span class=\"line\">\t  password,\t%% string()</span><br><span class=\"line\">\t  database,\t%% string()</span><br><span class=\"line\">\t  encoding</span><br><span class=\"line\">\t &#125;).</span><br><span class=\"line\">\t </span><br><span class=\"line\">-record(state, &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t  conn_pools = gb_trees:empty(), </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t  pids_pools = gb_trees:empty(),                               </span><br><span class=\"line\"></span><br><span class=\"line\">\t  log_fun,\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t  prepares = gb_trees:empty()</span><br><span class=\"line\">\t &#125;).</span><br></pre></td></tr></table></figure></p>\n<p>conn这个结构大部分就是把函数参数存了起来，其中只有pid需要注意下，它就是mysql_conn:start返回的Pid，new_conn这个函数将参数转成了#conn这个record，然后通过add_conn将#conn存入了#state的conn_pools.字面理解就是链接池。值得注意的是my_sql_game这个gen_server的state用了3个gb_trees这个存储结构。也就是二叉查找树。erlang:monitor(process, Conn#conn.pid).</p>\n<blockquote>\n<p>monitor(Type, Item) -&gt; MonitorRef<br>Types:<br>Type = process<br>Item = pid() | {RegName, Node} | RegName<br> RegName = atom()<br> Node = node()<br>MonitorRef = reference()</p>\n</blockquote>\n<p>目前Type只接受process这个参数，这个函数字面理解就是监控，让这个gen_server监控之前建立的conn进程，被监控进程如果崩溃了，一条{&#39;DOWN&#39;, MonitorRef, Type, Object，Info}<br>消息会发往监控者，这时可以被handle_info处理。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">handle_info(&#123;&#x27;DOWN&#x27;, _MonitorRef, process, Pid, Info&#125;, State) -&gt;</span><br><span class=\"line\">    LogFun = State#state.log_fun,</span><br><span class=\"line\">    case remove_conn(Pid, State) of</span><br><span class=\"line\">\t&#123;ok, Conn, NewState&#125; -&gt;</span><br><span class=\"line\">\t    LogLevel = case Info of</span><br><span class=\"line\">\t\t\t   normal -&gt; normal;</span><br><span class=\"line\">\t\t\t   _ -&gt; error</span><br><span class=\"line\">\t\t       end,</span><br><span class=\"line\">\t    ?Log2(LogFun, LogLevel,</span><br><span class=\"line\">\t\t&quot;connection pid ~p exited : ~p&quot;, [Pid, Info]),</span><br><span class=\"line\">\t    case Conn#conn.reconnect of</span><br><span class=\"line\">\t\ttrue -&gt;</span><br><span class=\"line\">\t\t    start_reconnect(Conn, LogFun);</span><br><span class=\"line\">\t\tfalse -&gt;</span><br><span class=\"line\">\t\t    ok</span><br><span class=\"line\">\t    end,</span><br><span class=\"line\">\t    &#123;noreply, NewState&#125;;</span><br><span class=\"line\">\terror -&gt;</span><br><span class=\"line\">\t    ?Log2(LogFun, error,</span><br><span class=\"line\">\t\t  &quot;received &#x27;DOWN&#x27; signal from pid ~p not in my list&quot;, [Pid]),</span><br><span class=\"line\">\t    &#123;noreply, State&#125;</span><br><span class=\"line\">    end;</span><br></pre></td></tr></table></figure></p>\n<p>可以看出主要是讲state里面的conn_pool里面把这个崩掉的进程conn移除，然后如果这个链接conn的属性是reconnect，那么会重新start_reconnect。先不展开，以机会再说，要不init的过程就跑远了。<br>回到erlang:monitor.(还有个对应的函数是demonitor，可以取消监控)<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NewPool = </span><br><span class=\"line\">\tcase gb_trees:lookup(PoolId, ConnPools) of</span><br><span class=\"line\">\t    none -&gt;</span><br><span class=\"line\">\t\t&#123;[Conn],[]&#125;;</span><br><span class=\"line\">\t    &#123;value, &#123;Unused, Used&#125;&#125; -&gt;</span><br><span class=\"line\">\t\t&#123;[Conn | Unused], Used&#125;</span><br><span class=\"line\">\tend,</span><br></pre></td></tr></table></figure></p>\n<p>从ConnPool中找到PoolId的结点，由case可见这个结点存的是{Unused， Used}的形式。<br>gb_tree的结构是{Size, Tree}.Size表示这个tree有多少个结点。tree的结构是{key, Value, Smaller, Biger}.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1&gt; gb_trees:empty().</span><br><span class=\"line\">&#123;0,nil&#125;</span><br><span class=\"line\">2&gt; gb_trees:insert(5, v0, v(1)).</span><br><span class=\"line\">&#123;1,&#123;5,v0,nil,nil&#125;&#125;</span><br><span class=\"line\">3&gt; gb_trees:insert(8, v1, v(2)).</span><br><span class=\"line\">&#123;2,&#123;5,v0,nil,&#123;8,v1,nil,nil&#125;&#125;&#125;</span><br><span class=\"line\">4&gt; gb_trees:insert(3, v2, v(3)).</span><br><span class=\"line\">&#123;3,&#123;5,v0,&#123;3,v2,nil,nil&#125;,&#123;8,v1,nil,nil&#125;&#125;&#125;</span><br><span class=\"line\">5&gt; gb_trees:insert(7, v3, v(4)).</span><br><span class=\"line\">&#123;4,&#123;5,v0,&#123;3,v2,nil,nil&#125;,&#123;8,v1,&#123;7,v3,nil,nil&#125;,nil&#125;&#125;&#125;</span><br><span class=\"line\">6&gt; gb_trees:insert(1, v4, v(5)).</span><br><span class=\"line\">&#123;5,</span><br><span class=\"line\"> &#123;5,v0,&#123;3,v2,&#123;1,v4,nil,nil&#125;,nil&#125;,&#123;8,v1,&#123;7,v3,nil,nil&#125;,nil&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>\n<p>上面演示了一个gb_tree的建立，gb_tree的大小判断是基于key的。二叉树数据结构都学过。<br>我们可以看一下state里面的结构究竟是什么样子<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql:613: state:&#123;state,</span><br><span class=\"line\">                     &#123;1,</span><br><span class=\"line\">                      &#123;my_sql_game,</span><br><span class=\"line\">                          &#123;[&#123;conn,my_sql_game,&lt;0.62.0&gt;,true,&quot;127.0.0.1&quot;,3306,</span><br><span class=\"line\">                                &quot;aries&quot;,&quot;arig&quot;,&quot;aries_game&quot;,utf8&#125;,</span><br><span class=\"line\">                            &#123;conn,my_sql_game,&lt;0.58.0&gt;,true,&quot;127.0.0.1&quot;,3306,</span><br><span class=\"line\">                                &quot;aries&quot;,&quot;arig&quot;,&quot;aries_game&quot;,utf8&#125;,</span><br><span class=\"line\">                            &#123;conn,my_sql_game,&lt;0.54.0&gt;,true,&quot;127.0.0.1&quot;,3306,</span><br><span class=\"line\">                                &quot;aries&quot;,&quot;arig&quot;,&quot;aries_game&quot;,utf8&#125;],</span><br><span class=\"line\">                           [&#123;conn,my_sql_game,&lt;0.41.0&gt;,true,&quot;127.0.0.1&quot;,3306,</span><br><span class=\"line\">                                &quot;aries&quot;,&quot;arig&quot;,&quot;aries_game&quot;,utf8&#125;]&#125;,</span><br><span class=\"line\">                          nil,nil&#125;&#125;,</span><br><span class=\"line\">                     &#123;4,</span><br><span class=\"line\">                      &#123;&lt;0.41.0&gt;,my_sql_game,nil,</span><br><span class=\"line\">                       &#123;&lt;0.54.0&gt;,my_sql_game,nil,</span><br><span class=\"line\">                        &#123;&lt;0.58.0&gt;,my_sql_game,nil,</span><br><span class=\"line\">                         &#123;&lt;0.62.0&gt;,my_sql_game,nil,nil&#125;&#125;&#125;&#125;&#125;,</span><br><span class=\"line\">                     #Fun&lt;mysql.0.74618748&gt;,</span><br><span class=\"line\">                     &#123;0,nil&#125;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可见我们my_sql_game的conn_pool的size始终为1，<br>因为我们在add_conn函数中的最后总是将conn enter进poolId为my_sql_game的链接池，之后又以pid为key，enter进pid_pool,因为pid不是唯一的，所以pid_pool的size会不断变大。至此我们了解了my_sql_game这个gen_server的创建过程。下篇看一下之前没看到部分。<br>相关参考</p>\n<blockquote>\n<p><a href=\"http://www.cnblogs.com/me-sa/archive/2012/06/23/erlang-gb_trees.html\">gb_trees(坚强2002博客）</a><br><a href=\"http://learnyousomeerlang.com/a-short-visit-to-common-data-structures\">A Short Visit to Common Data Structures(推荐！)</a><br><a href=\"http://www.erlang.org/doc/man/gb_trees.html\">gb_trees(官方doc)</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>这两天抽时间看了看erlang_mysql_driver这个项目，用来建立管理服务器端mysql方面的处理。听说emysql也不错，过两天看看对比下。<br>这个项目主体有这么几个文件</p>\n<blockquote>\n<p>mysql.erl<br>mysql_auth.erl<br>mysql_conn.erl<br>mysql_recv.erl</p>\n</blockquote>","more":"<p>#mysql:start_link<br>主要接口在mysql里面。<br>mysql文件头有作者写的功能使用注释</p>\n<blockquote>\n<p>%%% Usage:<br>%%%<br>%%%<br>%%% Call one of the start-functions before any call to fetch/2<br>%%%<br>%%%   start_link(PoolId, Host, User, Password, Database)<br>%%%   start_link(PoolId, Host, Port, User, Password, Database)<br>%%%   start_link(PoolId, Host, User, Password, Database, LogFun)<br>%%%   start_link(PoolId, Host, Port, User, Password, Database, LogFun)<br>%%%<br>%%% (These functions also have non-linking coutnerparts.)</p>\n</blockquote>\n<p>让我们在使用任何fetch之前先start_link,如果不需要link，同时提供了start接口。<br>好，找到start_link.<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start_link(PoolId, Host, User, Password, Database) -&gt;</span><br><span class=\"line\">    start_link(PoolId, Host, ?PORT, User, Password, Database).</span><br><span class=\"line\"></span><br><span class=\"line\">start_link(PoolId, Host, Port, User, Password, Database) -&gt;</span><br><span class=\"line\">    start_link(PoolId, Host, Port, User, Password, Database, undefined,</span><br><span class=\"line\">\t       undefined).</span><br><span class=\"line\"></span><br><span class=\"line\">start_link(PoolId, Host, undefined, User, Password, Database, LogFun) -&gt;</span><br><span class=\"line\">    start_link(PoolId, Host, ?PORT, User, Password, Database, LogFun,</span><br><span class=\"line\">\t       undefined);</span><br><span class=\"line\">start_link(PoolId, Host, Port, User, Password, Database, LogFun) -&gt;</span><br><span class=\"line\">    start_link(PoolId, Host, Port, User, Password, Database, LogFun,</span><br><span class=\"line\">\t       undefined).</span><br><span class=\"line\"></span><br><span class=\"line\">start_link(PoolId, Host, undefined, User, Password, Database, LogFun,</span><br><span class=\"line\">\t   Encoding) -&gt;</span><br><span class=\"line\">    start1(PoolId, Host, ?PORT, User, Password, Database, LogFun, Encoding,</span><br><span class=\"line\">\t   start_link);</span><br><span class=\"line\">start_link(PoolId, Host, Port, User, Password, Database, LogFun, Encoding) -&gt;</span><br><span class=\"line\">    start1(PoolId, Host, Port, User, Password, Database, LogFun, Encoding,</span><br><span class=\"line\">\t   start_link).</span><br></pre></td></tr></table></figure></p>\n<p>start与start_link大致相同，只不过最后参数是start不是start_link<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">start(PoolId, Host, undefined, User, Password, Database, LogFun, Encoding) -&gt;</span><br><span class=\"line\">    start1(PoolId, Host, ?PORT, User, Password, Database, LogFun, Encoding,</span><br><span class=\"line\">\t   start);</span><br><span class=\"line\">start(PoolId, Host, Port, User, Password, Database, LogFun, Encoding) -&gt;</span><br><span class=\"line\">    start1(PoolId, Host, Port, User, Password, Database, LogFun, Encoding,</span><br><span class=\"line\">\t   start).</span><br></pre></td></tr></table></figure></p>\n<p>其中</p>\n<blockquote>\n<p>PoolId: 这个进程的id，随便起，比如my_sql_game.<br>Host: 目标ip, 本机写&quot;127.0.0.1&quot;<br>Port: 端口号，不改的话默认是3306<br>User: 数据库的用户名：比如 youthy<br>Password：密码<br>Database:数据库名<br>LogFun:日志输出函数，如果undefined则会用默认的输出<br>Encoding:编码方式，我们这里用utf8.</p>\n</blockquote>\n<p>然后转入start1这个函数<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start1(PoolId, Host, Port, User, Password, Database, LogFun, Encoding,</span><br><span class=\"line\">       StartFunc) -&gt;</span><br><span class=\"line\">    crypto:start(),</span><br><span class=\"line\">    gen_server:StartFunc(</span><br><span class=\"line\">      &#123;local, ?SERVER&#125;, ?MODULE,</span><br><span class=\"line\">      [PoolId, Host, Port, User, Password, Database, LogFun, Encoding], []).</span><br></pre></td></tr></table></figure></p>\n<p>crypto是之后需要一些加密算法， 比如md5，sha等，使用前必须先start。<br>而后就是再熟悉不过的gen_server,这里面根据方式不同，分别调用start_link, start,然后找到init函数<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">init([PoolId, Host, Port, User, Password, Database, LogFun, Encoding]) -&gt;</span><br><span class=\"line\">    erlang:process_flag(priority, high),</span><br><span class=\"line\">    LogFun1 = if LogFun == undefined -&gt; fun log/4; true -&gt; LogFun end,</span><br><span class=\"line\">    case mysql_conn:start(Host, Port, User, Password, Database, LogFun1,</span><br><span class=\"line\">\t\t\t  Encoding, PoolId) of</span><br><span class=\"line\">\t&#123;ok, ConnPid&#125; -&gt;</span><br><span class=\"line\">\t    Conn = new_conn(PoolId, ConnPid, true, Host, Port, User, Password,</span><br><span class=\"line\">\t\t\t    Database, Encoding),</span><br><span class=\"line\">\t    State = #state&#123;log_fun = LogFun1&#125;,</span><br><span class=\"line\">\t    &#123;ok, add_conn(Conn, State)&#125;;</span><br><span class=\"line\">\t&#123;error, Reason&#125; -&gt;</span><br><span class=\"line\">\t    ?Log(LogFun1, error,</span><br><span class=\"line\">\t\t &quot;failed starting first MySQL connection handler, &quot;</span><br><span class=\"line\">\t\t &quot;exiting&quot;),</span><br><span class=\"line\">\t    &#123;stop, &#123;error, Reason&#125;&#125;</span><br><span class=\"line\">    end.</span><br></pre></td></tr></table></figure></p>\n<p>首先用process_flag将优先级设为高。之后调用mysql_conn:start/8,等会再进去看它内部，我们只知道它返回一个ConnPid,或者出错，然后将这个Pid用new_conn生成一个Conn。然后用add_conn将Conn加入State中，返回，至此这个gen_server创建完毕。名字是&quot;my_sql_game&quot;（随便取）。我们看一下new_conn和add_conn这两个函数<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new_conn(PoolId, ConnPid, Reconnect, Host, Port, User, Password, Database,</span><br><span class=\"line\">\t Encoding) -&gt;</span><br><span class=\"line\">    case Reconnect of</span><br><span class=\"line\">\ttrue -&gt;</span><br><span class=\"line\">\t    #conn&#123;pool_id = PoolId,</span><br><span class=\"line\">\t\t  pid = ConnPid,</span><br><span class=\"line\">\t\t  reconnect = true,</span><br><span class=\"line\">\t\t  host = Host,</span><br><span class=\"line\">\t\t  port = Port,</span><br><span class=\"line\">\t\t  user = User,</span><br><span class=\"line\">\t\t  password = Password,</span><br><span class=\"line\">\t\t  database = Database,</span><br><span class=\"line\">\t\t  encoding = Encoding</span><br><span class=\"line\">\t\t &#125;;</span><br><span class=\"line\">\tfalse -&gt;                        </span><br><span class=\"line\">\t    #conn&#123;pool_id = PoolId,</span><br><span class=\"line\">\t\t  pid = ConnPid,</span><br><span class=\"line\">\t\t  reconnect = false&#125;</span><br><span class=\"line\">    end.</span><br><span class=\"line\">---------</span><br><span class=\"line\">add_conn(Conn, State) -&gt;</span><br><span class=\"line\">    Pid = Conn#conn.pid,</span><br><span class=\"line\">    erlang:monitor(process, Conn#conn.pid),</span><br><span class=\"line\">    PoolId = Conn#conn.pool_id,</span><br><span class=\"line\">    ConnPools = State#state.conn_pools,</span><br><span class=\"line\">    NewPool = </span><br><span class=\"line\">\tcase gb_trees:lookup(PoolId, ConnPools) of</span><br><span class=\"line\">\t    none -&gt;</span><br><span class=\"line\">\t\t&#123;[Conn],[]&#125;;</span><br><span class=\"line\">\t    &#123;value, &#123;Unused, Used&#125;&#125; -&gt;</span><br><span class=\"line\">\t\t&#123;[Conn | Unused], Used&#125;</span><br><span class=\"line\">\tend,</span><br><span class=\"line\">    State#state&#123;conn_pools =</span><br><span class=\"line\">\t\tgb_trees:enter(PoolId, NewPool,</span><br><span class=\"line\">\t\t\t       ConnPools),</span><br><span class=\"line\">\t\tpids_pools = gb_trees:enter(Pid, PoolId,</span><br><span class=\"line\">\t\t\t\t\t    State#state.pids_pools)&#125;.</span><br></pre></td></tr></table></figure></p>\n<p>这里涉及了两个结构<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-record(conn, &#123;</span><br><span class=\"line\">\t  pool_id,      %% atom(), the pool&#x27;s id</span><br><span class=\"line\">\t  pid,          %% pid(), mysql_conn process\t </span><br><span class=\"line\">\t  reconnect,\t%% true | false, should mysql_dispatcher try</span><br><span class=\"line\">                        </span><br><span class=\"line\">\t  host,\t\t%% string()</span><br><span class=\"line\">\t  port,\t\t%% integer()</span><br><span class=\"line\">\t  user,\t\t%% string()</span><br><span class=\"line\">\t  password,\t%% string()</span><br><span class=\"line\">\t  database,\t%% string()</span><br><span class=\"line\">\t  encoding</span><br><span class=\"line\">\t &#125;).</span><br><span class=\"line\">\t </span><br><span class=\"line\">-record(state, &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t  conn_pools = gb_trees:empty(), </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t  pids_pools = gb_trees:empty(),                               </span><br><span class=\"line\"></span><br><span class=\"line\">\t  log_fun,\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t  prepares = gb_trees:empty()</span><br><span class=\"line\">\t &#125;).</span><br></pre></td></tr></table></figure></p>\n<p>conn这个结构大部分就是把函数参数存了起来，其中只有pid需要注意下，它就是mysql_conn:start返回的Pid，new_conn这个函数将参数转成了#conn这个record，然后通过add_conn将#conn存入了#state的conn_pools.字面理解就是链接池。值得注意的是my_sql_game这个gen_server的state用了3个gb_trees这个存储结构。也就是二叉查找树。erlang:monitor(process, Conn#conn.pid).</p>\n<blockquote>\n<p>monitor(Type, Item) -&gt; MonitorRef<br>Types:<br>Type = process<br>Item = pid() | {RegName, Node} | RegName<br> RegName = atom()<br> Node = node()<br>MonitorRef = reference()</p>\n</blockquote>\n<p>目前Type只接受process这个参数，这个函数字面理解就是监控，让这个gen_server监控之前建立的conn进程，被监控进程如果崩溃了，一条{&#39;DOWN&#39;, MonitorRef, Type, Object，Info}<br>消息会发往监控者，这时可以被handle_info处理。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">handle_info(&#123;&#x27;DOWN&#x27;, _MonitorRef, process, Pid, Info&#125;, State) -&gt;</span><br><span class=\"line\">    LogFun = State#state.log_fun,</span><br><span class=\"line\">    case remove_conn(Pid, State) of</span><br><span class=\"line\">\t&#123;ok, Conn, NewState&#125; -&gt;</span><br><span class=\"line\">\t    LogLevel = case Info of</span><br><span class=\"line\">\t\t\t   normal -&gt; normal;</span><br><span class=\"line\">\t\t\t   _ -&gt; error</span><br><span class=\"line\">\t\t       end,</span><br><span class=\"line\">\t    ?Log2(LogFun, LogLevel,</span><br><span class=\"line\">\t\t&quot;connection pid ~p exited : ~p&quot;, [Pid, Info]),</span><br><span class=\"line\">\t    case Conn#conn.reconnect of</span><br><span class=\"line\">\t\ttrue -&gt;</span><br><span class=\"line\">\t\t    start_reconnect(Conn, LogFun);</span><br><span class=\"line\">\t\tfalse -&gt;</span><br><span class=\"line\">\t\t    ok</span><br><span class=\"line\">\t    end,</span><br><span class=\"line\">\t    &#123;noreply, NewState&#125;;</span><br><span class=\"line\">\terror -&gt;</span><br><span class=\"line\">\t    ?Log2(LogFun, error,</span><br><span class=\"line\">\t\t  &quot;received &#x27;DOWN&#x27; signal from pid ~p not in my list&quot;, [Pid]),</span><br><span class=\"line\">\t    &#123;noreply, State&#125;</span><br><span class=\"line\">    end;</span><br></pre></td></tr></table></figure></p>\n<p>可以看出主要是讲state里面的conn_pool里面把这个崩掉的进程conn移除，然后如果这个链接conn的属性是reconnect，那么会重新start_reconnect。先不展开，以机会再说，要不init的过程就跑远了。<br>回到erlang:monitor.(还有个对应的函数是demonitor，可以取消监控)<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NewPool = </span><br><span class=\"line\">\tcase gb_trees:lookup(PoolId, ConnPools) of</span><br><span class=\"line\">\t    none -&gt;</span><br><span class=\"line\">\t\t&#123;[Conn],[]&#125;;</span><br><span class=\"line\">\t    &#123;value, &#123;Unused, Used&#125;&#125; -&gt;</span><br><span class=\"line\">\t\t&#123;[Conn | Unused], Used&#125;</span><br><span class=\"line\">\tend,</span><br></pre></td></tr></table></figure></p>\n<p>从ConnPool中找到PoolId的结点，由case可见这个结点存的是{Unused， Used}的形式。<br>gb_tree的结构是{Size, Tree}.Size表示这个tree有多少个结点。tree的结构是{key, Value, Smaller, Biger}.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1&gt; gb_trees:empty().</span><br><span class=\"line\">&#123;0,nil&#125;</span><br><span class=\"line\">2&gt; gb_trees:insert(5, v0, v(1)).</span><br><span class=\"line\">&#123;1,&#123;5,v0,nil,nil&#125;&#125;</span><br><span class=\"line\">3&gt; gb_trees:insert(8, v1, v(2)).</span><br><span class=\"line\">&#123;2,&#123;5,v0,nil,&#123;8,v1,nil,nil&#125;&#125;&#125;</span><br><span class=\"line\">4&gt; gb_trees:insert(3, v2, v(3)).</span><br><span class=\"line\">&#123;3,&#123;5,v0,&#123;3,v2,nil,nil&#125;,&#123;8,v1,nil,nil&#125;&#125;&#125;</span><br><span class=\"line\">5&gt; gb_trees:insert(7, v3, v(4)).</span><br><span class=\"line\">&#123;4,&#123;5,v0,&#123;3,v2,nil,nil&#125;,&#123;8,v1,&#123;7,v3,nil,nil&#125;,nil&#125;&#125;&#125;</span><br><span class=\"line\">6&gt; gb_trees:insert(1, v4, v(5)).</span><br><span class=\"line\">&#123;5,</span><br><span class=\"line\"> &#123;5,v0,&#123;3,v2,&#123;1,v4,nil,nil&#125;,nil&#125;,&#123;8,v1,&#123;7,v3,nil,nil&#125;,nil&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>\n<p>上面演示了一个gb_tree的建立，gb_tree的大小判断是基于key的。二叉树数据结构都学过。<br>我们可以看一下state里面的结构究竟是什么样子<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql:613: state:&#123;state,</span><br><span class=\"line\">                     &#123;1,</span><br><span class=\"line\">                      &#123;my_sql_game,</span><br><span class=\"line\">                          &#123;[&#123;conn,my_sql_game,&lt;0.62.0&gt;,true,&quot;127.0.0.1&quot;,3306,</span><br><span class=\"line\">                                &quot;aries&quot;,&quot;arig&quot;,&quot;aries_game&quot;,utf8&#125;,</span><br><span class=\"line\">                            &#123;conn,my_sql_game,&lt;0.58.0&gt;,true,&quot;127.0.0.1&quot;,3306,</span><br><span class=\"line\">                                &quot;aries&quot;,&quot;arig&quot;,&quot;aries_game&quot;,utf8&#125;,</span><br><span class=\"line\">                            &#123;conn,my_sql_game,&lt;0.54.0&gt;,true,&quot;127.0.0.1&quot;,3306,</span><br><span class=\"line\">                                &quot;aries&quot;,&quot;arig&quot;,&quot;aries_game&quot;,utf8&#125;],</span><br><span class=\"line\">                           [&#123;conn,my_sql_game,&lt;0.41.0&gt;,true,&quot;127.0.0.1&quot;,3306,</span><br><span class=\"line\">                                &quot;aries&quot;,&quot;arig&quot;,&quot;aries_game&quot;,utf8&#125;]&#125;,</span><br><span class=\"line\">                          nil,nil&#125;&#125;,</span><br><span class=\"line\">                     &#123;4,</span><br><span class=\"line\">                      &#123;&lt;0.41.0&gt;,my_sql_game,nil,</span><br><span class=\"line\">                       &#123;&lt;0.54.0&gt;,my_sql_game,nil,</span><br><span class=\"line\">                        &#123;&lt;0.58.0&gt;,my_sql_game,nil,</span><br><span class=\"line\">                         &#123;&lt;0.62.0&gt;,my_sql_game,nil,nil&#125;&#125;&#125;&#125;&#125;,</span><br><span class=\"line\">                     #Fun&lt;mysql.0.74618748&gt;,</span><br><span class=\"line\">                     &#123;0,nil&#125;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可见我们my_sql_game的conn_pool的size始终为1，<br>因为我们在add_conn函数中的最后总是将conn enter进poolId为my_sql_game的链接池，之后又以pid为key，enter进pid_pool,因为pid不是唯一的，所以pid_pool的size会不断变大。至此我们了解了my_sql_game这个gen_server的创建过程。下篇看一下之前没看到部分。<br>相关参考</p>\n<blockquote>\n<p><a href=\"http://www.cnblogs.com/me-sa/archive/2012/06/23/erlang-gb_trees.html\">gb_trees(坚强2002博客）</a><br><a href=\"http://learnyousomeerlang.com/a-short-visit-to-common-data-structures\">A Short Visit to Common Data Structures(推荐！)</a><br><a href=\"http://www.erlang.org/doc/man/gb_trees.html\">gb_trees(官方doc)</a></p>\n</blockquote>"},{"title":"erlang_mysql_driver源码分析(三)","date":"2015-06-10T07:37:35.000Z","_content":"<!-- toc -->\n#mysql_recv:start_link\n\n```\ninit(Host, Port, User, Password, Database, LogFun, Encoding, PoolId, Parent) ->\n    case mysql_recv:start_link(Host, Port, LogFun, self()) of\n\t{ok, RecvPid, Sock} ->\n\t    case mysql_init(Sock, RecvPid, User, Password, LogFun) of\n\t\t{ok, Version} ->\n```\n\n上次在mysql_conn:init里面调用了mysql_recv:start_link,我们知道返回一个RecvPid接收进程的Pid和Sock套接字。mysql_recv:start_link过程如下\n<!--more-->\n\n```\nstart_link(Host, Port, LogFun, Parent) when is_list(Host), is_integer(Port) ->\n    RecvPid =\n\tspawn_link(fun () ->\n\t\t\t   init(Host, Port, LogFun, Parent)\n\t\t   end),\n    %% wait for the socket from the spawned pid\n    receive\n\t{mysql_recv, RecvPid, init, {error, E}} ->\n\t    {error, E};\n\t{mysql_recv, RecvPid, init, {ok, Socket}} ->\n\t    {ok, RecvPid, Socket}\n    after ?CONNECT_TIMEOUT ->\n\t    catch exit(RecvPid, kill),\n\t    {error, \"timeout\"}\n    end.\n```\n\n与mysql_conn大体相同，同样spawn一个进程，将mysql_conn的Pid传入当做Parent父进程，然后mysql_conn等待receive消息，如果spawn的mysql_recv进程返回{mysql_recv, RecvPid, init, {ok, Socket}},就代表创建成功，然后将RecvPid, Socket这些有用的变量返回，以便于mysql_init进行,\n如果超过?CONNECT_TIMEOUT的时间，则会调用exit(RecvPid, kill)关闭mysql_recv进程，并返回{error, \"timeout\"}.\n\n```\ninit(Host, Port, LogFun, Parent) ->\n    case gen_tcp:connect(Host, Port, [binary, {packet, 0}]) of\n\t{ok, Sock} ->\n\t    Parent ! {mysql_recv, self(), init, {ok, Sock}},\n\t    State = #state{socket  = Sock,\n\t\t\t   parent  = Parent,\n\t\t\t   log_fun = LogFun,\n\t\t\t   data    = <<>>\n\t\t\t  },\n\t    loop(State);\n\tE ->\n\t    LogFun(?MODULE, ?LINE, error,\n\t\t   fun() ->\n\t\t\t   {\"mysql_recv: Failed connecting to ~p:~p : ~p\",\n\t\t\t    [Host, Port, E]}\n\t\t   end),\n\t    Msg = lists:flatten(io_lib:format(\"connect failed : ~p\", [E])),\n\t    Parent ! {mysql_recv, self(), init, {error, Msg}}\n    end.\n```\n\ninit里面通过gen_tcp:connect连接了端口，返回套接字，将这个套接字发送给父进程也就是在上面receive的地方，之后进入loop。如果连接失败，打印错误，并通知父进程。\n> state{socket,   %套接字\n        parent,   %父进程pid\n        log_fun,  %打印日志函数\n        data,     %端口发来的数据\n}\n\n```\nloop(State) ->\n    Sock = State#state.socket,\n    receive\n\t{tcp, Sock, InData} ->\n\t    NewData = list_to_binary([State#state.data, InData]),\n\t    %% send data to parent if we have enough data\n\t    Rest = sendpacket(State#state.parent, NewData),\n\t    loop(State#state{data = Rest});\n\t{tcp_error, Sock, Reason} ->\n\t    LogFun = State#state.log_fun,\n\t    LogFun(?MODULE, ?LINE, error,\n\t\t   fun() ->\n\t\t\t   {\"mysql_recv: Socket ~p closed : ~p\",\n\t\t\t    [Sock, Reason]}\n\t\t   end),\n\t    State#state.parent ! {mysql_recv, self(), closed, {error, Reason}},\n\t    error;\n\t{tcp_closed, Sock} ->\n\t    LogFun = State#state.log_fun,\n\t    LogFun(?MODULE, ?LINE, debug,\n\t\t   fun() ->\n\t\t\t   {\"mysql_recv: Socket ~p closed\", [Sock]}\n\t\t   end),\n\t    State#state.parent ! {mysql_recv, self(), closed, normal},\n\t    error\n    end.\n```\n\ngen_tcp:connect没有指定{active, false},这样的话，端口可以主动发给recv进程消息。实际上在在gen_tcp:connect之后我们得到Socket的同时，mysql_recv进程的消息队列里已经有Socket的发来的消息了。我们在shell里面可以试一下\n```\n1> gen_tcp:connect(\"localhost\", 3306, [binary, {packet, 0}]).\n{ok,#Port<0.595>}\n2> rp(process_info(self())).\n[{current_function,{erl_eval,do_apply,6}},\n {initial_call,{erlang,apply,2}},\n {status,running},\n {message_queue_len,2},\n {messages,[{tcp,#Port<0.595>,\n                 <<91,0,0,0,10,53,46,53,46,51,55,45,48,117,98,117,110,116,\n                   117,48,46,49,52,46,48,52,46,49,0,187,1,0,0,57,98,97,67,\n                   104,98,52,123,0,255,247,8,2,0,15,128,21,0,0,0,0,0,0,0,\n                   0,0,0,50,36,92,38,67,96,59,67,125,112,59,115,0,109,121,\n                   115,113,108,95,110,97,116,105,118,101,95,112,97,115,\n                   115,119,111,114,100,0>>},\n            {tcp_closed,#Port<0.595>}]},\n {links,[<0.26.0>]},\n {dictionary,[]},\n {trap_exit,false},\n {error_handler,error_handler},\n {priority,normal},\n {group_leader,<0.25.0>},\n {total_heap_size,3571},\n {heap_size,987},\n {stack_size,37},\n {reductions,4070},\n {garbage_collection,[{min_bin_vheap_size,46368},\n                      {min_heap_size,233},\n                      {fullsweep_after,65535},\n                      {minor_gcs,5}]},\n {suspending,[]}]\nok\n```\n\n我们所做的操作以mysql_recv:init里面是一样的。打开了3306端口。这是shell的messagebox里面已经有了两天Socket发来的消息。loop函数将这段消息交给了sendpacket处理\n\n```\nsendpacket(Parent, Data) ->\n    case Data of\n\t<<Length:24/little, Num:8, D/binary>> ->\n\t    if\n\t\tLength =< size(D) ->\n\t\t    {Packet, Rest} = split_binary(D, Length),\n\t\t    Parent ! {mysql_recv, self(), data, Packet, Num},\n\t\t    sendpacket(Parent, Rest);\n\t\ttrue ->\n\t\t    Data\n\t    end;\n\t_ ->\n\t    Data\n    end.\n```\n\npacket头3个字节表示数据长度，第四个字节是帧序号，之后所有的是数据。那么这段数据头三个<<91,0,0>>代表数据长度是91字节（小端存储），之后的0代表这个帧序号是0，<<10....>>就是真正的数据。sendpacket将这段数据发给了parent。在如下的地方匹配\n```\ninit(Host, Port, User, Password, Database, LogFun, Encoding, PoolId, Parent) ->\n    case mysql_recv:start_link(Host, Port, LogFun, self()) of\n\t{ok, RecvPid, Sock} ->\n\t    case mysql_init(Sock, RecvPid, User, Password, LogFun) of\n\t\t{ok, Version} ->\n------\nmysql_init(Sock, RecvPid, User, Password, LogFun) ->\n    case do_recv(LogFun, RecvPid, undefined) of\n\t{ok, Packet, InitSeqNum} ->\n\t\t    {Version, Salt1, Salt2, Caps} = greeting(Packet, LogFun),\n-----\ndo_recv(LogFun, RecvPid, SeqNum)  when is_function(LogFun);\n\t\t\t\t       LogFun == undefined,\n\t\t\t\t       SeqNum == undefined ->\n    receive\n        {mysql_recv, RecvPid, data, Packet, Num} ->\n\t    {ok, Packet, Num};\n\t{mysql_recv, RecvPid, closed, _E} ->\n\t    {error, \"mysql_recv: socket was closed\"}\n    end;\n```\n\n在mysql_conn的do_recv完成对消息的匹配。\n上面的数据其实就是\n```\n=INFO REPORT==== 10-Jun-2015::11:59:21 ===\nI(<0.116.0>:mysql_conn:620) : greeting packet <<10,53,46,53,46,51,55,45,48,117,\n                                                98,117,110,116,117,48,46,49,52,\n                                                46,48,52,46,49,0,173,1,0,0,100,\n                                                44,77,124,75,63,60,78,0,255,\n                                                247,8,2,0,15,128,21,0,0,0,0,0,\n                                                0,0,0,0,0,84,60,110,54,95,93,\n                                                55,57,88,46,122,66,0,109,121,\n                                                115,113,108,95,110,97,116,105,\n                                                118,101,95,112,97,115,115,119,\n                                                111,114,100,0>> version \"5.5.37-0ubuntu0.14.04.1\" (protocol 10) salt \"d,M|K?<N\" caps 63487 serverchar <<8,2,0,\n                                                                                                                                                        15,128,\n                                                                                                                                                        21,0,0,\n                                                                                                                                                        0,0,0,0,\n                                                                                                                                                        0,0,0,0>>salt2 \"T<n6_]79X.zB\"\n```\n\ngreeting函数用来转化为版本号，salt等参数的。\n```\ngreeting(Packet, LogFun) ->\n    <<Protocol:8, Rest/binary>> = Packet,\n    {Version, Rest2} = asciz(Rest),\n    <<_TreadID:32/little, Rest3/binary>> = Rest2,\n    {Salt, Rest4} = asciz(Rest3),\n    <<Caps:16/little, Rest5/binary>> = Rest4,\n    <<ServerChar:16/binary-unit:8, Rest6/binary>> = Rest5,\n    {Salt2, _Rest7} = asciz(Rest6),\n    ?Log2(LogFun, debug,\n\t  \"greeting packet ~p version ~p (protocol ~p) salt ~p caps ~p serverchar ~p\"\n\t  \"salt2 ~p\",\n\t  [Packet, Version, Protocol, Salt, Caps, ServerChar, Salt2]),\n    {normalize_version(Version, LogFun), Salt, Salt2, Caps}.\n------------------------------------------\nasciz(Data) when is_binary(Data) ->\n    mysql:asciz_binary(Data, []).\n-----------------------------------------\nasciz_binary(<<>>, Acc) ->\n    {lists:reverse(Acc), <<>>};\nasciz_binary(<<0:8, Rest/binary>>, Acc) ->\n    {lists:reverse(Acc), Rest};\nasciz_binary(<<C:8, Rest/binary>>, Acc) ->\n    asciz_binary(Rest, [C | Acc]).\n```\n\nPacket第一个字节是protocol,之后asciz函数将剩下的二进制以0位分界点分开。那么\nPacket被分成了\n> Protocol : <<10>>\nVersion:<<53,46,53,46,51,55,45,48,117,98,117,110,116,117,48,46,49,52,46,48,52,46,49>>,\nSalt:<<100,44,77,124,75,63,60,78>>\nCaps:<<255,247>>\nServerChar:<<15,128,21,0,0,0,0,0,0,0,0,0,0,84,60,110>>(ServerChar是16个字节不是16个bit)\nSalt2:<<97,116,105,118,101,95,112,97,115,115,119,111,114,100>>\n\n在shell中检测下\n```\n4> <<53,46,53,46,51,55,45,48,117,98,117,110,116,117,48,46,49,52,46,48,52,46,49>>.\n<<\"5.5.37-0ubuntu0.14.04.1\">>\n5> <<100,44,77,124,75,63,60,78>>.\n<<\"d,M|K?<N\">>\n6> <<Caps:16/little>> = <<255,247>>.\n<<\"ÿ÷\">>\n7> Caps.\n63487\n```\n\n和上面打印的log是一样的。\n","source":"_posts/erlang_mysql_driver源码分析(三).md","raw":"title: erlang_mysql_driver源码分析(三)\ndate: 2015-06-10 15:37:35\ntags: erlang\ncategories: erlang\n---\n<!-- toc -->\n#mysql_recv:start_link\n\n```\ninit(Host, Port, User, Password, Database, LogFun, Encoding, PoolId, Parent) ->\n    case mysql_recv:start_link(Host, Port, LogFun, self()) of\n\t{ok, RecvPid, Sock} ->\n\t    case mysql_init(Sock, RecvPid, User, Password, LogFun) of\n\t\t{ok, Version} ->\n```\n\n上次在mysql_conn:init里面调用了mysql_recv:start_link,我们知道返回一个RecvPid接收进程的Pid和Sock套接字。mysql_recv:start_link过程如下\n<!--more-->\n\n```\nstart_link(Host, Port, LogFun, Parent) when is_list(Host), is_integer(Port) ->\n    RecvPid =\n\tspawn_link(fun () ->\n\t\t\t   init(Host, Port, LogFun, Parent)\n\t\t   end),\n    %% wait for the socket from the spawned pid\n    receive\n\t{mysql_recv, RecvPid, init, {error, E}} ->\n\t    {error, E};\n\t{mysql_recv, RecvPid, init, {ok, Socket}} ->\n\t    {ok, RecvPid, Socket}\n    after ?CONNECT_TIMEOUT ->\n\t    catch exit(RecvPid, kill),\n\t    {error, \"timeout\"}\n    end.\n```\n\n与mysql_conn大体相同，同样spawn一个进程，将mysql_conn的Pid传入当做Parent父进程，然后mysql_conn等待receive消息，如果spawn的mysql_recv进程返回{mysql_recv, RecvPid, init, {ok, Socket}},就代表创建成功，然后将RecvPid, Socket这些有用的变量返回，以便于mysql_init进行,\n如果超过?CONNECT_TIMEOUT的时间，则会调用exit(RecvPid, kill)关闭mysql_recv进程，并返回{error, \"timeout\"}.\n\n```\ninit(Host, Port, LogFun, Parent) ->\n    case gen_tcp:connect(Host, Port, [binary, {packet, 0}]) of\n\t{ok, Sock} ->\n\t    Parent ! {mysql_recv, self(), init, {ok, Sock}},\n\t    State = #state{socket  = Sock,\n\t\t\t   parent  = Parent,\n\t\t\t   log_fun = LogFun,\n\t\t\t   data    = <<>>\n\t\t\t  },\n\t    loop(State);\n\tE ->\n\t    LogFun(?MODULE, ?LINE, error,\n\t\t   fun() ->\n\t\t\t   {\"mysql_recv: Failed connecting to ~p:~p : ~p\",\n\t\t\t    [Host, Port, E]}\n\t\t   end),\n\t    Msg = lists:flatten(io_lib:format(\"connect failed : ~p\", [E])),\n\t    Parent ! {mysql_recv, self(), init, {error, Msg}}\n    end.\n```\n\ninit里面通过gen_tcp:connect连接了端口，返回套接字，将这个套接字发送给父进程也就是在上面receive的地方，之后进入loop。如果连接失败，打印错误，并通知父进程。\n> state{socket,   %套接字\n        parent,   %父进程pid\n        log_fun,  %打印日志函数\n        data,     %端口发来的数据\n}\n\n```\nloop(State) ->\n    Sock = State#state.socket,\n    receive\n\t{tcp, Sock, InData} ->\n\t    NewData = list_to_binary([State#state.data, InData]),\n\t    %% send data to parent if we have enough data\n\t    Rest = sendpacket(State#state.parent, NewData),\n\t    loop(State#state{data = Rest});\n\t{tcp_error, Sock, Reason} ->\n\t    LogFun = State#state.log_fun,\n\t    LogFun(?MODULE, ?LINE, error,\n\t\t   fun() ->\n\t\t\t   {\"mysql_recv: Socket ~p closed : ~p\",\n\t\t\t    [Sock, Reason]}\n\t\t   end),\n\t    State#state.parent ! {mysql_recv, self(), closed, {error, Reason}},\n\t    error;\n\t{tcp_closed, Sock} ->\n\t    LogFun = State#state.log_fun,\n\t    LogFun(?MODULE, ?LINE, debug,\n\t\t   fun() ->\n\t\t\t   {\"mysql_recv: Socket ~p closed\", [Sock]}\n\t\t   end),\n\t    State#state.parent ! {mysql_recv, self(), closed, normal},\n\t    error\n    end.\n```\n\ngen_tcp:connect没有指定{active, false},这样的话，端口可以主动发给recv进程消息。实际上在在gen_tcp:connect之后我们得到Socket的同时，mysql_recv进程的消息队列里已经有Socket的发来的消息了。我们在shell里面可以试一下\n```\n1> gen_tcp:connect(\"localhost\", 3306, [binary, {packet, 0}]).\n{ok,#Port<0.595>}\n2> rp(process_info(self())).\n[{current_function,{erl_eval,do_apply,6}},\n {initial_call,{erlang,apply,2}},\n {status,running},\n {message_queue_len,2},\n {messages,[{tcp,#Port<0.595>,\n                 <<91,0,0,0,10,53,46,53,46,51,55,45,48,117,98,117,110,116,\n                   117,48,46,49,52,46,48,52,46,49,0,187,1,0,0,57,98,97,67,\n                   104,98,52,123,0,255,247,8,2,0,15,128,21,0,0,0,0,0,0,0,\n                   0,0,0,50,36,92,38,67,96,59,67,125,112,59,115,0,109,121,\n                   115,113,108,95,110,97,116,105,118,101,95,112,97,115,\n                   115,119,111,114,100,0>>},\n            {tcp_closed,#Port<0.595>}]},\n {links,[<0.26.0>]},\n {dictionary,[]},\n {trap_exit,false},\n {error_handler,error_handler},\n {priority,normal},\n {group_leader,<0.25.0>},\n {total_heap_size,3571},\n {heap_size,987},\n {stack_size,37},\n {reductions,4070},\n {garbage_collection,[{min_bin_vheap_size,46368},\n                      {min_heap_size,233},\n                      {fullsweep_after,65535},\n                      {minor_gcs,5}]},\n {suspending,[]}]\nok\n```\n\n我们所做的操作以mysql_recv:init里面是一样的。打开了3306端口。这是shell的messagebox里面已经有了两天Socket发来的消息。loop函数将这段消息交给了sendpacket处理\n\n```\nsendpacket(Parent, Data) ->\n    case Data of\n\t<<Length:24/little, Num:8, D/binary>> ->\n\t    if\n\t\tLength =< size(D) ->\n\t\t    {Packet, Rest} = split_binary(D, Length),\n\t\t    Parent ! {mysql_recv, self(), data, Packet, Num},\n\t\t    sendpacket(Parent, Rest);\n\t\ttrue ->\n\t\t    Data\n\t    end;\n\t_ ->\n\t    Data\n    end.\n```\n\npacket头3个字节表示数据长度，第四个字节是帧序号，之后所有的是数据。那么这段数据头三个<<91,0,0>>代表数据长度是91字节（小端存储），之后的0代表这个帧序号是0，<<10....>>就是真正的数据。sendpacket将这段数据发给了parent。在如下的地方匹配\n```\ninit(Host, Port, User, Password, Database, LogFun, Encoding, PoolId, Parent) ->\n    case mysql_recv:start_link(Host, Port, LogFun, self()) of\n\t{ok, RecvPid, Sock} ->\n\t    case mysql_init(Sock, RecvPid, User, Password, LogFun) of\n\t\t{ok, Version} ->\n------\nmysql_init(Sock, RecvPid, User, Password, LogFun) ->\n    case do_recv(LogFun, RecvPid, undefined) of\n\t{ok, Packet, InitSeqNum} ->\n\t\t    {Version, Salt1, Salt2, Caps} = greeting(Packet, LogFun),\n-----\ndo_recv(LogFun, RecvPid, SeqNum)  when is_function(LogFun);\n\t\t\t\t       LogFun == undefined,\n\t\t\t\t       SeqNum == undefined ->\n    receive\n        {mysql_recv, RecvPid, data, Packet, Num} ->\n\t    {ok, Packet, Num};\n\t{mysql_recv, RecvPid, closed, _E} ->\n\t    {error, \"mysql_recv: socket was closed\"}\n    end;\n```\n\n在mysql_conn的do_recv完成对消息的匹配。\n上面的数据其实就是\n```\n=INFO REPORT==== 10-Jun-2015::11:59:21 ===\nI(<0.116.0>:mysql_conn:620) : greeting packet <<10,53,46,53,46,51,55,45,48,117,\n                                                98,117,110,116,117,48,46,49,52,\n                                                46,48,52,46,49,0,173,1,0,0,100,\n                                                44,77,124,75,63,60,78,0,255,\n                                                247,8,2,0,15,128,21,0,0,0,0,0,\n                                                0,0,0,0,0,84,60,110,54,95,93,\n                                                55,57,88,46,122,66,0,109,121,\n                                                115,113,108,95,110,97,116,105,\n                                                118,101,95,112,97,115,115,119,\n                                                111,114,100,0>> version \"5.5.37-0ubuntu0.14.04.1\" (protocol 10) salt \"d,M|K?<N\" caps 63487 serverchar <<8,2,0,\n                                                                                                                                                        15,128,\n                                                                                                                                                        21,0,0,\n                                                                                                                                                        0,0,0,0,\n                                                                                                                                                        0,0,0,0>>salt2 \"T<n6_]79X.zB\"\n```\n\ngreeting函数用来转化为版本号，salt等参数的。\n```\ngreeting(Packet, LogFun) ->\n    <<Protocol:8, Rest/binary>> = Packet,\n    {Version, Rest2} = asciz(Rest),\n    <<_TreadID:32/little, Rest3/binary>> = Rest2,\n    {Salt, Rest4} = asciz(Rest3),\n    <<Caps:16/little, Rest5/binary>> = Rest4,\n    <<ServerChar:16/binary-unit:8, Rest6/binary>> = Rest5,\n    {Salt2, _Rest7} = asciz(Rest6),\n    ?Log2(LogFun, debug,\n\t  \"greeting packet ~p version ~p (protocol ~p) salt ~p caps ~p serverchar ~p\"\n\t  \"salt2 ~p\",\n\t  [Packet, Version, Protocol, Salt, Caps, ServerChar, Salt2]),\n    {normalize_version(Version, LogFun), Salt, Salt2, Caps}.\n------------------------------------------\nasciz(Data) when is_binary(Data) ->\n    mysql:asciz_binary(Data, []).\n-----------------------------------------\nasciz_binary(<<>>, Acc) ->\n    {lists:reverse(Acc), <<>>};\nasciz_binary(<<0:8, Rest/binary>>, Acc) ->\n    {lists:reverse(Acc), Rest};\nasciz_binary(<<C:8, Rest/binary>>, Acc) ->\n    asciz_binary(Rest, [C | Acc]).\n```\n\nPacket第一个字节是protocol,之后asciz函数将剩下的二进制以0位分界点分开。那么\nPacket被分成了\n> Protocol : <<10>>\nVersion:<<53,46,53,46,51,55,45,48,117,98,117,110,116,117,48,46,49,52,46,48,52,46,49>>,\nSalt:<<100,44,77,124,75,63,60,78>>\nCaps:<<255,247>>\nServerChar:<<15,128,21,0,0,0,0,0,0,0,0,0,0,84,60,110>>(ServerChar是16个字节不是16个bit)\nSalt2:<<97,116,105,118,101,95,112,97,115,115,119,111,114,100>>\n\n在shell中检测下\n```\n4> <<53,46,53,46,51,55,45,48,117,98,117,110,116,117,48,46,49,52,46,48,52,46,49>>.\n<<\"5.5.37-0ubuntu0.14.04.1\">>\n5> <<100,44,77,124,75,63,60,78>>.\n<<\"d,M|K?<N\">>\n6> <<Caps:16/little>> = <<255,247>>.\n<<\"ÿ÷\">>\n7> Caps.\n63487\n```\n\n和上面打印的log是一样的。\n","slug":"erlang_mysql_driver源码分析(三)","published":1,"updated":"2018-06-26T09:49:27.734Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqw7jdvv000l6f1rgwpj5skw","content":"<!-- toc -->\n<!-- tocstop -->\n<p>#mysql_recv:start_link</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">init(Host, Port, User, Password, Database, LogFun, Encoding, PoolId, Parent) -&gt;</span><br><span class=\"line\">    case mysql_recv:start_link(Host, Port, LogFun, self()) of</span><br><span class=\"line\">\t&#123;ok, RecvPid, Sock&#125; -&gt;</span><br><span class=\"line\">\t    case mysql_init(Sock, RecvPid, User, Password, LogFun) of</span><br><span class=\"line\">\t\t&#123;ok, Version&#125; -&gt;</span><br></pre></td></tr></table></figure>\n<p>上次在mysql_conn:init里面调用了mysql_recv:start_link,我们知道返回一个RecvPid接收进程的Pid和Sock套接字。mysql_recv:start_link过程如下<br><span id=\"more\"></span></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start_link(Host, Port, LogFun, Parent) when is_list(Host), is_integer(Port) -&gt;</span><br><span class=\"line\">    RecvPid =</span><br><span class=\"line\">\tspawn_link(fun () -&gt;</span><br><span class=\"line\">\t\t\t   init(Host, Port, LogFun, Parent)</span><br><span class=\"line\">\t\t   end),</span><br><span class=\"line\">    %% wait for the socket from the spawned pid</span><br><span class=\"line\">    receive</span><br><span class=\"line\">\t&#123;mysql_recv, RecvPid, init, &#123;error, E&#125;&#125; -&gt;</span><br><span class=\"line\">\t    &#123;error, E&#125;;</span><br><span class=\"line\">\t&#123;mysql_recv, RecvPid, init, &#123;ok, Socket&#125;&#125; -&gt;</span><br><span class=\"line\">\t    &#123;ok, RecvPid, Socket&#125;</span><br><span class=\"line\">    after ?CONNECT_TIMEOUT -&gt;</span><br><span class=\"line\">\t    catch exit(RecvPid, kill),</span><br><span class=\"line\">\t    &#123;error, &quot;timeout&quot;&#125;</span><br><span class=\"line\">    end.</span><br></pre></td></tr></table></figure>\n<p>与mysql_conn大体相同，同样spawn一个进程，将mysql_conn的Pid传入当做Parent父进程，然后mysql_conn等待receive消息，如果spawn的mysql_recv进程返回{mysql_recv, RecvPid, init, {ok, Socket}},就代表创建成功，然后将RecvPid, Socket这些有用的变量返回，以便于mysql_init进行,<br>如果超过?CONNECT_TIMEOUT的时间，则会调用exit(RecvPid, kill)关闭mysql_recv进程，并返回{error, &quot;timeout&quot;}.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">init(Host, Port, LogFun, Parent) -&gt;</span><br><span class=\"line\">    case gen_tcp:connect(Host, Port, [binary, &#123;packet, 0&#125;]) of</span><br><span class=\"line\">\t&#123;ok, Sock&#125; -&gt;</span><br><span class=\"line\">\t    Parent ! &#123;mysql_recv, self(), init, &#123;ok, Sock&#125;&#125;,</span><br><span class=\"line\">\t    State = #state&#123;socket  = Sock,</span><br><span class=\"line\">\t\t\t   parent  = Parent,</span><br><span class=\"line\">\t\t\t   log_fun = LogFun,</span><br><span class=\"line\">\t\t\t   data    = &lt;&lt;&gt;&gt;</span><br><span class=\"line\">\t\t\t  &#125;,</span><br><span class=\"line\">\t    loop(State);</span><br><span class=\"line\">\tE -&gt;</span><br><span class=\"line\">\t    LogFun(?MODULE, ?LINE, error,</span><br><span class=\"line\">\t\t   fun() -&gt;</span><br><span class=\"line\">\t\t\t   &#123;&quot;mysql_recv: Failed connecting to ~p:~p : ~p&quot;,</span><br><span class=\"line\">\t\t\t    [Host, Port, E]&#125;</span><br><span class=\"line\">\t\t   end),</span><br><span class=\"line\">\t    Msg = lists:flatten(io_lib:format(&quot;connect failed : ~p&quot;, [E])),</span><br><span class=\"line\">\t    Parent ! &#123;mysql_recv, self(), init, &#123;error, Msg&#125;&#125;</span><br><span class=\"line\">    end.</span><br></pre></td></tr></table></figure>\n<p>init里面通过gen_tcp:connect连接了端口，返回套接字，将这个套接字发送给父进程也就是在上面receive的地方，之后进入loop。如果连接失败，打印错误，并通知父进程。</p>\n<blockquote>\n<p>state{socket,   %套接字<br>        parent,   %父进程pid<br>        log_fun,  %打印日志函数<br>        data,     %端口发来的数据<br>}</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loop(State) -&gt;</span><br><span class=\"line\">    Sock = State#state.socket,</span><br><span class=\"line\">    receive</span><br><span class=\"line\">\t&#123;tcp, Sock, InData&#125; -&gt;</span><br><span class=\"line\">\t    NewData = list_to_binary([State#state.data, InData]),</span><br><span class=\"line\">\t    %% send data to parent if we have enough data</span><br><span class=\"line\">\t    Rest = sendpacket(State#state.parent, NewData),</span><br><span class=\"line\">\t    loop(State#state&#123;data = Rest&#125;);</span><br><span class=\"line\">\t&#123;tcp_error, Sock, Reason&#125; -&gt;</span><br><span class=\"line\">\t    LogFun = State#state.log_fun,</span><br><span class=\"line\">\t    LogFun(?MODULE, ?LINE, error,</span><br><span class=\"line\">\t\t   fun() -&gt;</span><br><span class=\"line\">\t\t\t   &#123;&quot;mysql_recv: Socket ~p closed : ~p&quot;,</span><br><span class=\"line\">\t\t\t    [Sock, Reason]&#125;</span><br><span class=\"line\">\t\t   end),</span><br><span class=\"line\">\t    State#state.parent ! &#123;mysql_recv, self(), closed, &#123;error, Reason&#125;&#125;,</span><br><span class=\"line\">\t    error;</span><br><span class=\"line\">\t&#123;tcp_closed, Sock&#125; -&gt;</span><br><span class=\"line\">\t    LogFun = State#state.log_fun,</span><br><span class=\"line\">\t    LogFun(?MODULE, ?LINE, debug,</span><br><span class=\"line\">\t\t   fun() -&gt;</span><br><span class=\"line\">\t\t\t   &#123;&quot;mysql_recv: Socket ~p closed&quot;, [Sock]&#125;</span><br><span class=\"line\">\t\t   end),</span><br><span class=\"line\">\t    State#state.parent ! &#123;mysql_recv, self(), closed, normal&#125;,</span><br><span class=\"line\">\t    error</span><br><span class=\"line\">    end.</span><br></pre></td></tr></table></figure>\n<p>gen_tcp:connect没有指定{active, false},这样的话，端口可以主动发给recv进程消息。实际上在在gen_tcp:connect之后我们得到Socket的同时，mysql_recv进程的消息队列里已经有Socket的发来的消息了。我们在shell里面可以试一下<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1&gt; gen_tcp:connect(&quot;localhost&quot;, 3306, [binary, &#123;packet, 0&#125;]).</span><br><span class=\"line\">&#123;ok,#Port&lt;0.595&gt;&#125;</span><br><span class=\"line\">2&gt; rp(process_info(self())).</span><br><span class=\"line\">[&#123;current_function,&#123;erl_eval,do_apply,6&#125;&#125;,</span><br><span class=\"line\"> &#123;initial_call,&#123;erlang,apply,2&#125;&#125;,</span><br><span class=\"line\"> &#123;status,running&#125;,</span><br><span class=\"line\"> &#123;message_queue_len,2&#125;,</span><br><span class=\"line\"> &#123;messages,[&#123;tcp,#Port&lt;0.595&gt;,</span><br><span class=\"line\">                 &lt;&lt;91,0,0,0,10,53,46,53,46,51,55,45,48,117,98,117,110,116,</span><br><span class=\"line\">                   117,48,46,49,52,46,48,52,46,49,0,187,1,0,0,57,98,97,67,</span><br><span class=\"line\">                   104,98,52,123,0,255,247,8,2,0,15,128,21,0,0,0,0,0,0,0,</span><br><span class=\"line\">                   0,0,0,50,36,92,38,67,96,59,67,125,112,59,115,0,109,121,</span><br><span class=\"line\">                   115,113,108,95,110,97,116,105,118,101,95,112,97,115,</span><br><span class=\"line\">                   115,119,111,114,100,0&gt;&gt;&#125;,</span><br><span class=\"line\">            &#123;tcp_closed,#Port&lt;0.595&gt;&#125;]&#125;,</span><br><span class=\"line\"> &#123;links,[&lt;0.26.0&gt;]&#125;,</span><br><span class=\"line\"> &#123;dictionary,[]&#125;,</span><br><span class=\"line\"> &#123;trap_exit,false&#125;,</span><br><span class=\"line\"> &#123;error_handler,error_handler&#125;,</span><br><span class=\"line\"> &#123;priority,normal&#125;,</span><br><span class=\"line\"> &#123;group_leader,&lt;0.25.0&gt;&#125;,</span><br><span class=\"line\"> &#123;total_heap_size,3571&#125;,</span><br><span class=\"line\"> &#123;heap_size,987&#125;,</span><br><span class=\"line\"> &#123;stack_size,37&#125;,</span><br><span class=\"line\"> &#123;reductions,4070&#125;,</span><br><span class=\"line\"> &#123;garbage_collection,[&#123;min_bin_vheap_size,46368&#125;,</span><br><span class=\"line\">                      &#123;min_heap_size,233&#125;,</span><br><span class=\"line\">                      &#123;fullsweep_after,65535&#125;,</span><br><span class=\"line\">                      &#123;minor_gcs,5&#125;]&#125;,</span><br><span class=\"line\"> &#123;suspending,[]&#125;]</span><br><span class=\"line\">ok</span><br></pre></td></tr></table></figure></p>\n<p>我们所做的操作以mysql_recv:init里面是一样的。打开了3306端口。这是shell的messagebox里面已经有了两天Socket发来的消息。loop函数将这段消息交给了sendpacket处理</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sendpacket(Parent, Data) -&gt;</span><br><span class=\"line\">    case Data of</span><br><span class=\"line\">\t&lt;&lt;Length:24/little, Num:8, D/binary&gt;&gt; -&gt;</span><br><span class=\"line\">\t    if</span><br><span class=\"line\">\t\tLength =&lt; size(D) -&gt;</span><br><span class=\"line\">\t\t    &#123;Packet, Rest&#125; = split_binary(D, Length),</span><br><span class=\"line\">\t\t    Parent ! &#123;mysql_recv, self(), data, Packet, Num&#125;,</span><br><span class=\"line\">\t\t    sendpacket(Parent, Rest);</span><br><span class=\"line\">\t\ttrue -&gt;</span><br><span class=\"line\">\t\t    Data</span><br><span class=\"line\">\t    end;</span><br><span class=\"line\">\t_ -&gt;</span><br><span class=\"line\">\t    Data</span><br><span class=\"line\">    end.</span><br></pre></td></tr></table></figure>\n<p>packet头3个字节表示数据长度，第四个字节是帧序号，之后所有的是数据。那么这段数据头三个&lt;&lt;91,0,0&gt;&gt;代表数据长度是91字节（小端存储），之后的0代表这个帧序号是0，&lt;&lt;10....&gt;&gt;就是真正的数据。sendpacket将这段数据发给了parent。在如下的地方匹配<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">init(Host, Port, User, Password, Database, LogFun, Encoding, PoolId, Parent) -&gt;</span><br><span class=\"line\">    case mysql_recv:start_link(Host, Port, LogFun, self()) of</span><br><span class=\"line\">\t&#123;ok, RecvPid, Sock&#125; -&gt;</span><br><span class=\"line\">\t    case mysql_init(Sock, RecvPid, User, Password, LogFun) of</span><br><span class=\"line\">\t\t&#123;ok, Version&#125; -&gt;</span><br><span class=\"line\">------</span><br><span class=\"line\">mysql_init(Sock, RecvPid, User, Password, LogFun) -&gt;</span><br><span class=\"line\">    case do_recv(LogFun, RecvPid, undefined) of</span><br><span class=\"line\">\t&#123;ok, Packet, InitSeqNum&#125; -&gt;</span><br><span class=\"line\">\t\t    &#123;Version, Salt1, Salt2, Caps&#125; = greeting(Packet, LogFun),</span><br><span class=\"line\">-----</span><br><span class=\"line\">do_recv(LogFun, RecvPid, SeqNum)  when is_function(LogFun);</span><br><span class=\"line\">\t\t\t\t       LogFun == undefined,</span><br><span class=\"line\">\t\t\t\t       SeqNum == undefined -&gt;</span><br><span class=\"line\">    receive</span><br><span class=\"line\">        &#123;mysql_recv, RecvPid, data, Packet, Num&#125; -&gt;</span><br><span class=\"line\">\t    &#123;ok, Packet, Num&#125;;</span><br><span class=\"line\">\t&#123;mysql_recv, RecvPid, closed, _E&#125; -&gt;</span><br><span class=\"line\">\t    &#123;error, &quot;mysql_recv: socket was closed&quot;&#125;</span><br><span class=\"line\">    end;</span><br></pre></td></tr></table></figure></p>\n<p>在mysql_conn的do_recv完成对消息的匹配。<br>上面的数据其实就是<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">=INFO REPORT==== 10-Jun-2015::11:59:21 ===</span><br><span class=\"line\">I(&lt;0.116.0&gt;:mysql_conn:620) : greeting packet &lt;&lt;10,53,46,53,46,51,55,45,48,117,</span><br><span class=\"line\">                                                98,117,110,116,117,48,46,49,52,</span><br><span class=\"line\">                                                46,48,52,46,49,0,173,1,0,0,100,</span><br><span class=\"line\">                                                44,77,124,75,63,60,78,0,255,</span><br><span class=\"line\">                                                247,8,2,0,15,128,21,0,0,0,0,0,</span><br><span class=\"line\">                                                0,0,0,0,0,84,60,110,54,95,93,</span><br><span class=\"line\">                                                55,57,88,46,122,66,0,109,121,</span><br><span class=\"line\">                                                115,113,108,95,110,97,116,105,</span><br><span class=\"line\">                                                118,101,95,112,97,115,115,119,</span><br><span class=\"line\">                                                111,114,100,0&gt;&gt; version &quot;5.5.37-0ubuntu0.14.04.1&quot; (protocol 10) salt &quot;d,M|K?&lt;N&quot; caps 63487 serverchar &lt;&lt;8,2,0,</span><br><span class=\"line\">                                                                                                                                                        15,128,</span><br><span class=\"line\">                                                                                                                                                        21,0,0,</span><br><span class=\"line\">                                                                                                                                                        0,0,0,0,</span><br><span class=\"line\">                                                                                                                                                        0,0,0,0&gt;&gt;salt2 &quot;T&lt;n6_]79X.zB&quot;</span><br></pre></td></tr></table></figure></p>\n<p>greeting函数用来转化为版本号，salt等参数的。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">greeting(Packet, LogFun) -&gt;</span><br><span class=\"line\">    &lt;&lt;Protocol:8, Rest/binary&gt;&gt; = Packet,</span><br><span class=\"line\">    &#123;Version, Rest2&#125; = asciz(Rest),</span><br><span class=\"line\">    &lt;&lt;_TreadID:32/little, Rest3/binary&gt;&gt; = Rest2,</span><br><span class=\"line\">    &#123;Salt, Rest4&#125; = asciz(Rest3),</span><br><span class=\"line\">    &lt;&lt;Caps:16/little, Rest5/binary&gt;&gt; = Rest4,</span><br><span class=\"line\">    &lt;&lt;ServerChar:16/binary-unit:8, Rest6/binary&gt;&gt; = Rest5,</span><br><span class=\"line\">    &#123;Salt2, _Rest7&#125; = asciz(Rest6),</span><br><span class=\"line\">    ?Log2(LogFun, debug,</span><br><span class=\"line\">\t  &quot;greeting packet ~p version ~p (protocol ~p) salt ~p caps ~p serverchar ~p&quot;</span><br><span class=\"line\">\t  &quot;salt2 ~p&quot;,</span><br><span class=\"line\">\t  [Packet, Version, Protocol, Salt, Caps, ServerChar, Salt2]),</span><br><span class=\"line\">    &#123;normalize_version(Version, LogFun), Salt, Salt2, Caps&#125;.</span><br><span class=\"line\">------------------------------------------</span><br><span class=\"line\">asciz(Data) when is_binary(Data) -&gt;</span><br><span class=\"line\">    mysql:asciz_binary(Data, []).</span><br><span class=\"line\">-----------------------------------------</span><br><span class=\"line\">asciz_binary(&lt;&lt;&gt;&gt;, Acc) -&gt;</span><br><span class=\"line\">    &#123;lists:reverse(Acc), &lt;&lt;&gt;&gt;&#125;;</span><br><span class=\"line\">asciz_binary(&lt;&lt;0:8, Rest/binary&gt;&gt;, Acc) -&gt;</span><br><span class=\"line\">    &#123;lists:reverse(Acc), Rest&#125;;</span><br><span class=\"line\">asciz_binary(&lt;&lt;C:8, Rest/binary&gt;&gt;, Acc) -&gt;</span><br><span class=\"line\">    asciz_binary(Rest, [C | Acc]).</span><br></pre></td></tr></table></figure></p>\n<p>Packet第一个字节是protocol,之后asciz函数将剩下的二进制以0位分界点分开。那么<br>Packet被分成了</p>\n<blockquote>\n<p>Protocol : &lt;<10>&gt;<br>Version:&lt;&lt;53,46,53,46,51,55,45,48,117,98,117,110,116,117,48,46,49,52,46,48,52,46,49&gt;&gt;,<br>Salt:&lt;&lt;100,44,77,124,75,63,60,78&gt;&gt;<br>Caps:&lt;&lt;255,247&gt;&gt;<br>ServerChar:&lt;&lt;15,128,21,0,0,0,0,0,0,0,0,0,0,84,60,110&gt;&gt;(ServerChar是16个字节不是16个bit)<br>Salt2:&lt;&lt;97,116,105,118,101,95,112,97,115,115,119,111,114,100&gt;&gt;</p>\n</blockquote>\n<p>在shell中检测下<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">4&gt; &lt;&lt;53,46,53,46,51,55,45,48,117,98,117,110,116,117,48,46,49,52,46,48,52,46,49&gt;&gt;.</span><br><span class=\"line\">&lt;&lt;&quot;5.5.37-0ubuntu0.14.04.1&quot;&gt;&gt;</span><br><span class=\"line\">5&gt; &lt;&lt;100,44,77,124,75,63,60,78&gt;&gt;.</span><br><span class=\"line\">&lt;&lt;&quot;d,M|K?&lt;N&quot;&gt;&gt;</span><br><span class=\"line\">6&gt; &lt;&lt;Caps:16/little&gt;&gt; = &lt;&lt;255,247&gt;&gt;.</span><br><span class=\"line\">&lt;&lt;&quot;ÿ÷&quot;&gt;&gt;</span><br><span class=\"line\">7&gt; Caps.</span><br><span class=\"line\">63487</span><br></pre></td></tr></table></figure></p>\n<p>和上面打印的log是一样的。</p>\n","site":{"data":{}},"excerpt":"<!-- toc -->\n<!-- tocstop -->\n<p>#mysql_recv:start_link</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">init(Host, Port, User, Password, Database, LogFun, Encoding, PoolId, Parent) -&gt;</span><br><span class=\"line\">    case mysql_recv:start_link(Host, Port, LogFun, self()) of</span><br><span class=\"line\">\t&#123;ok, RecvPid, Sock&#125; -&gt;</span><br><span class=\"line\">\t    case mysql_init(Sock, RecvPid, User, Password, LogFun) of</span><br><span class=\"line\">\t\t&#123;ok, Version&#125; -&gt;</span><br></pre></td></tr></table></figure>\n<p>上次在mysql_conn:init里面调用了mysql_recv:start_link,我们知道返回一个RecvPid接收进程的Pid和Sock套接字。mysql_recv:start_link过程如下<br>","more":"</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start_link(Host, Port, LogFun, Parent) when is_list(Host), is_integer(Port) -&gt;</span><br><span class=\"line\">    RecvPid =</span><br><span class=\"line\">\tspawn_link(fun () -&gt;</span><br><span class=\"line\">\t\t\t   init(Host, Port, LogFun, Parent)</span><br><span class=\"line\">\t\t   end),</span><br><span class=\"line\">    %% wait for the socket from the spawned pid</span><br><span class=\"line\">    receive</span><br><span class=\"line\">\t&#123;mysql_recv, RecvPid, init, &#123;error, E&#125;&#125; -&gt;</span><br><span class=\"line\">\t    &#123;error, E&#125;;</span><br><span class=\"line\">\t&#123;mysql_recv, RecvPid, init, &#123;ok, Socket&#125;&#125; -&gt;</span><br><span class=\"line\">\t    &#123;ok, RecvPid, Socket&#125;</span><br><span class=\"line\">    after ?CONNECT_TIMEOUT -&gt;</span><br><span class=\"line\">\t    catch exit(RecvPid, kill),</span><br><span class=\"line\">\t    &#123;error, &quot;timeout&quot;&#125;</span><br><span class=\"line\">    end.</span><br></pre></td></tr></table></figure>\n<p>与mysql_conn大体相同，同样spawn一个进程，将mysql_conn的Pid传入当做Parent父进程，然后mysql_conn等待receive消息，如果spawn的mysql_recv进程返回{mysql_recv, RecvPid, init, {ok, Socket}},就代表创建成功，然后将RecvPid, Socket这些有用的变量返回，以便于mysql_init进行,<br>如果超过?CONNECT_TIMEOUT的时间，则会调用exit(RecvPid, kill)关闭mysql_recv进程，并返回{error, &quot;timeout&quot;}.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">init(Host, Port, LogFun, Parent) -&gt;</span><br><span class=\"line\">    case gen_tcp:connect(Host, Port, [binary, &#123;packet, 0&#125;]) of</span><br><span class=\"line\">\t&#123;ok, Sock&#125; -&gt;</span><br><span class=\"line\">\t    Parent ! &#123;mysql_recv, self(), init, &#123;ok, Sock&#125;&#125;,</span><br><span class=\"line\">\t    State = #state&#123;socket  = Sock,</span><br><span class=\"line\">\t\t\t   parent  = Parent,</span><br><span class=\"line\">\t\t\t   log_fun = LogFun,</span><br><span class=\"line\">\t\t\t   data    = &lt;&lt;&gt;&gt;</span><br><span class=\"line\">\t\t\t  &#125;,</span><br><span class=\"line\">\t    loop(State);</span><br><span class=\"line\">\tE -&gt;</span><br><span class=\"line\">\t    LogFun(?MODULE, ?LINE, error,</span><br><span class=\"line\">\t\t   fun() -&gt;</span><br><span class=\"line\">\t\t\t   &#123;&quot;mysql_recv: Failed connecting to ~p:~p : ~p&quot;,</span><br><span class=\"line\">\t\t\t    [Host, Port, E]&#125;</span><br><span class=\"line\">\t\t   end),</span><br><span class=\"line\">\t    Msg = lists:flatten(io_lib:format(&quot;connect failed : ~p&quot;, [E])),</span><br><span class=\"line\">\t    Parent ! &#123;mysql_recv, self(), init, &#123;error, Msg&#125;&#125;</span><br><span class=\"line\">    end.</span><br></pre></td></tr></table></figure>\n<p>init里面通过gen_tcp:connect连接了端口，返回套接字，将这个套接字发送给父进程也就是在上面receive的地方，之后进入loop。如果连接失败，打印错误，并通知父进程。</p>\n<blockquote>\n<p>state{socket,   %套接字<br>        parent,   %父进程pid<br>        log_fun,  %打印日志函数<br>        data,     %端口发来的数据<br>}</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loop(State) -&gt;</span><br><span class=\"line\">    Sock = State#state.socket,</span><br><span class=\"line\">    receive</span><br><span class=\"line\">\t&#123;tcp, Sock, InData&#125; -&gt;</span><br><span class=\"line\">\t    NewData = list_to_binary([State#state.data, InData]),</span><br><span class=\"line\">\t    %% send data to parent if we have enough data</span><br><span class=\"line\">\t    Rest = sendpacket(State#state.parent, NewData),</span><br><span class=\"line\">\t    loop(State#state&#123;data = Rest&#125;);</span><br><span class=\"line\">\t&#123;tcp_error, Sock, Reason&#125; -&gt;</span><br><span class=\"line\">\t    LogFun = State#state.log_fun,</span><br><span class=\"line\">\t    LogFun(?MODULE, ?LINE, error,</span><br><span class=\"line\">\t\t   fun() -&gt;</span><br><span class=\"line\">\t\t\t   &#123;&quot;mysql_recv: Socket ~p closed : ~p&quot;,</span><br><span class=\"line\">\t\t\t    [Sock, Reason]&#125;</span><br><span class=\"line\">\t\t   end),</span><br><span class=\"line\">\t    State#state.parent ! &#123;mysql_recv, self(), closed, &#123;error, Reason&#125;&#125;,</span><br><span class=\"line\">\t    error;</span><br><span class=\"line\">\t&#123;tcp_closed, Sock&#125; -&gt;</span><br><span class=\"line\">\t    LogFun = State#state.log_fun,</span><br><span class=\"line\">\t    LogFun(?MODULE, ?LINE, debug,</span><br><span class=\"line\">\t\t   fun() -&gt;</span><br><span class=\"line\">\t\t\t   &#123;&quot;mysql_recv: Socket ~p closed&quot;, [Sock]&#125;</span><br><span class=\"line\">\t\t   end),</span><br><span class=\"line\">\t    State#state.parent ! &#123;mysql_recv, self(), closed, normal&#125;,</span><br><span class=\"line\">\t    error</span><br><span class=\"line\">    end.</span><br></pre></td></tr></table></figure>\n<p>gen_tcp:connect没有指定{active, false},这样的话，端口可以主动发给recv进程消息。实际上在在gen_tcp:connect之后我们得到Socket的同时，mysql_recv进程的消息队列里已经有Socket的发来的消息了。我们在shell里面可以试一下<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1&gt; gen_tcp:connect(&quot;localhost&quot;, 3306, [binary, &#123;packet, 0&#125;]).</span><br><span class=\"line\">&#123;ok,#Port&lt;0.595&gt;&#125;</span><br><span class=\"line\">2&gt; rp(process_info(self())).</span><br><span class=\"line\">[&#123;current_function,&#123;erl_eval,do_apply,6&#125;&#125;,</span><br><span class=\"line\"> &#123;initial_call,&#123;erlang,apply,2&#125;&#125;,</span><br><span class=\"line\"> &#123;status,running&#125;,</span><br><span class=\"line\"> &#123;message_queue_len,2&#125;,</span><br><span class=\"line\"> &#123;messages,[&#123;tcp,#Port&lt;0.595&gt;,</span><br><span class=\"line\">                 &lt;&lt;91,0,0,0,10,53,46,53,46,51,55,45,48,117,98,117,110,116,</span><br><span class=\"line\">                   117,48,46,49,52,46,48,52,46,49,0,187,1,0,0,57,98,97,67,</span><br><span class=\"line\">                   104,98,52,123,0,255,247,8,2,0,15,128,21,0,0,0,0,0,0,0,</span><br><span class=\"line\">                   0,0,0,50,36,92,38,67,96,59,67,125,112,59,115,0,109,121,</span><br><span class=\"line\">                   115,113,108,95,110,97,116,105,118,101,95,112,97,115,</span><br><span class=\"line\">                   115,119,111,114,100,0&gt;&gt;&#125;,</span><br><span class=\"line\">            &#123;tcp_closed,#Port&lt;0.595&gt;&#125;]&#125;,</span><br><span class=\"line\"> &#123;links,[&lt;0.26.0&gt;]&#125;,</span><br><span class=\"line\"> &#123;dictionary,[]&#125;,</span><br><span class=\"line\"> &#123;trap_exit,false&#125;,</span><br><span class=\"line\"> &#123;error_handler,error_handler&#125;,</span><br><span class=\"line\"> &#123;priority,normal&#125;,</span><br><span class=\"line\"> &#123;group_leader,&lt;0.25.0&gt;&#125;,</span><br><span class=\"line\"> &#123;total_heap_size,3571&#125;,</span><br><span class=\"line\"> &#123;heap_size,987&#125;,</span><br><span class=\"line\"> &#123;stack_size,37&#125;,</span><br><span class=\"line\"> &#123;reductions,4070&#125;,</span><br><span class=\"line\"> &#123;garbage_collection,[&#123;min_bin_vheap_size,46368&#125;,</span><br><span class=\"line\">                      &#123;min_heap_size,233&#125;,</span><br><span class=\"line\">                      &#123;fullsweep_after,65535&#125;,</span><br><span class=\"line\">                      &#123;minor_gcs,5&#125;]&#125;,</span><br><span class=\"line\"> &#123;suspending,[]&#125;]</span><br><span class=\"line\">ok</span><br></pre></td></tr></table></figure></p>\n<p>我们所做的操作以mysql_recv:init里面是一样的。打开了3306端口。这是shell的messagebox里面已经有了两天Socket发来的消息。loop函数将这段消息交给了sendpacket处理</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sendpacket(Parent, Data) -&gt;</span><br><span class=\"line\">    case Data of</span><br><span class=\"line\">\t&lt;&lt;Length:24/little, Num:8, D/binary&gt;&gt; -&gt;</span><br><span class=\"line\">\t    if</span><br><span class=\"line\">\t\tLength =&lt; size(D) -&gt;</span><br><span class=\"line\">\t\t    &#123;Packet, Rest&#125; = split_binary(D, Length),</span><br><span class=\"line\">\t\t    Parent ! &#123;mysql_recv, self(), data, Packet, Num&#125;,</span><br><span class=\"line\">\t\t    sendpacket(Parent, Rest);</span><br><span class=\"line\">\t\ttrue -&gt;</span><br><span class=\"line\">\t\t    Data</span><br><span class=\"line\">\t    end;</span><br><span class=\"line\">\t_ -&gt;</span><br><span class=\"line\">\t    Data</span><br><span class=\"line\">    end.</span><br></pre></td></tr></table></figure>\n<p>packet头3个字节表示数据长度，第四个字节是帧序号，之后所有的是数据。那么这段数据头三个&lt;&lt;91,0,0&gt;&gt;代表数据长度是91字节（小端存储），之后的0代表这个帧序号是0，&lt;&lt;10....&gt;&gt;就是真正的数据。sendpacket将这段数据发给了parent。在如下的地方匹配<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">init(Host, Port, User, Password, Database, LogFun, Encoding, PoolId, Parent) -&gt;</span><br><span class=\"line\">    case mysql_recv:start_link(Host, Port, LogFun, self()) of</span><br><span class=\"line\">\t&#123;ok, RecvPid, Sock&#125; -&gt;</span><br><span class=\"line\">\t    case mysql_init(Sock, RecvPid, User, Password, LogFun) of</span><br><span class=\"line\">\t\t&#123;ok, Version&#125; -&gt;</span><br><span class=\"line\">------</span><br><span class=\"line\">mysql_init(Sock, RecvPid, User, Password, LogFun) -&gt;</span><br><span class=\"line\">    case do_recv(LogFun, RecvPid, undefined) of</span><br><span class=\"line\">\t&#123;ok, Packet, InitSeqNum&#125; -&gt;</span><br><span class=\"line\">\t\t    &#123;Version, Salt1, Salt2, Caps&#125; = greeting(Packet, LogFun),</span><br><span class=\"line\">-----</span><br><span class=\"line\">do_recv(LogFun, RecvPid, SeqNum)  when is_function(LogFun);</span><br><span class=\"line\">\t\t\t\t       LogFun == undefined,</span><br><span class=\"line\">\t\t\t\t       SeqNum == undefined -&gt;</span><br><span class=\"line\">    receive</span><br><span class=\"line\">        &#123;mysql_recv, RecvPid, data, Packet, Num&#125; -&gt;</span><br><span class=\"line\">\t    &#123;ok, Packet, Num&#125;;</span><br><span class=\"line\">\t&#123;mysql_recv, RecvPid, closed, _E&#125; -&gt;</span><br><span class=\"line\">\t    &#123;error, &quot;mysql_recv: socket was closed&quot;&#125;</span><br><span class=\"line\">    end;</span><br></pre></td></tr></table></figure></p>\n<p>在mysql_conn的do_recv完成对消息的匹配。<br>上面的数据其实就是<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">=INFO REPORT==== 10-Jun-2015::11:59:21 ===</span><br><span class=\"line\">I(&lt;0.116.0&gt;:mysql_conn:620) : greeting packet &lt;&lt;10,53,46,53,46,51,55,45,48,117,</span><br><span class=\"line\">                                                98,117,110,116,117,48,46,49,52,</span><br><span class=\"line\">                                                46,48,52,46,49,0,173,1,0,0,100,</span><br><span class=\"line\">                                                44,77,124,75,63,60,78,0,255,</span><br><span class=\"line\">                                                247,8,2,0,15,128,21,0,0,0,0,0,</span><br><span class=\"line\">                                                0,0,0,0,0,84,60,110,54,95,93,</span><br><span class=\"line\">                                                55,57,88,46,122,66,0,109,121,</span><br><span class=\"line\">                                                115,113,108,95,110,97,116,105,</span><br><span class=\"line\">                                                118,101,95,112,97,115,115,119,</span><br><span class=\"line\">                                                111,114,100,0&gt;&gt; version &quot;5.5.37-0ubuntu0.14.04.1&quot; (protocol 10) salt &quot;d,M|K?&lt;N&quot; caps 63487 serverchar &lt;&lt;8,2,0,</span><br><span class=\"line\">                                                                                                                                                        15,128,</span><br><span class=\"line\">                                                                                                                                                        21,0,0,</span><br><span class=\"line\">                                                                                                                                                        0,0,0,0,</span><br><span class=\"line\">                                                                                                                                                        0,0,0,0&gt;&gt;salt2 &quot;T&lt;n6_]79X.zB&quot;</span><br></pre></td></tr></table></figure></p>\n<p>greeting函数用来转化为版本号，salt等参数的。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">greeting(Packet, LogFun) -&gt;</span><br><span class=\"line\">    &lt;&lt;Protocol:8, Rest/binary&gt;&gt; = Packet,</span><br><span class=\"line\">    &#123;Version, Rest2&#125; = asciz(Rest),</span><br><span class=\"line\">    &lt;&lt;_TreadID:32/little, Rest3/binary&gt;&gt; = Rest2,</span><br><span class=\"line\">    &#123;Salt, Rest4&#125; = asciz(Rest3),</span><br><span class=\"line\">    &lt;&lt;Caps:16/little, Rest5/binary&gt;&gt; = Rest4,</span><br><span class=\"line\">    &lt;&lt;ServerChar:16/binary-unit:8, Rest6/binary&gt;&gt; = Rest5,</span><br><span class=\"line\">    &#123;Salt2, _Rest7&#125; = asciz(Rest6),</span><br><span class=\"line\">    ?Log2(LogFun, debug,</span><br><span class=\"line\">\t  &quot;greeting packet ~p version ~p (protocol ~p) salt ~p caps ~p serverchar ~p&quot;</span><br><span class=\"line\">\t  &quot;salt2 ~p&quot;,</span><br><span class=\"line\">\t  [Packet, Version, Protocol, Salt, Caps, ServerChar, Salt2]),</span><br><span class=\"line\">    &#123;normalize_version(Version, LogFun), Salt, Salt2, Caps&#125;.</span><br><span class=\"line\">------------------------------------------</span><br><span class=\"line\">asciz(Data) when is_binary(Data) -&gt;</span><br><span class=\"line\">    mysql:asciz_binary(Data, []).</span><br><span class=\"line\">-----------------------------------------</span><br><span class=\"line\">asciz_binary(&lt;&lt;&gt;&gt;, Acc) -&gt;</span><br><span class=\"line\">    &#123;lists:reverse(Acc), &lt;&lt;&gt;&gt;&#125;;</span><br><span class=\"line\">asciz_binary(&lt;&lt;0:8, Rest/binary&gt;&gt;, Acc) -&gt;</span><br><span class=\"line\">    &#123;lists:reverse(Acc), Rest&#125;;</span><br><span class=\"line\">asciz_binary(&lt;&lt;C:8, Rest/binary&gt;&gt;, Acc) -&gt;</span><br><span class=\"line\">    asciz_binary(Rest, [C | Acc]).</span><br></pre></td></tr></table></figure></p>\n<p>Packet第一个字节是protocol,之后asciz函数将剩下的二进制以0位分界点分开。那么<br>Packet被分成了</p>\n<blockquote>\n<p>Protocol : &lt;<10>&gt;<br>Version:&lt;&lt;53,46,53,46,51,55,45,48,117,98,117,110,116,117,48,46,49,52,46,48,52,46,49&gt;&gt;,<br>Salt:&lt;&lt;100,44,77,124,75,63,60,78&gt;&gt;<br>Caps:&lt;&lt;255,247&gt;&gt;<br>ServerChar:&lt;&lt;15,128,21,0,0,0,0,0,0,0,0,0,0,84,60,110&gt;&gt;(ServerChar是16个字节不是16个bit)<br>Salt2:&lt;&lt;97,116,105,118,101,95,112,97,115,115,119,111,114,100&gt;&gt;</p>\n</blockquote>\n<p>在shell中检测下<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">4&gt; &lt;&lt;53,46,53,46,51,55,45,48,117,98,117,110,116,117,48,46,49,52,46,48,52,46,49&gt;&gt;.</span><br><span class=\"line\">&lt;&lt;&quot;5.5.37-0ubuntu0.14.04.1&quot;&gt;&gt;</span><br><span class=\"line\">5&gt; &lt;&lt;100,44,77,124,75,63,60,78&gt;&gt;.</span><br><span class=\"line\">&lt;&lt;&quot;d,M|K?&lt;N&quot;&gt;&gt;</span><br><span class=\"line\">6&gt; &lt;&lt;Caps:16/little&gt;&gt; = &lt;&lt;255,247&gt;&gt;.</span><br><span class=\"line\">&lt;&lt;&quot;ÿ÷&quot;&gt;&gt;</span><br><span class=\"line\">7&gt; Caps.</span><br><span class=\"line\">63487</span><br></pre></td></tr></table></figure></p>\n<p>和上面打印的log是一样的。</p>"},{"title":"erlang_mysql_driver　源码分析(二)","date":"2015-06-09T09:21:15.000Z","_content":"\n#mysql_conn:start\n回到mysql:start_link这个最开始这个地方\n\n```\n LogFun1 = if LogFun == undefined -> fun log/4; true -> LogFun end,\n    case mysql_conn:start(Host, Port, User, Password, Database, LogFun1,\n\t\t\t  Encoding, PoolId) of\n\t{ok, ConnPid} ->\n```\n\n<!--more-->\n起初为了不断开gen_server的创建，我们没有进入mysql_conn里面。现在可以进去一窥究竟啦。\n```\nstart(Host, Port, User, Password, Database, LogFun, Encoding, PoolId) ->\n    ConnPid = self(),\n    Pid = spawn(fun () ->\n\t\t\tinit(Host, Port, User, Password, Database,\n\t\t\t     LogFun, Encoding, PoolId, ConnPid)\n\t\tend),\n    post_start(Pid, LogFun).\n    --------------------\npost_start(Pid, LogFun) ->\n    receive\n\t{mysql_conn, Pid, ok} ->\n\t    {ok, Pid};\n\t{mysql_conn, Pid, {error, Reason}} ->\n\t    {error, Reason};\n\tUnknown ->\n\t    ?Log2(LogFun, error,\n\t\t \"received unknown signal, exiting: ~p\", [Unknown]),\n\t    {error, \"unknown signal received\"}\n    after 5000 ->\n\t    {error, \"timed out\"}\n    end.\n```\n\n这里作者将post_start抽出来了，因为与start类似还有个start_link也需要这块代码，但是值得注意的是\npost_start里面的receive仍然是由mysql:start_link生成的my_sql_game这个gen_server 在调用，而且` ConnPid = self()`这句代码很有歧义，因为这个ConnPid与mysql中的`{ok, ConnPid}`明显不是同一个意思。这里的ConnPid实际就是gen_server的Pid，用来传给init作为父进程参数，在子进程可以给父进程发消息,我觉得把这段post_start放到mysql中更容易理解一点。\n这里我们可以看出来，start函数spawn一个mysql_conn:init这个进程，然后等待消息，如果成功的话，会返回{ok, Pid}，这个Pid是真正意义的ConnPid，用来生成#conn加入my_sql_game的#state里面的。其他情况会返回{error, Reason}.\n然后看一下init\n```\ninit(Host, Port, User, Password, Database, LogFun, Encoding, PoolId, Parent) ->\n    case mysql_recv:start_link(Host, Port, LogFun, self()) of\n\t{ok, RecvPid, Sock} ->\n\t    case mysql_init(Sock, RecvPid, User, Password, LogFun) of\n\t\t{ok, Version} ->\n\t\t    Db = iolist_to_binary(Database),\n\t\t    case do_query(Sock, RecvPid, LogFun,\n\t\t\t\t  <<\"use \", Db/binary>>,\n\t\t\t\t  Version) of\n\t\t\t{error, MySQLRes} ->\n\t\t\t    ?Log2(LogFun, error,\n\t\t\t\t \"mysql_conn: Failed changing to database \"\n\t\t\t\t \"~p : ~p\",\n\t\t\t\t [Database,\n\t\t\t\t  mysql:get_result_reason(MySQLRes)]),\n\t\t\t    Parent ! {mysql_conn, self(),\n\t\t\t\t      {error, failed_changing_database}};\n\n\t\t\t%% ResultType: data | updated\n\t\t\t{_ResultType, _MySQLRes} ->\n\t\t\t    Parent ! {mysql_conn, self(), ok},\n\t\t\t    case Encoding of\n\t\t\t\tundefined -> undefined;\n\t\t\t\t_ ->\n\t\t\t\t    EncodingBinary = list_to_binary(atom_to_list(Encoding)),\n\t\t\t\t    do_query(Sock, RecvPid, LogFun,\n\t\t\t\t\t     <<\"set names '\", EncodingBinary/binary, \"'\">>,\n\t\t\t\t\t     Version)\n\t\t\t    end,\n\t\t\t    State = #state{mysql_version=Version,\n\t\t\t\t\t   recv_pid = RecvPid,\n\t\t\t\t\t   socket   = Sock,\n\t\t\t\t\t   log_fun  = LogFun,\n\t\t\t\t\t   pool_id  = PoolId,\n\t\t\t\t\t   data     = <<>>\n\t\t\t\t\t  },\n\t\t\t    loop(State)\n\t\t    end;\n\t\t{error, _Reason} ->\n\t\t    Parent ! {mysql_conn, self(), {error, login_failed}}\n\t    end;\n\tE ->\n\t    ?Log2(LogFun, error,\n\t\t \"failed connecting to ~p:~p : ~p\",\n\t\t [Host, Port, E]),\n\t    Parent ! {mysql_conn, self(), {error, connect_failed}}\n    end.\n```\n\n这个init比较长，而且里面又调了mysql_recv:start_link，之前之所以没有直接分析这里面也是这个原因，在start_link里面重复调用各个模块的start_link很容易绕进去。\n同样，我们根据case语句，知道mysql_recv:start_link建了一个新的进程，并且返回RecvPid和一个Sock，可知创建进程的同时监听了某个端口。如果没有成功会返回{error， Reason}\n\n之后进入mysql_init函数。我们先不要进入mysql_init，这个函数完成了用户名和密码的认证，认证成功会返回{ok, Version}\n\n接下来要做的是\n` case do_query(Sock, RecvPid, LogFun,\n\t\t\t\t  <<\"use \", Db/binary>>,\n\t\t\t\t  Version) of`\n通知端口我们要使用哪个数据库，打印出来是这段文字\n`fetch <<\"use aries_game\">>`\n返回结果{error, MysqlRes}或者{ResultType, MysqlRes}.\nMysqlRes是一个record\n> -record(mysql_result,\n\t{fieldinfo=[],\n\t rows=[],\n\t affectedrows=0,\n\t error=\"\"}).\n\n在do_query的里面，将端口返回来的结果构造成#mysql_result的样子，他包含了需要的rows，或者操作所影响的affetedrows，fieldinfo以及如果出错的错误信息error.\n如果返回{error, MysqlRes}, 我们调用接口mysql:get_result_reason(MysqlRes)获取错误原因。\n```\nget_result_reason(#mysql_result{error=Reason}) ->\n    Reason.\n```\n\n并通知父进程出错了\n```\nParent ! {mysql_conn, self(), {error, failed_changing_database}};\n```\n\n相反\n```\n{_ResultType, _MySQLRes} ->\n\t\t\t    Parent ! {mysql_conn, self(), ok},\n```\n\n如果没有出错，我们就告诉父进程ok。\n还记得post_start里面的\n```\npost_start(Pid, LogFun) ->\n    receive\n\t{mysql_conn, Pid, ok} ->\n\t    {ok, Pid};\n\t{mysql_conn, Pid, {error, Reason}} ->\n\t    {error, Reason};\n```\n\n这就是receive我们这些消息的地方。\n后面的\n```\n  EncodingBinary = list_to_binary(atom_to_list(Encoding)),\n\t\t\t\t    do_query(Sock, RecvPid, LogFun,\n\t\t\t\t\t     <<\"set names '\", EncodingBinary/binary, \"'\">>,\n\t\t\t\t\t     Version)\n```\n\n用来设定我们的编码方式，目前用的utf8.\n下面了解下do_query的细节，因为之后我们要做的查询，插入等操作也经过它\n```\ndo_query(Sock, RecvPid, LogFun, Query, Version) ->\n    Query1 = iolist_to_binary(Query),\n    ?Log2(LogFun, debug, \"fetch ~p (id ~p)\", [Query1,RecvPid]),\n    Packet =  <<?MYSQL_QUERY_OP, Query1/binary>>,\n    case do_send(Sock, Packet, 0, LogFun) of\n\tok ->\n\t    get_query_response(LogFun,RecvPid,\n\t\t\t\t    Version);\n\t{error, Reason} ->\n\t    Msg = io_lib:format(\"Failed sending data \"\n\t\t\t\t\"on socket : ~p\",\n\t\t\t\t[Reason]),\n\t    {error, Msg}\n    end.\n```\n\nQuery是我们的sql语句，比如上面的<<<\"use aries_game\">>,\nQuery1使我们给Query加上一个字节的3(?MYSQL_QUERY_OP是3）.\ndo_send将packet打包并发送，头三个字节是packet大小，第4个字节是序列号，之后是packet内容，如下\n```\ndo_send(Sock, Packet, SeqNum, _LogFun) when is_binary(Packet), is_integer(SeqNum) ->\n    Data = <<(size(Packet)):24/little, SeqNum:8, Packet/binary>>,\n    gen_tcp:send(Sock, Data).\n```\n\n这时候向端口发送了请求,get_query_response等待回应。\n```\nget_query_response(LogFun, RecvPid, Version) ->\n    case do_recv(LogFun, RecvPid, undefined) of\n\t{ok, <<Fieldcount:8, Rest/binary>>, _} ->\n\t    case Fieldcount of\n\t\t0 ->\n\t\t    %% No Tabular data\n            <<AffectedRows:8, _Rest2/binary>> = Rest,\n            ?Log2(LogFun, debug, \"updated ~p\", [AffectedRows]),\n\t\t    {updated, #mysql_result{affectedrows=AffectedRows}};\n\t\t255 ->\n\t\t    <<_Code:16/little, Message/binary>>  = Rest,\n\t\t    {error, #mysql_result{error=Message}};\n\t\t_ ->\n\t\t    %% Tabular data received\n\t\t    case get_fields(LogFun, RecvPid, [], Version) of\n\t\t\t{ok, Fields} ->\n\t\t\t    case get_rows(Fields, LogFun, RecvPid, []) of\n\t\t\t\t{ok, Rows} ->\n                    ?Log2(LogFun, debug, \"data: field:~p, rows:~p\", [Fields, Rows]),\n                    {data, #mysql_result{fieldinfo=Fields,\n                            rows=Rows}};\n\t\t\t\t{error, Reason} ->\n\t\t\t\t    {error, #mysql_result{error=Reason}}\n\t\t\t    end;\n\t\t\t{error, Reason} ->\n\t\t\t    {error, #mysql_result{error=Reason}}\n\t\t    end\n\t    end;\n\t{error, Reason} ->\n\t    {error, #mysql_result{error=Reason}}\n    end.\n```\n\n第一句do_recv主要用来对第三个参数帧序列号的不同做匹配，这里是undefined，意在接受任何帧，如果指定一个帧号A，那么do_recv只接受A+1的消息。如下\n```\n do_recv(LogFun, RecvPid, SeqNum)  when is_function(LogFun);\n\t\t\t\t       LogFun == undefined,\n\t\t\t\t       SeqNum == undefined ->\n    receive\n        {mysql_recv, RecvPid, data, Packet, Num} ->\n\t    {ok, Packet, Num};\n\t{mysql_recv, RecvPid, closed, _E} ->\n\t    {error, \"mysql_recv: socket was closed\"}\n    end;\ndo_recv(LogFun, RecvPid, SeqNum) when is_function(LogFun);\n\t\t\t\t      LogFun == undefined,\n\t\t\t\t      is_integer(SeqNum) ->\n    ResponseNum = SeqNum + 1,\n    receive\n        {mysql_recv, RecvPid, data, Packet, ResponseNum} ->\n\t    {ok, Packet, ResponseNum};\n\t{mysql_recv, RecvPid, closed, _E} ->\n\t    {error, \"mysql_recv: socket was closed\"}\n    end.\n```\n\n这个函数将端口返回的Packet和帧序号返回，或者帧序号+1返回。\n回到`case do_recv(LogFun, RecvPid, undefined) of`\n接下来是对结果的匹配，Fieldcount为0表示执行的是update操作，而不是请求某些数据。如果为255则表示出错，返回{error, #mysql_result{error = Message}}.\n其他数值时，会执行get_field().\n```\n%% Support for MySQL 4.1.x and 5.x:\nget_fields(LogFun, RecvPid, Res, ?MYSQL_4_1) ->\n    case do_recv(LogFun, RecvPid, undefined) of\n\t{ok, Packet, _Num} ->\n        ?Log2(LogFun, debug, \"get_field: packet ~p\", [Packet]),\n\t    case Packet of\n\t\t<<254:8>> ->\n\t\t    {ok, lists:reverse(Res)};\n\t\t<<254:8, Rest/binary>> when size(Rest) < 8 ->\n\t\t    {ok, lists:reverse(Res)};\n\t\t_ ->\n\t\t    {_Catalog, Rest} = get_with_length(Packet),\n\t\t    {_Database, Rest2} = get_with_length(Rest),\n\t\t    {Table, Rest3} = get_with_length(Rest2),\n\t\t    %% OrgTable is the real table name if Table is an alias\n\t\t    {_OrgTable, Rest4} = get_with_length(Rest3),\n\t\t    {Field, Rest5} = get_with_length(Rest4),\n\t\t    %% OrgField is the real field name if Field is an alias\n\t\t    {_OrgField, Rest6} = get_with_length(Rest5),\n\n\t\t    <<_Metadata:8/little, _Charset:16/little,\n\t\t     Length:32/little, Type:8/little,\n\t\t     _Flags:16/little, _Decimals:8/little,\n\t\t     _Rest7/binary>> = Rest6,\n\t\t    \n\t\t    This = {Table,\n\t\t\t    Field,\n\t\t\t    Length,\n\t\t\t    get_field_datatype(Type)},\n\t\t    get_fields(LogFun, RecvPid, [This | Res], ?MYSQL_4_1)\n\t    end;\n\t{error, Reason} ->\n\t    {error, Reason}\n    end.\n```\n\n这里提供了两个版本的get_field,我的mysql是5.5所以会匹配到这个函数上。\nget_field一开始仍然是do_recv，用来提取一个Packet。case Packet告诉我们这个包第一个字节是254的时候表示结果已经全部告诉我们了，这时候会将Res（result）翻转，返回。\nget_with_length用来将Packet切割，用来得到Table， Field， Length等参数。\n```\nget_with_length(<<251:8, Rest/binary>>) ->\n    {null, Rest};\nget_with_length(<<252:8, Length:16/little, Rest/binary>>) ->\n    split_binary(Rest, Length);\nget_with_length(<<253:8, Length:24/little, Rest/binary>>) ->\n    split_binary(Rest, Length);\nget_with_length(<<254:8, Length:64/little, Rest/binary>>) ->\n    split_binary(Rest, Length);\nget_with_length(<<Length:8, Rest/binary>>) when Length < 251 ->\n    split_binary(Rest, Length).\n```\n\n这个函数的意思大致可以看出来，如果第一个字节是251，就直接返回null和Rest，如果第一个字节小于251，那么第一个字节表示长度，将Rest分割成{Value， Rest2}，Value是我们需要的，对应长度的值，如果第一个字节大于251，分不同的情况，接下来的2个4个或者8个字节表示长度，将Rest分割。举个例子\n```\nmysql:fetch(mysql_game_pool, \"select name from player where id = 301\").\n\n=INFO REPORT==== 9-Jun-2015::16:43:29 ===\nI(<0.94.0>:mysql_conn:426) : fetch <<\"select name from player where id = 301\">> (id <0.95.0>)\n\n=INFO REPORT==== 9-Jun-2015::16:43:29 ===\nI(<0.94.0>:mysql_conn:726) : get_field: packet <<3,100,101,102,10,97,114,105,\n                                                 101,115,95,103,97,109,101,6,\n                                                 112,108,97,121,101,114,6,112,\n                                                 108,97,121,101,114,4,110,97,\n                                                 109,101,4,110,97,109,101,12,\n                                                 33,0,150,0,0,0,253,5,64,0,0,0>>\n\n=INFO REPORT==== 9-Jun-2015::16:43:29 ===\nI(<0.94.0>:mysql_conn:726) : get_field: packet <<254,0,0,2,0>>\n{data,{mysql_result,[{<<\"player\">>,<<\"name\">>,150,\n                      'VAR_STRING'}],\n                    [[<<\"aaaa\">>]],\n                    0,[]}}\n\n=INFO REPORT==== 9-Jun-2015::16:43:29 ===\nI(<0.94.0>:mysql_conn:770) : get_rows: packet <<4,97,97,97,97>>\n\n=INFO REPORT==== 9-Jun-2015::16:43:29 ===\nI(<0.94.0>:mysql_conn:770) : get_rows: packet <<254,0,0,2,0>>\n(aries_game@192.168.1.85)2> \n=INFO REPORT==== 9-Jun-2015::16:43:29 ===\nI(<0.94.0>:mysql_conn:667) : data: field:[{<<\"player\">>,<<\"name\">>,150,\n                                           'VAR_STRING'}], rows:[[<<\"aaaa\">>]]\n\n```\n\n我们执行了一个sql语句，从player表中选出id为301的玩家的名字。\n端口回复给我们的是get_field后面打印的二进制串。\n  1. 第一个字节是3，不是254。走get_with_length拆分。\n  2. 将100,101,102提出，为CataLog,这个参数我们不需要。\n  3. 10表示接下来取10个字节，一直到109，101.位Database，我们也不需要\n  4. 接下来6，表示6个字节，<<112,108,97,121,101,114>>提取为Table，也就是我们的表名，我们在shell中打一下可以看到实际上就是<<\"player\">>。表示我们是从player表取得。\n  5. 接下来6个字节和上面一下，我们不需要。\n  6. 下面4个字节<<110,97,109,101>>,就是<<\"name\">>,表示字段名。\n  7. 后面4个字节以上面一下，不需要。\n  8. 从12开始一直到最后我们只需要<<150,0,0,0>>这四个表示长度,注意是小段存储，即长150，253，表示Type.\n  9. 紧着着第一个packet到达，由于是254，告诉我们这个语句结果已返回。\n这个时候我们只知道是player表的name字段，接下来get_rows将得到具体结果。\n```\nget_rows(Fields, LogFun, RecvPid, Res) ->\n    case do_recv(LogFun, RecvPid, undefined) of\n\t{ok, Packet, _Num} ->\n        ?Log2(LogFun, debug, \"get_rows: packet ~p\", [Packet]),\n\t    case Packet of\n\t\t<<254:8, Rest/binary>> when size(Rest) < 8 ->\n\t\t    {ok, lists:reverse(Res)};\n\t\t_ ->\n\t\t    {ok, This} = get_row(Fields, Packet, []),\n\t\t    get_rows(Fields, LogFun, RecvPid, [This | Res])\n\t    end;\n\t{error, Reason} ->\n\t    {error, Reason}\n    end.\n\n%% part of get_rows/4\nget_row([], _Data, Res) ->\n    {ok, lists:reverse(Res)};\nget_row([Field | OtherFields], Data, Res) ->\n    {Col, Rest} = get_with_length(Data),\n    This = case Col of\n\t       null ->\n\t\t   undefined;\n\t       _ ->\n\t\t   convert_type(Col, element(4, Field))\n\t   end,\n    get_row(OtherFields, Rest, [This | Res]).\n```\n其中Field为[{<<\"player\">>,<<\"name\">>,150,'VAR_STRING'}],\n与上面get_field大致相同，row的这个packet很简单，<<4,97,97,97,97>>，后面的4个字节就是我们要的结果就是<<\"aaaa\">>.然后convert_type将结果转为对应的形式\nconvert_type不贴了，ｈｅｘｏ转码会有问题．\n我们的类型是VAR_STRING，直接原样返回。\n这样回到get_query_response，我们得到了需要的结果{data, #mysql_result{}}这种形式。\n在往上回到init处，我们执行完<<\"use XXX(数据库名)\">>, 返回成功后，执行<<\"set names utf8\">>,\n最后构造State\n```\nState = #state{mysql_version=Version,\n\t\t\t\t\t   recv_pid = RecvPid,\n\t\t\t\t\t   socket   = Sock,\n\t\t\t\t\t   log_fun  = LogFun,\n\t\t\t\t\t   pool_id  = PoolId,\n\t\t\t\t\t   data     = <<>>\n\t\t\t\t\t  },\n\t\t\t    loop(State)\n```\n\n并开始loop。至此这个mysql_conn进程创建完毕。\n","source":"_posts/erlang_mysql_driver源码分析(二).md","raw":"title: erlang_mysql_driver　源码分析(二)\ndate: 2015-06-09 17:21:15\ntags: erlang\ncategories: erlang\n---\n\n#mysql_conn:start\n回到mysql:start_link这个最开始这个地方\n\n```\n LogFun1 = if LogFun == undefined -> fun log/4; true -> LogFun end,\n    case mysql_conn:start(Host, Port, User, Password, Database, LogFun1,\n\t\t\t  Encoding, PoolId) of\n\t{ok, ConnPid} ->\n```\n\n<!--more-->\n起初为了不断开gen_server的创建，我们没有进入mysql_conn里面。现在可以进去一窥究竟啦。\n```\nstart(Host, Port, User, Password, Database, LogFun, Encoding, PoolId) ->\n    ConnPid = self(),\n    Pid = spawn(fun () ->\n\t\t\tinit(Host, Port, User, Password, Database,\n\t\t\t     LogFun, Encoding, PoolId, ConnPid)\n\t\tend),\n    post_start(Pid, LogFun).\n    --------------------\npost_start(Pid, LogFun) ->\n    receive\n\t{mysql_conn, Pid, ok} ->\n\t    {ok, Pid};\n\t{mysql_conn, Pid, {error, Reason}} ->\n\t    {error, Reason};\n\tUnknown ->\n\t    ?Log2(LogFun, error,\n\t\t \"received unknown signal, exiting: ~p\", [Unknown]),\n\t    {error, \"unknown signal received\"}\n    after 5000 ->\n\t    {error, \"timed out\"}\n    end.\n```\n\n这里作者将post_start抽出来了，因为与start类似还有个start_link也需要这块代码，但是值得注意的是\npost_start里面的receive仍然是由mysql:start_link生成的my_sql_game这个gen_server 在调用，而且` ConnPid = self()`这句代码很有歧义，因为这个ConnPid与mysql中的`{ok, ConnPid}`明显不是同一个意思。这里的ConnPid实际就是gen_server的Pid，用来传给init作为父进程参数，在子进程可以给父进程发消息,我觉得把这段post_start放到mysql中更容易理解一点。\n这里我们可以看出来，start函数spawn一个mysql_conn:init这个进程，然后等待消息，如果成功的话，会返回{ok, Pid}，这个Pid是真正意义的ConnPid，用来生成#conn加入my_sql_game的#state里面的。其他情况会返回{error, Reason}.\n然后看一下init\n```\ninit(Host, Port, User, Password, Database, LogFun, Encoding, PoolId, Parent) ->\n    case mysql_recv:start_link(Host, Port, LogFun, self()) of\n\t{ok, RecvPid, Sock} ->\n\t    case mysql_init(Sock, RecvPid, User, Password, LogFun) of\n\t\t{ok, Version} ->\n\t\t    Db = iolist_to_binary(Database),\n\t\t    case do_query(Sock, RecvPid, LogFun,\n\t\t\t\t  <<\"use \", Db/binary>>,\n\t\t\t\t  Version) of\n\t\t\t{error, MySQLRes} ->\n\t\t\t    ?Log2(LogFun, error,\n\t\t\t\t \"mysql_conn: Failed changing to database \"\n\t\t\t\t \"~p : ~p\",\n\t\t\t\t [Database,\n\t\t\t\t  mysql:get_result_reason(MySQLRes)]),\n\t\t\t    Parent ! {mysql_conn, self(),\n\t\t\t\t      {error, failed_changing_database}};\n\n\t\t\t%% ResultType: data | updated\n\t\t\t{_ResultType, _MySQLRes} ->\n\t\t\t    Parent ! {mysql_conn, self(), ok},\n\t\t\t    case Encoding of\n\t\t\t\tundefined -> undefined;\n\t\t\t\t_ ->\n\t\t\t\t    EncodingBinary = list_to_binary(atom_to_list(Encoding)),\n\t\t\t\t    do_query(Sock, RecvPid, LogFun,\n\t\t\t\t\t     <<\"set names '\", EncodingBinary/binary, \"'\">>,\n\t\t\t\t\t     Version)\n\t\t\t    end,\n\t\t\t    State = #state{mysql_version=Version,\n\t\t\t\t\t   recv_pid = RecvPid,\n\t\t\t\t\t   socket   = Sock,\n\t\t\t\t\t   log_fun  = LogFun,\n\t\t\t\t\t   pool_id  = PoolId,\n\t\t\t\t\t   data     = <<>>\n\t\t\t\t\t  },\n\t\t\t    loop(State)\n\t\t    end;\n\t\t{error, _Reason} ->\n\t\t    Parent ! {mysql_conn, self(), {error, login_failed}}\n\t    end;\n\tE ->\n\t    ?Log2(LogFun, error,\n\t\t \"failed connecting to ~p:~p : ~p\",\n\t\t [Host, Port, E]),\n\t    Parent ! {mysql_conn, self(), {error, connect_failed}}\n    end.\n```\n\n这个init比较长，而且里面又调了mysql_recv:start_link，之前之所以没有直接分析这里面也是这个原因，在start_link里面重复调用各个模块的start_link很容易绕进去。\n同样，我们根据case语句，知道mysql_recv:start_link建了一个新的进程，并且返回RecvPid和一个Sock，可知创建进程的同时监听了某个端口。如果没有成功会返回{error， Reason}\n\n之后进入mysql_init函数。我们先不要进入mysql_init，这个函数完成了用户名和密码的认证，认证成功会返回{ok, Version}\n\n接下来要做的是\n` case do_query(Sock, RecvPid, LogFun,\n\t\t\t\t  <<\"use \", Db/binary>>,\n\t\t\t\t  Version) of`\n通知端口我们要使用哪个数据库，打印出来是这段文字\n`fetch <<\"use aries_game\">>`\n返回结果{error, MysqlRes}或者{ResultType, MysqlRes}.\nMysqlRes是一个record\n> -record(mysql_result,\n\t{fieldinfo=[],\n\t rows=[],\n\t affectedrows=0,\n\t error=\"\"}).\n\n在do_query的里面，将端口返回来的结果构造成#mysql_result的样子，他包含了需要的rows，或者操作所影响的affetedrows，fieldinfo以及如果出错的错误信息error.\n如果返回{error, MysqlRes}, 我们调用接口mysql:get_result_reason(MysqlRes)获取错误原因。\n```\nget_result_reason(#mysql_result{error=Reason}) ->\n    Reason.\n```\n\n并通知父进程出错了\n```\nParent ! {mysql_conn, self(), {error, failed_changing_database}};\n```\n\n相反\n```\n{_ResultType, _MySQLRes} ->\n\t\t\t    Parent ! {mysql_conn, self(), ok},\n```\n\n如果没有出错，我们就告诉父进程ok。\n还记得post_start里面的\n```\npost_start(Pid, LogFun) ->\n    receive\n\t{mysql_conn, Pid, ok} ->\n\t    {ok, Pid};\n\t{mysql_conn, Pid, {error, Reason}} ->\n\t    {error, Reason};\n```\n\n这就是receive我们这些消息的地方。\n后面的\n```\n  EncodingBinary = list_to_binary(atom_to_list(Encoding)),\n\t\t\t\t    do_query(Sock, RecvPid, LogFun,\n\t\t\t\t\t     <<\"set names '\", EncodingBinary/binary, \"'\">>,\n\t\t\t\t\t     Version)\n```\n\n用来设定我们的编码方式，目前用的utf8.\n下面了解下do_query的细节，因为之后我们要做的查询，插入等操作也经过它\n```\ndo_query(Sock, RecvPid, LogFun, Query, Version) ->\n    Query1 = iolist_to_binary(Query),\n    ?Log2(LogFun, debug, \"fetch ~p (id ~p)\", [Query1,RecvPid]),\n    Packet =  <<?MYSQL_QUERY_OP, Query1/binary>>,\n    case do_send(Sock, Packet, 0, LogFun) of\n\tok ->\n\t    get_query_response(LogFun,RecvPid,\n\t\t\t\t    Version);\n\t{error, Reason} ->\n\t    Msg = io_lib:format(\"Failed sending data \"\n\t\t\t\t\"on socket : ~p\",\n\t\t\t\t[Reason]),\n\t    {error, Msg}\n    end.\n```\n\nQuery是我们的sql语句，比如上面的<<<\"use aries_game\">>,\nQuery1使我们给Query加上一个字节的3(?MYSQL_QUERY_OP是3）.\ndo_send将packet打包并发送，头三个字节是packet大小，第4个字节是序列号，之后是packet内容，如下\n```\ndo_send(Sock, Packet, SeqNum, _LogFun) when is_binary(Packet), is_integer(SeqNum) ->\n    Data = <<(size(Packet)):24/little, SeqNum:8, Packet/binary>>,\n    gen_tcp:send(Sock, Data).\n```\n\n这时候向端口发送了请求,get_query_response等待回应。\n```\nget_query_response(LogFun, RecvPid, Version) ->\n    case do_recv(LogFun, RecvPid, undefined) of\n\t{ok, <<Fieldcount:8, Rest/binary>>, _} ->\n\t    case Fieldcount of\n\t\t0 ->\n\t\t    %% No Tabular data\n            <<AffectedRows:8, _Rest2/binary>> = Rest,\n            ?Log2(LogFun, debug, \"updated ~p\", [AffectedRows]),\n\t\t    {updated, #mysql_result{affectedrows=AffectedRows}};\n\t\t255 ->\n\t\t    <<_Code:16/little, Message/binary>>  = Rest,\n\t\t    {error, #mysql_result{error=Message}};\n\t\t_ ->\n\t\t    %% Tabular data received\n\t\t    case get_fields(LogFun, RecvPid, [], Version) of\n\t\t\t{ok, Fields} ->\n\t\t\t    case get_rows(Fields, LogFun, RecvPid, []) of\n\t\t\t\t{ok, Rows} ->\n                    ?Log2(LogFun, debug, \"data: field:~p, rows:~p\", [Fields, Rows]),\n                    {data, #mysql_result{fieldinfo=Fields,\n                            rows=Rows}};\n\t\t\t\t{error, Reason} ->\n\t\t\t\t    {error, #mysql_result{error=Reason}}\n\t\t\t    end;\n\t\t\t{error, Reason} ->\n\t\t\t    {error, #mysql_result{error=Reason}}\n\t\t    end\n\t    end;\n\t{error, Reason} ->\n\t    {error, #mysql_result{error=Reason}}\n    end.\n```\n\n第一句do_recv主要用来对第三个参数帧序列号的不同做匹配，这里是undefined，意在接受任何帧，如果指定一个帧号A，那么do_recv只接受A+1的消息。如下\n```\n do_recv(LogFun, RecvPid, SeqNum)  when is_function(LogFun);\n\t\t\t\t       LogFun == undefined,\n\t\t\t\t       SeqNum == undefined ->\n    receive\n        {mysql_recv, RecvPid, data, Packet, Num} ->\n\t    {ok, Packet, Num};\n\t{mysql_recv, RecvPid, closed, _E} ->\n\t    {error, \"mysql_recv: socket was closed\"}\n    end;\ndo_recv(LogFun, RecvPid, SeqNum) when is_function(LogFun);\n\t\t\t\t      LogFun == undefined,\n\t\t\t\t      is_integer(SeqNum) ->\n    ResponseNum = SeqNum + 1,\n    receive\n        {mysql_recv, RecvPid, data, Packet, ResponseNum} ->\n\t    {ok, Packet, ResponseNum};\n\t{mysql_recv, RecvPid, closed, _E} ->\n\t    {error, \"mysql_recv: socket was closed\"}\n    end.\n```\n\n这个函数将端口返回的Packet和帧序号返回，或者帧序号+1返回。\n回到`case do_recv(LogFun, RecvPid, undefined) of`\n接下来是对结果的匹配，Fieldcount为0表示执行的是update操作，而不是请求某些数据。如果为255则表示出错，返回{error, #mysql_result{error = Message}}.\n其他数值时，会执行get_field().\n```\n%% Support for MySQL 4.1.x and 5.x:\nget_fields(LogFun, RecvPid, Res, ?MYSQL_4_1) ->\n    case do_recv(LogFun, RecvPid, undefined) of\n\t{ok, Packet, _Num} ->\n        ?Log2(LogFun, debug, \"get_field: packet ~p\", [Packet]),\n\t    case Packet of\n\t\t<<254:8>> ->\n\t\t    {ok, lists:reverse(Res)};\n\t\t<<254:8, Rest/binary>> when size(Rest) < 8 ->\n\t\t    {ok, lists:reverse(Res)};\n\t\t_ ->\n\t\t    {_Catalog, Rest} = get_with_length(Packet),\n\t\t    {_Database, Rest2} = get_with_length(Rest),\n\t\t    {Table, Rest3} = get_with_length(Rest2),\n\t\t    %% OrgTable is the real table name if Table is an alias\n\t\t    {_OrgTable, Rest4} = get_with_length(Rest3),\n\t\t    {Field, Rest5} = get_with_length(Rest4),\n\t\t    %% OrgField is the real field name if Field is an alias\n\t\t    {_OrgField, Rest6} = get_with_length(Rest5),\n\n\t\t    <<_Metadata:8/little, _Charset:16/little,\n\t\t     Length:32/little, Type:8/little,\n\t\t     _Flags:16/little, _Decimals:8/little,\n\t\t     _Rest7/binary>> = Rest6,\n\t\t    \n\t\t    This = {Table,\n\t\t\t    Field,\n\t\t\t    Length,\n\t\t\t    get_field_datatype(Type)},\n\t\t    get_fields(LogFun, RecvPid, [This | Res], ?MYSQL_4_1)\n\t    end;\n\t{error, Reason} ->\n\t    {error, Reason}\n    end.\n```\n\n这里提供了两个版本的get_field,我的mysql是5.5所以会匹配到这个函数上。\nget_field一开始仍然是do_recv，用来提取一个Packet。case Packet告诉我们这个包第一个字节是254的时候表示结果已经全部告诉我们了，这时候会将Res（result）翻转，返回。\nget_with_length用来将Packet切割，用来得到Table， Field， Length等参数。\n```\nget_with_length(<<251:8, Rest/binary>>) ->\n    {null, Rest};\nget_with_length(<<252:8, Length:16/little, Rest/binary>>) ->\n    split_binary(Rest, Length);\nget_with_length(<<253:8, Length:24/little, Rest/binary>>) ->\n    split_binary(Rest, Length);\nget_with_length(<<254:8, Length:64/little, Rest/binary>>) ->\n    split_binary(Rest, Length);\nget_with_length(<<Length:8, Rest/binary>>) when Length < 251 ->\n    split_binary(Rest, Length).\n```\n\n这个函数的意思大致可以看出来，如果第一个字节是251，就直接返回null和Rest，如果第一个字节小于251，那么第一个字节表示长度，将Rest分割成{Value， Rest2}，Value是我们需要的，对应长度的值，如果第一个字节大于251，分不同的情况，接下来的2个4个或者8个字节表示长度，将Rest分割。举个例子\n```\nmysql:fetch(mysql_game_pool, \"select name from player where id = 301\").\n\n=INFO REPORT==== 9-Jun-2015::16:43:29 ===\nI(<0.94.0>:mysql_conn:426) : fetch <<\"select name from player where id = 301\">> (id <0.95.0>)\n\n=INFO REPORT==== 9-Jun-2015::16:43:29 ===\nI(<0.94.0>:mysql_conn:726) : get_field: packet <<3,100,101,102,10,97,114,105,\n                                                 101,115,95,103,97,109,101,6,\n                                                 112,108,97,121,101,114,6,112,\n                                                 108,97,121,101,114,4,110,97,\n                                                 109,101,4,110,97,109,101,12,\n                                                 33,0,150,0,0,0,253,5,64,0,0,0>>\n\n=INFO REPORT==== 9-Jun-2015::16:43:29 ===\nI(<0.94.0>:mysql_conn:726) : get_field: packet <<254,0,0,2,0>>\n{data,{mysql_result,[{<<\"player\">>,<<\"name\">>,150,\n                      'VAR_STRING'}],\n                    [[<<\"aaaa\">>]],\n                    0,[]}}\n\n=INFO REPORT==== 9-Jun-2015::16:43:29 ===\nI(<0.94.0>:mysql_conn:770) : get_rows: packet <<4,97,97,97,97>>\n\n=INFO REPORT==== 9-Jun-2015::16:43:29 ===\nI(<0.94.0>:mysql_conn:770) : get_rows: packet <<254,0,0,2,0>>\n(aries_game@192.168.1.85)2> \n=INFO REPORT==== 9-Jun-2015::16:43:29 ===\nI(<0.94.0>:mysql_conn:667) : data: field:[{<<\"player\">>,<<\"name\">>,150,\n                                           'VAR_STRING'}], rows:[[<<\"aaaa\">>]]\n\n```\n\n我们执行了一个sql语句，从player表中选出id为301的玩家的名字。\n端口回复给我们的是get_field后面打印的二进制串。\n  1. 第一个字节是3，不是254。走get_with_length拆分。\n  2. 将100,101,102提出，为CataLog,这个参数我们不需要。\n  3. 10表示接下来取10个字节，一直到109，101.位Database，我们也不需要\n  4. 接下来6，表示6个字节，<<112,108,97,121,101,114>>提取为Table，也就是我们的表名，我们在shell中打一下可以看到实际上就是<<\"player\">>。表示我们是从player表取得。\n  5. 接下来6个字节和上面一下，我们不需要。\n  6. 下面4个字节<<110,97,109,101>>,就是<<\"name\">>,表示字段名。\n  7. 后面4个字节以上面一下，不需要。\n  8. 从12开始一直到最后我们只需要<<150,0,0,0>>这四个表示长度,注意是小段存储，即长150，253，表示Type.\n  9. 紧着着第一个packet到达，由于是254，告诉我们这个语句结果已返回。\n这个时候我们只知道是player表的name字段，接下来get_rows将得到具体结果。\n```\nget_rows(Fields, LogFun, RecvPid, Res) ->\n    case do_recv(LogFun, RecvPid, undefined) of\n\t{ok, Packet, _Num} ->\n        ?Log2(LogFun, debug, \"get_rows: packet ~p\", [Packet]),\n\t    case Packet of\n\t\t<<254:8, Rest/binary>> when size(Rest) < 8 ->\n\t\t    {ok, lists:reverse(Res)};\n\t\t_ ->\n\t\t    {ok, This} = get_row(Fields, Packet, []),\n\t\t    get_rows(Fields, LogFun, RecvPid, [This | Res])\n\t    end;\n\t{error, Reason} ->\n\t    {error, Reason}\n    end.\n\n%% part of get_rows/4\nget_row([], _Data, Res) ->\n    {ok, lists:reverse(Res)};\nget_row([Field | OtherFields], Data, Res) ->\n    {Col, Rest} = get_with_length(Data),\n    This = case Col of\n\t       null ->\n\t\t   undefined;\n\t       _ ->\n\t\t   convert_type(Col, element(4, Field))\n\t   end,\n    get_row(OtherFields, Rest, [This | Res]).\n```\n其中Field为[{<<\"player\">>,<<\"name\">>,150,'VAR_STRING'}],\n与上面get_field大致相同，row的这个packet很简单，<<4,97,97,97,97>>，后面的4个字节就是我们要的结果就是<<\"aaaa\">>.然后convert_type将结果转为对应的形式\nconvert_type不贴了，ｈｅｘｏ转码会有问题．\n我们的类型是VAR_STRING，直接原样返回。\n这样回到get_query_response，我们得到了需要的结果{data, #mysql_result{}}这种形式。\n在往上回到init处，我们执行完<<\"use XXX(数据库名)\">>, 返回成功后，执行<<\"set names utf8\">>,\n最后构造State\n```\nState = #state{mysql_version=Version,\n\t\t\t\t\t   recv_pid = RecvPid,\n\t\t\t\t\t   socket   = Sock,\n\t\t\t\t\t   log_fun  = LogFun,\n\t\t\t\t\t   pool_id  = PoolId,\n\t\t\t\t\t   data     = <<>>\n\t\t\t\t\t  },\n\t\t\t    loop(State)\n```\n\n并开始loop。至此这个mysql_conn进程创建完毕。\n","slug":"erlang_mysql_driver源码分析(二)","published":1,"updated":"2018-06-26T09:49:27.734Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqw7jdvw000q6f1rc8nkcxga","content":"<p>#mysql_conn:start<br>回到mysql:start_link这个最开始这个地方</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LogFun1 = if LogFun == undefined -&gt; fun log/4; true -&gt; LogFun end,</span><br><span class=\"line\">   case mysql_conn:start(Host, Port, User, Password, Database, LogFun1,</span><br><span class=\"line\">\t\t  Encoding, PoolId) of</span><br><span class=\"line\">&#123;ok, ConnPid&#125; -&gt;</span><br></pre></td></tr></table></figure>\n<span id=\"more\"></span>\n<p>起初为了不断开gen_server的创建，我们没有进入mysql_conn里面。现在可以进去一窥究竟啦。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start(Host, Port, User, Password, Database, LogFun, Encoding, PoolId) -&gt;</span><br><span class=\"line\">    ConnPid = self(),</span><br><span class=\"line\">    Pid = spawn(fun () -&gt;</span><br><span class=\"line\">\t\t\tinit(Host, Port, User, Password, Database,</span><br><span class=\"line\">\t\t\t     LogFun, Encoding, PoolId, ConnPid)</span><br><span class=\"line\">\t\tend),</span><br><span class=\"line\">    post_start(Pid, LogFun).</span><br><span class=\"line\">    --------------------</span><br><span class=\"line\">post_start(Pid, LogFun) -&gt;</span><br><span class=\"line\">    receive</span><br><span class=\"line\">\t&#123;mysql_conn, Pid, ok&#125; -&gt;</span><br><span class=\"line\">\t    &#123;ok, Pid&#125;;</span><br><span class=\"line\">\t&#123;mysql_conn, Pid, &#123;error, Reason&#125;&#125; -&gt;</span><br><span class=\"line\">\t    &#123;error, Reason&#125;;</span><br><span class=\"line\">\tUnknown -&gt;</span><br><span class=\"line\">\t    ?Log2(LogFun, error,</span><br><span class=\"line\">\t\t &quot;received unknown signal, exiting: ~p&quot;, [Unknown]),</span><br><span class=\"line\">\t    &#123;error, &quot;unknown signal received&quot;&#125;</span><br><span class=\"line\">    after 5000 -&gt;</span><br><span class=\"line\">\t    &#123;error, &quot;timed out&quot;&#125;</span><br><span class=\"line\">    end.</span><br></pre></td></tr></table></figure></p>\n<p>这里作者将post_start抽出来了，因为与start类似还有个start_link也需要这块代码，但是值得注意的是<br>post_start里面的receive仍然是由mysql:start_link生成的my_sql_game这个gen_server 在调用，而且<code>ConnPid = self()</code>这句代码很有歧义，因为这个ConnPid与mysql中的<code>&#123;ok, ConnPid&#125;</code>明显不是同一个意思。这里的ConnPid实际就是gen_server的Pid，用来传给init作为父进程参数，在子进程可以给父进程发消息,我觉得把这段post_start放到mysql中更容易理解一点。<br>这里我们可以看出来，start函数spawn一个mysql_conn:init这个进程，然后等待消息，如果成功的话，会返回{ok, Pid}，这个Pid是真正意义的ConnPid，用来生成#conn加入my_sql_game的#state里面的。其他情况会返回{error, Reason}.<br>然后看一下init<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">init(Host, Port, User, Password, Database, LogFun, Encoding, PoolId, Parent) -&gt;</span><br><span class=\"line\">    case mysql_recv:start_link(Host, Port, LogFun, self()) of</span><br><span class=\"line\">\t&#123;ok, RecvPid, Sock&#125; -&gt;</span><br><span class=\"line\">\t    case mysql_init(Sock, RecvPid, User, Password, LogFun) of</span><br><span class=\"line\">\t\t&#123;ok, Version&#125; -&gt;</span><br><span class=\"line\">\t\t    Db = iolist_to_binary(Database),</span><br><span class=\"line\">\t\t    case do_query(Sock, RecvPid, LogFun,</span><br><span class=\"line\">\t\t\t\t  &lt;&lt;&quot;use &quot;, Db/binary&gt;&gt;,</span><br><span class=\"line\">\t\t\t\t  Version) of</span><br><span class=\"line\">\t\t\t&#123;error, MySQLRes&#125; -&gt;</span><br><span class=\"line\">\t\t\t    ?Log2(LogFun, error,</span><br><span class=\"line\">\t\t\t\t &quot;mysql_conn: Failed changing to database &quot;</span><br><span class=\"line\">\t\t\t\t &quot;~p : ~p&quot;,</span><br><span class=\"line\">\t\t\t\t [Database,</span><br><span class=\"line\">\t\t\t\t  mysql:get_result_reason(MySQLRes)]),</span><br><span class=\"line\">\t\t\t    Parent ! &#123;mysql_conn, self(),</span><br><span class=\"line\">\t\t\t\t      &#123;error, failed_changing_database&#125;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t%% ResultType: data | updated</span><br><span class=\"line\">\t\t\t&#123;_ResultType, _MySQLRes&#125; -&gt;</span><br><span class=\"line\">\t\t\t    Parent ! &#123;mysql_conn, self(), ok&#125;,</span><br><span class=\"line\">\t\t\t    case Encoding of</span><br><span class=\"line\">\t\t\t\tundefined -&gt; undefined;</span><br><span class=\"line\">\t\t\t\t_ -&gt;</span><br><span class=\"line\">\t\t\t\t    EncodingBinary = list_to_binary(atom_to_list(Encoding)),</span><br><span class=\"line\">\t\t\t\t    do_query(Sock, RecvPid, LogFun,</span><br><span class=\"line\">\t\t\t\t\t     &lt;&lt;&quot;set names &#x27;&quot;, EncodingBinary/binary, &quot;&#x27;&quot;&gt;&gt;,</span><br><span class=\"line\">\t\t\t\t\t     Version)</span><br><span class=\"line\">\t\t\t    end,</span><br><span class=\"line\">\t\t\t    State = #state&#123;mysql_version=Version,</span><br><span class=\"line\">\t\t\t\t\t   recv_pid = RecvPid,</span><br><span class=\"line\">\t\t\t\t\t   socket   = Sock,</span><br><span class=\"line\">\t\t\t\t\t   log_fun  = LogFun,</span><br><span class=\"line\">\t\t\t\t\t   pool_id  = PoolId,</span><br><span class=\"line\">\t\t\t\t\t   data     = &lt;&lt;&gt;&gt;</span><br><span class=\"line\">\t\t\t\t\t  &#125;,</span><br><span class=\"line\">\t\t\t    loop(State)</span><br><span class=\"line\">\t\t    end;</span><br><span class=\"line\">\t\t&#123;error, _Reason&#125; -&gt;</span><br><span class=\"line\">\t\t    Parent ! &#123;mysql_conn, self(), &#123;error, login_failed&#125;&#125;</span><br><span class=\"line\">\t    end;</span><br><span class=\"line\">\tE -&gt;</span><br><span class=\"line\">\t    ?Log2(LogFun, error,</span><br><span class=\"line\">\t\t &quot;failed connecting to ~p:~p : ~p&quot;,</span><br><span class=\"line\">\t\t [Host, Port, E]),</span><br><span class=\"line\">\t    Parent ! &#123;mysql_conn, self(), &#123;error, connect_failed&#125;&#125;</span><br><span class=\"line\">    end.</span><br></pre></td></tr></table></figure></p>\n<p>这个init比较长，而且里面又调了mysql_recv:start_link，之前之所以没有直接分析这里面也是这个原因，在start_link里面重复调用各个模块的start_link很容易绕进去。<br>同样，我们根据case语句，知道mysql_recv:start_link建了一个新的进程，并且返回RecvPid和一个Sock，可知创建进程的同时监听了某个端口。如果没有成功会返回{error， Reason}</p>\n<p>之后进入mysql_init函数。我们先不要进入mysql_init，这个函数完成了用户名和密码的认证，认证成功会返回{ok, Version}</p>\n<p>接下来要做的是<br><code>case do_query(Sock, RecvPid, LogFun,\n                  &lt;&lt;&quot;use &quot;, Db/binary&gt;&gt;,\n                  Version) of</code><br>通知端口我们要使用哪个数据库，打印出来是这段文字<br><code>fetch &lt;&lt;&quot;use aries_game&quot;&gt;&gt;</code><br>返回结果{error, MysqlRes}或者{ResultType, MysqlRes}.<br>MysqlRes是一个record</p>\n<blockquote>\n<p>-record(mysql_result,<br>    {fieldinfo=[],<br>     rows=[],<br>     affectedrows=0,<br>     error=&quot;&quot;}).</p>\n</blockquote>\n<p>在do_query的里面，将端口返回来的结果构造成#mysql_result的样子，他包含了需要的rows，或者操作所影响的affetedrows，fieldinfo以及如果出错的错误信息error.<br>如果返回{error, MysqlRes}, 我们调用接口mysql:get_result_reason(MysqlRes)获取错误原因。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">get_result_reason(#mysql_result&#123;error=Reason&#125;) -&gt;</span><br><span class=\"line\">    Reason.</span><br></pre></td></tr></table></figure></p>\n<p>并通知父进程出错了<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Parent ! &#123;mysql_conn, self(), &#123;error, failed_changing_database&#125;&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>相反<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;_ResultType, _MySQLRes&#125; -&gt;</span><br><span class=\"line\">\t\t\t    Parent ! &#123;mysql_conn, self(), ok&#125;,</span><br></pre></td></tr></table></figure></p>\n<p>如果没有出错，我们就告诉父进程ok。<br>还记得post_start里面的<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">post_start(Pid, LogFun) -&gt;</span><br><span class=\"line\">    receive</span><br><span class=\"line\">\t&#123;mysql_conn, Pid, ok&#125; -&gt;</span><br><span class=\"line\">\t    &#123;ok, Pid&#125;;</span><br><span class=\"line\">\t&#123;mysql_conn, Pid, &#123;error, Reason&#125;&#125; -&gt;</span><br><span class=\"line\">\t    &#123;error, Reason&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>这就是receive我们这些消息的地方。<br>后面的<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EncodingBinary = list_to_binary(atom_to_list(Encoding)),</span><br><span class=\"line\">\t\t    do_query(Sock, RecvPid, LogFun,</span><br><span class=\"line\">\t\t\t     &lt;&lt;&quot;set names &#x27;&quot;, EncodingBinary/binary, &quot;&#x27;&quot;&gt;&gt;,</span><br><span class=\"line\">\t\t\t     Version)</span><br></pre></td></tr></table></figure></p>\n<p>用来设定我们的编码方式，目前用的utf8.<br>下面了解下do_query的细节，因为之后我们要做的查询，插入等操作也经过它<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">do_query(Sock, RecvPid, LogFun, Query, Version) -&gt;</span><br><span class=\"line\">    Query1 = iolist_to_binary(Query),</span><br><span class=\"line\">    ?Log2(LogFun, debug, &quot;fetch ~p (id ~p)&quot;, [Query1,RecvPid]),</span><br><span class=\"line\">    Packet =  &lt;&lt;?MYSQL_QUERY_OP, Query1/binary&gt;&gt;,</span><br><span class=\"line\">    case do_send(Sock, Packet, 0, LogFun) of</span><br><span class=\"line\">\tok -&gt;</span><br><span class=\"line\">\t    get_query_response(LogFun,RecvPid,</span><br><span class=\"line\">\t\t\t\t    Version);</span><br><span class=\"line\">\t&#123;error, Reason&#125; -&gt;</span><br><span class=\"line\">\t    Msg = io_lib:format(&quot;Failed sending data &quot;</span><br><span class=\"line\">\t\t\t\t&quot;on socket : ~p&quot;,</span><br><span class=\"line\">\t\t\t\t[Reason]),</span><br><span class=\"line\">\t    &#123;error, Msg&#125;</span><br><span class=\"line\">    end.</span><br></pre></td></tr></table></figure></p>\n<p>Query是我们的sql语句，比如上面的&lt;&lt;&lt;&quot;use aries_game&quot;&gt;&gt;,<br>Query1使我们给Query加上一个字节的3(?MYSQL_QUERY_OP是3）.<br>do_send将packet打包并发送，头三个字节是packet大小，第4个字节是序列号，之后是packet内容，如下<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">do_send(Sock, Packet, SeqNum, _LogFun) when is_binary(Packet), is_integer(SeqNum) -&gt;</span><br><span class=\"line\">    Data = &lt;&lt;(size(Packet)):24/little, SeqNum:8, Packet/binary&gt;&gt;,</span><br><span class=\"line\">    gen_tcp:send(Sock, Data).</span><br></pre></td></tr></table></figure></p>\n<p>这时候向端口发送了请求,get_query_response等待回应。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">get_query_response(LogFun, RecvPid, Version) -&gt;</span><br><span class=\"line\">    case do_recv(LogFun, RecvPid, undefined) of</span><br><span class=\"line\">\t&#123;ok, &lt;&lt;Fieldcount:8, Rest/binary&gt;&gt;, _&#125; -&gt;</span><br><span class=\"line\">\t    case Fieldcount of</span><br><span class=\"line\">\t\t0 -&gt;</span><br><span class=\"line\">\t\t    %% No Tabular data</span><br><span class=\"line\">            &lt;&lt;AffectedRows:8, _Rest2/binary&gt;&gt; = Rest,</span><br><span class=\"line\">            ?Log2(LogFun, debug, &quot;updated ~p&quot;, [AffectedRows]),</span><br><span class=\"line\">\t\t    &#123;updated, #mysql_result&#123;affectedrows=AffectedRows&#125;&#125;;</span><br><span class=\"line\">\t\t255 -&gt;</span><br><span class=\"line\">\t\t    &lt;&lt;_Code:16/little, Message/binary&gt;&gt;  = Rest,</span><br><span class=\"line\">\t\t    &#123;error, #mysql_result&#123;error=Message&#125;&#125;;</span><br><span class=\"line\">\t\t_ -&gt;</span><br><span class=\"line\">\t\t    %% Tabular data received</span><br><span class=\"line\">\t\t    case get_fields(LogFun, RecvPid, [], Version) of</span><br><span class=\"line\">\t\t\t&#123;ok, Fields&#125; -&gt;</span><br><span class=\"line\">\t\t\t    case get_rows(Fields, LogFun, RecvPid, []) of</span><br><span class=\"line\">\t\t\t\t&#123;ok, Rows&#125; -&gt;</span><br><span class=\"line\">                    ?Log2(LogFun, debug, &quot;data: field:~p, rows:~p&quot;, [Fields, Rows]),</span><br><span class=\"line\">                    &#123;data, #mysql_result&#123;fieldinfo=Fields,</span><br><span class=\"line\">                            rows=Rows&#125;&#125;;</span><br><span class=\"line\">\t\t\t\t&#123;error, Reason&#125; -&gt;</span><br><span class=\"line\">\t\t\t\t    &#123;error, #mysql_result&#123;error=Reason&#125;&#125;</span><br><span class=\"line\">\t\t\t    end;</span><br><span class=\"line\">\t\t\t&#123;error, Reason&#125; -&gt;</span><br><span class=\"line\">\t\t\t    &#123;error, #mysql_result&#123;error=Reason&#125;&#125;</span><br><span class=\"line\">\t\t    end</span><br><span class=\"line\">\t    end;</span><br><span class=\"line\">\t&#123;error, Reason&#125; -&gt;</span><br><span class=\"line\">\t    &#123;error, #mysql_result&#123;error=Reason&#125;&#125;</span><br><span class=\"line\">    end.</span><br></pre></td></tr></table></figure></p>\n<p>第一句do_recv主要用来对第三个参数帧序列号的不同做匹配，这里是undefined，意在接受任何帧，如果指定一个帧号A，那么do_recv只接受A+1的消息。如下<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> do_recv(LogFun, RecvPid, SeqNum)  when is_function(LogFun);</span><br><span class=\"line\">\t\t\t\t       LogFun == undefined,</span><br><span class=\"line\">\t\t\t\t       SeqNum == undefined -&gt;</span><br><span class=\"line\">    receive</span><br><span class=\"line\">        &#123;mysql_recv, RecvPid, data, Packet, Num&#125; -&gt;</span><br><span class=\"line\">\t    &#123;ok, Packet, Num&#125;;</span><br><span class=\"line\">\t&#123;mysql_recv, RecvPid, closed, _E&#125; -&gt;</span><br><span class=\"line\">\t    &#123;error, &quot;mysql_recv: socket was closed&quot;&#125;</span><br><span class=\"line\">    end;</span><br><span class=\"line\">do_recv(LogFun, RecvPid, SeqNum) when is_function(LogFun);</span><br><span class=\"line\">\t\t\t\t      LogFun == undefined,</span><br><span class=\"line\">\t\t\t\t      is_integer(SeqNum) -&gt;</span><br><span class=\"line\">    ResponseNum = SeqNum + 1,</span><br><span class=\"line\">    receive</span><br><span class=\"line\">        &#123;mysql_recv, RecvPid, data, Packet, ResponseNum&#125; -&gt;</span><br><span class=\"line\">\t    &#123;ok, Packet, ResponseNum&#125;;</span><br><span class=\"line\">\t&#123;mysql_recv, RecvPid, closed, _E&#125; -&gt;</span><br><span class=\"line\">\t    &#123;error, &quot;mysql_recv: socket was closed&quot;&#125;</span><br><span class=\"line\">    end.</span><br></pre></td></tr></table></figure></p>\n<p>这个函数将端口返回的Packet和帧序号返回，或者帧序号+1返回。<br>回到<code>case do_recv(LogFun, RecvPid, undefined) of</code><br>接下来是对结果的匹配，Fieldcount为0表示执行的是update操作，而不是请求某些数据。如果为255则表示出错，返回{error, #mysql_result{error = Message}}.<br>其他数值时，会执行get_field().<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">%% Support for MySQL 4.1.x and 5.x:</span><br><span class=\"line\">get_fields(LogFun, RecvPid, Res, ?MYSQL_4_1) -&gt;</span><br><span class=\"line\">    case do_recv(LogFun, RecvPid, undefined) of</span><br><span class=\"line\">\t&#123;ok, Packet, _Num&#125; -&gt;</span><br><span class=\"line\">        ?Log2(LogFun, debug, &quot;get_field: packet ~p&quot;, [Packet]),</span><br><span class=\"line\">\t    case Packet of</span><br><span class=\"line\">\t\t&lt;&lt;254:8&gt;&gt; -&gt;</span><br><span class=\"line\">\t\t    &#123;ok, lists:reverse(Res)&#125;;</span><br><span class=\"line\">\t\t&lt;&lt;254:8, Rest/binary&gt;&gt; when size(Rest) &lt; 8 -&gt;</span><br><span class=\"line\">\t\t    &#123;ok, lists:reverse(Res)&#125;;</span><br><span class=\"line\">\t\t_ -&gt;</span><br><span class=\"line\">\t\t    &#123;_Catalog, Rest&#125; = get_with_length(Packet),</span><br><span class=\"line\">\t\t    &#123;_Database, Rest2&#125; = get_with_length(Rest),</span><br><span class=\"line\">\t\t    &#123;Table, Rest3&#125; = get_with_length(Rest2),</span><br><span class=\"line\">\t\t    %% OrgTable is the real table name if Table is an alias</span><br><span class=\"line\">\t\t    &#123;_OrgTable, Rest4&#125; = get_with_length(Rest3),</span><br><span class=\"line\">\t\t    &#123;Field, Rest5&#125; = get_with_length(Rest4),</span><br><span class=\"line\">\t\t    %% OrgField is the real field name if Field is an alias</span><br><span class=\"line\">\t\t    &#123;_OrgField, Rest6&#125; = get_with_length(Rest5),</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t    &lt;&lt;_Metadata:8/little, _Charset:16/little,</span><br><span class=\"line\">\t\t     Length:32/little, Type:8/little,</span><br><span class=\"line\">\t\t     _Flags:16/little, _Decimals:8/little,</span><br><span class=\"line\">\t\t     _Rest7/binary&gt;&gt; = Rest6,</span><br><span class=\"line\">\t\t    </span><br><span class=\"line\">\t\t    This = &#123;Table,</span><br><span class=\"line\">\t\t\t    Field,</span><br><span class=\"line\">\t\t\t    Length,</span><br><span class=\"line\">\t\t\t    get_field_datatype(Type)&#125;,</span><br><span class=\"line\">\t\t    get_fields(LogFun, RecvPid, [This | Res], ?MYSQL_4_1)</span><br><span class=\"line\">\t    end;</span><br><span class=\"line\">\t&#123;error, Reason&#125; -&gt;</span><br><span class=\"line\">\t    &#123;error, Reason&#125;</span><br><span class=\"line\">    end.</span><br></pre></td></tr></table></figure></p>\n<p>这里提供了两个版本的get_field,我的mysql是5.5所以会匹配到这个函数上。<br>get_field一开始仍然是do_recv，用来提取一个Packet。case Packet告诉我们这个包第一个字节是254的时候表示结果已经全部告诉我们了，这时候会将Res（result）翻转，返回。<br>get_with_length用来将Packet切割，用来得到Table， Field， Length等参数。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">get_with_length(&lt;&lt;251:8, Rest/binary&gt;&gt;) -&gt;</span><br><span class=\"line\">    &#123;null, Rest&#125;;</span><br><span class=\"line\">get_with_length(&lt;&lt;252:8, Length:16/little, Rest/binary&gt;&gt;) -&gt;</span><br><span class=\"line\">    split_binary(Rest, Length);</span><br><span class=\"line\">get_with_length(&lt;&lt;253:8, Length:24/little, Rest/binary&gt;&gt;) -&gt;</span><br><span class=\"line\">    split_binary(Rest, Length);</span><br><span class=\"line\">get_with_length(&lt;&lt;254:8, Length:64/little, Rest/binary&gt;&gt;) -&gt;</span><br><span class=\"line\">    split_binary(Rest, Length);</span><br><span class=\"line\">get_with_length(&lt;&lt;Length:8, Rest/binary&gt;&gt;) when Length &lt; 251 -&gt;</span><br><span class=\"line\">    split_binary(Rest, Length).</span><br></pre></td></tr></table></figure></p>\n<p>这个函数的意思大致可以看出来，如果第一个字节是251，就直接返回null和Rest，如果第一个字节小于251，那么第一个字节表示长度，将Rest分割成{Value， Rest2}，Value是我们需要的，对应长度的值，如果第一个字节大于251，分不同的情况，接下来的2个4个或者8个字节表示长度，将Rest分割。举个例子<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql:fetch(mysql_game_pool, &quot;select name from player where id = 301&quot;).</span><br><span class=\"line\"></span><br><span class=\"line\">=INFO REPORT==== 9-Jun-2015::16:43:29 ===</span><br><span class=\"line\">I(&lt;0.94.0&gt;:mysql_conn:426) : fetch &lt;&lt;&quot;select name from player where id = 301&quot;&gt;&gt; (id &lt;0.95.0&gt;)</span><br><span class=\"line\"></span><br><span class=\"line\">=INFO REPORT==== 9-Jun-2015::16:43:29 ===</span><br><span class=\"line\">I(&lt;0.94.0&gt;:mysql_conn:726) : get_field: packet &lt;&lt;3,100,101,102,10,97,114,105,</span><br><span class=\"line\">                                                 101,115,95,103,97,109,101,6,</span><br><span class=\"line\">                                                 112,108,97,121,101,114,6,112,</span><br><span class=\"line\">                                                 108,97,121,101,114,4,110,97,</span><br><span class=\"line\">                                                 109,101,4,110,97,109,101,12,</span><br><span class=\"line\">                                                 33,0,150,0,0,0,253,5,64,0,0,0&gt;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">=INFO REPORT==== 9-Jun-2015::16:43:29 ===</span><br><span class=\"line\">I(&lt;0.94.0&gt;:mysql_conn:726) : get_field: packet &lt;&lt;254,0,0,2,0&gt;&gt;</span><br><span class=\"line\">&#123;data,&#123;mysql_result,[&#123;&lt;&lt;&quot;player&quot;&gt;&gt;,&lt;&lt;&quot;name&quot;&gt;&gt;,150,</span><br><span class=\"line\">                      &#x27;VAR_STRING&#x27;&#125;],</span><br><span class=\"line\">                    [[&lt;&lt;&quot;aaaa&quot;&gt;&gt;]],</span><br><span class=\"line\">                    0,[]&#125;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">=INFO REPORT==== 9-Jun-2015::16:43:29 ===</span><br><span class=\"line\">I(&lt;0.94.0&gt;:mysql_conn:770) : get_rows: packet &lt;&lt;4,97,97,97,97&gt;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">=INFO REPORT==== 9-Jun-2015::16:43:29 ===</span><br><span class=\"line\">I(&lt;0.94.0&gt;:mysql_conn:770) : get_rows: packet &lt;&lt;254,0,0,2,0&gt;&gt;</span><br><span class=\"line\">(aries_game@192.168.1.85)2&gt; </span><br><span class=\"line\">=INFO REPORT==== 9-Jun-2015::16:43:29 ===</span><br><span class=\"line\">I(&lt;0.94.0&gt;:mysql_conn:667) : data: field:[&#123;&lt;&lt;&quot;player&quot;&gt;&gt;,&lt;&lt;&quot;name&quot;&gt;&gt;,150,</span><br><span class=\"line\">                                           &#x27;VAR_STRING&#x27;&#125;], rows:[[&lt;&lt;&quot;aaaa&quot;&gt;&gt;]]</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>我们执行了一个sql语句，从player表中选出id为301的玩家的名字。<br>端口回复给我们的是get_field后面打印的二进制串。</p>\n<ol>\n<li>第一个字节是3，不是254。走get_with_length拆分。</li>\n<li>将100,101,102提出，为CataLog,这个参数我们不需要。</li>\n<li>10表示接下来取10个字节，一直到109，101.位Database，我们也不需要</li>\n<li>接下来6，表示6个字节，&lt;&lt;112,108,97,121,101,114&gt;&gt;提取为Table，也就是我们的表名，我们在shell中打一下可以看到实际上就是&lt;&lt;&quot;player&quot;&gt;&gt;。表示我们是从player表取得。</li>\n<li>接下来6个字节和上面一下，我们不需要。</li>\n<li>下面4个字节&lt;&lt;110,97,109,101&gt;&gt;,就是&lt;&lt;&quot;name&quot;&gt;&gt;,表示字段名。</li>\n<li>后面4个字节以上面一下，不需要。</li>\n<li>从12开始一直到最后我们只需要&lt;&lt;150,0,0,0&gt;&gt;这四个表示长度,注意是小段存储，即长150，253，表示Type.</li>\n<li>紧着着第一个packet到达，由于是254，告诉我们这个语句结果已返回。<br>这个时候我们只知道是player表的name字段，接下来get_rows将得到具体结果。<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">get_rows(Fields, LogFun, RecvPid, Res) -&gt;</span><br><span class=\"line\">    case do_recv(LogFun, RecvPid, undefined) of</span><br><span class=\"line\">\t&#123;ok, Packet, _Num&#125; -&gt;</span><br><span class=\"line\">        ?Log2(LogFun, debug, &quot;get_rows: packet ~p&quot;, [Packet]),</span><br><span class=\"line\">\t    case Packet of</span><br><span class=\"line\">\t\t&lt;&lt;254:8, Rest/binary&gt;&gt; when size(Rest) &lt; 8 -&gt;</span><br><span class=\"line\">\t\t    &#123;ok, lists:reverse(Res)&#125;;</span><br><span class=\"line\">\t\t_ -&gt;</span><br><span class=\"line\">\t\t    &#123;ok, This&#125; = get_row(Fields, Packet, []),</span><br><span class=\"line\">\t\t    get_rows(Fields, LogFun, RecvPid, [This | Res])</span><br><span class=\"line\">\t    end;</span><br><span class=\"line\">\t&#123;error, Reason&#125; -&gt;</span><br><span class=\"line\">\t    &#123;error, Reason&#125;</span><br><span class=\"line\">    end.</span><br><span class=\"line\"></span><br><span class=\"line\">%% part of get_rows/4</span><br><span class=\"line\">get_row([], _Data, Res) -&gt;</span><br><span class=\"line\">    &#123;ok, lists:reverse(Res)&#125;;</span><br><span class=\"line\">get_row([Field | OtherFields], Data, Res) -&gt;</span><br><span class=\"line\">    &#123;Col, Rest&#125; = get_with_length(Data),</span><br><span class=\"line\">    This = case Col of</span><br><span class=\"line\">\t       null -&gt;</span><br><span class=\"line\">\t\t   undefined;</span><br><span class=\"line\">\t       _ -&gt;</span><br><span class=\"line\">\t\t   convert_type(Col, element(4, Field))</span><br><span class=\"line\">\t   end,</span><br><span class=\"line\">    get_row(OtherFields, Rest, [This | Res]).</span><br></pre></td></tr></table></figure>\n其中Field为[{&lt;&lt;&quot;player&quot;&gt;&gt;,&lt;&lt;&quot;name&quot;&gt;&gt;,150,&#39;VAR_STRING&#39;}],<br>与上面get_field大致相同，row的这个packet很简单，&lt;&lt;4,97,97,97,97&gt;&gt;，后面的4个字节就是我们要的结果就是&lt;&lt;&quot;aaaa&quot;&gt;&gt;.然后convert_type将结果转为对应的形式<br>convert_type不贴了，ｈｅｘｏ转码会有问题．<br>我们的类型是VAR_STRING，直接原样返回。<br>这样回到get_query_response，我们得到了需要的结果{data, #mysql_result{}}这种形式。<br>在往上回到init处，我们执行完&lt;&lt;&quot;use XXX(数据库名)&quot;&gt;&gt;, 返回成功后，执行&lt;&lt;&quot;set names utf8&quot;&gt;&gt;,<br>最后构造State<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">State = #state&#123;mysql_version=Version,</span><br><span class=\"line\">\t\t\t\t\t   recv_pid = RecvPid,</span><br><span class=\"line\">\t\t\t\t\t   socket   = Sock,</span><br><span class=\"line\">\t\t\t\t\t   log_fun  = LogFun,</span><br><span class=\"line\">\t\t\t\t\t   pool_id  = PoolId,</span><br><span class=\"line\">\t\t\t\t\t   data     = &lt;&lt;&gt;&gt;</span><br><span class=\"line\">\t\t\t\t\t  &#125;,</span><br><span class=\"line\">\t\t\t    loop(State)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>并开始loop。至此这个mysql_conn进程创建完毕。</p>\n","site":{"data":{}},"excerpt":"<p>#mysql_conn:start<br>回到mysql:start_link这个最开始这个地方</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LogFun1 = if LogFun == undefined -&gt; fun log/4; true -&gt; LogFun end,</span><br><span class=\"line\">   case mysql_conn:start(Host, Port, User, Password, Database, LogFun1,</span><br><span class=\"line\">\t\t  Encoding, PoolId) of</span><br><span class=\"line\">&#123;ok, ConnPid&#125; -&gt;</span><br></pre></td></tr></table></figure>","more":"<p>起初为了不断开gen_server的创建，我们没有进入mysql_conn里面。现在可以进去一窥究竟啦。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start(Host, Port, User, Password, Database, LogFun, Encoding, PoolId) -&gt;</span><br><span class=\"line\">    ConnPid = self(),</span><br><span class=\"line\">    Pid = spawn(fun () -&gt;</span><br><span class=\"line\">\t\t\tinit(Host, Port, User, Password, Database,</span><br><span class=\"line\">\t\t\t     LogFun, Encoding, PoolId, ConnPid)</span><br><span class=\"line\">\t\tend),</span><br><span class=\"line\">    post_start(Pid, LogFun).</span><br><span class=\"line\">    --------------------</span><br><span class=\"line\">post_start(Pid, LogFun) -&gt;</span><br><span class=\"line\">    receive</span><br><span class=\"line\">\t&#123;mysql_conn, Pid, ok&#125; -&gt;</span><br><span class=\"line\">\t    &#123;ok, Pid&#125;;</span><br><span class=\"line\">\t&#123;mysql_conn, Pid, &#123;error, Reason&#125;&#125; -&gt;</span><br><span class=\"line\">\t    &#123;error, Reason&#125;;</span><br><span class=\"line\">\tUnknown -&gt;</span><br><span class=\"line\">\t    ?Log2(LogFun, error,</span><br><span class=\"line\">\t\t &quot;received unknown signal, exiting: ~p&quot;, [Unknown]),</span><br><span class=\"line\">\t    &#123;error, &quot;unknown signal received&quot;&#125;</span><br><span class=\"line\">    after 5000 -&gt;</span><br><span class=\"line\">\t    &#123;error, &quot;timed out&quot;&#125;</span><br><span class=\"line\">    end.</span><br></pre></td></tr></table></figure></p>\n<p>这里作者将post_start抽出来了，因为与start类似还有个start_link也需要这块代码，但是值得注意的是<br>post_start里面的receive仍然是由mysql:start_link生成的my_sql_game这个gen_server 在调用，而且<code>ConnPid = self()</code>这句代码很有歧义，因为这个ConnPid与mysql中的<code>&#123;ok, ConnPid&#125;</code>明显不是同一个意思。这里的ConnPid实际就是gen_server的Pid，用来传给init作为父进程参数，在子进程可以给父进程发消息,我觉得把这段post_start放到mysql中更容易理解一点。<br>这里我们可以看出来，start函数spawn一个mysql_conn:init这个进程，然后等待消息，如果成功的话，会返回{ok, Pid}，这个Pid是真正意义的ConnPid，用来生成#conn加入my_sql_game的#state里面的。其他情况会返回{error, Reason}.<br>然后看一下init<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">init(Host, Port, User, Password, Database, LogFun, Encoding, PoolId, Parent) -&gt;</span><br><span class=\"line\">    case mysql_recv:start_link(Host, Port, LogFun, self()) of</span><br><span class=\"line\">\t&#123;ok, RecvPid, Sock&#125; -&gt;</span><br><span class=\"line\">\t    case mysql_init(Sock, RecvPid, User, Password, LogFun) of</span><br><span class=\"line\">\t\t&#123;ok, Version&#125; -&gt;</span><br><span class=\"line\">\t\t    Db = iolist_to_binary(Database),</span><br><span class=\"line\">\t\t    case do_query(Sock, RecvPid, LogFun,</span><br><span class=\"line\">\t\t\t\t  &lt;&lt;&quot;use &quot;, Db/binary&gt;&gt;,</span><br><span class=\"line\">\t\t\t\t  Version) of</span><br><span class=\"line\">\t\t\t&#123;error, MySQLRes&#125; -&gt;</span><br><span class=\"line\">\t\t\t    ?Log2(LogFun, error,</span><br><span class=\"line\">\t\t\t\t &quot;mysql_conn: Failed changing to database &quot;</span><br><span class=\"line\">\t\t\t\t &quot;~p : ~p&quot;,</span><br><span class=\"line\">\t\t\t\t [Database,</span><br><span class=\"line\">\t\t\t\t  mysql:get_result_reason(MySQLRes)]),</span><br><span class=\"line\">\t\t\t    Parent ! &#123;mysql_conn, self(),</span><br><span class=\"line\">\t\t\t\t      &#123;error, failed_changing_database&#125;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t%% ResultType: data | updated</span><br><span class=\"line\">\t\t\t&#123;_ResultType, _MySQLRes&#125; -&gt;</span><br><span class=\"line\">\t\t\t    Parent ! &#123;mysql_conn, self(), ok&#125;,</span><br><span class=\"line\">\t\t\t    case Encoding of</span><br><span class=\"line\">\t\t\t\tundefined -&gt; undefined;</span><br><span class=\"line\">\t\t\t\t_ -&gt;</span><br><span class=\"line\">\t\t\t\t    EncodingBinary = list_to_binary(atom_to_list(Encoding)),</span><br><span class=\"line\">\t\t\t\t    do_query(Sock, RecvPid, LogFun,</span><br><span class=\"line\">\t\t\t\t\t     &lt;&lt;&quot;set names &#x27;&quot;, EncodingBinary/binary, &quot;&#x27;&quot;&gt;&gt;,</span><br><span class=\"line\">\t\t\t\t\t     Version)</span><br><span class=\"line\">\t\t\t    end,</span><br><span class=\"line\">\t\t\t    State = #state&#123;mysql_version=Version,</span><br><span class=\"line\">\t\t\t\t\t   recv_pid = RecvPid,</span><br><span class=\"line\">\t\t\t\t\t   socket   = Sock,</span><br><span class=\"line\">\t\t\t\t\t   log_fun  = LogFun,</span><br><span class=\"line\">\t\t\t\t\t   pool_id  = PoolId,</span><br><span class=\"line\">\t\t\t\t\t   data     = &lt;&lt;&gt;&gt;</span><br><span class=\"line\">\t\t\t\t\t  &#125;,</span><br><span class=\"line\">\t\t\t    loop(State)</span><br><span class=\"line\">\t\t    end;</span><br><span class=\"line\">\t\t&#123;error, _Reason&#125; -&gt;</span><br><span class=\"line\">\t\t    Parent ! &#123;mysql_conn, self(), &#123;error, login_failed&#125;&#125;</span><br><span class=\"line\">\t    end;</span><br><span class=\"line\">\tE -&gt;</span><br><span class=\"line\">\t    ?Log2(LogFun, error,</span><br><span class=\"line\">\t\t &quot;failed connecting to ~p:~p : ~p&quot;,</span><br><span class=\"line\">\t\t [Host, Port, E]),</span><br><span class=\"line\">\t    Parent ! &#123;mysql_conn, self(), &#123;error, connect_failed&#125;&#125;</span><br><span class=\"line\">    end.</span><br></pre></td></tr></table></figure></p>\n<p>这个init比较长，而且里面又调了mysql_recv:start_link，之前之所以没有直接分析这里面也是这个原因，在start_link里面重复调用各个模块的start_link很容易绕进去。<br>同样，我们根据case语句，知道mysql_recv:start_link建了一个新的进程，并且返回RecvPid和一个Sock，可知创建进程的同时监听了某个端口。如果没有成功会返回{error， Reason}</p>\n<p>之后进入mysql_init函数。我们先不要进入mysql_init，这个函数完成了用户名和密码的认证，认证成功会返回{ok, Version}</p>\n<p>接下来要做的是<br><code>case do_query(Sock, RecvPid, LogFun,\n                  &lt;&lt;&quot;use &quot;, Db/binary&gt;&gt;,\n                  Version) of</code><br>通知端口我们要使用哪个数据库，打印出来是这段文字<br><code>fetch &lt;&lt;&quot;use aries_game&quot;&gt;&gt;</code><br>返回结果{error, MysqlRes}或者{ResultType, MysqlRes}.<br>MysqlRes是一个record</p>\n<blockquote>\n<p>-record(mysql_result,<br>    {fieldinfo=[],<br>     rows=[],<br>     affectedrows=0,<br>     error=&quot;&quot;}).</p>\n</blockquote>\n<p>在do_query的里面，将端口返回来的结果构造成#mysql_result的样子，他包含了需要的rows，或者操作所影响的affetedrows，fieldinfo以及如果出错的错误信息error.<br>如果返回{error, MysqlRes}, 我们调用接口mysql:get_result_reason(MysqlRes)获取错误原因。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">get_result_reason(#mysql_result&#123;error=Reason&#125;) -&gt;</span><br><span class=\"line\">    Reason.</span><br></pre></td></tr></table></figure></p>\n<p>并通知父进程出错了<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Parent ! &#123;mysql_conn, self(), &#123;error, failed_changing_database&#125;&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>相反<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;_ResultType, _MySQLRes&#125; -&gt;</span><br><span class=\"line\">\t\t\t    Parent ! &#123;mysql_conn, self(), ok&#125;,</span><br></pre></td></tr></table></figure></p>\n<p>如果没有出错，我们就告诉父进程ok。<br>还记得post_start里面的<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">post_start(Pid, LogFun) -&gt;</span><br><span class=\"line\">    receive</span><br><span class=\"line\">\t&#123;mysql_conn, Pid, ok&#125; -&gt;</span><br><span class=\"line\">\t    &#123;ok, Pid&#125;;</span><br><span class=\"line\">\t&#123;mysql_conn, Pid, &#123;error, Reason&#125;&#125; -&gt;</span><br><span class=\"line\">\t    &#123;error, Reason&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>这就是receive我们这些消息的地方。<br>后面的<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EncodingBinary = list_to_binary(atom_to_list(Encoding)),</span><br><span class=\"line\">\t\t    do_query(Sock, RecvPid, LogFun,</span><br><span class=\"line\">\t\t\t     &lt;&lt;&quot;set names &#x27;&quot;, EncodingBinary/binary, &quot;&#x27;&quot;&gt;&gt;,</span><br><span class=\"line\">\t\t\t     Version)</span><br></pre></td></tr></table></figure></p>\n<p>用来设定我们的编码方式，目前用的utf8.<br>下面了解下do_query的细节，因为之后我们要做的查询，插入等操作也经过它<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">do_query(Sock, RecvPid, LogFun, Query, Version) -&gt;</span><br><span class=\"line\">    Query1 = iolist_to_binary(Query),</span><br><span class=\"line\">    ?Log2(LogFun, debug, &quot;fetch ~p (id ~p)&quot;, [Query1,RecvPid]),</span><br><span class=\"line\">    Packet =  &lt;&lt;?MYSQL_QUERY_OP, Query1/binary&gt;&gt;,</span><br><span class=\"line\">    case do_send(Sock, Packet, 0, LogFun) of</span><br><span class=\"line\">\tok -&gt;</span><br><span class=\"line\">\t    get_query_response(LogFun,RecvPid,</span><br><span class=\"line\">\t\t\t\t    Version);</span><br><span class=\"line\">\t&#123;error, Reason&#125; -&gt;</span><br><span class=\"line\">\t    Msg = io_lib:format(&quot;Failed sending data &quot;</span><br><span class=\"line\">\t\t\t\t&quot;on socket : ~p&quot;,</span><br><span class=\"line\">\t\t\t\t[Reason]),</span><br><span class=\"line\">\t    &#123;error, Msg&#125;</span><br><span class=\"line\">    end.</span><br></pre></td></tr></table></figure></p>\n<p>Query是我们的sql语句，比如上面的&lt;&lt;&lt;&quot;use aries_game&quot;&gt;&gt;,<br>Query1使我们给Query加上一个字节的3(?MYSQL_QUERY_OP是3）.<br>do_send将packet打包并发送，头三个字节是packet大小，第4个字节是序列号，之后是packet内容，如下<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">do_send(Sock, Packet, SeqNum, _LogFun) when is_binary(Packet), is_integer(SeqNum) -&gt;</span><br><span class=\"line\">    Data = &lt;&lt;(size(Packet)):24/little, SeqNum:8, Packet/binary&gt;&gt;,</span><br><span class=\"line\">    gen_tcp:send(Sock, Data).</span><br></pre></td></tr></table></figure></p>\n<p>这时候向端口发送了请求,get_query_response等待回应。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">get_query_response(LogFun, RecvPid, Version) -&gt;</span><br><span class=\"line\">    case do_recv(LogFun, RecvPid, undefined) of</span><br><span class=\"line\">\t&#123;ok, &lt;&lt;Fieldcount:8, Rest/binary&gt;&gt;, _&#125; -&gt;</span><br><span class=\"line\">\t    case Fieldcount of</span><br><span class=\"line\">\t\t0 -&gt;</span><br><span class=\"line\">\t\t    %% No Tabular data</span><br><span class=\"line\">            &lt;&lt;AffectedRows:8, _Rest2/binary&gt;&gt; = Rest,</span><br><span class=\"line\">            ?Log2(LogFun, debug, &quot;updated ~p&quot;, [AffectedRows]),</span><br><span class=\"line\">\t\t    &#123;updated, #mysql_result&#123;affectedrows=AffectedRows&#125;&#125;;</span><br><span class=\"line\">\t\t255 -&gt;</span><br><span class=\"line\">\t\t    &lt;&lt;_Code:16/little, Message/binary&gt;&gt;  = Rest,</span><br><span class=\"line\">\t\t    &#123;error, #mysql_result&#123;error=Message&#125;&#125;;</span><br><span class=\"line\">\t\t_ -&gt;</span><br><span class=\"line\">\t\t    %% Tabular data received</span><br><span class=\"line\">\t\t    case get_fields(LogFun, RecvPid, [], Version) of</span><br><span class=\"line\">\t\t\t&#123;ok, Fields&#125; -&gt;</span><br><span class=\"line\">\t\t\t    case get_rows(Fields, LogFun, RecvPid, []) of</span><br><span class=\"line\">\t\t\t\t&#123;ok, Rows&#125; -&gt;</span><br><span class=\"line\">                    ?Log2(LogFun, debug, &quot;data: field:~p, rows:~p&quot;, [Fields, Rows]),</span><br><span class=\"line\">                    &#123;data, #mysql_result&#123;fieldinfo=Fields,</span><br><span class=\"line\">                            rows=Rows&#125;&#125;;</span><br><span class=\"line\">\t\t\t\t&#123;error, Reason&#125; -&gt;</span><br><span class=\"line\">\t\t\t\t    &#123;error, #mysql_result&#123;error=Reason&#125;&#125;</span><br><span class=\"line\">\t\t\t    end;</span><br><span class=\"line\">\t\t\t&#123;error, Reason&#125; -&gt;</span><br><span class=\"line\">\t\t\t    &#123;error, #mysql_result&#123;error=Reason&#125;&#125;</span><br><span class=\"line\">\t\t    end</span><br><span class=\"line\">\t    end;</span><br><span class=\"line\">\t&#123;error, Reason&#125; -&gt;</span><br><span class=\"line\">\t    &#123;error, #mysql_result&#123;error=Reason&#125;&#125;</span><br><span class=\"line\">    end.</span><br></pre></td></tr></table></figure></p>\n<p>第一句do_recv主要用来对第三个参数帧序列号的不同做匹配，这里是undefined，意在接受任何帧，如果指定一个帧号A，那么do_recv只接受A+1的消息。如下<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> do_recv(LogFun, RecvPid, SeqNum)  when is_function(LogFun);</span><br><span class=\"line\">\t\t\t\t       LogFun == undefined,</span><br><span class=\"line\">\t\t\t\t       SeqNum == undefined -&gt;</span><br><span class=\"line\">    receive</span><br><span class=\"line\">        &#123;mysql_recv, RecvPid, data, Packet, Num&#125; -&gt;</span><br><span class=\"line\">\t    &#123;ok, Packet, Num&#125;;</span><br><span class=\"line\">\t&#123;mysql_recv, RecvPid, closed, _E&#125; -&gt;</span><br><span class=\"line\">\t    &#123;error, &quot;mysql_recv: socket was closed&quot;&#125;</span><br><span class=\"line\">    end;</span><br><span class=\"line\">do_recv(LogFun, RecvPid, SeqNum) when is_function(LogFun);</span><br><span class=\"line\">\t\t\t\t      LogFun == undefined,</span><br><span class=\"line\">\t\t\t\t      is_integer(SeqNum) -&gt;</span><br><span class=\"line\">    ResponseNum = SeqNum + 1,</span><br><span class=\"line\">    receive</span><br><span class=\"line\">        &#123;mysql_recv, RecvPid, data, Packet, ResponseNum&#125; -&gt;</span><br><span class=\"line\">\t    &#123;ok, Packet, ResponseNum&#125;;</span><br><span class=\"line\">\t&#123;mysql_recv, RecvPid, closed, _E&#125; -&gt;</span><br><span class=\"line\">\t    &#123;error, &quot;mysql_recv: socket was closed&quot;&#125;</span><br><span class=\"line\">    end.</span><br></pre></td></tr></table></figure></p>\n<p>这个函数将端口返回的Packet和帧序号返回，或者帧序号+1返回。<br>回到<code>case do_recv(LogFun, RecvPid, undefined) of</code><br>接下来是对结果的匹配，Fieldcount为0表示执行的是update操作，而不是请求某些数据。如果为255则表示出错，返回{error, #mysql_result{error = Message}}.<br>其他数值时，会执行get_field().<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">%% Support for MySQL 4.1.x and 5.x:</span><br><span class=\"line\">get_fields(LogFun, RecvPid, Res, ?MYSQL_4_1) -&gt;</span><br><span class=\"line\">    case do_recv(LogFun, RecvPid, undefined) of</span><br><span class=\"line\">\t&#123;ok, Packet, _Num&#125; -&gt;</span><br><span class=\"line\">        ?Log2(LogFun, debug, &quot;get_field: packet ~p&quot;, [Packet]),</span><br><span class=\"line\">\t    case Packet of</span><br><span class=\"line\">\t\t&lt;&lt;254:8&gt;&gt; -&gt;</span><br><span class=\"line\">\t\t    &#123;ok, lists:reverse(Res)&#125;;</span><br><span class=\"line\">\t\t&lt;&lt;254:8, Rest/binary&gt;&gt; when size(Rest) &lt; 8 -&gt;</span><br><span class=\"line\">\t\t    &#123;ok, lists:reverse(Res)&#125;;</span><br><span class=\"line\">\t\t_ -&gt;</span><br><span class=\"line\">\t\t    &#123;_Catalog, Rest&#125; = get_with_length(Packet),</span><br><span class=\"line\">\t\t    &#123;_Database, Rest2&#125; = get_with_length(Rest),</span><br><span class=\"line\">\t\t    &#123;Table, Rest3&#125; = get_with_length(Rest2),</span><br><span class=\"line\">\t\t    %% OrgTable is the real table name if Table is an alias</span><br><span class=\"line\">\t\t    &#123;_OrgTable, Rest4&#125; = get_with_length(Rest3),</span><br><span class=\"line\">\t\t    &#123;Field, Rest5&#125; = get_with_length(Rest4),</span><br><span class=\"line\">\t\t    %% OrgField is the real field name if Field is an alias</span><br><span class=\"line\">\t\t    &#123;_OrgField, Rest6&#125; = get_with_length(Rest5),</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t    &lt;&lt;_Metadata:8/little, _Charset:16/little,</span><br><span class=\"line\">\t\t     Length:32/little, Type:8/little,</span><br><span class=\"line\">\t\t     _Flags:16/little, _Decimals:8/little,</span><br><span class=\"line\">\t\t     _Rest7/binary&gt;&gt; = Rest6,</span><br><span class=\"line\">\t\t    </span><br><span class=\"line\">\t\t    This = &#123;Table,</span><br><span class=\"line\">\t\t\t    Field,</span><br><span class=\"line\">\t\t\t    Length,</span><br><span class=\"line\">\t\t\t    get_field_datatype(Type)&#125;,</span><br><span class=\"line\">\t\t    get_fields(LogFun, RecvPid, [This | Res], ?MYSQL_4_1)</span><br><span class=\"line\">\t    end;</span><br><span class=\"line\">\t&#123;error, Reason&#125; -&gt;</span><br><span class=\"line\">\t    &#123;error, Reason&#125;</span><br><span class=\"line\">    end.</span><br></pre></td></tr></table></figure></p>\n<p>这里提供了两个版本的get_field,我的mysql是5.5所以会匹配到这个函数上。<br>get_field一开始仍然是do_recv，用来提取一个Packet。case Packet告诉我们这个包第一个字节是254的时候表示结果已经全部告诉我们了，这时候会将Res（result）翻转，返回。<br>get_with_length用来将Packet切割，用来得到Table， Field， Length等参数。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">get_with_length(&lt;&lt;251:8, Rest/binary&gt;&gt;) -&gt;</span><br><span class=\"line\">    &#123;null, Rest&#125;;</span><br><span class=\"line\">get_with_length(&lt;&lt;252:8, Length:16/little, Rest/binary&gt;&gt;) -&gt;</span><br><span class=\"line\">    split_binary(Rest, Length);</span><br><span class=\"line\">get_with_length(&lt;&lt;253:8, Length:24/little, Rest/binary&gt;&gt;) -&gt;</span><br><span class=\"line\">    split_binary(Rest, Length);</span><br><span class=\"line\">get_with_length(&lt;&lt;254:8, Length:64/little, Rest/binary&gt;&gt;) -&gt;</span><br><span class=\"line\">    split_binary(Rest, Length);</span><br><span class=\"line\">get_with_length(&lt;&lt;Length:8, Rest/binary&gt;&gt;) when Length &lt; 251 -&gt;</span><br><span class=\"line\">    split_binary(Rest, Length).</span><br></pre></td></tr></table></figure></p>\n<p>这个函数的意思大致可以看出来，如果第一个字节是251，就直接返回null和Rest，如果第一个字节小于251，那么第一个字节表示长度，将Rest分割成{Value， Rest2}，Value是我们需要的，对应长度的值，如果第一个字节大于251，分不同的情况，接下来的2个4个或者8个字节表示长度，将Rest分割。举个例子<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql:fetch(mysql_game_pool, &quot;select name from player where id = 301&quot;).</span><br><span class=\"line\"></span><br><span class=\"line\">=INFO REPORT==== 9-Jun-2015::16:43:29 ===</span><br><span class=\"line\">I(&lt;0.94.0&gt;:mysql_conn:426) : fetch &lt;&lt;&quot;select name from player where id = 301&quot;&gt;&gt; (id &lt;0.95.0&gt;)</span><br><span class=\"line\"></span><br><span class=\"line\">=INFO REPORT==== 9-Jun-2015::16:43:29 ===</span><br><span class=\"line\">I(&lt;0.94.0&gt;:mysql_conn:726) : get_field: packet &lt;&lt;3,100,101,102,10,97,114,105,</span><br><span class=\"line\">                                                 101,115,95,103,97,109,101,6,</span><br><span class=\"line\">                                                 112,108,97,121,101,114,6,112,</span><br><span class=\"line\">                                                 108,97,121,101,114,4,110,97,</span><br><span class=\"line\">                                                 109,101,4,110,97,109,101,12,</span><br><span class=\"line\">                                                 33,0,150,0,0,0,253,5,64,0,0,0&gt;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">=INFO REPORT==== 9-Jun-2015::16:43:29 ===</span><br><span class=\"line\">I(&lt;0.94.0&gt;:mysql_conn:726) : get_field: packet &lt;&lt;254,0,0,2,0&gt;&gt;</span><br><span class=\"line\">&#123;data,&#123;mysql_result,[&#123;&lt;&lt;&quot;player&quot;&gt;&gt;,&lt;&lt;&quot;name&quot;&gt;&gt;,150,</span><br><span class=\"line\">                      &#x27;VAR_STRING&#x27;&#125;],</span><br><span class=\"line\">                    [[&lt;&lt;&quot;aaaa&quot;&gt;&gt;]],</span><br><span class=\"line\">                    0,[]&#125;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">=INFO REPORT==== 9-Jun-2015::16:43:29 ===</span><br><span class=\"line\">I(&lt;0.94.0&gt;:mysql_conn:770) : get_rows: packet &lt;&lt;4,97,97,97,97&gt;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">=INFO REPORT==== 9-Jun-2015::16:43:29 ===</span><br><span class=\"line\">I(&lt;0.94.0&gt;:mysql_conn:770) : get_rows: packet &lt;&lt;254,0,0,2,0&gt;&gt;</span><br><span class=\"line\">(aries_game@192.168.1.85)2&gt; </span><br><span class=\"line\">=INFO REPORT==== 9-Jun-2015::16:43:29 ===</span><br><span class=\"line\">I(&lt;0.94.0&gt;:mysql_conn:667) : data: field:[&#123;&lt;&lt;&quot;player&quot;&gt;&gt;,&lt;&lt;&quot;name&quot;&gt;&gt;,150,</span><br><span class=\"line\">                                           &#x27;VAR_STRING&#x27;&#125;], rows:[[&lt;&lt;&quot;aaaa&quot;&gt;&gt;]]</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>我们执行了一个sql语句，从player表中选出id为301的玩家的名字。<br>端口回复给我们的是get_field后面打印的二进制串。</p>\n<ol>\n<li>第一个字节是3，不是254。走get_with_length拆分。</li>\n<li>将100,101,102提出，为CataLog,这个参数我们不需要。</li>\n<li>10表示接下来取10个字节，一直到109，101.位Database，我们也不需要</li>\n<li>接下来6，表示6个字节，&lt;&lt;112,108,97,121,101,114&gt;&gt;提取为Table，也就是我们的表名，我们在shell中打一下可以看到实际上就是&lt;&lt;&quot;player&quot;&gt;&gt;。表示我们是从player表取得。</li>\n<li>接下来6个字节和上面一下，我们不需要。</li>\n<li>下面4个字节&lt;&lt;110,97,109,101&gt;&gt;,就是&lt;&lt;&quot;name&quot;&gt;&gt;,表示字段名。</li>\n<li>后面4个字节以上面一下，不需要。</li>\n<li>从12开始一直到最后我们只需要&lt;&lt;150,0,0,0&gt;&gt;这四个表示长度,注意是小段存储，即长150，253，表示Type.</li>\n<li>紧着着第一个packet到达，由于是254，告诉我们这个语句结果已返回。<br>这个时候我们只知道是player表的name字段，接下来get_rows将得到具体结果。<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">get_rows(Fields, LogFun, RecvPid, Res) -&gt;</span><br><span class=\"line\">    case do_recv(LogFun, RecvPid, undefined) of</span><br><span class=\"line\">\t&#123;ok, Packet, _Num&#125; -&gt;</span><br><span class=\"line\">        ?Log2(LogFun, debug, &quot;get_rows: packet ~p&quot;, [Packet]),</span><br><span class=\"line\">\t    case Packet of</span><br><span class=\"line\">\t\t&lt;&lt;254:8, Rest/binary&gt;&gt; when size(Rest) &lt; 8 -&gt;</span><br><span class=\"line\">\t\t    &#123;ok, lists:reverse(Res)&#125;;</span><br><span class=\"line\">\t\t_ -&gt;</span><br><span class=\"line\">\t\t    &#123;ok, This&#125; = get_row(Fields, Packet, []),</span><br><span class=\"line\">\t\t    get_rows(Fields, LogFun, RecvPid, [This | Res])</span><br><span class=\"line\">\t    end;</span><br><span class=\"line\">\t&#123;error, Reason&#125; -&gt;</span><br><span class=\"line\">\t    &#123;error, Reason&#125;</span><br><span class=\"line\">    end.</span><br><span class=\"line\"></span><br><span class=\"line\">%% part of get_rows/4</span><br><span class=\"line\">get_row([], _Data, Res) -&gt;</span><br><span class=\"line\">    &#123;ok, lists:reverse(Res)&#125;;</span><br><span class=\"line\">get_row([Field | OtherFields], Data, Res) -&gt;</span><br><span class=\"line\">    &#123;Col, Rest&#125; = get_with_length(Data),</span><br><span class=\"line\">    This = case Col of</span><br><span class=\"line\">\t       null -&gt;</span><br><span class=\"line\">\t\t   undefined;</span><br><span class=\"line\">\t       _ -&gt;</span><br><span class=\"line\">\t\t   convert_type(Col, element(4, Field))</span><br><span class=\"line\">\t   end,</span><br><span class=\"line\">    get_row(OtherFields, Rest, [This | Res]).</span><br></pre></td></tr></table></figure>\n其中Field为[{&lt;&lt;&quot;player&quot;&gt;&gt;,&lt;&lt;&quot;name&quot;&gt;&gt;,150,&#39;VAR_STRING&#39;}],<br>与上面get_field大致相同，row的这个packet很简单，&lt;&lt;4,97,97,97,97&gt;&gt;，后面的4个字节就是我们要的结果就是&lt;&lt;&quot;aaaa&quot;&gt;&gt;.然后convert_type将结果转为对应的形式<br>convert_type不贴了，ｈｅｘｏ转码会有问题．<br>我们的类型是VAR_STRING，直接原样返回。<br>这样回到get_query_response，我们得到了需要的结果{data, #mysql_result{}}这种形式。<br>在往上回到init处，我们执行完&lt;&lt;&quot;use XXX(数据库名)&quot;&gt;&gt;, 返回成功后，执行&lt;&lt;&quot;set names utf8&quot;&gt;&gt;,<br>最后构造State<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">State = #state&#123;mysql_version=Version,</span><br><span class=\"line\">\t\t\t\t\t   recv_pid = RecvPid,</span><br><span class=\"line\">\t\t\t\t\t   socket   = Sock,</span><br><span class=\"line\">\t\t\t\t\t   log_fun  = LogFun,</span><br><span class=\"line\">\t\t\t\t\t   pool_id  = PoolId,</span><br><span class=\"line\">\t\t\t\t\t   data     = &lt;&lt;&gt;&gt;</span><br><span class=\"line\">\t\t\t\t\t  &#125;,</span><br><span class=\"line\">\t\t\t    loop(State)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>并开始loop。至此这个mysql_conn进程创建完毕。</p>"},{"title":"Erlang实现多人聊天室模型","date":"2014-06-26T10:31:04.000Z","_content":"##Erlang程序设计课后习题,模拟聊天室代码.\n\n> useage:用终端打开多个节点其中一个用于启动聊天服务器,在erl环境中调用``chat_room:start()``启动,之后其他节点运行``telnet localhost 8000``登录聊天室服务器,在其中一个节点发送消息,其他节点能收到.\n\n<!--more-->\n\n```Erlang\n-module(chat_room).\n-behaviour(gen_server).\n-export([start/0, stop/0, lists/0]).\n\n%gen_server handle export function declaration\n-export([init/1, handle_call/3, handle_cast/2, handle_info/2, \n        terminate/2, code_change/3]).\n%start the gen_server for saving the Socketlist\nstart() ->\n    gen_server:start_link({local, ?MODULE}, ?MODULE, [], []).\n    \nstop() ->\n    gen_server:cast(?MODULE, stop).\n\n%add the new Socket to Socket_list\nadd(Socket) -> \n    gen_server:cast(?MODULE, {add, Socket}).\n\n%delete Socket in Socketlist\ndelete_port(Socket) -> \n    gen_server:cast(?MODULE, {delete, Socket}).\n\n%get Socketlist\nlists() -> gen_server:call(?MODULE, list).\n\n%%----------------------------------------------------\n%% handle functions\n%%----------------------------------------------------\n\ninit([]) ->\n    Listen = gen_listensocket(),\n    io:format(\"beginning listen ~p~n\", [Listen]),\n    {ok, {Listen, []}}.\n\nhandle_cast({delete, Socket}, {Listen, Socket_list}) ->\n    Socket_list1=lists:delete(Socket, Socket_list),\n    {noreply, {Listen, Socket_list1}};\nhandle_cast({add, Socket}, {Listen,Socket_list}) ->\n    Socket_list1 = [Socket | Socket_list],\n    {noreply, {Listen, Socket_list1}};\nhandle_cast(stop, State) ->\n    {stop, normal, State}.\n\nhandle_call(list, _From, State) ->\n    {_, Reply} = State,\n    {reply, Reply, State}.\n\nhandle_info(_Info, State) ->\n    {noreply, State}.\n\nterminate(_Reason, {Listen, Sockets}) ->\n    io:format(\"listen~p~n\" ,[Listen]),\n    gen_tcp:close(Listen),\n    [gen_tcp:close(S) || S <- Sockets],\n    ok.\n\ncode_change(_OldVsn, State, _Extra) ->\n    {ok, State}.\n\n%%----------------------------------------------------\n%%  internal functions \n%%----------------------------------------------------\n\n%get the listen socket,new a thread to wait clients to connect.\ngen_listensocket() ->\n    {ok, Listen} = gen_tcp:listen(8000, [binary, {active, false}, {reuseaddr, true}]),\n    spawn(fun() -> gen_socket(Listen) end),\n    Listen.\n\n%do loop() to Socket and new a thread to wait clients to connect\ngen_socket(Listen) ->\n    case gen_tcp:accept(Listen) of\n        {ok, Socket} -> \n            add(Socket),\n            spawn(fun() -> gen_socket(Listen) end),\n            loop(Socket);\n        {error, closed} -> exit\n    end.\n\n%send information from Socket to other Socket in Socketlist\nloop(Socket) -> \n    case gen_tcp:recv(Socket, 0) of \n        {ok, Bin} ->\n            [gen_tcp:send(X, Bin) || X <- lists(), X /= Socket],\n            loop(Socket);\n        {error, closed} ->\n            delete_port(Socket)\n    end.```\n\n\n \n","source":"_posts/erlang实现多人聊天室模型.md","raw":"title: Erlang实现多人聊天室模型\ndate: 2014-06-26 18:31:04\ntags: [erlang,代码]\ncategories: Erlang\n---\n##Erlang程序设计课后习题,模拟聊天室代码.\n\n> useage:用终端打开多个节点其中一个用于启动聊天服务器,在erl环境中调用``chat_room:start()``启动,之后其他节点运行``telnet localhost 8000``登录聊天室服务器,在其中一个节点发送消息,其他节点能收到.\n\n<!--more-->\n\n```Erlang\n-module(chat_room).\n-behaviour(gen_server).\n-export([start/0, stop/0, lists/0]).\n\n%gen_server handle export function declaration\n-export([init/1, handle_call/3, handle_cast/2, handle_info/2, \n        terminate/2, code_change/3]).\n%start the gen_server for saving the Socketlist\nstart() ->\n    gen_server:start_link({local, ?MODULE}, ?MODULE, [], []).\n    \nstop() ->\n    gen_server:cast(?MODULE, stop).\n\n%add the new Socket to Socket_list\nadd(Socket) -> \n    gen_server:cast(?MODULE, {add, Socket}).\n\n%delete Socket in Socketlist\ndelete_port(Socket) -> \n    gen_server:cast(?MODULE, {delete, Socket}).\n\n%get Socketlist\nlists() -> gen_server:call(?MODULE, list).\n\n%%----------------------------------------------------\n%% handle functions\n%%----------------------------------------------------\n\ninit([]) ->\n    Listen = gen_listensocket(),\n    io:format(\"beginning listen ~p~n\", [Listen]),\n    {ok, {Listen, []}}.\n\nhandle_cast({delete, Socket}, {Listen, Socket_list}) ->\n    Socket_list1=lists:delete(Socket, Socket_list),\n    {noreply, {Listen, Socket_list1}};\nhandle_cast({add, Socket}, {Listen,Socket_list}) ->\n    Socket_list1 = [Socket | Socket_list],\n    {noreply, {Listen, Socket_list1}};\nhandle_cast(stop, State) ->\n    {stop, normal, State}.\n\nhandle_call(list, _From, State) ->\n    {_, Reply} = State,\n    {reply, Reply, State}.\n\nhandle_info(_Info, State) ->\n    {noreply, State}.\n\nterminate(_Reason, {Listen, Sockets}) ->\n    io:format(\"listen~p~n\" ,[Listen]),\n    gen_tcp:close(Listen),\n    [gen_tcp:close(S) || S <- Sockets],\n    ok.\n\ncode_change(_OldVsn, State, _Extra) ->\n    {ok, State}.\n\n%%----------------------------------------------------\n%%  internal functions \n%%----------------------------------------------------\n\n%get the listen socket,new a thread to wait clients to connect.\ngen_listensocket() ->\n    {ok, Listen} = gen_tcp:listen(8000, [binary, {active, false}, {reuseaddr, true}]),\n    spawn(fun() -> gen_socket(Listen) end),\n    Listen.\n\n%do loop() to Socket and new a thread to wait clients to connect\ngen_socket(Listen) ->\n    case gen_tcp:accept(Listen) of\n        {ok, Socket} -> \n            add(Socket),\n            spawn(fun() -> gen_socket(Listen) end),\n            loop(Socket);\n        {error, closed} -> exit\n    end.\n\n%send information from Socket to other Socket in Socketlist\nloop(Socket) -> \n    case gen_tcp:recv(Socket, 0) of \n        {ok, Bin} ->\n            [gen_tcp:send(X, Bin) || X <- lists(), X /= Socket],\n            loop(Socket);\n        {error, closed} ->\n            delete_port(Socket)\n    end.```\n\n\n \n","slug":"erlang实现多人聊天室模型","published":1,"updated":"2018-06-26T09:49:27.735Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqw7jdvx000s6f1r5xgm6l08","content":"<p>##Erlang程序设计课后习题,模拟聊天室代码.</p>\n<blockquote>\n<p>useage:用终端打开多个节点其中一个用于启动聊天服务器,在erl环境中调用<code>chat_room:start()</code>启动,之后其他节点运行<code>telnet localhost 8000</code>登录聊天室服务器,在其中一个节点发送消息,其他节点能收到.</p>\n</blockquote>\n<span id=\"more\"></span>\n<pre><code class=\"Erlang\"><span class=\"pp\"><span class=\"keyword\">-module</span><span class=\"params\">(chat_room)</span></span>.\n<span class=\"pp\"><span class=\"keyword\">-behaviour</span><span class=\"params\">(gen_server)</span></span>.\n<span class=\"pp\"><span class=\"keyword\">-export</span><span class=\"params\">([start/<span class=\"number\">0</span>, stop/<span class=\"number\">0</span>, lists/<span class=\"number\">0</span>])</span></span>.\n\n<span class=\"comment\">%gen_server handle export function declaration</span>\n<span class=\"pp\"><span class=\"keyword\">-export</span><span class=\"params\">([init/<span class=\"number\">1</span>, handle_call/<span class=\"number\">3</span>, handle_cast/<span class=\"number\">2</span>, handle_info/<span class=\"number\">2</span>, \n        terminate/<span class=\"number\">2</span>, code_change/<span class=\"number\">3</span>])</span></span>.\n<span class=\"comment\">%start the gen_server for saving the Socketlist</span>\n<span class=\"function\"><span class=\"title\">start</span><span class=\"params\">()</span> -&gt;</span>\n    <span class=\"function_name\">gen_server:start_link</span>(<span class=\"tuple\">&#123;local, ?<span class=\"variable\">MODULE</span>&#125;</span>, ?<span class=\"variable\">MODULE</span>, [], []).\n\n<span class=\"function\"><span class=\"title\">stop</span><span class=\"params\">()</span> -&gt;</span>\n    <span class=\"function_name\">gen_server:cast</span>(?<span class=\"variable\">MODULE</span>, stop).\n\n<span class=\"comment\">%add the new Socket to Socket_list</span>\n<span class=\"function\"><span class=\"title\">add</span><span class=\"params\">(<span class=\"variable\">Socket</span>)</span> -&gt;</span> \n    <span class=\"function_name\">gen_server:cast</span>(?<span class=\"variable\">MODULE</span>, <span class=\"tuple\">&#123;add, <span class=\"variable\">Socket</span>&#125;</span>).\n\n<span class=\"comment\">%delete Socket in Socketlist</span>\n<span class=\"function\"><span class=\"title\">delete_port</span><span class=\"params\">(<span class=\"variable\">Socket</span>)</span> -&gt;</span> \n    <span class=\"function_name\">gen_server:cast</span>(?<span class=\"variable\">MODULE</span>, <span class=\"tuple\">&#123;delete, <span class=\"variable\">Socket</span>&#125;</span>).\n\n<span class=\"comment\">%get Socketlist</span>\n<span class=\"function\"><span class=\"title\">lists</span><span class=\"params\">()</span> -&gt;</span> <span class=\"function_name\">gen_server:call</span>(?<span class=\"variable\">MODULE</span>, list).\n\n<span class=\"comment\">%%----------------------------------------------------</span>\n<span class=\"comment\">%% handle functions</span>\n<span class=\"comment\">%%----------------------------------------------------</span>\n\n<span class=\"function\"><span class=\"title\">init</span><span class=\"params\">([])</span> -&gt;</span>\n    <span class=\"variable\">Listen</span> = <span class=\"function_name\">gen_listensocket</span>(),\n    <span class=\"function_name\">io:format</span>(<span class=\"string\">\"beginning listen ~p~n\"</span>, [<span class=\"variable\">Listen</span>]),\n    <span class=\"tuple\">&#123;ok, <span class=\"tuple\">&#123;<span class=\"variable\">Listen</span>, []&#125;</span>&#125;</span>.\n\n<span class=\"function\"><span class=\"title\">handle_cast</span><span class=\"params\">(<span class=\"tuple\">&#123;delete, <span class=\"variable\">Socket</span>&#125;</span>, <span class=\"tuple\">&#123;<span class=\"variable\">Listen</span>, <span class=\"variable\">Socket_list</span>&#125;</span>)</span> -&gt;</span>\n    <span class=\"variable\">Socket_list1</span>=<span class=\"function_name\">lists:delete</span>(<span class=\"variable\">Socket</span>, <span class=\"variable\">Socket_list</span>),\n    <span class=\"tuple\">&#123;noreply, <span class=\"tuple\">&#123;<span class=\"variable\">Listen</span>, <span class=\"variable\">Socket_list1</span>&#125;</span>&#125;</span>;\n<span class=\"function\"><span class=\"title\">handle_cast</span><span class=\"params\">(<span class=\"tuple\">&#123;add, <span class=\"variable\">Socket</span>&#125;</span>, <span class=\"tuple\">&#123;<span class=\"variable\">Listen</span>,<span class=\"variable\">Socket_list</span>&#125;</span>)</span> -&gt;</span>\n    <span class=\"variable\">Socket_list1</span> = [<span class=\"variable\">Socket</span> | <span class=\"variable\">Socket_list</span>],\n    <span class=\"tuple\">&#123;noreply, <span class=\"tuple\">&#123;<span class=\"variable\">Listen</span>, <span class=\"variable\">Socket_list1</span>&#125;</span>&#125;</span>;\n<span class=\"function\"><span class=\"title\">handle_cast</span><span class=\"params\">(stop, <span class=\"variable\">State</span>)</span> -&gt;</span>\n    <span class=\"tuple\">&#123;stop, normal, <span class=\"variable\">State</span>&#125;</span>.\n\n<span class=\"function\"><span class=\"title\">handle_call</span><span class=\"params\">(list, <span class=\"variable\">_From</span>, <span class=\"variable\">State</span>)</span> -&gt;</span>\n    <span class=\"tuple\">&#123;<span class=\"variable\">_</span>, <span class=\"variable\">Reply</span>&#125;</span> = <span class=\"variable\">State</span>,\n    <span class=\"tuple\">&#123;reply, <span class=\"variable\">Reply</span>, <span class=\"variable\">State</span>&#125;</span>.\n\n<span class=\"function\"><span class=\"title\">handle_info</span><span class=\"params\">(<span class=\"variable\">_Info</span>, <span class=\"variable\">State</span>)</span> -&gt;</span>\n    <span class=\"tuple\">&#123;noreply, <span class=\"variable\">State</span>&#125;</span>.\n\n<span class=\"function\"><span class=\"title\">terminate</span><span class=\"params\">(<span class=\"variable\">_Reason</span>, <span class=\"tuple\">&#123;<span class=\"variable\">Listen</span>, <span class=\"variable\">Sockets</span>&#125;</span>)</span> -&gt;</span>\n    <span class=\"function_name\">io:format</span>(<span class=\"string\">\"listen~p~n\"</span> ,[<span class=\"variable\">Listen</span>]),\n    <span class=\"function_name\">gen_tcp:close</span>(<span class=\"variable\">Listen</span>),\n    [<span class=\"function_name\">gen_tcp:close</span>(<span class=\"variable\">S</span>) || <span class=\"variable\">S</span> &lt;- <span class=\"variable\">Sockets</span>],\n    ok.\n\n<span class=\"function\"><span class=\"title\">code_change</span><span class=\"params\">(<span class=\"variable\">_OldVsn</span>, <span class=\"variable\">State</span>, <span class=\"variable\">_Extra</span>)</span> -&gt;</span>\n    <span class=\"tuple\">&#123;ok, <span class=\"variable\">State</span>&#125;</span>.\n\n<span class=\"comment\">%%----------------------------------------------------</span>\n<span class=\"comment\">%%  internal functions </span>\n<span class=\"comment\">%%----------------------------------------------------</span>\n\n<span class=\"comment\">%get the listen socket,new a thread to wait clients to connect.</span>\n<span class=\"function\"><span class=\"title\">gen_listensocket</span><span class=\"params\">()</span> -&gt;</span>\n    <span class=\"tuple\">&#123;ok, <span class=\"variable\">Listen</span>&#125;</span> = <span class=\"function_name\">gen_tcp:listen</span>(<span class=\"number\">8000</span>, [binary, <span class=\"tuple\">&#123;active, false&#125;</span>, <span class=\"tuple\">&#123;reuseaddr, true&#125;</span>]),\n    <span class=\"function_name\">spawn</span>(<span class=\"keyword\">fun</span>() -&gt; <span class=\"function_name\">gen_socket</span>(<span class=\"variable\">Listen</span>) <span class=\"keyword\">end</span>),\n    <span class=\"variable\">Listen</span>.\n\n<span class=\"comment\">%do loop() to Socket and new a thread to wait clients to connect</span>\n<span class=\"function\"><span class=\"title\">gen_socket</span><span class=\"params\">(<span class=\"variable\">Listen</span>)</span> -&gt;</span>\n    <span class=\"keyword\">case</span> <span class=\"function_name\">gen_tcp:accept</span>(<span class=\"variable\">Listen</span>) <span class=\"keyword\">of</span>\n        <span class=\"tuple\">&#123;ok, <span class=\"variable\">Socket</span>&#125;</span> -&gt; \n            <span class=\"function_name\">add</span>(<span class=\"variable\">Socket</span>),\n            <span class=\"function_name\">spawn</span>(<span class=\"keyword\">fun</span>() -&gt; <span class=\"function_name\">gen_socket</span>(<span class=\"variable\">Listen</span>) <span class=\"keyword\">end</span>),\n            <span class=\"function_name\">loop</span>(<span class=\"variable\">Socket</span>);\n        <span class=\"tuple\">&#123;error, closed&#125;</span> -&gt; exit\n    <span class=\"keyword\">end</span>.\n\n<span class=\"comment\">%send information from Socket to other Socket in Socketlist</span>\n<span class=\"function\"><span class=\"title\">loop</span><span class=\"params\">(<span class=\"variable\">Socket</span>)</span> -&gt;</span> \n    <span class=\"keyword\">case</span> <span class=\"function_name\">gen_tcp:recv</span>(<span class=\"variable\">Socket</span>, <span class=\"number\">0</span>) <span class=\"keyword\">of</span> \n        <span class=\"tuple\">&#123;ok, <span class=\"variable\">Bin</span>&#125;</span> -&gt;\n            [<span class=\"function_name\">gen_tcp:send</span>(<span class=\"variable\">X</span>, <span class=\"variable\">Bin</span>) || <span class=\"variable\">X</span> &lt;- <span class=\"function_name\">lists</span>(), <span class=\"variable\">X</span> /= <span class=\"variable\">Socket</span>],\n            <span class=\"function_name\">loop</span>(<span class=\"variable\">Socket</span>);\n        <span class=\"tuple\">&#123;error, closed&#125;</span> -&gt;\n            <span class=\"function_name\">delete_port</span>(<span class=\"variable\">Socket</span>)\n    <span class=\"keyword\">end</span>.\n</code></pre>\n","site":{"data":{}},"excerpt":"<p>##Erlang程序设计课后习题,模拟聊天室代码.</p>\n<blockquote>\n<p>useage:用终端打开多个节点其中一个用于启动聊天服务器,在erl环境中调用<code>chat_room:start()</code>启动,之后其他节点运行<code>telnet localhost 8000</code>登录聊天室服务器,在其中一个节点发送消息,其他节点能收到.</p>\n</blockquote>","more":"<pre><code class=\"Erlang\"><span class=\"pp\"><span class=\"keyword\">-module</span><span class=\"params\">(chat_room)</span></span>.\n<span class=\"pp\"><span class=\"keyword\">-behaviour</span><span class=\"params\">(gen_server)</span></span>.\n<span class=\"pp\"><span class=\"keyword\">-export</span><span class=\"params\">([start/<span class=\"number\">0</span>, stop/<span class=\"number\">0</span>, lists/<span class=\"number\">0</span>])</span></span>.\n\n<span class=\"comment\">%gen_server handle export function declaration</span>\n<span class=\"pp\"><span class=\"keyword\">-export</span><span class=\"params\">([init/<span class=\"number\">1</span>, handle_call/<span class=\"number\">3</span>, handle_cast/<span class=\"number\">2</span>, handle_info/<span class=\"number\">2</span>, \n        terminate/<span class=\"number\">2</span>, code_change/<span class=\"number\">3</span>])</span></span>.\n<span class=\"comment\">%start the gen_server for saving the Socketlist</span>\n<span class=\"function\"><span class=\"title\">start</span><span class=\"params\">()</span> -&gt;</span>\n    <span class=\"function_name\">gen_server:start_link</span>(<span class=\"tuple\">&#123;local, ?<span class=\"variable\">MODULE</span>&#125;</span>, ?<span class=\"variable\">MODULE</span>, [], []).\n\n<span class=\"function\"><span class=\"title\">stop</span><span class=\"params\">()</span> -&gt;</span>\n    <span class=\"function_name\">gen_server:cast</span>(?<span class=\"variable\">MODULE</span>, stop).\n\n<span class=\"comment\">%add the new Socket to Socket_list</span>\n<span class=\"function\"><span class=\"title\">add</span><span class=\"params\">(<span class=\"variable\">Socket</span>)</span> -&gt;</span> \n    <span class=\"function_name\">gen_server:cast</span>(?<span class=\"variable\">MODULE</span>, <span class=\"tuple\">&#123;add, <span class=\"variable\">Socket</span>&#125;</span>).\n\n<span class=\"comment\">%delete Socket in Socketlist</span>\n<span class=\"function\"><span class=\"title\">delete_port</span><span class=\"params\">(<span class=\"variable\">Socket</span>)</span> -&gt;</span> \n    <span class=\"function_name\">gen_server:cast</span>(?<span class=\"variable\">MODULE</span>, <span class=\"tuple\">&#123;delete, <span class=\"variable\">Socket</span>&#125;</span>).\n\n<span class=\"comment\">%get Socketlist</span>\n<span class=\"function\"><span class=\"title\">lists</span><span class=\"params\">()</span> -&gt;</span> <span class=\"function_name\">gen_server:call</span>(?<span class=\"variable\">MODULE</span>, list).\n\n<span class=\"comment\">%%----------------------------------------------------</span>\n<span class=\"comment\">%% handle functions</span>\n<span class=\"comment\">%%----------------------------------------------------</span>\n\n<span class=\"function\"><span class=\"title\">init</span><span class=\"params\">([])</span> -&gt;</span>\n    <span class=\"variable\">Listen</span> = <span class=\"function_name\">gen_listensocket</span>(),\n    <span class=\"function_name\">io:format</span>(<span class=\"string\">\"beginning listen ~p~n\"</span>, [<span class=\"variable\">Listen</span>]),\n    <span class=\"tuple\">&#123;ok, <span class=\"tuple\">&#123;<span class=\"variable\">Listen</span>, []&#125;</span>&#125;</span>.\n\n<span class=\"function\"><span class=\"title\">handle_cast</span><span class=\"params\">(<span class=\"tuple\">&#123;delete, <span class=\"variable\">Socket</span>&#125;</span>, <span class=\"tuple\">&#123;<span class=\"variable\">Listen</span>, <span class=\"variable\">Socket_list</span>&#125;</span>)</span> -&gt;</span>\n    <span class=\"variable\">Socket_list1</span>=<span class=\"function_name\">lists:delete</span>(<span class=\"variable\">Socket</span>, <span class=\"variable\">Socket_list</span>),\n    <span class=\"tuple\">&#123;noreply, <span class=\"tuple\">&#123;<span class=\"variable\">Listen</span>, <span class=\"variable\">Socket_list1</span>&#125;</span>&#125;</span>;\n<span class=\"function\"><span class=\"title\">handle_cast</span><span class=\"params\">(<span class=\"tuple\">&#123;add, <span class=\"variable\">Socket</span>&#125;</span>, <span class=\"tuple\">&#123;<span class=\"variable\">Listen</span>,<span class=\"variable\">Socket_list</span>&#125;</span>)</span> -&gt;</span>\n    <span class=\"variable\">Socket_list1</span> = [<span class=\"variable\">Socket</span> | <span class=\"variable\">Socket_list</span>],\n    <span class=\"tuple\">&#123;noreply, <span class=\"tuple\">&#123;<span class=\"variable\">Listen</span>, <span class=\"variable\">Socket_list1</span>&#125;</span>&#125;</span>;\n<span class=\"function\"><span class=\"title\">handle_cast</span><span class=\"params\">(stop, <span class=\"variable\">State</span>)</span> -&gt;</span>\n    <span class=\"tuple\">&#123;stop, normal, <span class=\"variable\">State</span>&#125;</span>.\n\n<span class=\"function\"><span class=\"title\">handle_call</span><span class=\"params\">(list, <span class=\"variable\">_From</span>, <span class=\"variable\">State</span>)</span> -&gt;</span>\n    <span class=\"tuple\">&#123;<span class=\"variable\">_</span>, <span class=\"variable\">Reply</span>&#125;</span> = <span class=\"variable\">State</span>,\n    <span class=\"tuple\">&#123;reply, <span class=\"variable\">Reply</span>, <span class=\"variable\">State</span>&#125;</span>.\n\n<span class=\"function\"><span class=\"title\">handle_info</span><span class=\"params\">(<span class=\"variable\">_Info</span>, <span class=\"variable\">State</span>)</span> -&gt;</span>\n    <span class=\"tuple\">&#123;noreply, <span class=\"variable\">State</span>&#125;</span>.\n\n<span class=\"function\"><span class=\"title\">terminate</span><span class=\"params\">(<span class=\"variable\">_Reason</span>, <span class=\"tuple\">&#123;<span class=\"variable\">Listen</span>, <span class=\"variable\">Sockets</span>&#125;</span>)</span> -&gt;</span>\n    <span class=\"function_name\">io:format</span>(<span class=\"string\">\"listen~p~n\"</span> ,[<span class=\"variable\">Listen</span>]),\n    <span class=\"function_name\">gen_tcp:close</span>(<span class=\"variable\">Listen</span>),\n    [<span class=\"function_name\">gen_tcp:close</span>(<span class=\"variable\">S</span>) || <span class=\"variable\">S</span> &lt;- <span class=\"variable\">Sockets</span>],\n    ok.\n\n<span class=\"function\"><span class=\"title\">code_change</span><span class=\"params\">(<span class=\"variable\">_OldVsn</span>, <span class=\"variable\">State</span>, <span class=\"variable\">_Extra</span>)</span> -&gt;</span>\n    <span class=\"tuple\">&#123;ok, <span class=\"variable\">State</span>&#125;</span>.\n\n<span class=\"comment\">%%----------------------------------------------------</span>\n<span class=\"comment\">%%  internal functions </span>\n<span class=\"comment\">%%----------------------------------------------------</span>\n\n<span class=\"comment\">%get the listen socket,new a thread to wait clients to connect.</span>\n<span class=\"function\"><span class=\"title\">gen_listensocket</span><span class=\"params\">()</span> -&gt;</span>\n    <span class=\"tuple\">&#123;ok, <span class=\"variable\">Listen</span>&#125;</span> = <span class=\"function_name\">gen_tcp:listen</span>(<span class=\"number\">8000</span>, [binary, <span class=\"tuple\">&#123;active, false&#125;</span>, <span class=\"tuple\">&#123;reuseaddr, true&#125;</span>]),\n    <span class=\"function_name\">spawn</span>(<span class=\"keyword\">fun</span>() -&gt; <span class=\"function_name\">gen_socket</span>(<span class=\"variable\">Listen</span>) <span class=\"keyword\">end</span>),\n    <span class=\"variable\">Listen</span>.\n\n<span class=\"comment\">%do loop() to Socket and new a thread to wait clients to connect</span>\n<span class=\"function\"><span class=\"title\">gen_socket</span><span class=\"params\">(<span class=\"variable\">Listen</span>)</span> -&gt;</span>\n    <span class=\"keyword\">case</span> <span class=\"function_name\">gen_tcp:accept</span>(<span class=\"variable\">Listen</span>) <span class=\"keyword\">of</span>\n        <span class=\"tuple\">&#123;ok, <span class=\"variable\">Socket</span>&#125;</span> -&gt; \n            <span class=\"function_name\">add</span>(<span class=\"variable\">Socket</span>),\n            <span class=\"function_name\">spawn</span>(<span class=\"keyword\">fun</span>() -&gt; <span class=\"function_name\">gen_socket</span>(<span class=\"variable\">Listen</span>) <span class=\"keyword\">end</span>),\n            <span class=\"function_name\">loop</span>(<span class=\"variable\">Socket</span>);\n        <span class=\"tuple\">&#123;error, closed&#125;</span> -&gt; exit\n    <span class=\"keyword\">end</span>.\n\n<span class=\"comment\">%send information from Socket to other Socket in Socketlist</span>\n<span class=\"function\"><span class=\"title\">loop</span><span class=\"params\">(<span class=\"variable\">Socket</span>)</span> -&gt;</span> \n    <span class=\"keyword\">case</span> <span class=\"function_name\">gen_tcp:recv</span>(<span class=\"variable\">Socket</span>, <span class=\"number\">0</span>) <span class=\"keyword\">of</span> \n        <span class=\"tuple\">&#123;ok, <span class=\"variable\">Bin</span>&#125;</span> -&gt;\n            [<span class=\"function_name\">gen_tcp:send</span>(<span class=\"variable\">X</span>, <span class=\"variable\">Bin</span>) || <span class=\"variable\">X</span> &lt;- <span class=\"function_name\">lists</span>(), <span class=\"variable\">X</span> /= <span class=\"variable\">Socket</span>],\n            <span class=\"function_name\">loop</span>(<span class=\"variable\">Socket</span>);\n        <span class=\"tuple\">&#123;error, closed&#125;</span> -&gt;\n            <span class=\"function_name\">delete_port</span>(<span class=\"variable\">Socket</span>)\n    <span class=\"keyword\">end</span>.\n</code></pre>"},{"title":"erlang有关效率的一些limit","date":"2014-08-05T12:57:32.000Z","_content":"\n Erlang Efficiency Guide\n \n###1. 数据类型的空间消耗\n 基本单位: word\n 在32位架构中占32位,即4bytes\n 在64位架构中占64位,即8bytes\n\n<!--more-->\n\n | data type |  memory cost |\n |------------|:-------------|\n|small integer|1 word :|\n|              |On 32-bit architectures: -134217729 < i < 134217728 (28 bits)|\n|             |On 64-bit architectures: -576460752303423489 < i < 576460752303423488 (60 bits) |\n|big integer | 3..N words |\n|Atom |1 word :值得注意的是原子储存在一个原子表中,这个原子表同样耗空间,而且不会被回收 |\n|float| On 32-bit architectures: 4 words / On 64-bit architectures: 3 words|\n|binary|3..6 + data (can be shared)|\n|list|1word + 每个元素分配一个word + 每个元素的大小|\n|String|1word + 每个元素分配两个word,同list 只不过每个元素的大小就是一个word|\n|Tuple |2words + 每个元素的大小|\n|Pid|本地节点一个word,其他节点5 words. 另外 port table node table 都耗空间|\n|reference|32位:本地节点5 word ,其他节点7 word 64位:本地4word  其他地方6word|\n|Fun|9..13 words + size of environment :fun table also cost momery|\n|ets|初始时需要768 words + 为每个元素分配该元素的的大小加6words |\n|process|327 words when spawned including a heap of 233 words.|\n\n> **Note** : integer 为什么少了4个bits?我去stackoverflow上问了问,大致是用来判断类型的,这4个bits用来区别list,tuple,pid 等等.而32,64位架构指的是你的编译系统,可以在启动erlang的时候看到\n`Erlang R16B03-1 (erts-5.10.4) [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false]`\n我的erlang环境没有显示,但是用`erlang:system_info(wordsize)`看出,如果为4就是4bytes即32bits如果为8就是64bits\n\n所以能用atom就用atom,别用string.\n\n###2.system limit\n#### Process limit\nerlang运行时系统默认进程的上限是32768,可以通过erl +P NUMBER 提高到一定数量,NUMBER最高为268435456,即2^28(28 bits).\n可以通过`erlang:system_info(process_limit)`查看当前系统的进程数上限\n#### atom limit\n* 一个原子最多由255 个字符构成\n* atom最多为2^20个, 即 1048576个,可以通过erl +t NUMBER 增加或者降低,暂时还不清楚能增加到多少,doc上没说\n\n#### ets limit\n最多为1400个,可以通过修改ERL_MAX_ETS_TABLES环境变量提高\n\n#### element in tuple \n元组中的元素最多为2^26 即67108863个,但是由于memory的限制,一般达不到这么多.\n\n#### size of binary \n32位环境中,binary最大不能超过2^29(536870911),64位中不能超过2^61\n#### node name\n因为是atom 所以不能超过255个character\n#### open port\n默认最多为1024, 可以通过修改ERL_MAX_PORTS到2^28\n### 函数的参数\n最多为255\n","source":"_posts/erlang有关效率的一些limit.md","raw":"title: erlang有关效率的一些limit\ndate: 2014-08-05 20:57:32\ntags: erlang\ncategories: erlang\n---\n\n Erlang Efficiency Guide\n \n###1. 数据类型的空间消耗\n 基本单位: word\n 在32位架构中占32位,即4bytes\n 在64位架构中占64位,即8bytes\n\n<!--more-->\n\n | data type |  memory cost |\n |------------|:-------------|\n|small integer|1 word :|\n|              |On 32-bit architectures: -134217729 < i < 134217728 (28 bits)|\n|             |On 64-bit architectures: -576460752303423489 < i < 576460752303423488 (60 bits) |\n|big integer | 3..N words |\n|Atom |1 word :值得注意的是原子储存在一个原子表中,这个原子表同样耗空间,而且不会被回收 |\n|float| On 32-bit architectures: 4 words / On 64-bit architectures: 3 words|\n|binary|3..6 + data (can be shared)|\n|list|1word + 每个元素分配一个word + 每个元素的大小|\n|String|1word + 每个元素分配两个word,同list 只不过每个元素的大小就是一个word|\n|Tuple |2words + 每个元素的大小|\n|Pid|本地节点一个word,其他节点5 words. 另外 port table node table 都耗空间|\n|reference|32位:本地节点5 word ,其他节点7 word 64位:本地4word  其他地方6word|\n|Fun|9..13 words + size of environment :fun table also cost momery|\n|ets|初始时需要768 words + 为每个元素分配该元素的的大小加6words |\n|process|327 words when spawned including a heap of 233 words.|\n\n> **Note** : integer 为什么少了4个bits?我去stackoverflow上问了问,大致是用来判断类型的,这4个bits用来区别list,tuple,pid 等等.而32,64位架构指的是你的编译系统,可以在启动erlang的时候看到\n`Erlang R16B03-1 (erts-5.10.4) [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false]`\n我的erlang环境没有显示,但是用`erlang:system_info(wordsize)`看出,如果为4就是4bytes即32bits如果为8就是64bits\n\n所以能用atom就用atom,别用string.\n\n###2.system limit\n#### Process limit\nerlang运行时系统默认进程的上限是32768,可以通过erl +P NUMBER 提高到一定数量,NUMBER最高为268435456,即2^28(28 bits).\n可以通过`erlang:system_info(process_limit)`查看当前系统的进程数上限\n#### atom limit\n* 一个原子最多由255 个字符构成\n* atom最多为2^20个, 即 1048576个,可以通过erl +t NUMBER 增加或者降低,暂时还不清楚能增加到多少,doc上没说\n\n#### ets limit\n最多为1400个,可以通过修改ERL_MAX_ETS_TABLES环境变量提高\n\n#### element in tuple \n元组中的元素最多为2^26 即67108863个,但是由于memory的限制,一般达不到这么多.\n\n#### size of binary \n32位环境中,binary最大不能超过2^29(536870911),64位中不能超过2^61\n#### node name\n因为是atom 所以不能超过255个character\n#### open port\n默认最多为1024, 可以通过修改ERL_MAX_PORTS到2^28\n### 函数的参数\n最多为255\n","slug":"erlang有关效率的一些limit","published":1,"updated":"2018-06-26T09:49:27.735Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqw7jdw1000x6f1ra99w11r6","content":"<p>Erlang Efficiency Guide</p>\n<p>###1. 数据类型的空间消耗<br> 基本单位: word<br> 在32位架构中占32位,即4bytes<br> 在64位架构中占64位,即8bytes</p>\n<span id=\"more\"></span>\n<table>\n<thead>\n<tr>\n<th>data type</th>\n<th style=\"text-align:left\">memory cost</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>small integer</td>\n<td style=\"text-align:left\">1 word :</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:left\">On 32-bit architectures: -134217729 &lt; i &lt; 134217728 (28 bits)</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:left\">On 64-bit architectures: -576460752303423489 &lt; i &lt; 576460752303423488 (60 bits)</td>\n</tr>\n<tr>\n<td>big integer</td>\n<td style=\"text-align:left\">3..N words</td>\n</tr>\n<tr>\n<td>Atom</td>\n<td style=\"text-align:left\">1 word :值得注意的是原子储存在一个原子表中,这个原子表同样耗空间,而且不会被回收</td>\n</tr>\n<tr>\n<td>float</td>\n<td style=\"text-align:left\">On 32-bit architectures: 4 words / On 64-bit architectures: 3 words</td>\n</tr>\n<tr>\n<td>binary</td>\n<td style=\"text-align:left\">3..6 + data (can be shared)</td>\n</tr>\n<tr>\n<td>list</td>\n<td style=\"text-align:left\">1word + 每个元素分配一个word + 每个元素的大小</td>\n</tr>\n<tr>\n<td>String</td>\n<td style=\"text-align:left\">1word + 每个元素分配两个word,同list 只不过每个元素的大小就是一个word</td>\n</tr>\n<tr>\n<td>Tuple</td>\n<td style=\"text-align:left\">2words + 每个元素的大小</td>\n</tr>\n<tr>\n<td>Pid</td>\n<td style=\"text-align:left\">本地节点一个word,其他节点5 words. 另外 port table node table 都耗空间</td>\n</tr>\n<tr>\n<td>reference</td>\n<td style=\"text-align:left\">32位:本地节点5 word ,其他节点7 word 64位:本地4word  其他地方6word</td>\n</tr>\n<tr>\n<td>Fun</td>\n<td style=\"text-align:left\">9..13 words + size of environment :fun table also cost momery</td>\n</tr>\n<tr>\n<td>ets</td>\n<td style=\"text-align:left\">初始时需要768 words + 为每个元素分配该元素的的大小加6words</td>\n</tr>\n<tr>\n<td>process</td>\n<td style=\"text-align:left\">327 words when spawned including a heap of 233 words.</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p><strong>Note</strong> : integer 为什么少了4个bits?我去stackoverflow上问了问,大致是用来判断类型的,这4个bits用来区别list,tuple,pid 等等.而32,64位架构指的是你的编译系统,可以在启动erlang的时候看到<br><code>Erlang R16B03-1 (erts-5.10.4) [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false]</code><br>我的erlang环境没有显示,但是用<code>erlang:system_info(wordsize)</code>看出,如果为4就是4bytes即32bits如果为8就是64bits</p>\n</blockquote>\n<p>所以能用atom就用atom,别用string.</p>\n<p>###2.system limit</p>\n<h4 id=\"Process_limit\">Process limit</h4><p>erlang运行时系统默认进程的上限是32768,可以通过erl +P NUMBER 提高到一定数量,NUMBER最高为268435456,即2^28(28 bits).<br>可以通过<code>erlang:system_info(process_limit)</code>查看当前系统的进程数上限</p>\n<h4 id=\"atom_limit\">atom limit</h4><ul>\n<li>一个原子最多由255 个字符构成</li>\n<li>atom最多为2^20个, 即 1048576个,可以通过erl +t NUMBER 增加或者降低,暂时还不清楚能增加到多少,doc上没说</li>\n</ul>\n<h4 id=\"ets_limit\">ets limit</h4><p>最多为1400个,可以通过修改ERL_MAX_ETS_TABLES环境变量提高</p>\n<h4 id=\"element_in_tuple\">element in tuple</h4><p>元组中的元素最多为2^26 即67108863个,但是由于memory的限制,一般达不到这么多.</p>\n<h4 id=\"size_of_binary\">size of binary</h4><p>32位环境中,binary最大不能超过2^29(536870911),64位中不能超过2^61</p>\n<h4 id=\"node_name\">node name</h4><p>因为是atom 所以不能超过255个character</p>\n<h4 id=\"open_port\">open port</h4><p>默认最多为1024, 可以通过修改ERL_MAX_PORTS到2^28</p>\n<h3 id=\"函数的参数\">函数的参数</h3><p>最多为255</p>\n","site":{"data":{}},"excerpt":"<p>Erlang Efficiency Guide</p>\n<p>###1. 数据类型的空间消耗<br> 基本单位: word<br> 在32位架构中占32位,即4bytes<br> 在64位架构中占64位,即8bytes</p>","more":"<table>\n<thead>\n<tr>\n<th>data type</th>\n<th style=\"text-align:left\">memory cost</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>small integer</td>\n<td style=\"text-align:left\">1 word :</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:left\">On 32-bit architectures: -134217729 &lt; i &lt; 134217728 (28 bits)</td>\n</tr>\n<tr>\n<td></td>\n<td style=\"text-align:left\">On 64-bit architectures: -576460752303423489 &lt; i &lt; 576460752303423488 (60 bits)</td>\n</tr>\n<tr>\n<td>big integer</td>\n<td style=\"text-align:left\">3..N words</td>\n</tr>\n<tr>\n<td>Atom</td>\n<td style=\"text-align:left\">1 word :值得注意的是原子储存在一个原子表中,这个原子表同样耗空间,而且不会被回收</td>\n</tr>\n<tr>\n<td>float</td>\n<td style=\"text-align:left\">On 32-bit architectures: 4 words / On 64-bit architectures: 3 words</td>\n</tr>\n<tr>\n<td>binary</td>\n<td style=\"text-align:left\">3..6 + data (can be shared)</td>\n</tr>\n<tr>\n<td>list</td>\n<td style=\"text-align:left\">1word + 每个元素分配一个word + 每个元素的大小</td>\n</tr>\n<tr>\n<td>String</td>\n<td style=\"text-align:left\">1word + 每个元素分配两个word,同list 只不过每个元素的大小就是一个word</td>\n</tr>\n<tr>\n<td>Tuple</td>\n<td style=\"text-align:left\">2words + 每个元素的大小</td>\n</tr>\n<tr>\n<td>Pid</td>\n<td style=\"text-align:left\">本地节点一个word,其他节点5 words. 另外 port table node table 都耗空间</td>\n</tr>\n<tr>\n<td>reference</td>\n<td style=\"text-align:left\">32位:本地节点5 word ,其他节点7 word 64位:本地4word  其他地方6word</td>\n</tr>\n<tr>\n<td>Fun</td>\n<td style=\"text-align:left\">9..13 words + size of environment :fun table also cost momery</td>\n</tr>\n<tr>\n<td>ets</td>\n<td style=\"text-align:left\">初始时需要768 words + 为每个元素分配该元素的的大小加6words</td>\n</tr>\n<tr>\n<td>process</td>\n<td style=\"text-align:left\">327 words when spawned including a heap of 233 words.</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p><strong>Note</strong> : integer 为什么少了4个bits?我去stackoverflow上问了问,大致是用来判断类型的,这4个bits用来区别list,tuple,pid 等等.而32,64位架构指的是你的编译系统,可以在启动erlang的时候看到<br><code>Erlang R16B03-1 (erts-5.10.4) [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false]</code><br>我的erlang环境没有显示,但是用<code>erlang:system_info(wordsize)</code>看出,如果为4就是4bytes即32bits如果为8就是64bits</p>\n</blockquote>\n<p>所以能用atom就用atom,别用string.</p>\n<p>###2.system limit</p>\n<h4 id=\"Process_limit\">Process limit</h4><p>erlang运行时系统默认进程的上限是32768,可以通过erl +P NUMBER 提高到一定数量,NUMBER最高为268435456,即2^28(28 bits).<br>可以通过<code>erlang:system_info(process_limit)</code>查看当前系统的进程数上限</p>\n<h4 id=\"atom_limit\">atom limit</h4><ul>\n<li>一个原子最多由255 个字符构成</li>\n<li>atom最多为2^20个, 即 1048576个,可以通过erl +t NUMBER 增加或者降低,暂时还不清楚能增加到多少,doc上没说</li>\n</ul>\n<h4 id=\"ets_limit\">ets limit</h4><p>最多为1400个,可以通过修改ERL_MAX_ETS_TABLES环境变量提高</p>\n<h4 id=\"element_in_tuple\">element in tuple</h4><p>元组中的元素最多为2^26 即67108863个,但是由于memory的限制,一般达不到这么多.</p>\n<h4 id=\"size_of_binary\">size of binary</h4><p>32位环境中,binary最大不能超过2^29(536870911),64位中不能超过2^61</p>\n<h4 id=\"node_name\">node name</h4><p>因为是atom 所以不能超过255个character</p>\n<h4 id=\"open_port\">open port</h4><p>默认最多为1024, 可以通过修改ERL_MAX_PORTS到2^28</p>\n<h3 id=\"函数的参数\">函数的参数</h3><p>最多为255</p>"},{"title":"erl命令和参数","date":"2015-07-22T02:11:37.000Z","_content":"\n\n## Startup\n先拿mochiweb生成的一个例子说起，这是start-dev.sh脚本中的内容。启动一个mochiweb应用调用的就是这个\n```\n#!/bin/sh\nexec erl \\\n    -pa ebin deps/*/ebin \\\n    -boot start_sasl \\\n    -sname helloworld_dev \\\n    -s helloworld \\\n    -s reloader\n```\n\n<!--more-->\n通用形式就是\n> erl -a b --sth -c d +f g -extra abc\n\nerl后面的都是参数arguments\narguments可以分为**emulator flags**，**flags**，**plain arguments**\n    * 任何已+开始的参数会被解释为emulator flags\n    * 任何以-开始的参数会被解释为flags，并传入交给了init模块。\n    * 在--之后到任何-或者+符号之间的所有flags以及-extra之后所有的flags都是plain arguments，这些参数不会发生解释行为，只不过被储存起来。同样交给init模块。\ninit:boot(Args)函数接受上面的flags和plain arguments。\n\n>**boot(BootArgs) -> no_return()\nTypes:\nBootArgs = [binary()]**\nStarts the Erlang runtime system. This function is called when the emulator is started and coordinates system start-up.\nBootArgs are all command line arguments except the emulator flags, that is, flags and plain arguments. See erl(1).\ninit itself interprets some of the flags, see Command Line Flags below. The remaining flags (\"user flags\") and plain arguments are passed to the init loop and can be retrieved by callingget_arguments/0 and get_plain_arguments/0, respectively.\n\nflags会被boot函数分为 init flags和user flags。user flags可以通过init:get_arguments()得到，plain arguments通过init:get_plain_arguments()得到。值得注意的是一小部分的“-”后面的flags现在是属于emulator flags。后面提到。\n\n<!-- toc -->\n\n## Init Flags\n### --(两个横杠)\n任何在--到下一个-或者+之间的都是plain arguments，可以通过init:get_plain_arguments()取到.\n### -extra\n和--的作用一样，extra后面的flags都是plain arguments\n### -code_path_choice Choice::strict|relexed\n> When the choice of directories in the code path is strict, the directory that ends up in the code path will be exactly the stated one. This means that if for example the directory \\$OTPROOT/lib/mnesia-4.4.7/ebin is explicitly added to the code path, the code server will not load files from $OTPROOT/lib/mnesia-4.4.7.ez/mnesia-4.4.7/ebin and vice versa.\n\n> This behavior can be controlled via the command line flag -code_path_choice Choice. If the flag is set to relaxed, the code server will instead choose a suitable directory depending on the actual file structure. If there exists a regular application ebin directory,situation it will be chosen. But if it does not exist, the ebin directory in the archive is chosen if it exists. If neither of them exists the original directory will be chosen.\n```\n\"/home/yuyouqi/Erlang/lib/snmp-5.1.1/ebin\",\n \"/home/yuyouqi/Erlang/lib/sasl-2.4.1/ebin\",\n \"/home/yuyouqi/Erlang/lib/runtime_tools-1.8.15/ebin\",\n \"/home/yuyouqi/Erlang/lib/reltool-0.6.6/ebin\",\n```\n\n```\n \"/home/yuyouqi/Erlang/lib/ssh-3.1/ebin\",\n \"/home/yuyouqi/Erlang/lib/snmp-5.1.1/ebin\",\n \"/home/yuyouqi/Erlang/lib/sasl-2.4.1.ez/sasl-2.4.1/ebin\",\n \"/home/yuyouqi/Erlang/lib/runtime_tools-1.8.15/ebin\",\n 3> code:lib_dir(sasl, ebin).\n\"/home/yuyouqi/Erlang/lib/sasl-2.4.1.ez/sasl-2.4.1/ebin\"\n```\n### -eval Expr\nExpr是个函数，在erl初始化时按顺序执行，如果fail的，则初始化失败。例如\n```\nerl -eval '{X,Y,Z} = now(), random:seed(X,Y,Z).'\n```\n> 官方文档Z}旁边多了‘符号，需要去掉\n\n### -run Mod Func Arg1 Arg2....ArgN\n调用Mod:Func([\"Arg1\", \"Arg2\", ...\"ArgN\"]),\n所有参数都是以string方式传入的。同样按顺序执行，前一个执行完才会执行下一个。但是貌似并不会阻塞shell。\n### -s Mod Func Arg1 Arg2 ... ArgN\n与run完成同样的功能，但是Arg都是atom的形式传入，值得注意的是数字也会变成atom,\n```\nerl -s test time 5000 atom\n```\n\n就是test:time(['5000', atom]).\n一般数字需要atom_to_list, list_to_integer转换。\n\n##User flags\n\n### -ApplicationName Par Val\n指定应用的名字，属性名称和值，可以将应用的某个参数设置成Val。\n比如\n```\n erl -pa ./ebin -s helloworld -helloworld par haha\n 1> application:get_all_key(helloworld).\n{ok,[{description,\"helloworld\"},\n     {id,[]},\n     {vsn,\"0.1\"},\n     {modules,[helloworld,helloworld_app,helloworld_deps,\n               helloworld_dtl,helloworld_sup,helloworld_web]},\n     {maxP,infinity},\n     {maxT,infinity},\n     {registered,[]},\n     {included_applications,[]},\n     {applications,[kernel,stdlib,crypto]},\n     {env,[{par,haha},{included_applications,[]}]},\n     {mod,{helloworld_app,[]}},\n     {start_phases,undefined}]}\n2> application:get_all_env(helloworld).\n[{par,haha},{included_applications,[]}]\n```\n\n启动了一个helloworld应用，并将par参数设置成haha。\n\n### -args_file FileName\n直接从FileName读取erl所用的参数。例如在agrsfile的文件中写入如下\n> -eval 'io:format(\"read from file~n\")' -extra hello -pa ./ebin\n\n实际结果\n```\nerl -args_file argsfile\nErlang R15B (erts-5.9) [source] [smp:2:2] [async-threads:0] [hipe] [kernel-poll:false]\n\nEshell V5.9  (abort with ^G)\n1> read from file\n1> init:get_arguments().\n[{root,[\"/usr/local/lib/erlang\"]},\n {progname,[\"erl\"]},\n {home,[\"/home/yuyouqi\"]}]\n2> init:get_plain_arguments().\n[\"hello\",\"-pa\",\"./ebin\"]\n```\n\n可以看到启动的时候执行了io:format函数，但是-extra这个参数是特殊的，正常情况下-extra到下一个-或者+之间的参数才会被认为是plain arguments，可是如果写在文件中就变成-extra后面所有的参数，都会当成plain arguments.只有这点不同。\n\n### -async_shell_start\n名字上来说是异步启动shell\n\n### -boot File\n试用File.boot启动erl系统,除非File是个绝对路径，否则在当前文件夹和$ROOT/bin下面找（我的:/usr/local/lib/erlang/bin,  $ROOT可以通过code:root_dir()查看),\n默认情况下是-boot start\n[script](http://www.erlang.org/doc/man/script.html)\n> The command erl -boot Name starts the system with a boot file called Name.boot, which is generated from the Name.script file, using systools:script2boot/1.\nThe .script file is generated by systools from a .rel file and .app files.\n\n.boot文件是用systools产生的，打开后是乱码.\n文件的生成顺序 .rel -> .script -> .boot\n[systools](http://erlang.org/doc/man/systools.html)\nsystools里面提供了生成rel,script, boot等方法。可以在`/usr/local/lib/erlang/releases/R15B`下找到几个官方的rel，script，boot\n```\nUbuntu@desktop:/usr/local/lib/erlang/releases/R15B$ ls\nstart_all_example.rel  start_clean.boot  start_clean.script  start_sasl.rel     start.script\nstart.boot             start_clean.rel   start_sasl.boot     start_sasl.script\n```\n\n打开start_sasl.rel\n```\n%%注释....\n{release, {\"OTP  APN 181 01\",\"R15B\"}, {erts, \"5.9\"},\n [{kernel,\"2.15\"},\n  {stdlib,\"1.18\"},\n  {sasl, \"2.2\"}]}.\n```\n\n具体格式在上面的systools链接中有说明\n仿照它这个样子写一个test\n```\n{release, {\"test_rel\",\"0.1\"}, {erts, \"5.9\"},\n [{kernel,\"2.15\"},\n  {stdlib,\"1.18\"},\n  {sasl, \"2.2\"},\n  {crypto, \"2.1\"},\n  {helloworld,\"0.1\"}]}.\n```\n\nhelloworld使用mochiweb生成的简单框架,用到了crypto，所以讲crypto加入。\n```\nErlang R15B (erts-5.9) [source] [smp:2:2] [async-threads:0] [hipe] [kernel-poll:false]\n\nEshell V5.9  (abort with ^G)\n1> systools:make_script(\"test\").       \nhelloworld: File not found: \"helloworld.app\"\n\nerror\n2> systools:make_script(\"test\", [{path, [\"ebin\"]}]).\nok\n```\n由于helloworld不在默认的ebin下，所以下加上当前路径中的ebin。否则找不到helloworld.app\n如果是使用systools的make_script命令省的script会自动生成.boot。打开test.script\n```\n%% script generated at {2015,7,1} {12,5,26}\n{script,\n    {\"test_rel\",\"0.1\"},\n    [{preLoaded,\n         [erl_prim_loader,erlang,init,otp_ring0,prim_file,prim_inet,prim_zip,\n          zlib]},\n     {progress,preloaded},\n     {path,[\"$ROOT/lib/kernel-2.15/ebin\",\"$ROOT/lib/stdlib-1.18/ebin\"]},\n     {primLoad,[error_handler]},\n     {kernel_load_completed},\n     {progress,kernel_load_completed},\n     {path,[\"$ROOT/lib/kernel-2.15/ebin\"]},\n     {primLoad,\n         [application,application_controller,application_master,\n          application_starter,auth,code,code_server,disk_log,disk_log_1,\n          disk_log_server,disk_log_sup,dist_ac,dist_util,erl_boot_server,\n          erl_ddll,erl_distribution,erl_epmd,erl_reply,error_logger,\n          erts_debug,file,file_io_server,file_server,gen_sctp,gen_tcp,gen_udp,\n          global,global_group,global_search,group,heart,hipe_unified_loader,\n          inet,inet6_sctp,inet6_tcp,inet6_tcp_dist,inet6_udp,inet_config,\n          inet_db,inet_dns,inet_gethost_native,inet_hosts,inet_parse,inet_res,\n          inet_sctp,inet_tcp,inet_tcp_dist,inet_udp,kernel,kernel_config,net,\n          net_adm,net_kernel,os,packages,pg2,ram_file,rpc,seq_trace,\n          standard_error,user,user_drv,user_sup,wrap_log_reader]},\n     {path,[\"$ROOT/lib/stdlib-1.18/ebin\"]},\n...\n...\n```\n\n有了.boot文件后就可以使用了\n```\nyuyouqi@yuyouqi-desktop:~/Erlang/helloworld$ erl -pa ebin deps/*/ebin -boot test\nErlang R15B (erts-5.9) [source] [smp:2:2] [async-threads:0] [hipe] [kernel-poll:false]\n\n\n=PROGRESS REPORT==== 1-Jul-2015::12:10:49 ===\n          supervisor: {local,sasl_safe_sup}\n             started: [{pid,<0.35.0>},\n                       {name,alarm_handler},\n                       {mfargs,{alarm_handler,start_link,[]}},\n                       {restart_type,permanent},\n                       {shutdown,2000},\n                       {child_type,worker}]\n\n=PROGRESS REPORT==== 1-Jul-2015::12:10:49 ===\n          supervisor: {local,sasl_safe_sup}\n             started: [{pid,<0.36.0>},\n                       {name,overload},\n                       {mfargs,{overload,start_link,[]}},\n                       {restart_type,permanent},\n                       {shutdown,2000},\n                       {child_type,worker}]\n\n=PROGRESS REPORT==== 1-Jul-2015::12:10:49 ===\n          supervisor: {local,sasl_sup}\n             started: [{pid,<0.34.0>},\n                       {name,sasl_safe_sup},\n                       {mfargs,\n                           {supervisor,start_link,\n                               [{local,sasl_safe_sup},sasl,safe]}},\n                       {restart_type,permanent},\n                       {shutdown,infinity},\n                       {child_type,supervisor}]\n\n=PROGRESS REPORT==== 1-Jul-2015::12:10:49 ===\n          supervisor: {local,sasl_sup}\n             started: [{pid,<0.37.0>},\n                       {name,release_handler},\n                       {mfargs,{release_handler,start_link,[]}},\n                       {restart_type,permanent},\n                       {shutdown,2000},\n                       {child_type,worker}]\n\n=PROGRESS REPORT==== 1-Jul-2015::12:10:49 ===\n         application: sasl\n          started_at: nonode@nohost\n\n=PROGRESS REPORT==== 1-Jul-2015::12:10:49 ===\n          supervisor: {local,crypto_sup}\n             started: [{pid,<0.43.0>},\n                       {name,crypto_server},\n                       {mfargs,{crypto_server,start_link,[]}},\n                       {restart_type,permanent},\n                       {shutdown,2000},\n                       {child_type,worker}]\n\n=PROGRESS REPORT==== 1-Jul-2015::12:10:49 ===\n         application: crypto\n          started_at: nonode@nohost\n** Found 0 name clashes in code paths \n\n=PROGRESS REPORT==== 1-Jul-2015::12:10:49 ===\n          supervisor: {local,helloworld_sup}\n             started: [{pid,<0.48.0>},\n                       {name,helloworld_web},\n                       {mfargs,\n                           {helloworld_web,start,\n                               [[{ip,{0,0,0,0}},\n                                 {port,8080},\n                                 {docroot,\n                                     \"/home/yuyouqi/Erlang/helloworld/priv/www\"}]]}},\n                       {restart_type,permanent},\n                       {shutdown,5000},\n                       {child_type,worker}]\n\n=PROGRESS REPORT==== 1-Jul-2015::12:10:49 ===\n         application: helloworld\n          started_at: nonode@nohost\nEshell V5.9  (abort with ^G)\n1> \n```\n\n### -boot_var Var Dir\n指定一个变量Var的路径为Dir，主要用于systools:make_script的{variables, [{\"Var\", \"Prefix\"}]},\n因为默认的script路径都是在$ROOT/lib下寻找，当在make_script中加入variables选项时，\n\n### -code_path_cache\n使用codepath的缓存，这样做的好处是加载模块更快，而且可以在常数时间找到模块，如果没加则需要search这个codepath才能找到对应模块，在模块数量很多时，可以使用。\n### -compile Mod1 Mod2 ...\n编译Mod1 Mod2 ... 如果失败会返回非零的错误码 默认同时使用了-noinput参数.**不推荐使用，推荐erlc**\n### connect_all true|false\n是否全联通（N1-N2， N2-N3 -> N1-N2-N3），如果是false那么global模块的注册名字的相关机制无法使用\n### -config Config\n读取Config文件，名字为AppName.config.\n格式\n> [{AppName, [{Key1, Value1}...]}, {AppName2, [...]}].\n\n见[config file](http://www.erlang.org/doc/man/config.html).\n例如新建helloworld.config\n```\n[{helloworld, [{key1, val1}, {key2, val2}]}].\n```\n\n并在start脚本中加入-config helloworld.config\n```\n#!/bin/sh\nexec erl \\\n    -pa ebin deps/*/ebin \\\n    -boot start_sasl \\\n    -sname helloworld_dev \\\n    -s helloworld \\\n    -s reloader \\\n    -config helloworld.config\n```\n\n如下看到在env中多了写入的config值\n\n```\n(helloworld_dev@Ubuntu-desktop)1> application:get_all_key(helloworld).\n{ok,[{description,\"helloworld\"},\n     {id,[]},\n     {vsn,\"0.1\"},\n     {modules,[helloworld,helloworld_app,helloworld_deps,\n               helloworld_dtl,helloworld_sup,helloworld_web]},\n     {maxP,infinity},\n     {maxT,infinity},\n     {registered,[]},\n     {included_applications,[]},\n     {applications,[kernel,stdlib,crypto]},\n     {env,[{included_applications,[]},{key2,val2},{key1,val1}]},\n     {mod,{helloworld_app,[]}},\n     {start_phases,undefined}]}\n```\n\n### -cookie Cookie\n过时的没有任何效果的标志，是setcookie的错误拼写，用setcookie代替。\n### -setcookie Cookie\n和erlang:set_cookie(Node, Cookie)的效果一样。给本地结点设置需要给本地结点起个名字-name/sname\n### -detached\n以background的形式运行erl，与当前shell分离开，但是需要知道如何停止这个系统\n[How to stop](http://stackoverflow.com/questions/15464606/erlang-kill-all-processes-running-in-background).\n### -emu_args\n打印传给emulator的参数，比如在start-dev.sh脚本中加入它，可以看到\n```\nyuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ ./start-dev.sh \nExecuting: /usr/local/lib/erlang/erts-5.9/bin/beam.smp /usr/local/lib/erlang/erts-5.9/bin/beam.smp -- -root /usr/local/lib/erlang -progname erl -- -home /home/yuyouqi -- -pa ebin deps/erlydtl/ebin deps/eunit_formatters/ebin deps/merl/ebin deps/mochiweb/ebin -boot start_sasl -sname helloworld_dev -s helloworld -s reloader\n\nErlang R15B (erts-5.9) [source] [smp:2:2] [async-threads:0] [hipe] [kernel-poll:false]\n```\n\n### -env Variable Value\n设置OS模块的环境变量Variable为Value.\n通过os:getenv/0 getenv/1可以得到\n### -heart\n开启心跳检测，尽管erlang有各种supervisor监管机制，但是如果emulator down掉了就完了，-heart会开启一个heart进程监控整个emulator，在规定时间内如果没有收到心跳，这个进程就会执行HEART_COMMAND参数，如果这个参数没有设定，那么只会弹出警告，而不会重启。一般HEART_COMMAND就是重启emulator。麻烦的是如果设定了heart，但是没有用-sname，是无法回到这个erlang shell的，也就是无法调用init：stop()来终止heart的监控策略。\n\n在没有开启任何erl shell的情况下调用`ps -ef|grep erl`看到跟erl有关的进程如下\n```\nyuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ ps -ef |grep erl\nyuyouqi   2475  2345  0 10:23 ?        00:00:01 /usr/bin/perl /usr/bin/shutter --min_at_startup\nyuyouqi   3329  2862  0 10:58 pts/2    00:00:00 grep --color=auto erl\n```\n\n启动一个erl emulator,然后Ctrl + z放到挂起\n```\nyuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ erl \nErlang R15B (erts-5.9) [source] [smp:2:2] [async-threads:0] [hipe] [kernel-poll:false]\n\nEshell V5.9  (abort with ^G)\n1> \n[1]+  已停止               erl\nyuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ ps -ef |grep erl\nyuyouqi   2475  2345  0 10:23 ?        00:00:01 /usr/bin/perl /usr/bin/shutter --min_at_startup\nyuyouqi   3333  2862  0 11:01 pts/2    00:00:00 /usr/local/lib/erlang/erts-5.9/bin/beam.smp -- -root /usr/local/lib/erlang -progname erl -- -home /home/yuyouqi --\nyuyouqi   3346  2862  0 11:01 pts/2    00:00:00 grep --color=auto erl\n```\n\n可以看到3333这个进程后面的命令是开启一个erl emulator的\n```\nyuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ kill -9 3333\nyuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ ps -ef | grep erl\nyuyouqi   2475  2345  0 10:23 ?        00:00:01 /usr/bin/perl /usr/bin/shutter --min_at_startup\nyuyouqi   3366  2862  0 11:04 pts/2    00:00:00 grep --color=auto erl\n[1]+  已杀死               erl\n```\n\n可以看到将他kill掉是没问题的\n下面启动一个-heart erl shell\n```\nyuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ erl -sname test1 -heart -env HEART_COMMAND \"erl -sname test1 -heart\"\nheart_beat_kill_pid = 3369\nErlang R15B (erts-5.9) [source] [smp:2:2] [async-threads:0] [hipe] [kernel-poll:false]\n\nEshell V5.9  (abort with ^G)\n(test1@yuyouqi-desktop)1> \n[1]+  已停止               erl -sname test1 -heart -env HEART_COMMAND \"erl -sname test1 -heart\"\nyuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ ps -ef | grep erl\nyuyouqi   2475  2345  0 10:23 ?        00:00:01 /usr/bin/perl /usr/bin/shutter --min_at_startup\nyuyouqi   3369  2862  1 11:05 pts/2    00:00:00 /usr/local/lib/erlang/erts-5.9/bin/beam.smp -- -root /usr/local/lib/erlang -progname erl -- -home /home/yuyouqi -- -sname test1 -heart\nyuyouqi   3376  2219  0 11:05 ?        00:00:00 /usr/local/lib/erlang/erts-5.9/bin/epmd -daemon\nyuyouqi   3387  2862  0 11:06 pts/2    00:00:00 grep --color=auto erl\n\nyuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ heart: Fri Jul  3 11:06:57 2015: heart-beat time-out.\nheart_beat_kill_pid = 3390\nyuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ ps -ef | grep erl\nyuyouqi   2475  2345  0 10:23 ?        00:00:01 /usr/bin/perl /usr/bin/shutter --min_at_startup\nyuyouqi   3376  2219  0 11:05 ?        00:00:00 /usr/local/lib/erlang/erts-5.9/bin/epmd -daemon\nyuyouqi   3389  3383  0 11:06 ?        00:00:00 sh -c erl -sname test1 -heart\nyuyouqi   3390  3389  0 11:06 ?        00:00:00 /usr/local/lib/erlang/erts-5.9/bin/beam.smp -- -root /usr/local/lib/erlang -progname erl -- -home /home/yuyouqi -- -sname test1 -heart\nyuyouqi   3410  2862  0 11:07 pts/2    00:00:00 grep --color=auto erl\n```\n\n上面命令是我用-heart启动一个erl shell，可以看到多了3369 和3376这两个进程，把erl shell挂起，一段时间后，由于heart进程没有接收到“心跳”，重启了erl shell,pid变为3390。而且多出了一个3389这个进程，而3390这个erl shell是3389的子进程。可以看到3389就是执行我们的HEART_COMMAND\n如果不指定HEART_COMMAND\n```\nyuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ erl -sname test2 -heart\nheart_beat_kill_pid = 3685\nErlang R15B (erts-5.9) [source] [smp:2:2] [async-threads:0] [hipe] [kernel-poll:false]\n\nEshell V5.9  (abort with ^G)\n(test2@yuyouqi-desktop)1> \n[1]+  已停止               erl -sname test2 -heart\nyuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ ps -ef|grep erl\nyuyouqi   2475  2345  0 10:23 ?        00:00:01 /usr/bin/perl /usr/bin/shutter --min_at_startup\nyuyouqi   3376  2219  0 11:05 ?        00:00:00 /usr/local/lib/erlang/erts-5.9/bin/epmd -daemon\nyuyouqi   3389  3383  0 11:06 ?        00:00:00 sh -c erl -sname test1 -heart\nyuyouqi   3390  3389  0 11:06 ?        00:00:00 /usr/local/lib/erlang/erts-5.9/bin/beam.smp -- -root /usr/local/lib/erlang -progname erl -- -home /home/yuyouqi -- -sname test1 -heart\nyuyouqi   3685  2862  2 12:15 pts/2    00:00:00 /usr/local/lib/erlang/erts-5.9/bin/beam.smp -- -root /usr/local/lib/erlang -progname erl -- -home /home/yuyouqi -- -sname test2 -heart\nyuyouqi   3703  2862  0 12:15 pts/2    00:00:00 grep --color=auto erl\nyuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ jobs\n[1]+  已停止               erl -sname test2 -heart\nyuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ fg\nerl -sname test2 -heart\n\n(test2@yuyouqi-desktop)1> \nUser switch command\n --> q\nyuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ heart: Fri Jul  3 12:16:10 2015: Erlang has closed.\nheart: Fri Jul  3 12:16:10 2015: Would reboot. Terminating.\n\nyuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ ps -ef|grep erl\nyuyouqi   2475  2345  0 10:23 ?        00:00:01 /usr/bin/perl /usr/bin/shutter --min_at_startup\nyuyouqi   3376  2219  0 11:05 ?        00:00:00 /usr/local/lib/erlang/erts-5.9/bin/epmd -daemon\nyuyouqi   3389  3383  0 11:06 ?        00:00:00 sh -c erl -sname test1 -heart\nyuyouqi   3390  3389  0 11:06 ?        00:00:00 /usr/local/lib/erlang/erts-5.9/bin/beam.smp -- -root /usr/local/lib/erlang -progname erl -- -home /home/yuyouqi -- -sname test1 -heart\nyuyouqi   3705  2862  0 12:16 pts/2    00:00:00 grep --color=auto erl\n```\n\n新建一个test2 shell，不设置HEART_COMMAND，\n可以看到如果没有设置HEART_COMMAND 使用ctrl g退出后不会重启，但是test1是会重启的。\n而且新建节点后发现-daemon进程并没有增加，我猜测-daemon有可能是heart监控进程。\n但是无论怎样kill都是无效的，依然会重启\n```\nyuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ kill -9 3376 3389 3390\nyuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ heart: Fri Jul  3 12:21:15 2015: Executed \"erl -sname test1 -heart\". Terminating.\nheart: Fri Jul  3 12:21:15 2015: Erlang has closed.\nheart_beat_kill_pid = 3716\n\nyuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ ps -ef|grep erl\nyuyouqi   2475  2345  0 10:23 ?        00:00:01 /usr/bin/perl /usr/bin/shutter --min_at_startup\nyuyouqi   3715  3404  0 12:21 ?        00:00:00 sh -c erl -sname test1 -heart\nyuyouqi   3716  3715  3 12:21 ?        00:00:00 /usr/local/lib/erlang/erts-5.9/bin/beam.smp -- -root /usr/local/lib/erlang -progname erl -- -home /home/yuyouqi -- -sname test1 -heart\nyuyouqi   3723  2219  0 12:21 ?        00:00:00 /usr/local/lib/erlang/erts-5.9/bin/epmd -daemon\nyuyouqi   3734  2862  0 12:21 pts/2    00:00:00 grep --color=auto erl\n```\n\n这时就需要进入test1，调用init:stop()来结束\n```\nyuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ erl -sname test2\nErlang R15B (erts-5.9) [source] [smp:2:2] [async-threads:0] [hipe] [kernel-poll:false]\n\nEshell V5.9  (abort with ^G)\n(test2@yuyouqi-desktop)1> \nUser switch command\n --> r 'test1@yuyouqi-desktop'\n --> c\nEshell V5.9  (abort with ^G)\n(test1@yuyouqi-desktop)1> init:stop().\n*** ERROR: Shell process terminated! (^G to start new job) ***\nheart: Fri Jul  3 12:23:40 2015: Executed \"erl -sname test1 -heart\". Terminating.\n\nUser switch command\n --> j\n   1  {shell,start,[init]}\n --> c 1\n\n(test2@yuyouqi-desktop)1>        \nUser switch command\n --> q\nyuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ ps -ef|grep erl\nyuyouqi   2475  2345  0 10:23 ?        00:00:01 /usr/bin/perl /usr/bin/shutter --min_at_startup\nyuyouqi   3723  2219  0 12:21 ?        00:00:00 /usr/local/lib/erlang/erts-5.9/bin/epmd -daemon\nyuyouqi   3760  2862  0 12:24 pts/2    00:00:00 grep --color=auto erl\n```\n\n这样才能将heart监控的shell关闭(或者使用rpc)\n参考[Is there a way to kill the erlang vm when it is running with -heart](http://stackoverflow.com/questions/7217892/is-there-a-way-to-kill-the-erlang-vm-when-it-is-running-with-heart)\n\n### -hidden\n已hidden启动的结点在于其他结点连接时，他的连接时隐藏的，不会再nodes()中得到自己的名字。只有与自己同属于一个[global_group](http://www.erlang.org/doc/man/global_group.html#type-group_name)的其他结点才能知道自己。\n比如建立一个kernel.config,定义一个global_group\n```\n[{kernel, [{global_groups, [{test, ['test1@yuyouqi-desktop', 'test2@yuyouqi-desktop']}]}]}].\n```\n\n然后启动3个结点test1，test2，test3\n```\nyuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ erl -sname test1 -config kernel.config \nErlang R15B (erts-5.9) [source] [smp:2:2] [async-threads:0] [hipe] [kernel-poll:false]\n\nEshell V5.9  (abort with ^G)\n(test1@yuyouqi-desktop)1> global_group:global_groups().\n{test,[]}\nyuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ erl -sname test2 -hidden -config kernel.config \nErlang R15B (erts-5.9) [source] [smp:2:2] [async-threads:0] [hipe] [kernel-poll:false]\n\nEshell V5.9  (abort with ^G)\n(test2@yuyouqi-desktop)1> global_group:global_groups().\n{test,[]}\nyuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ erl -sname test3 -config kernel.config \nErlang R15B (erts-5.9) [source] [smp:2:2] [async-threads:0] [hipe] [kernel-poll:false]\n\nEshell V5.9  (abort with ^G)\n(test3@yuyouqi-desktop)1> global_group:global_groups().\n{no_name,[test]}\n```\n\n其中test2已hidden形式启动，test3不在global_group中，可以看到test1和test2返回自己的global_group为test。\n用`net_kernel:connect`将它们互联。\n```\n(test2@yuyouqi-desktop)2> net_kernel:connect('test1@yuyouqi-desktop').\ntrue\n(test2@yuyouqi-desktop)3> nodes().\n['test1@yuyouqi-desktop']\n(test2@yuyouqi-desktop)5> net_kernel:connect('test3@yuyouqi-desktop').\ntrue\n(test2@yuyouqi-desktop)6> nodes().\n['test1@yuyouqi-desktop']\n(test1@yuyouqi-desktop)2> nodes().\n['test2@yuyouqi-desktop']\n(test3@yuyouqi-desktop)2> nodes().\n[]\n```\n\ntest1和test2是可以互相看到的，而test3的nodes()返回的是空\n\n### -init_debug\n启动的时候打印调试参数。可以尝试下`erl -init_debug` 然后对照着`/usr/local/lib/erlang/releases/RXXB/start.script`\n\n### -make\n相当于make:all(),见\n[make](http://www.erlang.org/doc/man/make.html)\n### -man Module\n查询某个模块的手册，首先需要去官网下载相应的手册\n### -mode interactive|embedded\nerlang system载入代码的方式，interactive模式下，系统只载入一部分代码，当使用为载入的代码时，会尝试自动载入这个模块。如果是embeded模式，实在系统初始化时，根据启动的script文件载入所有代码，如果文件上没有提到，不会载入，如果调用为载入模块的函数，会报exception error\n### -name/sname NAME\n```\nerl -sname test1\nerl -name test2@192.168.1.10\n```\n\nsname 与name之间的结点不能通信，必须命名方式相同才可以。 sname只能用于同一子网内的机器。\n### -noinput\nerl不读入任何参数\n### -noshell\n常用，不显示erl shell。一般都是执行一系列的-eval，-s，-ran，然后init:stop().\n### -pa/-pz \n添加code路径，没什么可说的同code:addpathsa/addpathsz\n### -remsh Node\n远程链接一个节点。例如在shell1中启动一个mochiweb例子\n```\nyouthy@youthy:~/code/helloworld$ ./start-dev.sh \n...=PROGRESS REPORT==== 17-Jul-2015::12:20:43 ===\n          supervisor: {local,kernel_safe_sup}\n             started: [{pid,<0.74.0>},\n                       {id,timer_server},\n                       {mfargs,{timer,start_link,[]}},\n                       {restart_type,permanent},\n                       {shutdown,1000},\n                       {child_type,worker}]\n\n(helloworld_dev@youthy)1> \n```\n\n然后在shell2中链接这个节点。\n```\nyouthy@youthy:~$ erl -sname test2 -remsh helloworld_dev@youthy\nErlang R15B (erts-5.9) [source] [64-bit] [smp:4:4] [async-threads:0] [hipe] [kernel-poll:false]\n\nEshell V7.0  (abort with ^G)\n(helloworld_dev@youthy)1> helloworld_web:\nloop/2         module_info/0  module_info/1  start/1        stop/0         \n\n(helloworld_dev@youthy)1> helloworld_web:module_info().\n[{module,helloworld_web},\n {exports,[{start,1},\n           {stop,0},\n           {loop,2},\n           {module_info,0},\n           {module_info,1}]},\n {attributes,[{vsn,[243820355007545606700617893262330487884]},\n              {author,\"Mochi Media <dev@mochimedia.com>\"}]},\n {compile,[{options,[{outdir,\"ebin\"},\n                     debug_info,debug_info,\n                     {i,\"include\"}]},\n           {version,\"6.0\"},\n           {time,{2015,7,17,4,17,8}},\n           {source,\"/home/youthy/code/helloworld/src/helloworld_web.erl\"}]},\n {native,false},\n {md5,<<183,110,23,159,102,166,62,91,144,171,107,229,135,\n        128,228,76>>}]\n(helloworld_dev@youthy)2> \nUser switch command\n --> q\nyouthy@youthy:~$ \n```\n\n值得注意的是1 必须给节点一个名字且命名方式需要一致。2退出时，不要用q()之类的，否则退出的时对面的节点。需要用ctrl+G然后q的方式。\n\n### -rsh Program\n一般用来启用slave节点时用到。下面例子一开始我们进程中没有erl shell先启动一个master节点。然后在master节点里调用slave:start_link(Host, Name, Args)的方式。启动一个slave节点。这时我们看到进程里面有了两个erl shell。其中一个是已-noshell, noinput等方式启动的。这个就是slave启动的奴隶节点。我们可以用rpc调用一个功能，然后结果会返回给master节点。\n因为我只有一台机器，如果不用\"-rsh ssh\"也是可以成功的。但是如果真是在其他机器上还是要加上ssh。两台节点环境，erl版本需一致。master节点退出后，不管时start_link启动还是start启动的slave节点都会退出。\n```\nyouthy@youthy:~$ ps -ef | grep erl\nyouthy   13884  2086  0 14:47 ?        00:00:00 /home/youthy/erls/R15B/erts-5.9/bin/epmd -daemon\nyouthy   23280 13177  0 15:19 pts/0    00:00:00 grep --color=auto erl\nyouthy@youthy:~$ erl -sname master\nErlang R15B (erts-5.9) [source] [64-bit] [smp:4:4] [async-threads:0] [hipe] [kernel-poll:false]\n\nEshell V5.9  (abort with ^G)\n(master@youthy)1> \n[1]+  已停止               erl -sname master\nyouthy@youthy:~$ ps -ef | grep erl\nyouthy   13884  2086  0 14:47 ?        00:00:00 /home/youthy/erls/R15B/erts-5.9/bin/epmd -daemon\nyouthy   23299 13177  1 15:19 pts/0    00:00:00 /home/youthy/erls/R15B/erts-5.9/bin/beam.smp -- -root /home/youthy/erls/R15B -progname erl -- -home /home/youthy -- -sname master\nyouthy   23336 13177  0 15:19 pts/0    00:00:00 grep --color=auto erl\nyouthy@youthy:~$ fg\nerl -sname master\n\n(master@youthy)1> slave:start_link('youthy', 'slave', \"-rsh ssh\").\n{ok,slave@youthy}\n(master@youthy)2> \n[1]+  已停止               erl -sname master\nyouthy@youthy:~$ ps -ef | grep erl\nyouthy   13884  2086  0 14:47 ?        00:00:00 /home/youthy/erls/R15B/erts-5.9/bin/epmd -daemon\nyouthy   23299 13177  0 15:19 pts/0    00:00:00 /home/youthy/erls/R15B/erts-5.9/bin/beam.smp -- -root /home/youthy/erls/R15B -progname erl -- -home /home/youthy -- -sname master\nyouthy   23546  2086  0 15:20 ?        00:00:00 /home/youthy/erls/R15B/erts-5.9/bin/beam.smp -- -root /home/youthy/erls/R15B -progname erl -- -home /home/youthy -- -noshell -noinput -noshell -noinput -master master@youthy -sname slave@youthy -s slave slave_start master@youthy slave_waiter_0 -rsh ssh\nyouthy   23587 13177  0 15:20 pts/0    00:00:00 grep --color=auto erl\nyouthy@youthy:~$ fg\nerl -sname master\n\n(master@youthy)2> rpc:call('slave@youthy', lists, sum, [[2,3,4]]).\n9\n(master@youthy)3> \n```\n\n### -set_cookie Cookie\n等同于erlang:set_cookie/2\n\n### -shutdown_time Time\nTime是ms毫秒。设置关闭erl节点的时间，如果时间到了还没有结束完，就强制结束掉还存在的进程。\n```\nyouthy@youthy:~$ erl -shutdown_time 1000\nErlang R15B (erts-5.9) [source] [64-bit] [smp:4:4] [async-threads:0] [hipe] [kernel-poll:false]\n\nEshell V5.9  (abort with ^G)\n1> q().\nok\n2> {init,shutdown_timeout}\nyouthy@youthy:~$ \nyouthy@youthy:~$ erl -shutdown_time 4000\nErlang R15B (erts-5.9) [source] [64-bit] [smp:4:4] [async-threads:0] [hipe] [kernel-poll:false]\n\nEshell V5.9  (abort with ^G)\n1> q().\nok\n2> youthy@youthy:~$ \n```\n\n如上，1秒的时间看来时不够用的。\n### -smp enable/auto/disable\n是否启用smp，默认时auto。auto自动检测。如果符合会自动开启smp。\n[关于smp](http://www.cnblogs.com/me-sa/archive/2012/02/01/erlang0035.html).\n### -version\n打印version信息。\n","source":"_posts/erl命令和参数.md","raw":"title: erl命令和参数\ndate: 2015-07-22 10:11:37\ntags: erlang\n\n---\n\n\n## Startup\n先拿mochiweb生成的一个例子说起，这是start-dev.sh脚本中的内容。启动一个mochiweb应用调用的就是这个\n```\n#!/bin/sh\nexec erl \\\n    -pa ebin deps/*/ebin \\\n    -boot start_sasl \\\n    -sname helloworld_dev \\\n    -s helloworld \\\n    -s reloader\n```\n\n<!--more-->\n通用形式就是\n> erl -a b --sth -c d +f g -extra abc\n\nerl后面的都是参数arguments\narguments可以分为**emulator flags**，**flags**，**plain arguments**\n    * 任何已+开始的参数会被解释为emulator flags\n    * 任何以-开始的参数会被解释为flags，并传入交给了init模块。\n    * 在--之后到任何-或者+符号之间的所有flags以及-extra之后所有的flags都是plain arguments，这些参数不会发生解释行为，只不过被储存起来。同样交给init模块。\ninit:boot(Args)函数接受上面的flags和plain arguments。\n\n>**boot(BootArgs) -> no_return()\nTypes:\nBootArgs = [binary()]**\nStarts the Erlang runtime system. This function is called when the emulator is started and coordinates system start-up.\nBootArgs are all command line arguments except the emulator flags, that is, flags and plain arguments. See erl(1).\ninit itself interprets some of the flags, see Command Line Flags below. The remaining flags (\"user flags\") and plain arguments are passed to the init loop and can be retrieved by callingget_arguments/0 and get_plain_arguments/0, respectively.\n\nflags会被boot函数分为 init flags和user flags。user flags可以通过init:get_arguments()得到，plain arguments通过init:get_plain_arguments()得到。值得注意的是一小部分的“-”后面的flags现在是属于emulator flags。后面提到。\n\n<!-- toc -->\n\n## Init Flags\n### --(两个横杠)\n任何在--到下一个-或者+之间的都是plain arguments，可以通过init:get_plain_arguments()取到.\n### -extra\n和--的作用一样，extra后面的flags都是plain arguments\n### -code_path_choice Choice::strict|relexed\n> When the choice of directories in the code path is strict, the directory that ends up in the code path will be exactly the stated one. This means that if for example the directory \\$OTPROOT/lib/mnesia-4.4.7/ebin is explicitly added to the code path, the code server will not load files from $OTPROOT/lib/mnesia-4.4.7.ez/mnesia-4.4.7/ebin and vice versa.\n\n> This behavior can be controlled via the command line flag -code_path_choice Choice. If the flag is set to relaxed, the code server will instead choose a suitable directory depending on the actual file structure. If there exists a regular application ebin directory,situation it will be chosen. But if it does not exist, the ebin directory in the archive is chosen if it exists. If neither of them exists the original directory will be chosen.\n```\n\"/home/yuyouqi/Erlang/lib/snmp-5.1.1/ebin\",\n \"/home/yuyouqi/Erlang/lib/sasl-2.4.1/ebin\",\n \"/home/yuyouqi/Erlang/lib/runtime_tools-1.8.15/ebin\",\n \"/home/yuyouqi/Erlang/lib/reltool-0.6.6/ebin\",\n```\n\n```\n \"/home/yuyouqi/Erlang/lib/ssh-3.1/ebin\",\n \"/home/yuyouqi/Erlang/lib/snmp-5.1.1/ebin\",\n \"/home/yuyouqi/Erlang/lib/sasl-2.4.1.ez/sasl-2.4.1/ebin\",\n \"/home/yuyouqi/Erlang/lib/runtime_tools-1.8.15/ebin\",\n 3> code:lib_dir(sasl, ebin).\n\"/home/yuyouqi/Erlang/lib/sasl-2.4.1.ez/sasl-2.4.1/ebin\"\n```\n### -eval Expr\nExpr是个函数，在erl初始化时按顺序执行，如果fail的，则初始化失败。例如\n```\nerl -eval '{X,Y,Z} = now(), random:seed(X,Y,Z).'\n```\n> 官方文档Z}旁边多了‘符号，需要去掉\n\n### -run Mod Func Arg1 Arg2....ArgN\n调用Mod:Func([\"Arg1\", \"Arg2\", ...\"ArgN\"]),\n所有参数都是以string方式传入的。同样按顺序执行，前一个执行完才会执行下一个。但是貌似并不会阻塞shell。\n### -s Mod Func Arg1 Arg2 ... ArgN\n与run完成同样的功能，但是Arg都是atom的形式传入，值得注意的是数字也会变成atom,\n```\nerl -s test time 5000 atom\n```\n\n就是test:time(['5000', atom]).\n一般数字需要atom_to_list, list_to_integer转换。\n\n##User flags\n\n### -ApplicationName Par Val\n指定应用的名字，属性名称和值，可以将应用的某个参数设置成Val。\n比如\n```\n erl -pa ./ebin -s helloworld -helloworld par haha\n 1> application:get_all_key(helloworld).\n{ok,[{description,\"helloworld\"},\n     {id,[]},\n     {vsn,\"0.1\"},\n     {modules,[helloworld,helloworld_app,helloworld_deps,\n               helloworld_dtl,helloworld_sup,helloworld_web]},\n     {maxP,infinity},\n     {maxT,infinity},\n     {registered,[]},\n     {included_applications,[]},\n     {applications,[kernel,stdlib,crypto]},\n     {env,[{par,haha},{included_applications,[]}]},\n     {mod,{helloworld_app,[]}},\n     {start_phases,undefined}]}\n2> application:get_all_env(helloworld).\n[{par,haha},{included_applications,[]}]\n```\n\n启动了一个helloworld应用，并将par参数设置成haha。\n\n### -args_file FileName\n直接从FileName读取erl所用的参数。例如在agrsfile的文件中写入如下\n> -eval 'io:format(\"read from file~n\")' -extra hello -pa ./ebin\n\n实际结果\n```\nerl -args_file argsfile\nErlang R15B (erts-5.9) [source] [smp:2:2] [async-threads:0] [hipe] [kernel-poll:false]\n\nEshell V5.9  (abort with ^G)\n1> read from file\n1> init:get_arguments().\n[{root,[\"/usr/local/lib/erlang\"]},\n {progname,[\"erl\"]},\n {home,[\"/home/yuyouqi\"]}]\n2> init:get_plain_arguments().\n[\"hello\",\"-pa\",\"./ebin\"]\n```\n\n可以看到启动的时候执行了io:format函数，但是-extra这个参数是特殊的，正常情况下-extra到下一个-或者+之间的参数才会被认为是plain arguments，可是如果写在文件中就变成-extra后面所有的参数，都会当成plain arguments.只有这点不同。\n\n### -async_shell_start\n名字上来说是异步启动shell\n\n### -boot File\n试用File.boot启动erl系统,除非File是个绝对路径，否则在当前文件夹和$ROOT/bin下面找（我的:/usr/local/lib/erlang/bin,  $ROOT可以通过code:root_dir()查看),\n默认情况下是-boot start\n[script](http://www.erlang.org/doc/man/script.html)\n> The command erl -boot Name starts the system with a boot file called Name.boot, which is generated from the Name.script file, using systools:script2boot/1.\nThe .script file is generated by systools from a .rel file and .app files.\n\n.boot文件是用systools产生的，打开后是乱码.\n文件的生成顺序 .rel -> .script -> .boot\n[systools](http://erlang.org/doc/man/systools.html)\nsystools里面提供了生成rel,script, boot等方法。可以在`/usr/local/lib/erlang/releases/R15B`下找到几个官方的rel，script，boot\n```\nUbuntu@desktop:/usr/local/lib/erlang/releases/R15B$ ls\nstart_all_example.rel  start_clean.boot  start_clean.script  start_sasl.rel     start.script\nstart.boot             start_clean.rel   start_sasl.boot     start_sasl.script\n```\n\n打开start_sasl.rel\n```\n%%注释....\n{release, {\"OTP  APN 181 01\",\"R15B\"}, {erts, \"5.9\"},\n [{kernel,\"2.15\"},\n  {stdlib,\"1.18\"},\n  {sasl, \"2.2\"}]}.\n```\n\n具体格式在上面的systools链接中有说明\n仿照它这个样子写一个test\n```\n{release, {\"test_rel\",\"0.1\"}, {erts, \"5.9\"},\n [{kernel,\"2.15\"},\n  {stdlib,\"1.18\"},\n  {sasl, \"2.2\"},\n  {crypto, \"2.1\"},\n  {helloworld,\"0.1\"}]}.\n```\n\nhelloworld使用mochiweb生成的简单框架,用到了crypto，所以讲crypto加入。\n```\nErlang R15B (erts-5.9) [source] [smp:2:2] [async-threads:0] [hipe] [kernel-poll:false]\n\nEshell V5.9  (abort with ^G)\n1> systools:make_script(\"test\").       \nhelloworld: File not found: \"helloworld.app\"\n\nerror\n2> systools:make_script(\"test\", [{path, [\"ebin\"]}]).\nok\n```\n由于helloworld不在默认的ebin下，所以下加上当前路径中的ebin。否则找不到helloworld.app\n如果是使用systools的make_script命令省的script会自动生成.boot。打开test.script\n```\n%% script generated at {2015,7,1} {12,5,26}\n{script,\n    {\"test_rel\",\"0.1\"},\n    [{preLoaded,\n         [erl_prim_loader,erlang,init,otp_ring0,prim_file,prim_inet,prim_zip,\n          zlib]},\n     {progress,preloaded},\n     {path,[\"$ROOT/lib/kernel-2.15/ebin\",\"$ROOT/lib/stdlib-1.18/ebin\"]},\n     {primLoad,[error_handler]},\n     {kernel_load_completed},\n     {progress,kernel_load_completed},\n     {path,[\"$ROOT/lib/kernel-2.15/ebin\"]},\n     {primLoad,\n         [application,application_controller,application_master,\n          application_starter,auth,code,code_server,disk_log,disk_log_1,\n          disk_log_server,disk_log_sup,dist_ac,dist_util,erl_boot_server,\n          erl_ddll,erl_distribution,erl_epmd,erl_reply,error_logger,\n          erts_debug,file,file_io_server,file_server,gen_sctp,gen_tcp,gen_udp,\n          global,global_group,global_search,group,heart,hipe_unified_loader,\n          inet,inet6_sctp,inet6_tcp,inet6_tcp_dist,inet6_udp,inet_config,\n          inet_db,inet_dns,inet_gethost_native,inet_hosts,inet_parse,inet_res,\n          inet_sctp,inet_tcp,inet_tcp_dist,inet_udp,kernel,kernel_config,net,\n          net_adm,net_kernel,os,packages,pg2,ram_file,rpc,seq_trace,\n          standard_error,user,user_drv,user_sup,wrap_log_reader]},\n     {path,[\"$ROOT/lib/stdlib-1.18/ebin\"]},\n...\n...\n```\n\n有了.boot文件后就可以使用了\n```\nyuyouqi@yuyouqi-desktop:~/Erlang/helloworld$ erl -pa ebin deps/*/ebin -boot test\nErlang R15B (erts-5.9) [source] [smp:2:2] [async-threads:0] [hipe] [kernel-poll:false]\n\n\n=PROGRESS REPORT==== 1-Jul-2015::12:10:49 ===\n          supervisor: {local,sasl_safe_sup}\n             started: [{pid,<0.35.0>},\n                       {name,alarm_handler},\n                       {mfargs,{alarm_handler,start_link,[]}},\n                       {restart_type,permanent},\n                       {shutdown,2000},\n                       {child_type,worker}]\n\n=PROGRESS REPORT==== 1-Jul-2015::12:10:49 ===\n          supervisor: {local,sasl_safe_sup}\n             started: [{pid,<0.36.0>},\n                       {name,overload},\n                       {mfargs,{overload,start_link,[]}},\n                       {restart_type,permanent},\n                       {shutdown,2000},\n                       {child_type,worker}]\n\n=PROGRESS REPORT==== 1-Jul-2015::12:10:49 ===\n          supervisor: {local,sasl_sup}\n             started: [{pid,<0.34.0>},\n                       {name,sasl_safe_sup},\n                       {mfargs,\n                           {supervisor,start_link,\n                               [{local,sasl_safe_sup},sasl,safe]}},\n                       {restart_type,permanent},\n                       {shutdown,infinity},\n                       {child_type,supervisor}]\n\n=PROGRESS REPORT==== 1-Jul-2015::12:10:49 ===\n          supervisor: {local,sasl_sup}\n             started: [{pid,<0.37.0>},\n                       {name,release_handler},\n                       {mfargs,{release_handler,start_link,[]}},\n                       {restart_type,permanent},\n                       {shutdown,2000},\n                       {child_type,worker}]\n\n=PROGRESS REPORT==== 1-Jul-2015::12:10:49 ===\n         application: sasl\n          started_at: nonode@nohost\n\n=PROGRESS REPORT==== 1-Jul-2015::12:10:49 ===\n          supervisor: {local,crypto_sup}\n             started: [{pid,<0.43.0>},\n                       {name,crypto_server},\n                       {mfargs,{crypto_server,start_link,[]}},\n                       {restart_type,permanent},\n                       {shutdown,2000},\n                       {child_type,worker}]\n\n=PROGRESS REPORT==== 1-Jul-2015::12:10:49 ===\n         application: crypto\n          started_at: nonode@nohost\n** Found 0 name clashes in code paths \n\n=PROGRESS REPORT==== 1-Jul-2015::12:10:49 ===\n          supervisor: {local,helloworld_sup}\n             started: [{pid,<0.48.0>},\n                       {name,helloworld_web},\n                       {mfargs,\n                           {helloworld_web,start,\n                               [[{ip,{0,0,0,0}},\n                                 {port,8080},\n                                 {docroot,\n                                     \"/home/yuyouqi/Erlang/helloworld/priv/www\"}]]}},\n                       {restart_type,permanent},\n                       {shutdown,5000},\n                       {child_type,worker}]\n\n=PROGRESS REPORT==== 1-Jul-2015::12:10:49 ===\n         application: helloworld\n          started_at: nonode@nohost\nEshell V5.9  (abort with ^G)\n1> \n```\n\n### -boot_var Var Dir\n指定一个变量Var的路径为Dir，主要用于systools:make_script的{variables, [{\"Var\", \"Prefix\"}]},\n因为默认的script路径都是在$ROOT/lib下寻找，当在make_script中加入variables选项时，\n\n### -code_path_cache\n使用codepath的缓存，这样做的好处是加载模块更快，而且可以在常数时间找到模块，如果没加则需要search这个codepath才能找到对应模块，在模块数量很多时，可以使用。\n### -compile Mod1 Mod2 ...\n编译Mod1 Mod2 ... 如果失败会返回非零的错误码 默认同时使用了-noinput参数.**不推荐使用，推荐erlc**\n### connect_all true|false\n是否全联通（N1-N2， N2-N3 -> N1-N2-N3），如果是false那么global模块的注册名字的相关机制无法使用\n### -config Config\n读取Config文件，名字为AppName.config.\n格式\n> [{AppName, [{Key1, Value1}...]}, {AppName2, [...]}].\n\n见[config file](http://www.erlang.org/doc/man/config.html).\n例如新建helloworld.config\n```\n[{helloworld, [{key1, val1}, {key2, val2}]}].\n```\n\n并在start脚本中加入-config helloworld.config\n```\n#!/bin/sh\nexec erl \\\n    -pa ebin deps/*/ebin \\\n    -boot start_sasl \\\n    -sname helloworld_dev \\\n    -s helloworld \\\n    -s reloader \\\n    -config helloworld.config\n```\n\n如下看到在env中多了写入的config值\n\n```\n(helloworld_dev@Ubuntu-desktop)1> application:get_all_key(helloworld).\n{ok,[{description,\"helloworld\"},\n     {id,[]},\n     {vsn,\"0.1\"},\n     {modules,[helloworld,helloworld_app,helloworld_deps,\n               helloworld_dtl,helloworld_sup,helloworld_web]},\n     {maxP,infinity},\n     {maxT,infinity},\n     {registered,[]},\n     {included_applications,[]},\n     {applications,[kernel,stdlib,crypto]},\n     {env,[{included_applications,[]},{key2,val2},{key1,val1}]},\n     {mod,{helloworld_app,[]}},\n     {start_phases,undefined}]}\n```\n\n### -cookie Cookie\n过时的没有任何效果的标志，是setcookie的错误拼写，用setcookie代替。\n### -setcookie Cookie\n和erlang:set_cookie(Node, Cookie)的效果一样。给本地结点设置需要给本地结点起个名字-name/sname\n### -detached\n以background的形式运行erl，与当前shell分离开，但是需要知道如何停止这个系统\n[How to stop](http://stackoverflow.com/questions/15464606/erlang-kill-all-processes-running-in-background).\n### -emu_args\n打印传给emulator的参数，比如在start-dev.sh脚本中加入它，可以看到\n```\nyuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ ./start-dev.sh \nExecuting: /usr/local/lib/erlang/erts-5.9/bin/beam.smp /usr/local/lib/erlang/erts-5.9/bin/beam.smp -- -root /usr/local/lib/erlang -progname erl -- -home /home/yuyouqi -- -pa ebin deps/erlydtl/ebin deps/eunit_formatters/ebin deps/merl/ebin deps/mochiweb/ebin -boot start_sasl -sname helloworld_dev -s helloworld -s reloader\n\nErlang R15B (erts-5.9) [source] [smp:2:2] [async-threads:0] [hipe] [kernel-poll:false]\n```\n\n### -env Variable Value\n设置OS模块的环境变量Variable为Value.\n通过os:getenv/0 getenv/1可以得到\n### -heart\n开启心跳检测，尽管erlang有各种supervisor监管机制，但是如果emulator down掉了就完了，-heart会开启一个heart进程监控整个emulator，在规定时间内如果没有收到心跳，这个进程就会执行HEART_COMMAND参数，如果这个参数没有设定，那么只会弹出警告，而不会重启。一般HEART_COMMAND就是重启emulator。麻烦的是如果设定了heart，但是没有用-sname，是无法回到这个erlang shell的，也就是无法调用init：stop()来终止heart的监控策略。\n\n在没有开启任何erl shell的情况下调用`ps -ef|grep erl`看到跟erl有关的进程如下\n```\nyuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ ps -ef |grep erl\nyuyouqi   2475  2345  0 10:23 ?        00:00:01 /usr/bin/perl /usr/bin/shutter --min_at_startup\nyuyouqi   3329  2862  0 10:58 pts/2    00:00:00 grep --color=auto erl\n```\n\n启动一个erl emulator,然后Ctrl + z放到挂起\n```\nyuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ erl \nErlang R15B (erts-5.9) [source] [smp:2:2] [async-threads:0] [hipe] [kernel-poll:false]\n\nEshell V5.9  (abort with ^G)\n1> \n[1]+  已停止               erl\nyuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ ps -ef |grep erl\nyuyouqi   2475  2345  0 10:23 ?        00:00:01 /usr/bin/perl /usr/bin/shutter --min_at_startup\nyuyouqi   3333  2862  0 11:01 pts/2    00:00:00 /usr/local/lib/erlang/erts-5.9/bin/beam.smp -- -root /usr/local/lib/erlang -progname erl -- -home /home/yuyouqi --\nyuyouqi   3346  2862  0 11:01 pts/2    00:00:00 grep --color=auto erl\n```\n\n可以看到3333这个进程后面的命令是开启一个erl emulator的\n```\nyuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ kill -9 3333\nyuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ ps -ef | grep erl\nyuyouqi   2475  2345  0 10:23 ?        00:00:01 /usr/bin/perl /usr/bin/shutter --min_at_startup\nyuyouqi   3366  2862  0 11:04 pts/2    00:00:00 grep --color=auto erl\n[1]+  已杀死               erl\n```\n\n可以看到将他kill掉是没问题的\n下面启动一个-heart erl shell\n```\nyuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ erl -sname test1 -heart -env HEART_COMMAND \"erl -sname test1 -heart\"\nheart_beat_kill_pid = 3369\nErlang R15B (erts-5.9) [source] [smp:2:2] [async-threads:0] [hipe] [kernel-poll:false]\n\nEshell V5.9  (abort with ^G)\n(test1@yuyouqi-desktop)1> \n[1]+  已停止               erl -sname test1 -heart -env HEART_COMMAND \"erl -sname test1 -heart\"\nyuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ ps -ef | grep erl\nyuyouqi   2475  2345  0 10:23 ?        00:00:01 /usr/bin/perl /usr/bin/shutter --min_at_startup\nyuyouqi   3369  2862  1 11:05 pts/2    00:00:00 /usr/local/lib/erlang/erts-5.9/bin/beam.smp -- -root /usr/local/lib/erlang -progname erl -- -home /home/yuyouqi -- -sname test1 -heart\nyuyouqi   3376  2219  0 11:05 ?        00:00:00 /usr/local/lib/erlang/erts-5.9/bin/epmd -daemon\nyuyouqi   3387  2862  0 11:06 pts/2    00:00:00 grep --color=auto erl\n\nyuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ heart: Fri Jul  3 11:06:57 2015: heart-beat time-out.\nheart_beat_kill_pid = 3390\nyuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ ps -ef | grep erl\nyuyouqi   2475  2345  0 10:23 ?        00:00:01 /usr/bin/perl /usr/bin/shutter --min_at_startup\nyuyouqi   3376  2219  0 11:05 ?        00:00:00 /usr/local/lib/erlang/erts-5.9/bin/epmd -daemon\nyuyouqi   3389  3383  0 11:06 ?        00:00:00 sh -c erl -sname test1 -heart\nyuyouqi   3390  3389  0 11:06 ?        00:00:00 /usr/local/lib/erlang/erts-5.9/bin/beam.smp -- -root /usr/local/lib/erlang -progname erl -- -home /home/yuyouqi -- -sname test1 -heart\nyuyouqi   3410  2862  0 11:07 pts/2    00:00:00 grep --color=auto erl\n```\n\n上面命令是我用-heart启动一个erl shell，可以看到多了3369 和3376这两个进程，把erl shell挂起，一段时间后，由于heart进程没有接收到“心跳”，重启了erl shell,pid变为3390。而且多出了一个3389这个进程，而3390这个erl shell是3389的子进程。可以看到3389就是执行我们的HEART_COMMAND\n如果不指定HEART_COMMAND\n```\nyuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ erl -sname test2 -heart\nheart_beat_kill_pid = 3685\nErlang R15B (erts-5.9) [source] [smp:2:2] [async-threads:0] [hipe] [kernel-poll:false]\n\nEshell V5.9  (abort with ^G)\n(test2@yuyouqi-desktop)1> \n[1]+  已停止               erl -sname test2 -heart\nyuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ ps -ef|grep erl\nyuyouqi   2475  2345  0 10:23 ?        00:00:01 /usr/bin/perl /usr/bin/shutter --min_at_startup\nyuyouqi   3376  2219  0 11:05 ?        00:00:00 /usr/local/lib/erlang/erts-5.9/bin/epmd -daemon\nyuyouqi   3389  3383  0 11:06 ?        00:00:00 sh -c erl -sname test1 -heart\nyuyouqi   3390  3389  0 11:06 ?        00:00:00 /usr/local/lib/erlang/erts-5.9/bin/beam.smp -- -root /usr/local/lib/erlang -progname erl -- -home /home/yuyouqi -- -sname test1 -heart\nyuyouqi   3685  2862  2 12:15 pts/2    00:00:00 /usr/local/lib/erlang/erts-5.9/bin/beam.smp -- -root /usr/local/lib/erlang -progname erl -- -home /home/yuyouqi -- -sname test2 -heart\nyuyouqi   3703  2862  0 12:15 pts/2    00:00:00 grep --color=auto erl\nyuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ jobs\n[1]+  已停止               erl -sname test2 -heart\nyuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ fg\nerl -sname test2 -heart\n\n(test2@yuyouqi-desktop)1> \nUser switch command\n --> q\nyuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ heart: Fri Jul  3 12:16:10 2015: Erlang has closed.\nheart: Fri Jul  3 12:16:10 2015: Would reboot. Terminating.\n\nyuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ ps -ef|grep erl\nyuyouqi   2475  2345  0 10:23 ?        00:00:01 /usr/bin/perl /usr/bin/shutter --min_at_startup\nyuyouqi   3376  2219  0 11:05 ?        00:00:00 /usr/local/lib/erlang/erts-5.9/bin/epmd -daemon\nyuyouqi   3389  3383  0 11:06 ?        00:00:00 sh -c erl -sname test1 -heart\nyuyouqi   3390  3389  0 11:06 ?        00:00:00 /usr/local/lib/erlang/erts-5.9/bin/beam.smp -- -root /usr/local/lib/erlang -progname erl -- -home /home/yuyouqi -- -sname test1 -heart\nyuyouqi   3705  2862  0 12:16 pts/2    00:00:00 grep --color=auto erl\n```\n\n新建一个test2 shell，不设置HEART_COMMAND，\n可以看到如果没有设置HEART_COMMAND 使用ctrl g退出后不会重启，但是test1是会重启的。\n而且新建节点后发现-daemon进程并没有增加，我猜测-daemon有可能是heart监控进程。\n但是无论怎样kill都是无效的，依然会重启\n```\nyuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ kill -9 3376 3389 3390\nyuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ heart: Fri Jul  3 12:21:15 2015: Executed \"erl -sname test1 -heart\". Terminating.\nheart: Fri Jul  3 12:21:15 2015: Erlang has closed.\nheart_beat_kill_pid = 3716\n\nyuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ ps -ef|grep erl\nyuyouqi   2475  2345  0 10:23 ?        00:00:01 /usr/bin/perl /usr/bin/shutter --min_at_startup\nyuyouqi   3715  3404  0 12:21 ?        00:00:00 sh -c erl -sname test1 -heart\nyuyouqi   3716  3715  3 12:21 ?        00:00:00 /usr/local/lib/erlang/erts-5.9/bin/beam.smp -- -root /usr/local/lib/erlang -progname erl -- -home /home/yuyouqi -- -sname test1 -heart\nyuyouqi   3723  2219  0 12:21 ?        00:00:00 /usr/local/lib/erlang/erts-5.9/bin/epmd -daemon\nyuyouqi   3734  2862  0 12:21 pts/2    00:00:00 grep --color=auto erl\n```\n\n这时就需要进入test1，调用init:stop()来结束\n```\nyuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ erl -sname test2\nErlang R15B (erts-5.9) [source] [smp:2:2] [async-threads:0] [hipe] [kernel-poll:false]\n\nEshell V5.9  (abort with ^G)\n(test2@yuyouqi-desktop)1> \nUser switch command\n --> r 'test1@yuyouqi-desktop'\n --> c\nEshell V5.9  (abort with ^G)\n(test1@yuyouqi-desktop)1> init:stop().\n*** ERROR: Shell process terminated! (^G to start new job) ***\nheart: Fri Jul  3 12:23:40 2015: Executed \"erl -sname test1 -heart\". Terminating.\n\nUser switch command\n --> j\n   1  {shell,start,[init]}\n --> c 1\n\n(test2@yuyouqi-desktop)1>        \nUser switch command\n --> q\nyuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ ps -ef|grep erl\nyuyouqi   2475  2345  0 10:23 ?        00:00:01 /usr/bin/perl /usr/bin/shutter --min_at_startup\nyuyouqi   3723  2219  0 12:21 ?        00:00:00 /usr/local/lib/erlang/erts-5.9/bin/epmd -daemon\nyuyouqi   3760  2862  0 12:24 pts/2    00:00:00 grep --color=auto erl\n```\n\n这样才能将heart监控的shell关闭(或者使用rpc)\n参考[Is there a way to kill the erlang vm when it is running with -heart](http://stackoverflow.com/questions/7217892/is-there-a-way-to-kill-the-erlang-vm-when-it-is-running-with-heart)\n\n### -hidden\n已hidden启动的结点在于其他结点连接时，他的连接时隐藏的，不会再nodes()中得到自己的名字。只有与自己同属于一个[global_group](http://www.erlang.org/doc/man/global_group.html#type-group_name)的其他结点才能知道自己。\n比如建立一个kernel.config,定义一个global_group\n```\n[{kernel, [{global_groups, [{test, ['test1@yuyouqi-desktop', 'test2@yuyouqi-desktop']}]}]}].\n```\n\n然后启动3个结点test1，test2，test3\n```\nyuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ erl -sname test1 -config kernel.config \nErlang R15B (erts-5.9) [source] [smp:2:2] [async-threads:0] [hipe] [kernel-poll:false]\n\nEshell V5.9  (abort with ^G)\n(test1@yuyouqi-desktop)1> global_group:global_groups().\n{test,[]}\nyuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ erl -sname test2 -hidden -config kernel.config \nErlang R15B (erts-5.9) [source] [smp:2:2] [async-threads:0] [hipe] [kernel-poll:false]\n\nEshell V5.9  (abort with ^G)\n(test2@yuyouqi-desktop)1> global_group:global_groups().\n{test,[]}\nyuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ erl -sname test3 -config kernel.config \nErlang R15B (erts-5.9) [source] [smp:2:2] [async-threads:0] [hipe] [kernel-poll:false]\n\nEshell V5.9  (abort with ^G)\n(test3@yuyouqi-desktop)1> global_group:global_groups().\n{no_name,[test]}\n```\n\n其中test2已hidden形式启动，test3不在global_group中，可以看到test1和test2返回自己的global_group为test。\n用`net_kernel:connect`将它们互联。\n```\n(test2@yuyouqi-desktop)2> net_kernel:connect('test1@yuyouqi-desktop').\ntrue\n(test2@yuyouqi-desktop)3> nodes().\n['test1@yuyouqi-desktop']\n(test2@yuyouqi-desktop)5> net_kernel:connect('test3@yuyouqi-desktop').\ntrue\n(test2@yuyouqi-desktop)6> nodes().\n['test1@yuyouqi-desktop']\n(test1@yuyouqi-desktop)2> nodes().\n['test2@yuyouqi-desktop']\n(test3@yuyouqi-desktop)2> nodes().\n[]\n```\n\ntest1和test2是可以互相看到的，而test3的nodes()返回的是空\n\n### -init_debug\n启动的时候打印调试参数。可以尝试下`erl -init_debug` 然后对照着`/usr/local/lib/erlang/releases/RXXB/start.script`\n\n### -make\n相当于make:all(),见\n[make](http://www.erlang.org/doc/man/make.html)\n### -man Module\n查询某个模块的手册，首先需要去官网下载相应的手册\n### -mode interactive|embedded\nerlang system载入代码的方式，interactive模式下，系统只载入一部分代码，当使用为载入的代码时，会尝试自动载入这个模块。如果是embeded模式，实在系统初始化时，根据启动的script文件载入所有代码，如果文件上没有提到，不会载入，如果调用为载入模块的函数，会报exception error\n### -name/sname NAME\n```\nerl -sname test1\nerl -name test2@192.168.1.10\n```\n\nsname 与name之间的结点不能通信，必须命名方式相同才可以。 sname只能用于同一子网内的机器。\n### -noinput\nerl不读入任何参数\n### -noshell\n常用，不显示erl shell。一般都是执行一系列的-eval，-s，-ran，然后init:stop().\n### -pa/-pz \n添加code路径，没什么可说的同code:addpathsa/addpathsz\n### -remsh Node\n远程链接一个节点。例如在shell1中启动一个mochiweb例子\n```\nyouthy@youthy:~/code/helloworld$ ./start-dev.sh \n...=PROGRESS REPORT==== 17-Jul-2015::12:20:43 ===\n          supervisor: {local,kernel_safe_sup}\n             started: [{pid,<0.74.0>},\n                       {id,timer_server},\n                       {mfargs,{timer,start_link,[]}},\n                       {restart_type,permanent},\n                       {shutdown,1000},\n                       {child_type,worker}]\n\n(helloworld_dev@youthy)1> \n```\n\n然后在shell2中链接这个节点。\n```\nyouthy@youthy:~$ erl -sname test2 -remsh helloworld_dev@youthy\nErlang R15B (erts-5.9) [source] [64-bit] [smp:4:4] [async-threads:0] [hipe] [kernel-poll:false]\n\nEshell V7.0  (abort with ^G)\n(helloworld_dev@youthy)1> helloworld_web:\nloop/2         module_info/0  module_info/1  start/1        stop/0         \n\n(helloworld_dev@youthy)1> helloworld_web:module_info().\n[{module,helloworld_web},\n {exports,[{start,1},\n           {stop,0},\n           {loop,2},\n           {module_info,0},\n           {module_info,1}]},\n {attributes,[{vsn,[243820355007545606700617893262330487884]},\n              {author,\"Mochi Media <dev@mochimedia.com>\"}]},\n {compile,[{options,[{outdir,\"ebin\"},\n                     debug_info,debug_info,\n                     {i,\"include\"}]},\n           {version,\"6.0\"},\n           {time,{2015,7,17,4,17,8}},\n           {source,\"/home/youthy/code/helloworld/src/helloworld_web.erl\"}]},\n {native,false},\n {md5,<<183,110,23,159,102,166,62,91,144,171,107,229,135,\n        128,228,76>>}]\n(helloworld_dev@youthy)2> \nUser switch command\n --> q\nyouthy@youthy:~$ \n```\n\n值得注意的是1 必须给节点一个名字且命名方式需要一致。2退出时，不要用q()之类的，否则退出的时对面的节点。需要用ctrl+G然后q的方式。\n\n### -rsh Program\n一般用来启用slave节点时用到。下面例子一开始我们进程中没有erl shell先启动一个master节点。然后在master节点里调用slave:start_link(Host, Name, Args)的方式。启动一个slave节点。这时我们看到进程里面有了两个erl shell。其中一个是已-noshell, noinput等方式启动的。这个就是slave启动的奴隶节点。我们可以用rpc调用一个功能，然后结果会返回给master节点。\n因为我只有一台机器，如果不用\"-rsh ssh\"也是可以成功的。但是如果真是在其他机器上还是要加上ssh。两台节点环境，erl版本需一致。master节点退出后，不管时start_link启动还是start启动的slave节点都会退出。\n```\nyouthy@youthy:~$ ps -ef | grep erl\nyouthy   13884  2086  0 14:47 ?        00:00:00 /home/youthy/erls/R15B/erts-5.9/bin/epmd -daemon\nyouthy   23280 13177  0 15:19 pts/0    00:00:00 grep --color=auto erl\nyouthy@youthy:~$ erl -sname master\nErlang R15B (erts-5.9) [source] [64-bit] [smp:4:4] [async-threads:0] [hipe] [kernel-poll:false]\n\nEshell V5.9  (abort with ^G)\n(master@youthy)1> \n[1]+  已停止               erl -sname master\nyouthy@youthy:~$ ps -ef | grep erl\nyouthy   13884  2086  0 14:47 ?        00:00:00 /home/youthy/erls/R15B/erts-5.9/bin/epmd -daemon\nyouthy   23299 13177  1 15:19 pts/0    00:00:00 /home/youthy/erls/R15B/erts-5.9/bin/beam.smp -- -root /home/youthy/erls/R15B -progname erl -- -home /home/youthy -- -sname master\nyouthy   23336 13177  0 15:19 pts/0    00:00:00 grep --color=auto erl\nyouthy@youthy:~$ fg\nerl -sname master\n\n(master@youthy)1> slave:start_link('youthy', 'slave', \"-rsh ssh\").\n{ok,slave@youthy}\n(master@youthy)2> \n[1]+  已停止               erl -sname master\nyouthy@youthy:~$ ps -ef | grep erl\nyouthy   13884  2086  0 14:47 ?        00:00:00 /home/youthy/erls/R15B/erts-5.9/bin/epmd -daemon\nyouthy   23299 13177  0 15:19 pts/0    00:00:00 /home/youthy/erls/R15B/erts-5.9/bin/beam.smp -- -root /home/youthy/erls/R15B -progname erl -- -home /home/youthy -- -sname master\nyouthy   23546  2086  0 15:20 ?        00:00:00 /home/youthy/erls/R15B/erts-5.9/bin/beam.smp -- -root /home/youthy/erls/R15B -progname erl -- -home /home/youthy -- -noshell -noinput -noshell -noinput -master master@youthy -sname slave@youthy -s slave slave_start master@youthy slave_waiter_0 -rsh ssh\nyouthy   23587 13177  0 15:20 pts/0    00:00:00 grep --color=auto erl\nyouthy@youthy:~$ fg\nerl -sname master\n\n(master@youthy)2> rpc:call('slave@youthy', lists, sum, [[2,3,4]]).\n9\n(master@youthy)3> \n```\n\n### -set_cookie Cookie\n等同于erlang:set_cookie/2\n\n### -shutdown_time Time\nTime是ms毫秒。设置关闭erl节点的时间，如果时间到了还没有结束完，就强制结束掉还存在的进程。\n```\nyouthy@youthy:~$ erl -shutdown_time 1000\nErlang R15B (erts-5.9) [source] [64-bit] [smp:4:4] [async-threads:0] [hipe] [kernel-poll:false]\n\nEshell V5.9  (abort with ^G)\n1> q().\nok\n2> {init,shutdown_timeout}\nyouthy@youthy:~$ \nyouthy@youthy:~$ erl -shutdown_time 4000\nErlang R15B (erts-5.9) [source] [64-bit] [smp:4:4] [async-threads:0] [hipe] [kernel-poll:false]\n\nEshell V5.9  (abort with ^G)\n1> q().\nok\n2> youthy@youthy:~$ \n```\n\n如上，1秒的时间看来时不够用的。\n### -smp enable/auto/disable\n是否启用smp，默认时auto。auto自动检测。如果符合会自动开启smp。\n[关于smp](http://www.cnblogs.com/me-sa/archive/2012/02/01/erlang0035.html).\n### -version\n打印version信息。\n","slug":"erl命令和参数","published":1,"updated":"2018-06-26T09:49:27.735Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqw7jdw200106f1rehp2b0ia","content":"<h2 id=\"Startup\">Startup</h2><p>先拿mochiweb生成的一个例子说起，这是start-dev.sh脚本中的内容。启动一个mochiweb应用调用的就是这个<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/sh</span><br><span class=\"line\">exec erl \\</span><br><span class=\"line\">    -pa ebin deps/*/ebin \\</span><br><span class=\"line\">    -boot start_sasl \\</span><br><span class=\"line\">    -sname helloworld_dev \\</span><br><span class=\"line\">    -s helloworld \\</span><br><span class=\"line\">    -s reloader</span><br></pre></td></tr></table></figure></p>\n<span id=\"more\"></span>\n<p>通用形式就是</p>\n<blockquote>\n<p>erl -a b --sth -c d +f g -extra abc</p>\n</blockquote>\n<p>erl后面的都是参数arguments<br>arguments可以分为<strong>emulator flags</strong>，<strong>flags</strong>，<strong>plain arguments</strong></p>\n<pre><code>* 任何已+开始的参数会被解释为emulator <span class=\"keyword\">flags</span>\n* 任何以-开始的参数会被解释为<span class=\"keyword\">flags</span>，并传入交给了init模块。\n* 在--之后到任何-或者+符号之间的所有<span class=\"keyword\">flags</span>以及-extra之后所有的<span class=\"keyword\">flags</span>都是plain arguments，这些参数不会发生解释行为，只不过被储存起来。同样交给init模块。\n</code></pre><p>init:boot(Args)函数接受上面的flags和plain arguments。</p>\n<blockquote>\n<p><strong>boot(BootArgs) -&gt; no_return()<br>Types:<br>BootArgs = [binary()]</strong><br>Starts the Erlang runtime system. This function is called when the emulator is started and coordinates system start-up.<br>BootArgs are all command line arguments except the emulator flags, that is, flags and plain arguments. See erl(1).<br>init itself interprets some of the flags, see Command Line Flags below. The remaining flags (&quot;user flags&quot;) and plain arguments are passed to the init loop and can be retrieved by callingget_arguments/0 and get_plain_arguments/0, respectively.</p>\n</blockquote>\n<p>flags会被boot函数分为 init flags和user flags。user flags可以通过init:get_arguments()得到，plain arguments通过init:get_plain_arguments()得到。值得注意的是一小部分的“-”后面的flags现在是属于emulator flags。后面提到。</p>\n<!-- toc -->\n<ul>\n<li><a href=\"#init-flags\">Init Flags</a><ul>\n<li><a href=\"#--------\">--(两个横杠)</a></li>\n<li><a href=\"#-extra\">-extra</a></li>\n<li><a href=\"#-code-path-choice-choice--strict-relexed\">-code_path_choice Choice::strict|relexed</a></li>\n<li><a href=\"#-eval-expr\">-eval Expr</a></li>\n<li><a href=\"#-run-mod-func-arg1-arg2argn\">-run Mod Func Arg1 Arg2....ArgN</a></li>\n<li><a href=\"#-s-mod-func-arg1-arg2--argn\">-s Mod Func Arg1 Arg2 ... ArgN</a></li>\n<li><a href=\"#-applicationname-par-val\">-ApplicationName Par Val</a></li>\n<li><a href=\"#-args-file-filename\">-args_file FileName</a></li>\n<li><a href=\"#-async-shell-start\">-async_shell_start</a></li>\n<li><a href=\"#-boot-file\">-boot File</a></li>\n<li><a href=\"#-boot-var-var-dir\">-boot_var Var Dir</a></li>\n<li><a href=\"#-code-path-cache\">-code_path_cache</a></li>\n<li><a href=\"#-compile-mod1-mod2-\">-compile Mod1 Mod2 ...</a></li>\n<li><a href=\"#connect-all-true-false\">connect_all true|false</a></li>\n<li><a href=\"#-config-config\">-config Config</a></li>\n<li><a href=\"#-cookie-cookie\">-cookie Cookie</a></li>\n<li><a href=\"#-setcookie-cookie\">-setcookie Cookie</a></li>\n<li><a href=\"#-detached\">-detached</a></li>\n<li><a href=\"#-emu-args\">-emu_args</a></li>\n<li><a href=\"#-env-variable-value\">-env Variable Value</a></li>\n<li><a href=\"#-heart\">-heart</a></li>\n<li><a href=\"#-hidden\">-hidden</a></li>\n<li><a href=\"#-init-debug\">-init_debug</a></li>\n<li><a href=\"#-make\">-make</a></li>\n<li><a href=\"#-man-module\">-man Module</a></li>\n<li><a href=\"#-mode-interactive-embedded\">-mode interactive|embedded</a></li>\n<li><a href=\"#-name-sname-name\">-name/sname NAME</a></li>\n<li><a href=\"#-noinput\">-noinput</a></li>\n<li><a href=\"#-noshell\">-noshell</a></li>\n<li><a href=\"#-pa--pz\">-pa/-pz</a></li>\n<li><a href=\"#-remsh-node\">-remsh Node</a></li>\n<li><a href=\"#-rsh-program\">-rsh Program</a></li>\n<li><a href=\"#-set-cookie-cookie\">-set_cookie Cookie</a></li>\n<li><a href=\"#-shutdown-time-time\">-shutdown_time Time</a></li>\n<li><a href=\"#-smp-enable-auto-disable\">-smp enable/auto/disable</a></li>\n<li><a href=\"#-version\">-version</a></li>\n</ul>\n</li>\n</ul>\n<!-- tocstop -->\n<h2 id=\"Init_Flags\">Init Flags</h2><h3 id=\"-(两个横杠)\">--(两个横杠)</h3><p>任何在--到下一个-或者+之间的都是plain arguments，可以通过init:get_plain_arguments()取到.</p>\n<h3 id=\"-extra\">-extra</h3><p>和--的作用一样，extra后面的flags都是plain arguments</p>\n<h3 id=\"-code_path_choice_Choice::strict|relexed\">-code_path_choice Choice::strict|relexed</h3><blockquote>\n<p>When the choice of directories in the code path is strict, the directory that ends up in the code path will be exactly the stated one. This means that if for example the directory \\$OTPROOT/lib/mnesia-4.4.7/ebin is explicitly added to the code path, the code server will not load files from $OTPROOT/lib/mnesia-4.4.7.ez/mnesia-4.4.7/ebin and vice versa.</p>\n</blockquote>\n<blockquote>\n<p>This behavior can be controlled via the command line flag -code_path_choice Choice. If the flag is set to relaxed, the code server will instead choose a suitable directory depending on the actual file structure. If there exists a regular application ebin directory,situation it will be chosen. But if it does not exist, the ebin directory in the archive is chosen if it exists. If neither of them exists the original directory will be chosen.<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;/home/yuyouqi/Erlang/lib/snmp-5.1.1/ebin&quot;,</span><br><span class=\"line\"> &quot;/home/yuyouqi/Erlang/lib/sasl-2.4.1/ebin&quot;,</span><br><span class=\"line\"> &quot;/home/yuyouqi/Erlang/lib/runtime_tools-1.8.15/ebin&quot;,</span><br><span class=\"line\"> &quot;/home/yuyouqi/Erlang/lib/reltool-0.6.6/ebin&quot;,</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> &quot;/home/yuyouqi/Erlang/lib/ssh-3.1/ebin&quot;,</span><br><span class=\"line\"> &quot;/home/yuyouqi/Erlang/lib/snmp-5.1.1/ebin&quot;,</span><br><span class=\"line\"> &quot;/home/yuyouqi/Erlang/lib/sasl-2.4.1.ez/sasl-2.4.1/ebin&quot;,</span><br><span class=\"line\"> &quot;/home/yuyouqi/Erlang/lib/runtime_tools-1.8.15/ebin&quot;,</span><br><span class=\"line\"> 3&gt; code:lib_dir(sasl, ebin).</span><br><span class=\"line\">&quot;/home/yuyouqi/Erlang/lib/sasl-2.4.1.ez/sasl-2.4.1/ebin&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"-eval_Expr\">-eval Expr</h3><p>Expr是个函数，在erl初始化时按顺序执行，如果fail的，则初始化失败。例如<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">erl -eval &#x27;&#123;X,Y,Z&#125; = now(), random:seed(X,Y,Z).&#x27;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>官方文档Z}旁边多了‘符号，需要去掉</p>\n</blockquote>\n<h3 id=\"-run_Mod_Func_Arg1_Arg2-ArgN\">-run Mod Func Arg1 Arg2....ArgN</h3><p>调用Mod:Func([&quot;Arg1&quot;, &quot;Arg2&quot;, ...&quot;ArgN&quot;]),<br>所有参数都是以string方式传入的。同样按顺序执行，前一个执行完才会执行下一个。但是貌似并不会阻塞shell。</p>\n<h3 id=\"-s_Mod_Func_Arg1_Arg2_-_ArgN\">-s Mod Func Arg1 Arg2 ... ArgN</h3><p>与run完成同样的功能，但是Arg都是atom的形式传入，值得注意的是数字也会变成atom,<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">erl -s test time 5000 atom</span><br></pre></td></tr></table></figure></p>\n<p>就是test:time([&#39;5000&#39;, atom]).<br>一般数字需要atom_to_list, list_to_integer转换。</p>\n<p>##User flags</p>\n<h3 id=\"-ApplicationName_Par_Val\">-ApplicationName Par Val</h3><p>指定应用的名字，属性名称和值，可以将应用的某个参数设置成Val。<br>比如<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> erl -pa ./ebin -s helloworld -helloworld par haha</span><br><span class=\"line\"> 1&gt; application:get_all_key(helloworld).</span><br><span class=\"line\">&#123;ok,[&#123;description,&quot;helloworld&quot;&#125;,</span><br><span class=\"line\">     &#123;id,[]&#125;,</span><br><span class=\"line\">     &#123;vsn,&quot;0.1&quot;&#125;,</span><br><span class=\"line\">     &#123;modules,[helloworld,helloworld_app,helloworld_deps,</span><br><span class=\"line\">               helloworld_dtl,helloworld_sup,helloworld_web]&#125;,</span><br><span class=\"line\">     &#123;maxP,infinity&#125;,</span><br><span class=\"line\">     &#123;maxT,infinity&#125;,</span><br><span class=\"line\">     &#123;registered,[]&#125;,</span><br><span class=\"line\">     &#123;included_applications,[]&#125;,</span><br><span class=\"line\">     &#123;applications,[kernel,stdlib,crypto]&#125;,</span><br><span class=\"line\">     &#123;env,[&#123;par,haha&#125;,&#123;included_applications,[]&#125;]&#125;,</span><br><span class=\"line\">     &#123;mod,&#123;helloworld_app,[]&#125;&#125;,</span><br><span class=\"line\">     &#123;start_phases,undefined&#125;]&#125;</span><br><span class=\"line\">2&gt; application:get_all_env(helloworld).</span><br><span class=\"line\">[&#123;par,haha&#125;,&#123;included_applications,[]&#125;]</span><br></pre></td></tr></table></figure></p>\n<p>启动了一个helloworld应用，并将par参数设置成haha。</p>\n<h3 id=\"-args_file_FileName\">-args_file FileName</h3><p>直接从FileName读取erl所用的参数。例如在agrsfile的文件中写入如下</p>\n<blockquote>\n<p>-eval &#39;io:format(&quot;read from file~n&quot;)&#39; -extra hello -pa ./ebin</p>\n</blockquote>\n<p>实际结果<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">erl -args_file argsfile</span><br><span class=\"line\">Erlang R15B (erts-5.9) [source] [smp:2:2] [async-threads:0] [hipe] [kernel-poll:false]</span><br><span class=\"line\"></span><br><span class=\"line\">Eshell V5.9  (abort with ^G)</span><br><span class=\"line\">1&gt; read from file</span><br><span class=\"line\">1&gt; init:get_arguments().</span><br><span class=\"line\">[&#123;root,[&quot;/usr/local/lib/erlang&quot;]&#125;,</span><br><span class=\"line\"> &#123;progname,[&quot;erl&quot;]&#125;,</span><br><span class=\"line\"> &#123;home,[&quot;/home/yuyouqi&quot;]&#125;]</span><br><span class=\"line\">2&gt; init:get_plain_arguments().</span><br><span class=\"line\">[&quot;hello&quot;,&quot;-pa&quot;,&quot;./ebin&quot;]</span><br></pre></td></tr></table></figure></p>\n<p>可以看到启动的时候执行了io:format函数，但是-extra这个参数是特殊的，正常情况下-extra到下一个-或者+之间的参数才会被认为是plain arguments，可是如果写在文件中就变成-extra后面所有的参数，都会当成plain arguments.只有这点不同。</p>\n<h3 id=\"-async_shell_start\">-async_shell_start</h3><p>名字上来说是异步启动shell</p>\n<h3 id=\"-boot_File\">-boot File</h3><p>试用File.boot启动erl系统,除非File是个绝对路径，否则在当前文件夹和$ROOT/bin下面找（我的:/usr/local/lib/erlang/bin,  $ROOT可以通过code:root_dir()查看),<br>默认情况下是-boot start<br><a href=\"http://www.erlang.org/doc/man/script.html\">script</a></p>\n<blockquote>\n<p>The command erl -boot Name starts the system with a boot file called Name.boot, which is generated from the Name.script file, using systools:script2boot/1.<br>The .script file is generated by systools from a .rel file and .app files.</p>\n</blockquote>\n<p>.boot文件是用systools产生的，打开后是乱码.<br>文件的生成顺序 .rel -&gt; .script -&gt; .boot<br><a href=\"http://erlang.org/doc/man/systools.html\">systools</a><br>systools里面提供了生成rel,script, boot等方法。可以在<code>/usr/local/lib/erlang/releases/R15B</code>下找到几个官方的rel，script，boot<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Ubuntu@desktop:/usr/local/lib/erlang/releases/R15B$ ls</span><br><span class=\"line\">start_all_example.rel  start_clean.boot  start_clean.script  start_sasl.rel     start.script</span><br><span class=\"line\">start.boot             start_clean.rel   start_sasl.boot     start_sasl.script</span><br></pre></td></tr></table></figure></p>\n<p>打开start_sasl.rel<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">%%注释....</span><br><span class=\"line\">&#123;release, &#123;&quot;OTP  APN 181 01&quot;,&quot;R15B&quot;&#125;, &#123;erts, &quot;5.9&quot;&#125;,</span><br><span class=\"line\"> [&#123;kernel,&quot;2.15&quot;&#125;,</span><br><span class=\"line\">  &#123;stdlib,&quot;1.18&quot;&#125;,</span><br><span class=\"line\">  &#123;sasl, &quot;2.2&quot;&#125;]&#125;.</span><br></pre></td></tr></table></figure></p>\n<p>具体格式在上面的systools链接中有说明<br>仿照它这个样子写一个test<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;release, &#123;&quot;test_rel&quot;,&quot;0.1&quot;&#125;, &#123;erts, &quot;5.9&quot;&#125;,</span><br><span class=\"line\"> [&#123;kernel,&quot;2.15&quot;&#125;,</span><br><span class=\"line\">  &#123;stdlib,&quot;1.18&quot;&#125;,</span><br><span class=\"line\">  &#123;sasl, &quot;2.2&quot;&#125;,</span><br><span class=\"line\">  &#123;crypto, &quot;2.1&quot;&#125;,</span><br><span class=\"line\">  &#123;helloworld,&quot;0.1&quot;&#125;]&#125;.</span><br></pre></td></tr></table></figure></p>\n<p>helloworld使用mochiweb生成的简单框架,用到了crypto，所以讲crypto加入。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Erlang R15B (erts-5.9) [source] [smp:2:2] [async-threads:0] [hipe] [kernel-poll:false]</span><br><span class=\"line\"></span><br><span class=\"line\">Eshell V5.9  (abort with ^G)</span><br><span class=\"line\">1&gt; systools:make_script(&quot;test&quot;).       </span><br><span class=\"line\">helloworld: File not found: &quot;helloworld.app&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">error</span><br><span class=\"line\">2&gt; systools:make_script(&quot;test&quot;, [&#123;path, [&quot;ebin&quot;]&#125;]).</span><br><span class=\"line\">ok</span><br></pre></td></tr></table></figure><br>由于helloworld不在默认的ebin下，所以下加上当前路径中的ebin。否则找不到helloworld.app<br>如果是使用systools的make_script命令省的script会自动生成.boot。打开test.script<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">%% script generated at &#123;2015,7,1&#125; &#123;12,5,26&#125;</span><br><span class=\"line\">&#123;script,</span><br><span class=\"line\">    &#123;&quot;test_rel&quot;,&quot;0.1&quot;&#125;,</span><br><span class=\"line\">    [&#123;preLoaded,</span><br><span class=\"line\">         [erl_prim_loader,erlang,init,otp_ring0,prim_file,prim_inet,prim_zip,</span><br><span class=\"line\">          zlib]&#125;,</span><br><span class=\"line\">     &#123;progress,preloaded&#125;,</span><br><span class=\"line\">     &#123;path,[&quot;$ROOT/lib/kernel-2.15/ebin&quot;,&quot;$ROOT/lib/stdlib-1.18/ebin&quot;]&#125;,</span><br><span class=\"line\">     &#123;primLoad,[error_handler]&#125;,</span><br><span class=\"line\">     &#123;kernel_load_completed&#125;,</span><br><span class=\"line\">     &#123;progress,kernel_load_completed&#125;,</span><br><span class=\"line\">     &#123;path,[&quot;$ROOT/lib/kernel-2.15/ebin&quot;]&#125;,</span><br><span class=\"line\">     &#123;primLoad,</span><br><span class=\"line\">         [application,application_controller,application_master,</span><br><span class=\"line\">          application_starter,auth,code,code_server,disk_log,disk_log_1,</span><br><span class=\"line\">          disk_log_server,disk_log_sup,dist_ac,dist_util,erl_boot_server,</span><br><span class=\"line\">          erl_ddll,erl_distribution,erl_epmd,erl_reply,error_logger,</span><br><span class=\"line\">          erts_debug,file,file_io_server,file_server,gen_sctp,gen_tcp,gen_udp,</span><br><span class=\"line\">          global,global_group,global_search,group,heart,hipe_unified_loader,</span><br><span class=\"line\">          inet,inet6_sctp,inet6_tcp,inet6_tcp_dist,inet6_udp,inet_config,</span><br><span class=\"line\">          inet_db,inet_dns,inet_gethost_native,inet_hosts,inet_parse,inet_res,</span><br><span class=\"line\">          inet_sctp,inet_tcp,inet_tcp_dist,inet_udp,kernel,kernel_config,net,</span><br><span class=\"line\">          net_adm,net_kernel,os,packages,pg2,ram_file,rpc,seq_trace,</span><br><span class=\"line\">          standard_error,user,user_drv,user_sup,wrap_log_reader]&#125;,</span><br><span class=\"line\">     &#123;path,[&quot;$ROOT/lib/stdlib-1.18/ebin&quot;]&#125;,</span><br><span class=\"line\">...</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<p>有了.boot文件后就可以使用了<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yuyouqi@yuyouqi-desktop:~/Erlang/helloworld$ erl -pa ebin deps/*/ebin -boot test</span><br><span class=\"line\">Erlang R15B (erts-5.9) [source] [smp:2:2] [async-threads:0] [hipe] [kernel-poll:false]</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">=PROGRESS REPORT==== 1-Jul-2015::12:10:49 ===</span><br><span class=\"line\">          supervisor: &#123;local,sasl_safe_sup&#125;</span><br><span class=\"line\">             started: [&#123;pid,&lt;0.35.0&gt;&#125;,</span><br><span class=\"line\">                       &#123;name,alarm_handler&#125;,</span><br><span class=\"line\">                       &#123;mfargs,&#123;alarm_handler,start_link,[]&#125;&#125;,</span><br><span class=\"line\">                       &#123;restart_type,permanent&#125;,</span><br><span class=\"line\">                       &#123;shutdown,2000&#125;,</span><br><span class=\"line\">                       &#123;child_type,worker&#125;]</span><br><span class=\"line\"></span><br><span class=\"line\">=PROGRESS REPORT==== 1-Jul-2015::12:10:49 ===</span><br><span class=\"line\">          supervisor: &#123;local,sasl_safe_sup&#125;</span><br><span class=\"line\">             started: [&#123;pid,&lt;0.36.0&gt;&#125;,</span><br><span class=\"line\">                       &#123;name,overload&#125;,</span><br><span class=\"line\">                       &#123;mfargs,&#123;overload,start_link,[]&#125;&#125;,</span><br><span class=\"line\">                       &#123;restart_type,permanent&#125;,</span><br><span class=\"line\">                       &#123;shutdown,2000&#125;,</span><br><span class=\"line\">                       &#123;child_type,worker&#125;]</span><br><span class=\"line\"></span><br><span class=\"line\">=PROGRESS REPORT==== 1-Jul-2015::12:10:49 ===</span><br><span class=\"line\">          supervisor: &#123;local,sasl_sup&#125;</span><br><span class=\"line\">             started: [&#123;pid,&lt;0.34.0&gt;&#125;,</span><br><span class=\"line\">                       &#123;name,sasl_safe_sup&#125;,</span><br><span class=\"line\">                       &#123;mfargs,</span><br><span class=\"line\">                           &#123;supervisor,start_link,</span><br><span class=\"line\">                               [&#123;local,sasl_safe_sup&#125;,sasl,safe]&#125;&#125;,</span><br><span class=\"line\">                       &#123;restart_type,permanent&#125;,</span><br><span class=\"line\">                       &#123;shutdown,infinity&#125;,</span><br><span class=\"line\">                       &#123;child_type,supervisor&#125;]</span><br><span class=\"line\"></span><br><span class=\"line\">=PROGRESS REPORT==== 1-Jul-2015::12:10:49 ===</span><br><span class=\"line\">          supervisor: &#123;local,sasl_sup&#125;</span><br><span class=\"line\">             started: [&#123;pid,&lt;0.37.0&gt;&#125;,</span><br><span class=\"line\">                       &#123;name,release_handler&#125;,</span><br><span class=\"line\">                       &#123;mfargs,&#123;release_handler,start_link,[]&#125;&#125;,</span><br><span class=\"line\">                       &#123;restart_type,permanent&#125;,</span><br><span class=\"line\">                       &#123;shutdown,2000&#125;,</span><br><span class=\"line\">                       &#123;child_type,worker&#125;]</span><br><span class=\"line\"></span><br><span class=\"line\">=PROGRESS REPORT==== 1-Jul-2015::12:10:49 ===</span><br><span class=\"line\">         application: sasl</span><br><span class=\"line\">          started_at: nonode@nohost</span><br><span class=\"line\"></span><br><span class=\"line\">=PROGRESS REPORT==== 1-Jul-2015::12:10:49 ===</span><br><span class=\"line\">          supervisor: &#123;local,crypto_sup&#125;</span><br><span class=\"line\">             started: [&#123;pid,&lt;0.43.0&gt;&#125;,</span><br><span class=\"line\">                       &#123;name,crypto_server&#125;,</span><br><span class=\"line\">                       &#123;mfargs,&#123;crypto_server,start_link,[]&#125;&#125;,</span><br><span class=\"line\">                       &#123;restart_type,permanent&#125;,</span><br><span class=\"line\">                       &#123;shutdown,2000&#125;,</span><br><span class=\"line\">                       &#123;child_type,worker&#125;]</span><br><span class=\"line\"></span><br><span class=\"line\">=PROGRESS REPORT==== 1-Jul-2015::12:10:49 ===</span><br><span class=\"line\">         application: crypto</span><br><span class=\"line\">          started_at: nonode@nohost</span><br><span class=\"line\">** Found 0 name clashes in code paths </span><br><span class=\"line\"></span><br><span class=\"line\">=PROGRESS REPORT==== 1-Jul-2015::12:10:49 ===</span><br><span class=\"line\">          supervisor: &#123;local,helloworld_sup&#125;</span><br><span class=\"line\">             started: [&#123;pid,&lt;0.48.0&gt;&#125;,</span><br><span class=\"line\">                       &#123;name,helloworld_web&#125;,</span><br><span class=\"line\">                       &#123;mfargs,</span><br><span class=\"line\">                           &#123;helloworld_web,start,</span><br><span class=\"line\">                               [[&#123;ip,&#123;0,0,0,0&#125;&#125;,</span><br><span class=\"line\">                                 &#123;port,8080&#125;,</span><br><span class=\"line\">                                 &#123;docroot,</span><br><span class=\"line\">                                     &quot;/home/yuyouqi/Erlang/helloworld/priv/www&quot;&#125;]]&#125;&#125;,</span><br><span class=\"line\">                       &#123;restart_type,permanent&#125;,</span><br><span class=\"line\">                       &#123;shutdown,5000&#125;,</span><br><span class=\"line\">                       &#123;child_type,worker&#125;]</span><br><span class=\"line\"></span><br><span class=\"line\">=PROGRESS REPORT==== 1-Jul-2015::12:10:49 ===</span><br><span class=\"line\">         application: helloworld</span><br><span class=\"line\">          started_at: nonode@nohost</span><br><span class=\"line\">Eshell V5.9  (abort with ^G)</span><br><span class=\"line\">1&gt; </span><br></pre></td></tr></table></figure></p>\n<h3 id=\"-boot_var_Var_Dir\">-boot_var Var Dir</h3><p>指定一个变量Var的路径为Dir，主要用于systools:make_script的{variables, [{&quot;Var&quot;, &quot;Prefix&quot;}]},<br>因为默认的script路径都是在$ROOT/lib下寻找，当在make_script中加入variables选项时，</p>\n<h3 id=\"-code_path_cache\">-code_path_cache</h3><p>使用codepath的缓存，这样做的好处是加载模块更快，而且可以在常数时间找到模块，如果没加则需要search这个codepath才能找到对应模块，在模块数量很多时，可以使用。</p>\n<h3 id=\"-compile_Mod1_Mod2_-\">-compile Mod1 Mod2 ...</h3><p>编译Mod1 Mod2 ... 如果失败会返回非零的错误码 默认同时使用了-noinput参数.<strong>不推荐使用，推荐erlc</strong></p>\n<h3 id=\"connect_all_true|false\">connect_all true|false</h3><p>是否全联通（N1-N2， N2-N3 -&gt; N1-N2-N3），如果是false那么global模块的注册名字的相关机制无法使用</p>\n<h3 id=\"-config_Config\">-config Config</h3><p>读取Config文件，名字为AppName.config.<br>格式</p>\n<blockquote>\n<p>[{AppName, [{Key1, Value1}...]}, {AppName2, [...]}].</p>\n</blockquote>\n<p>见<a href=\"http://www.erlang.org/doc/man/config.html\">config file</a>.<br>例如新建helloworld.config<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[&#123;helloworld, [&#123;key1, val1&#125;, &#123;key2, val2&#125;]&#125;].</span><br></pre></td></tr></table></figure></p>\n<p>并在start脚本中加入-config helloworld.config<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/sh</span><br><span class=\"line\">exec erl \\</span><br><span class=\"line\">    -pa ebin deps/*/ebin \\</span><br><span class=\"line\">    -boot start_sasl \\</span><br><span class=\"line\">    -sname helloworld_dev \\</span><br><span class=\"line\">    -s helloworld \\</span><br><span class=\"line\">    -s reloader \\</span><br><span class=\"line\">    -config helloworld.config</span><br></pre></td></tr></table></figure></p>\n<p>如下看到在env中多了写入的config值</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(helloworld_dev@Ubuntu-desktop)1&gt; application:get_all_key(helloworld).</span><br><span class=\"line\">&#123;ok,[&#123;description,&quot;helloworld&quot;&#125;,</span><br><span class=\"line\">     &#123;id,[]&#125;,</span><br><span class=\"line\">     &#123;vsn,&quot;0.1&quot;&#125;,</span><br><span class=\"line\">     &#123;modules,[helloworld,helloworld_app,helloworld_deps,</span><br><span class=\"line\">               helloworld_dtl,helloworld_sup,helloworld_web]&#125;,</span><br><span class=\"line\">     &#123;maxP,infinity&#125;,</span><br><span class=\"line\">     &#123;maxT,infinity&#125;,</span><br><span class=\"line\">     &#123;registered,[]&#125;,</span><br><span class=\"line\">     &#123;included_applications,[]&#125;,</span><br><span class=\"line\">     &#123;applications,[kernel,stdlib,crypto]&#125;,</span><br><span class=\"line\">     &#123;env,[&#123;included_applications,[]&#125;,&#123;key2,val2&#125;,&#123;key1,val1&#125;]&#125;,</span><br><span class=\"line\">     &#123;mod,&#123;helloworld_app,[]&#125;&#125;,</span><br><span class=\"line\">     &#123;start_phases,undefined&#125;]&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"-cookie_Cookie\">-cookie Cookie</h3><p>过时的没有任何效果的标志，是setcookie的错误拼写，用setcookie代替。</p>\n<h3 id=\"-setcookie_Cookie\">-setcookie Cookie</h3><p>和erlang:set_cookie(Node, Cookie)的效果一样。给本地结点设置需要给本地结点起个名字-name/sname</p>\n<h3 id=\"-detached\">-detached</h3><p>以background的形式运行erl，与当前shell分离开，但是需要知道如何停止这个系统<br><a href=\"http://stackoverflow.com/questions/15464606/erlang-kill-all-processes-running-in-background\">How to stop</a>.</p>\n<h3 id=\"-emu_args\">-emu_args</h3><p>打印传给emulator的参数，比如在start-dev.sh脚本中加入它，可以看到<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ ./start-dev.sh </span><br><span class=\"line\">Executing: /usr/local/lib/erlang/erts-5.9/bin/beam.smp /usr/local/lib/erlang/erts-5.9/bin/beam.smp -- -root /usr/local/lib/erlang -progname erl -- -home /home/yuyouqi -- -pa ebin deps/erlydtl/ebin deps/eunit_formatters/ebin deps/merl/ebin deps/mochiweb/ebin -boot start_sasl -sname helloworld_dev -s helloworld -s reloader</span><br><span class=\"line\"></span><br><span class=\"line\">Erlang R15B (erts-5.9) [source] [smp:2:2] [async-threads:0] [hipe] [kernel-poll:false]</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"-env_Variable_Value\">-env Variable Value</h3><p>设置OS模块的环境变量Variable为Value.<br>通过os:getenv/0 getenv/1可以得到</p>\n<h3 id=\"-heart\">-heart</h3><p>开启心跳检测，尽管erlang有各种supervisor监管机制，但是如果emulator down掉了就完了，-heart会开启一个heart进程监控整个emulator，在规定时间内如果没有收到心跳，这个进程就会执行HEART_COMMAND参数，如果这个参数没有设定，那么只会弹出警告，而不会重启。一般HEART_COMMAND就是重启emulator。麻烦的是如果设定了heart，但是没有用-sname，是无法回到这个erlang shell的，也就是无法调用init：stop()来终止heart的监控策略。</p>\n<p>在没有开启任何erl shell的情况下调用<code>ps -ef|grep erl</code>看到跟erl有关的进程如下<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ ps -ef |grep erl</span><br><span class=\"line\">yuyouqi   2475  2345  0 10:23 ?        00:00:01 /usr/bin/perl /usr/bin/shutter --min_at_startup</span><br><span class=\"line\">yuyouqi   3329  2862  0 10:58 pts/2    00:00:00 grep --color=auto erl</span><br></pre></td></tr></table></figure></p>\n<p>启动一个erl emulator,然后Ctrl + z放到挂起<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ erl </span><br><span class=\"line\">Erlang R15B (erts-5.9) [source] [smp:2:2] [async-threads:0] [hipe] [kernel-poll:false]</span><br><span class=\"line\"></span><br><span class=\"line\">Eshell V5.9  (abort with ^G)</span><br><span class=\"line\">1&gt; </span><br><span class=\"line\">[1]+  已停止               erl</span><br><span class=\"line\">yuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ ps -ef |grep erl</span><br><span class=\"line\">yuyouqi   2475  2345  0 10:23 ?        00:00:01 /usr/bin/perl /usr/bin/shutter --min_at_startup</span><br><span class=\"line\">yuyouqi   3333  2862  0 11:01 pts/2    00:00:00 /usr/local/lib/erlang/erts-5.9/bin/beam.smp -- -root /usr/local/lib/erlang -progname erl -- -home /home/yuyouqi --</span><br><span class=\"line\">yuyouqi   3346  2862  0 11:01 pts/2    00:00:00 grep --color=auto erl</span><br></pre></td></tr></table></figure></p>\n<p>可以看到3333这个进程后面的命令是开启一个erl emulator的<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ kill -9 3333</span><br><span class=\"line\">yuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ ps -ef | grep erl</span><br><span class=\"line\">yuyouqi   2475  2345  0 10:23 ?        00:00:01 /usr/bin/perl /usr/bin/shutter --min_at_startup</span><br><span class=\"line\">yuyouqi   3366  2862  0 11:04 pts/2    00:00:00 grep --color=auto erl</span><br><span class=\"line\">[1]+  已杀死               erl</span><br></pre></td></tr></table></figure></p>\n<p>可以看到将他kill掉是没问题的<br>下面启动一个-heart erl shell<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ erl -sname test1 -heart -env HEART_COMMAND &quot;erl -sname test1 -heart&quot;</span><br><span class=\"line\">heart_beat_kill_pid = 3369</span><br><span class=\"line\">Erlang R15B (erts-5.9) [source] [smp:2:2] [async-threads:0] [hipe] [kernel-poll:false]</span><br><span class=\"line\"></span><br><span class=\"line\">Eshell V5.9  (abort with ^G)</span><br><span class=\"line\">(test1@yuyouqi-desktop)1&gt; </span><br><span class=\"line\">[1]+  已停止               erl -sname test1 -heart -env HEART_COMMAND &quot;erl -sname test1 -heart&quot;</span><br><span class=\"line\">yuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ ps -ef | grep erl</span><br><span class=\"line\">yuyouqi   2475  2345  0 10:23 ?        00:00:01 /usr/bin/perl /usr/bin/shutter --min_at_startup</span><br><span class=\"line\">yuyouqi   3369  2862  1 11:05 pts/2    00:00:00 /usr/local/lib/erlang/erts-5.9/bin/beam.smp -- -root /usr/local/lib/erlang -progname erl -- -home /home/yuyouqi -- -sname test1 -heart</span><br><span class=\"line\">yuyouqi   3376  2219  0 11:05 ?        00:00:00 /usr/local/lib/erlang/erts-5.9/bin/epmd -daemon</span><br><span class=\"line\">yuyouqi   3387  2862  0 11:06 pts/2    00:00:00 grep --color=auto erl</span><br><span class=\"line\"></span><br><span class=\"line\">yuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ heart: Fri Jul  3 11:06:57 2015: heart-beat time-out.</span><br><span class=\"line\">heart_beat_kill_pid = 3390</span><br><span class=\"line\">yuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ ps -ef | grep erl</span><br><span class=\"line\">yuyouqi   2475  2345  0 10:23 ?        00:00:01 /usr/bin/perl /usr/bin/shutter --min_at_startup</span><br><span class=\"line\">yuyouqi   3376  2219  0 11:05 ?        00:00:00 /usr/local/lib/erlang/erts-5.9/bin/epmd -daemon</span><br><span class=\"line\">yuyouqi   3389  3383  0 11:06 ?        00:00:00 sh -c erl -sname test1 -heart</span><br><span class=\"line\">yuyouqi   3390  3389  0 11:06 ?        00:00:00 /usr/local/lib/erlang/erts-5.9/bin/beam.smp -- -root /usr/local/lib/erlang -progname erl -- -home /home/yuyouqi -- -sname test1 -heart</span><br><span class=\"line\">yuyouqi   3410  2862  0 11:07 pts/2    00:00:00 grep --color=auto erl</span><br></pre></td></tr></table></figure></p>\n<p>上面命令是我用-heart启动一个erl shell，可以看到多了3369 和3376这两个进程，把erl shell挂起，一段时间后，由于heart进程没有接收到“心跳”，重启了erl shell,pid变为3390。而且多出了一个3389这个进程，而3390这个erl shell是3389的子进程。可以看到3389就是执行我们的HEART_COMMAND<br>如果不指定HEART_COMMAND<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ erl -sname test2 -heart</span><br><span class=\"line\">heart_beat_kill_pid = 3685</span><br><span class=\"line\">Erlang R15B (erts-5.9) [source] [smp:2:2] [async-threads:0] [hipe] [kernel-poll:false]</span><br><span class=\"line\"></span><br><span class=\"line\">Eshell V5.9  (abort with ^G)</span><br><span class=\"line\">(test2@yuyouqi-desktop)1&gt; </span><br><span class=\"line\">[1]+  已停止               erl -sname test2 -heart</span><br><span class=\"line\">yuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ ps -ef|grep erl</span><br><span class=\"line\">yuyouqi   2475  2345  0 10:23 ?        00:00:01 /usr/bin/perl /usr/bin/shutter --min_at_startup</span><br><span class=\"line\">yuyouqi   3376  2219  0 11:05 ?        00:00:00 /usr/local/lib/erlang/erts-5.9/bin/epmd -daemon</span><br><span class=\"line\">yuyouqi   3389  3383  0 11:06 ?        00:00:00 sh -c erl -sname test1 -heart</span><br><span class=\"line\">yuyouqi   3390  3389  0 11:06 ?        00:00:00 /usr/local/lib/erlang/erts-5.9/bin/beam.smp -- -root /usr/local/lib/erlang -progname erl -- -home /home/yuyouqi -- -sname test1 -heart</span><br><span class=\"line\">yuyouqi   3685  2862  2 12:15 pts/2    00:00:00 /usr/local/lib/erlang/erts-5.9/bin/beam.smp -- -root /usr/local/lib/erlang -progname erl -- -home /home/yuyouqi -- -sname test2 -heart</span><br><span class=\"line\">yuyouqi   3703  2862  0 12:15 pts/2    00:00:00 grep --color=auto erl</span><br><span class=\"line\">yuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ jobs</span><br><span class=\"line\">[1]+  已停止               erl -sname test2 -heart</span><br><span class=\"line\">yuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ fg</span><br><span class=\"line\">erl -sname test2 -heart</span><br><span class=\"line\"></span><br><span class=\"line\">(test2@yuyouqi-desktop)1&gt; </span><br><span class=\"line\">User switch command</span><br><span class=\"line\"> --&gt; q</span><br><span class=\"line\">yuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ heart: Fri Jul  3 12:16:10 2015: Erlang has closed.</span><br><span class=\"line\">heart: Fri Jul  3 12:16:10 2015: Would reboot. Terminating.</span><br><span class=\"line\"></span><br><span class=\"line\">yuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ ps -ef|grep erl</span><br><span class=\"line\">yuyouqi   2475  2345  0 10:23 ?        00:00:01 /usr/bin/perl /usr/bin/shutter --min_at_startup</span><br><span class=\"line\">yuyouqi   3376  2219  0 11:05 ?        00:00:00 /usr/local/lib/erlang/erts-5.9/bin/epmd -daemon</span><br><span class=\"line\">yuyouqi   3389  3383  0 11:06 ?        00:00:00 sh -c erl -sname test1 -heart</span><br><span class=\"line\">yuyouqi   3390  3389  0 11:06 ?        00:00:00 /usr/local/lib/erlang/erts-5.9/bin/beam.smp -- -root /usr/local/lib/erlang -progname erl -- -home /home/yuyouqi -- -sname test1 -heart</span><br><span class=\"line\">yuyouqi   3705  2862  0 12:16 pts/2    00:00:00 grep --color=auto erl</span><br></pre></td></tr></table></figure></p>\n<p>新建一个test2 shell，不设置HEART_COMMAND，<br>可以看到如果没有设置HEART_COMMAND 使用ctrl g退出后不会重启，但是test1是会重启的。<br>而且新建节点后发现-daemon进程并没有增加，我猜测-daemon有可能是heart监控进程。<br>但是无论怎样kill都是无效的，依然会重启<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ kill -9 3376 3389 3390</span><br><span class=\"line\">yuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ heart: Fri Jul  3 12:21:15 2015: Executed &quot;erl -sname test1 -heart&quot;. Terminating.</span><br><span class=\"line\">heart: Fri Jul  3 12:21:15 2015: Erlang has closed.</span><br><span class=\"line\">heart_beat_kill_pid = 3716</span><br><span class=\"line\"></span><br><span class=\"line\">yuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ ps -ef|grep erl</span><br><span class=\"line\">yuyouqi   2475  2345  0 10:23 ?        00:00:01 /usr/bin/perl /usr/bin/shutter --min_at_startup</span><br><span class=\"line\">yuyouqi   3715  3404  0 12:21 ?        00:00:00 sh -c erl -sname test1 -heart</span><br><span class=\"line\">yuyouqi   3716  3715  3 12:21 ?        00:00:00 /usr/local/lib/erlang/erts-5.9/bin/beam.smp -- -root /usr/local/lib/erlang -progname erl -- -home /home/yuyouqi -- -sname test1 -heart</span><br><span class=\"line\">yuyouqi   3723  2219  0 12:21 ?        00:00:00 /usr/local/lib/erlang/erts-5.9/bin/epmd -daemon</span><br><span class=\"line\">yuyouqi   3734  2862  0 12:21 pts/2    00:00:00 grep --color=auto erl</span><br></pre></td></tr></table></figure></p>\n<p>这时就需要进入test1，调用init:stop()来结束<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ erl -sname test2</span><br><span class=\"line\">Erlang R15B (erts-5.9) [source] [smp:2:2] [async-threads:0] [hipe] [kernel-poll:false]</span><br><span class=\"line\"></span><br><span class=\"line\">Eshell V5.9  (abort with ^G)</span><br><span class=\"line\">(test2@yuyouqi-desktop)1&gt; </span><br><span class=\"line\">User switch command</span><br><span class=\"line\"> --&gt; r &#x27;test1@yuyouqi-desktop&#x27;</span><br><span class=\"line\"> --&gt; c</span><br><span class=\"line\">Eshell V5.9  (abort with ^G)</span><br><span class=\"line\">(test1@yuyouqi-desktop)1&gt; init:stop().</span><br><span class=\"line\">*** ERROR: Shell process terminated! (^G to start new job) ***</span><br><span class=\"line\">heart: Fri Jul  3 12:23:40 2015: Executed &quot;erl -sname test1 -heart&quot;. Terminating.</span><br><span class=\"line\"></span><br><span class=\"line\">User switch command</span><br><span class=\"line\"> --&gt; j</span><br><span class=\"line\">   1  &#123;shell,start,[init]&#125;</span><br><span class=\"line\"> --&gt; c 1</span><br><span class=\"line\"></span><br><span class=\"line\">(test2@yuyouqi-desktop)1&gt;        </span><br><span class=\"line\">User switch command</span><br><span class=\"line\"> --&gt; q</span><br><span class=\"line\">yuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ ps -ef|grep erl</span><br><span class=\"line\">yuyouqi   2475  2345  0 10:23 ?        00:00:01 /usr/bin/perl /usr/bin/shutter --min_at_startup</span><br><span class=\"line\">yuyouqi   3723  2219  0 12:21 ?        00:00:00 /usr/local/lib/erlang/erts-5.9/bin/epmd -daemon</span><br><span class=\"line\">yuyouqi   3760  2862  0 12:24 pts/2    00:00:00 grep --color=auto erl</span><br></pre></td></tr></table></figure></p>\n<p>这样才能将heart监控的shell关闭(或者使用rpc)<br>参考<a href=\"http://stackoverflow.com/questions/7217892/is-there-a-way-to-kill-the-erlang-vm-when-it-is-running-with-heart\">Is there a way to kill the erlang vm when it is running with -heart</a></p>\n<h3 id=\"-hidden\">-hidden</h3><p>已hidden启动的结点在于其他结点连接时，他的连接时隐藏的，不会再nodes()中得到自己的名字。只有与自己同属于一个<a href=\"http://www.erlang.org/doc/man/global_group.html#type-group_name\">global_group</a>的其他结点才能知道自己。<br>比如建立一个kernel.config,定义一个global_group<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[&#123;kernel, [&#123;global_groups, [&#123;test, [&#x27;test1@yuyouqi-desktop&#x27;, &#x27;test2@yuyouqi-desktop&#x27;]&#125;]&#125;]&#125;].</span><br></pre></td></tr></table></figure></p>\n<p>然后启动3个结点test1，test2，test3<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ erl -sname test1 -config kernel.config </span><br><span class=\"line\">Erlang R15B (erts-5.9) [source] [smp:2:2] [async-threads:0] [hipe] [kernel-poll:false]</span><br><span class=\"line\"></span><br><span class=\"line\">Eshell V5.9  (abort with ^G)</span><br><span class=\"line\">(test1@yuyouqi-desktop)1&gt; global_group:global_groups().</span><br><span class=\"line\">&#123;test,[]&#125;</span><br><span class=\"line\">yuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ erl -sname test2 -hidden -config kernel.config </span><br><span class=\"line\">Erlang R15B (erts-5.9) [source] [smp:2:2] [async-threads:0] [hipe] [kernel-poll:false]</span><br><span class=\"line\"></span><br><span class=\"line\">Eshell V5.9  (abort with ^G)</span><br><span class=\"line\">(test2@yuyouqi-desktop)1&gt; global_group:global_groups().</span><br><span class=\"line\">&#123;test,[]&#125;</span><br><span class=\"line\">yuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ erl -sname test3 -config kernel.config </span><br><span class=\"line\">Erlang R15B (erts-5.9) [source] [smp:2:2] [async-threads:0] [hipe] [kernel-poll:false]</span><br><span class=\"line\"></span><br><span class=\"line\">Eshell V5.9  (abort with ^G)</span><br><span class=\"line\">(test3@yuyouqi-desktop)1&gt; global_group:global_groups().</span><br><span class=\"line\">&#123;no_name,[test]&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其中test2已hidden形式启动，test3不在global_group中，可以看到test1和test2返回自己的global_group为test。<br>用<code>net_kernel:connect</code>将它们互联。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(test2@yuyouqi-desktop)2&gt; net_kernel:connect(&#x27;test1@yuyouqi-desktop&#x27;).</span><br><span class=\"line\">true</span><br><span class=\"line\">(test2@yuyouqi-desktop)3&gt; nodes().</span><br><span class=\"line\">[&#x27;test1@yuyouqi-desktop&#x27;]</span><br><span class=\"line\">(test2@yuyouqi-desktop)5&gt; net_kernel:connect(&#x27;test3@yuyouqi-desktop&#x27;).</span><br><span class=\"line\">true</span><br><span class=\"line\">(test2@yuyouqi-desktop)6&gt; nodes().</span><br><span class=\"line\">[&#x27;test1@yuyouqi-desktop&#x27;]</span><br><span class=\"line\">(test1@yuyouqi-desktop)2&gt; nodes().</span><br><span class=\"line\">[&#x27;test2@yuyouqi-desktop&#x27;]</span><br><span class=\"line\">(test3@yuyouqi-desktop)2&gt; nodes().</span><br><span class=\"line\">[]</span><br></pre></td></tr></table></figure></p>\n<p>test1和test2是可以互相看到的，而test3的nodes()返回的是空</p>\n<h3 id=\"-init_debug\">-init_debug</h3><p>启动的时候打印调试参数。可以尝试下<code>erl -init_debug</code> 然后对照着<code>/usr/local/lib/erlang/releases/RXXB/start.script</code></p>\n<h3 id=\"-make\">-make</h3><p>相当于make:all(),见<br><a href=\"http://www.erlang.org/doc/man/make.html\">make</a></p>\n<h3 id=\"-man_Module\">-man Module</h3><p>查询某个模块的手册，首先需要去官网下载相应的手册</p>\n<h3 id=\"-mode_interactive|embedded\">-mode interactive|embedded</h3><p>erlang system载入代码的方式，interactive模式下，系统只载入一部分代码，当使用为载入的代码时，会尝试自动载入这个模块。如果是embeded模式，实在系统初始化时，根据启动的script文件载入所有代码，如果文件上没有提到，不会载入，如果调用为载入模块的函数，会报exception error</p>\n<h3 id=\"-name/sname_NAME\">-name/sname NAME</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">erl -sname test1</span><br><span class=\"line\">erl -name test2@192.168.1.10</span><br></pre></td></tr></table></figure>\n<p>sname 与name之间的结点不能通信，必须命名方式相同才可以。 sname只能用于同一子网内的机器。</p>\n<h3 id=\"-noinput\">-noinput</h3><p>erl不读入任何参数</p>\n<h3 id=\"-noshell\">-noshell</h3><p>常用，不显示erl shell。一般都是执行一系列的-eval，-s，-ran，然后init:stop().</p>\n<h3 id=\"-pa/-pz\">-pa/-pz</h3><p>添加code路径，没什么可说的同code:addpathsa/addpathsz</p>\n<h3 id=\"-remsh_Node\">-remsh Node</h3><p>远程链接一个节点。例如在shell1中启动一个mochiweb例子<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">youthy@youthy:~/code/helloworld$ ./start-dev.sh </span><br><span class=\"line\">...=PROGRESS REPORT==== 17-Jul-2015::12:20:43 ===</span><br><span class=\"line\">          supervisor: &#123;local,kernel_safe_sup&#125;</span><br><span class=\"line\">             started: [&#123;pid,&lt;0.74.0&gt;&#125;,</span><br><span class=\"line\">                       &#123;id,timer_server&#125;,</span><br><span class=\"line\">                       &#123;mfargs,&#123;timer,start_link,[]&#125;&#125;,</span><br><span class=\"line\">                       &#123;restart_type,permanent&#125;,</span><br><span class=\"line\">                       &#123;shutdown,1000&#125;,</span><br><span class=\"line\">                       &#123;child_type,worker&#125;]</span><br><span class=\"line\"></span><br><span class=\"line\">(helloworld_dev@youthy)1&gt; </span><br></pre></td></tr></table></figure></p>\n<p>然后在shell2中链接这个节点。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">youthy@youthy:~$ erl -sname test2 -remsh helloworld_dev@youthy</span><br><span class=\"line\">Erlang R15B (erts-5.9) [source] [64-bit] [smp:4:4] [async-threads:0] [hipe] [kernel-poll:false]</span><br><span class=\"line\"></span><br><span class=\"line\">Eshell V7.0  (abort with ^G)</span><br><span class=\"line\">(helloworld_dev@youthy)1&gt; helloworld_web:</span><br><span class=\"line\">loop/2         module_info/0  module_info/1  start/1        stop/0         </span><br><span class=\"line\"></span><br><span class=\"line\">(helloworld_dev@youthy)1&gt; helloworld_web:module_info().</span><br><span class=\"line\">[&#123;module,helloworld_web&#125;,</span><br><span class=\"line\"> &#123;exports,[&#123;start,1&#125;,</span><br><span class=\"line\">           &#123;stop,0&#125;,</span><br><span class=\"line\">           &#123;loop,2&#125;,</span><br><span class=\"line\">           &#123;module_info,0&#125;,</span><br><span class=\"line\">           &#123;module_info,1&#125;]&#125;,</span><br><span class=\"line\"> &#123;attributes,[&#123;vsn,[243820355007545606700617893262330487884]&#125;,</span><br><span class=\"line\">              &#123;author,&quot;Mochi Media &lt;dev@mochimedia.com&gt;&quot;&#125;]&#125;,</span><br><span class=\"line\"> &#123;compile,[&#123;options,[&#123;outdir,&quot;ebin&quot;&#125;,</span><br><span class=\"line\">                     debug_info,debug_info,</span><br><span class=\"line\">                     &#123;i,&quot;include&quot;&#125;]&#125;,</span><br><span class=\"line\">           &#123;version,&quot;6.0&quot;&#125;,</span><br><span class=\"line\">           &#123;time,&#123;2015,7,17,4,17,8&#125;&#125;,</span><br><span class=\"line\">           &#123;source,&quot;/home/youthy/code/helloworld/src/helloworld_web.erl&quot;&#125;]&#125;,</span><br><span class=\"line\"> &#123;native,false&#125;,</span><br><span class=\"line\"> &#123;md5,&lt;&lt;183,110,23,159,102,166,62,91,144,171,107,229,135,</span><br><span class=\"line\">        128,228,76&gt;&gt;&#125;]</span><br><span class=\"line\">(helloworld_dev@youthy)2&gt; </span><br><span class=\"line\">User switch command</span><br><span class=\"line\"> --&gt; q</span><br><span class=\"line\">youthy@youthy:~$ </span><br></pre></td></tr></table></figure></p>\n<p>值得注意的是1 必须给节点一个名字且命名方式需要一致。2退出时，不要用q()之类的，否则退出的时对面的节点。需要用ctrl+G然后q的方式。</p>\n<h3 id=\"-rsh_Program\">-rsh Program</h3><p>一般用来启用slave节点时用到。下面例子一开始我们进程中没有erl shell先启动一个master节点。然后在master节点里调用slave:start_link(Host, Name, Args)的方式。启动一个slave节点。这时我们看到进程里面有了两个erl shell。其中一个是已-noshell, noinput等方式启动的。这个就是slave启动的奴隶节点。我们可以用rpc调用一个功能，然后结果会返回给master节点。<br>因为我只有一台机器，如果不用&quot;-rsh ssh&quot;也是可以成功的。但是如果真是在其他机器上还是要加上ssh。两台节点环境，erl版本需一致。master节点退出后，不管时start_link启动还是start启动的slave节点都会退出。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">youthy@youthy:~$ ps -ef | grep erl</span><br><span class=\"line\">youthy   13884  2086  0 14:47 ?        00:00:00 /home/youthy/erls/R15B/erts-5.9/bin/epmd -daemon</span><br><span class=\"line\">youthy   23280 13177  0 15:19 pts/0    00:00:00 grep --color=auto erl</span><br><span class=\"line\">youthy@youthy:~$ erl -sname master</span><br><span class=\"line\">Erlang R15B (erts-5.9) [source] [64-bit] [smp:4:4] [async-threads:0] [hipe] [kernel-poll:false]</span><br><span class=\"line\"></span><br><span class=\"line\">Eshell V5.9  (abort with ^G)</span><br><span class=\"line\">(master@youthy)1&gt; </span><br><span class=\"line\">[1]+  已停止               erl -sname master</span><br><span class=\"line\">youthy@youthy:~$ ps -ef | grep erl</span><br><span class=\"line\">youthy   13884  2086  0 14:47 ?        00:00:00 /home/youthy/erls/R15B/erts-5.9/bin/epmd -daemon</span><br><span class=\"line\">youthy   23299 13177  1 15:19 pts/0    00:00:00 /home/youthy/erls/R15B/erts-5.9/bin/beam.smp -- -root /home/youthy/erls/R15B -progname erl -- -home /home/youthy -- -sname master</span><br><span class=\"line\">youthy   23336 13177  0 15:19 pts/0    00:00:00 grep --color=auto erl</span><br><span class=\"line\">youthy@youthy:~$ fg</span><br><span class=\"line\">erl -sname master</span><br><span class=\"line\"></span><br><span class=\"line\">(master@youthy)1&gt; slave:start_link(&#x27;youthy&#x27;, &#x27;slave&#x27;, &quot;-rsh ssh&quot;).</span><br><span class=\"line\">&#123;ok,slave@youthy&#125;</span><br><span class=\"line\">(master@youthy)2&gt; </span><br><span class=\"line\">[1]+  已停止               erl -sname master</span><br><span class=\"line\">youthy@youthy:~$ ps -ef | grep erl</span><br><span class=\"line\">youthy   13884  2086  0 14:47 ?        00:00:00 /home/youthy/erls/R15B/erts-5.9/bin/epmd -daemon</span><br><span class=\"line\">youthy   23299 13177  0 15:19 pts/0    00:00:00 /home/youthy/erls/R15B/erts-5.9/bin/beam.smp -- -root /home/youthy/erls/R15B -progname erl -- -home /home/youthy -- -sname master</span><br><span class=\"line\">youthy   23546  2086  0 15:20 ?        00:00:00 /home/youthy/erls/R15B/erts-5.9/bin/beam.smp -- -root /home/youthy/erls/R15B -progname erl -- -home /home/youthy -- -noshell -noinput -noshell -noinput -master master@youthy -sname slave@youthy -s slave slave_start master@youthy slave_waiter_0 -rsh ssh</span><br><span class=\"line\">youthy   23587 13177  0 15:20 pts/0    00:00:00 grep --color=auto erl</span><br><span class=\"line\">youthy@youthy:~$ fg</span><br><span class=\"line\">erl -sname master</span><br><span class=\"line\"></span><br><span class=\"line\">(master@youthy)2&gt; rpc:call(&#x27;slave@youthy&#x27;, lists, sum, [[2,3,4]]).</span><br><span class=\"line\">9</span><br><span class=\"line\">(master@youthy)3&gt; </span><br></pre></td></tr></table></figure></p>\n<h3 id=\"-set_cookie_Cookie\">-set_cookie Cookie</h3><p>等同于erlang:set_cookie/2</p>\n<h3 id=\"-shutdown_time_Time\">-shutdown_time Time</h3><p>Time是ms毫秒。设置关闭erl节点的时间，如果时间到了还没有结束完，就强制结束掉还存在的进程。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">youthy@youthy:~$ erl -shutdown_time 1000</span><br><span class=\"line\">Erlang R15B (erts-5.9) [source] [64-bit] [smp:4:4] [async-threads:0] [hipe] [kernel-poll:false]</span><br><span class=\"line\"></span><br><span class=\"line\">Eshell V5.9  (abort with ^G)</span><br><span class=\"line\">1&gt; q().</span><br><span class=\"line\">ok</span><br><span class=\"line\">2&gt; &#123;init,shutdown_timeout&#125;</span><br><span class=\"line\">youthy@youthy:~$ </span><br><span class=\"line\">youthy@youthy:~$ erl -shutdown_time 4000</span><br><span class=\"line\">Erlang R15B (erts-5.9) [source] [64-bit] [smp:4:4] [async-threads:0] [hipe] [kernel-poll:false]</span><br><span class=\"line\"></span><br><span class=\"line\">Eshell V5.9  (abort with ^G)</span><br><span class=\"line\">1&gt; q().</span><br><span class=\"line\">ok</span><br><span class=\"line\">2&gt; youthy@youthy:~$ </span><br></pre></td></tr></table></figure></p>\n<p>如上，1秒的时间看来时不够用的。</p>\n<h3 id=\"-smp_enable/auto/disable\">-smp enable/auto/disable</h3><p>是否启用smp，默认时auto。auto自动检测。如果符合会自动开启smp。<br><a href=\"http://www.cnblogs.com/me-sa/archive/2012/02/01/erlang0035.html\">关于smp</a>.</p>\n<h3 id=\"-version\">-version</h3><p>打印version信息。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"Startup\">Startup</h2><p>先拿mochiweb生成的一个例子说起，这是start-dev.sh脚本中的内容。启动一个mochiweb应用调用的就是这个<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/sh</span><br><span class=\"line\">exec erl \\</span><br><span class=\"line\">    -pa ebin deps/*/ebin \\</span><br><span class=\"line\">    -boot start_sasl \\</span><br><span class=\"line\">    -sname helloworld_dev \\</span><br><span class=\"line\">    -s helloworld \\</span><br><span class=\"line\">    -s reloader</span><br></pre></td></tr></table></figure></p>","more":"<p>通用形式就是</p>\n<blockquote>\n<p>erl -a b --sth -c d +f g -extra abc</p>\n</blockquote>\n<p>erl后面的都是参数arguments<br>arguments可以分为<strong>emulator flags</strong>，<strong>flags</strong>，<strong>plain arguments</strong></p>\n<pre><code>* 任何已+开始的参数会被解释为emulator <span class=\"keyword\">flags</span>\n* 任何以-开始的参数会被解释为<span class=\"keyword\">flags</span>，并传入交给了init模块。\n* 在--之后到任何-或者+符号之间的所有<span class=\"keyword\">flags</span>以及-extra之后所有的<span class=\"keyword\">flags</span>都是plain arguments，这些参数不会发生解释行为，只不过被储存起来。同样交给init模块。\n</code></pre><p>init:boot(Args)函数接受上面的flags和plain arguments。</p>\n<blockquote>\n<p><strong>boot(BootArgs) -&gt; no_return()<br>Types:<br>BootArgs = [binary()]</strong><br>Starts the Erlang runtime system. This function is called when the emulator is started and coordinates system start-up.<br>BootArgs are all command line arguments except the emulator flags, that is, flags and plain arguments. See erl(1).<br>init itself interprets some of the flags, see Command Line Flags below. The remaining flags (&quot;user flags&quot;) and plain arguments are passed to the init loop and can be retrieved by callingget_arguments/0 and get_plain_arguments/0, respectively.</p>\n</blockquote>\n<p>flags会被boot函数分为 init flags和user flags。user flags可以通过init:get_arguments()得到，plain arguments通过init:get_plain_arguments()得到。值得注意的是一小部分的“-”后面的flags现在是属于emulator flags。后面提到。</p>\n<!-- toc -->\n<ul>\n<li><a href=\"#init-flags\">Init Flags</a><ul>\n<li><a href=\"#--------\">--(两个横杠)</a></li>\n<li><a href=\"#-extra\">-extra</a></li>\n<li><a href=\"#-code-path-choice-choice--strict-relexed\">-code_path_choice Choice::strict|relexed</a></li>\n<li><a href=\"#-eval-expr\">-eval Expr</a></li>\n<li><a href=\"#-run-mod-func-arg1-arg2argn\">-run Mod Func Arg1 Arg2....ArgN</a></li>\n<li><a href=\"#-s-mod-func-arg1-arg2--argn\">-s Mod Func Arg1 Arg2 ... ArgN</a></li>\n<li><a href=\"#-applicationname-par-val\">-ApplicationName Par Val</a></li>\n<li><a href=\"#-args-file-filename\">-args_file FileName</a></li>\n<li><a href=\"#-async-shell-start\">-async_shell_start</a></li>\n<li><a href=\"#-boot-file\">-boot File</a></li>\n<li><a href=\"#-boot-var-var-dir\">-boot_var Var Dir</a></li>\n<li><a href=\"#-code-path-cache\">-code_path_cache</a></li>\n<li><a href=\"#-compile-mod1-mod2-\">-compile Mod1 Mod2 ...</a></li>\n<li><a href=\"#connect-all-true-false\">connect_all true|false</a></li>\n<li><a href=\"#-config-config\">-config Config</a></li>\n<li><a href=\"#-cookie-cookie\">-cookie Cookie</a></li>\n<li><a href=\"#-setcookie-cookie\">-setcookie Cookie</a></li>\n<li><a href=\"#-detached\">-detached</a></li>\n<li><a href=\"#-emu-args\">-emu_args</a></li>\n<li><a href=\"#-env-variable-value\">-env Variable Value</a></li>\n<li><a href=\"#-heart\">-heart</a></li>\n<li><a href=\"#-hidden\">-hidden</a></li>\n<li><a href=\"#-init-debug\">-init_debug</a></li>\n<li><a href=\"#-make\">-make</a></li>\n<li><a href=\"#-man-module\">-man Module</a></li>\n<li><a href=\"#-mode-interactive-embedded\">-mode interactive|embedded</a></li>\n<li><a href=\"#-name-sname-name\">-name/sname NAME</a></li>\n<li><a href=\"#-noinput\">-noinput</a></li>\n<li><a href=\"#-noshell\">-noshell</a></li>\n<li><a href=\"#-pa--pz\">-pa/-pz</a></li>\n<li><a href=\"#-remsh-node\">-remsh Node</a></li>\n<li><a href=\"#-rsh-program\">-rsh Program</a></li>\n<li><a href=\"#-set-cookie-cookie\">-set_cookie Cookie</a></li>\n<li><a href=\"#-shutdown-time-time\">-shutdown_time Time</a></li>\n<li><a href=\"#-smp-enable-auto-disable\">-smp enable/auto/disable</a></li>\n<li><a href=\"#-version\">-version</a></li>\n</ul>\n</li>\n</ul>\n<!-- tocstop -->\n<h2 id=\"Init_Flags\">Init Flags</h2><h3 id=\"-(两个横杠)\">--(两个横杠)</h3><p>任何在--到下一个-或者+之间的都是plain arguments，可以通过init:get_plain_arguments()取到.</p>\n<h3 id=\"-extra\">-extra</h3><p>和--的作用一样，extra后面的flags都是plain arguments</p>\n<h3 id=\"-code_path_choice_Choice::strict|relexed\">-code_path_choice Choice::strict|relexed</h3><blockquote>\n<p>When the choice of directories in the code path is strict, the directory that ends up in the code path will be exactly the stated one. This means that if for example the directory \\$OTPROOT/lib/mnesia-4.4.7/ebin is explicitly added to the code path, the code server will not load files from $OTPROOT/lib/mnesia-4.4.7.ez/mnesia-4.4.7/ebin and vice versa.</p>\n</blockquote>\n<blockquote>\n<p>This behavior can be controlled via the command line flag -code_path_choice Choice. If the flag is set to relaxed, the code server will instead choose a suitable directory depending on the actual file structure. If there exists a regular application ebin directory,situation it will be chosen. But if it does not exist, the ebin directory in the archive is chosen if it exists. If neither of them exists the original directory will be chosen.<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;/home/yuyouqi/Erlang/lib/snmp-5.1.1/ebin&quot;,</span><br><span class=\"line\"> &quot;/home/yuyouqi/Erlang/lib/sasl-2.4.1/ebin&quot;,</span><br><span class=\"line\"> &quot;/home/yuyouqi/Erlang/lib/runtime_tools-1.8.15/ebin&quot;,</span><br><span class=\"line\"> &quot;/home/yuyouqi/Erlang/lib/reltool-0.6.6/ebin&quot;,</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> &quot;/home/yuyouqi/Erlang/lib/ssh-3.1/ebin&quot;,</span><br><span class=\"line\"> &quot;/home/yuyouqi/Erlang/lib/snmp-5.1.1/ebin&quot;,</span><br><span class=\"line\"> &quot;/home/yuyouqi/Erlang/lib/sasl-2.4.1.ez/sasl-2.4.1/ebin&quot;,</span><br><span class=\"line\"> &quot;/home/yuyouqi/Erlang/lib/runtime_tools-1.8.15/ebin&quot;,</span><br><span class=\"line\"> 3&gt; code:lib_dir(sasl, ebin).</span><br><span class=\"line\">&quot;/home/yuyouqi/Erlang/lib/sasl-2.4.1.ez/sasl-2.4.1/ebin&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"-eval_Expr\">-eval Expr</h3><p>Expr是个函数，在erl初始化时按顺序执行，如果fail的，则初始化失败。例如<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">erl -eval &#x27;&#123;X,Y,Z&#125; = now(), random:seed(X,Y,Z).&#x27;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>官方文档Z}旁边多了‘符号，需要去掉</p>\n</blockquote>\n<h3 id=\"-run_Mod_Func_Arg1_Arg2-ArgN\">-run Mod Func Arg1 Arg2....ArgN</h3><p>调用Mod:Func([&quot;Arg1&quot;, &quot;Arg2&quot;, ...&quot;ArgN&quot;]),<br>所有参数都是以string方式传入的。同样按顺序执行，前一个执行完才会执行下一个。但是貌似并不会阻塞shell。</p>\n<h3 id=\"-s_Mod_Func_Arg1_Arg2_-_ArgN\">-s Mod Func Arg1 Arg2 ... ArgN</h3><p>与run完成同样的功能，但是Arg都是atom的形式传入，值得注意的是数字也会变成atom,<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">erl -s test time 5000 atom</span><br></pre></td></tr></table></figure></p>\n<p>就是test:time([&#39;5000&#39;, atom]).<br>一般数字需要atom_to_list, list_to_integer转换。</p>\n<p>##User flags</p>\n<h3 id=\"-ApplicationName_Par_Val\">-ApplicationName Par Val</h3><p>指定应用的名字，属性名称和值，可以将应用的某个参数设置成Val。<br>比如<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> erl -pa ./ebin -s helloworld -helloworld par haha</span><br><span class=\"line\"> 1&gt; application:get_all_key(helloworld).</span><br><span class=\"line\">&#123;ok,[&#123;description,&quot;helloworld&quot;&#125;,</span><br><span class=\"line\">     &#123;id,[]&#125;,</span><br><span class=\"line\">     &#123;vsn,&quot;0.1&quot;&#125;,</span><br><span class=\"line\">     &#123;modules,[helloworld,helloworld_app,helloworld_deps,</span><br><span class=\"line\">               helloworld_dtl,helloworld_sup,helloworld_web]&#125;,</span><br><span class=\"line\">     &#123;maxP,infinity&#125;,</span><br><span class=\"line\">     &#123;maxT,infinity&#125;,</span><br><span class=\"line\">     &#123;registered,[]&#125;,</span><br><span class=\"line\">     &#123;included_applications,[]&#125;,</span><br><span class=\"line\">     &#123;applications,[kernel,stdlib,crypto]&#125;,</span><br><span class=\"line\">     &#123;env,[&#123;par,haha&#125;,&#123;included_applications,[]&#125;]&#125;,</span><br><span class=\"line\">     &#123;mod,&#123;helloworld_app,[]&#125;&#125;,</span><br><span class=\"line\">     &#123;start_phases,undefined&#125;]&#125;</span><br><span class=\"line\">2&gt; application:get_all_env(helloworld).</span><br><span class=\"line\">[&#123;par,haha&#125;,&#123;included_applications,[]&#125;]</span><br></pre></td></tr></table></figure></p>\n<p>启动了一个helloworld应用，并将par参数设置成haha。</p>\n<h3 id=\"-args_file_FileName\">-args_file FileName</h3><p>直接从FileName读取erl所用的参数。例如在agrsfile的文件中写入如下</p>\n<blockquote>\n<p>-eval &#39;io:format(&quot;read from file~n&quot;)&#39; -extra hello -pa ./ebin</p>\n</blockquote>\n<p>实际结果<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">erl -args_file argsfile</span><br><span class=\"line\">Erlang R15B (erts-5.9) [source] [smp:2:2] [async-threads:0] [hipe] [kernel-poll:false]</span><br><span class=\"line\"></span><br><span class=\"line\">Eshell V5.9  (abort with ^G)</span><br><span class=\"line\">1&gt; read from file</span><br><span class=\"line\">1&gt; init:get_arguments().</span><br><span class=\"line\">[&#123;root,[&quot;/usr/local/lib/erlang&quot;]&#125;,</span><br><span class=\"line\"> &#123;progname,[&quot;erl&quot;]&#125;,</span><br><span class=\"line\"> &#123;home,[&quot;/home/yuyouqi&quot;]&#125;]</span><br><span class=\"line\">2&gt; init:get_plain_arguments().</span><br><span class=\"line\">[&quot;hello&quot;,&quot;-pa&quot;,&quot;./ebin&quot;]</span><br></pre></td></tr></table></figure></p>\n<p>可以看到启动的时候执行了io:format函数，但是-extra这个参数是特殊的，正常情况下-extra到下一个-或者+之间的参数才会被认为是plain arguments，可是如果写在文件中就变成-extra后面所有的参数，都会当成plain arguments.只有这点不同。</p>\n<h3 id=\"-async_shell_start\">-async_shell_start</h3><p>名字上来说是异步启动shell</p>\n<h3 id=\"-boot_File\">-boot File</h3><p>试用File.boot启动erl系统,除非File是个绝对路径，否则在当前文件夹和$ROOT/bin下面找（我的:/usr/local/lib/erlang/bin,  $ROOT可以通过code:root_dir()查看),<br>默认情况下是-boot start<br><a href=\"http://www.erlang.org/doc/man/script.html\">script</a></p>\n<blockquote>\n<p>The command erl -boot Name starts the system with a boot file called Name.boot, which is generated from the Name.script file, using systools:script2boot/1.<br>The .script file is generated by systools from a .rel file and .app files.</p>\n</blockquote>\n<p>.boot文件是用systools产生的，打开后是乱码.<br>文件的生成顺序 .rel -&gt; .script -&gt; .boot<br><a href=\"http://erlang.org/doc/man/systools.html\">systools</a><br>systools里面提供了生成rel,script, boot等方法。可以在<code>/usr/local/lib/erlang/releases/R15B</code>下找到几个官方的rel，script，boot<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Ubuntu@desktop:/usr/local/lib/erlang/releases/R15B$ ls</span><br><span class=\"line\">start_all_example.rel  start_clean.boot  start_clean.script  start_sasl.rel     start.script</span><br><span class=\"line\">start.boot             start_clean.rel   start_sasl.boot     start_sasl.script</span><br></pre></td></tr></table></figure></p>\n<p>打开start_sasl.rel<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">%%注释....</span><br><span class=\"line\">&#123;release, &#123;&quot;OTP  APN 181 01&quot;,&quot;R15B&quot;&#125;, &#123;erts, &quot;5.9&quot;&#125;,</span><br><span class=\"line\"> [&#123;kernel,&quot;2.15&quot;&#125;,</span><br><span class=\"line\">  &#123;stdlib,&quot;1.18&quot;&#125;,</span><br><span class=\"line\">  &#123;sasl, &quot;2.2&quot;&#125;]&#125;.</span><br></pre></td></tr></table></figure></p>\n<p>具体格式在上面的systools链接中有说明<br>仿照它这个样子写一个test<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;release, &#123;&quot;test_rel&quot;,&quot;0.1&quot;&#125;, &#123;erts, &quot;5.9&quot;&#125;,</span><br><span class=\"line\"> [&#123;kernel,&quot;2.15&quot;&#125;,</span><br><span class=\"line\">  &#123;stdlib,&quot;1.18&quot;&#125;,</span><br><span class=\"line\">  &#123;sasl, &quot;2.2&quot;&#125;,</span><br><span class=\"line\">  &#123;crypto, &quot;2.1&quot;&#125;,</span><br><span class=\"line\">  &#123;helloworld,&quot;0.1&quot;&#125;]&#125;.</span><br></pre></td></tr></table></figure></p>\n<p>helloworld使用mochiweb生成的简单框架,用到了crypto，所以讲crypto加入。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Erlang R15B (erts-5.9) [source] [smp:2:2] [async-threads:0] [hipe] [kernel-poll:false]</span><br><span class=\"line\"></span><br><span class=\"line\">Eshell V5.9  (abort with ^G)</span><br><span class=\"line\">1&gt; systools:make_script(&quot;test&quot;).       </span><br><span class=\"line\">helloworld: File not found: &quot;helloworld.app&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">error</span><br><span class=\"line\">2&gt; systools:make_script(&quot;test&quot;, [&#123;path, [&quot;ebin&quot;]&#125;]).</span><br><span class=\"line\">ok</span><br></pre></td></tr></table></figure><br>由于helloworld不在默认的ebin下，所以下加上当前路径中的ebin。否则找不到helloworld.app<br>如果是使用systools的make_script命令省的script会自动生成.boot。打开test.script<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">%% script generated at &#123;2015,7,1&#125; &#123;12,5,26&#125;</span><br><span class=\"line\">&#123;script,</span><br><span class=\"line\">    &#123;&quot;test_rel&quot;,&quot;0.1&quot;&#125;,</span><br><span class=\"line\">    [&#123;preLoaded,</span><br><span class=\"line\">         [erl_prim_loader,erlang,init,otp_ring0,prim_file,prim_inet,prim_zip,</span><br><span class=\"line\">          zlib]&#125;,</span><br><span class=\"line\">     &#123;progress,preloaded&#125;,</span><br><span class=\"line\">     &#123;path,[&quot;$ROOT/lib/kernel-2.15/ebin&quot;,&quot;$ROOT/lib/stdlib-1.18/ebin&quot;]&#125;,</span><br><span class=\"line\">     &#123;primLoad,[error_handler]&#125;,</span><br><span class=\"line\">     &#123;kernel_load_completed&#125;,</span><br><span class=\"line\">     &#123;progress,kernel_load_completed&#125;,</span><br><span class=\"line\">     &#123;path,[&quot;$ROOT/lib/kernel-2.15/ebin&quot;]&#125;,</span><br><span class=\"line\">     &#123;primLoad,</span><br><span class=\"line\">         [application,application_controller,application_master,</span><br><span class=\"line\">          application_starter,auth,code,code_server,disk_log,disk_log_1,</span><br><span class=\"line\">          disk_log_server,disk_log_sup,dist_ac,dist_util,erl_boot_server,</span><br><span class=\"line\">          erl_ddll,erl_distribution,erl_epmd,erl_reply,error_logger,</span><br><span class=\"line\">          erts_debug,file,file_io_server,file_server,gen_sctp,gen_tcp,gen_udp,</span><br><span class=\"line\">          global,global_group,global_search,group,heart,hipe_unified_loader,</span><br><span class=\"line\">          inet,inet6_sctp,inet6_tcp,inet6_tcp_dist,inet6_udp,inet_config,</span><br><span class=\"line\">          inet_db,inet_dns,inet_gethost_native,inet_hosts,inet_parse,inet_res,</span><br><span class=\"line\">          inet_sctp,inet_tcp,inet_tcp_dist,inet_udp,kernel,kernel_config,net,</span><br><span class=\"line\">          net_adm,net_kernel,os,packages,pg2,ram_file,rpc,seq_trace,</span><br><span class=\"line\">          standard_error,user,user_drv,user_sup,wrap_log_reader]&#125;,</span><br><span class=\"line\">     &#123;path,[&quot;$ROOT/lib/stdlib-1.18/ebin&quot;]&#125;,</span><br><span class=\"line\">...</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<p>有了.boot文件后就可以使用了<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yuyouqi@yuyouqi-desktop:~/Erlang/helloworld$ erl -pa ebin deps/*/ebin -boot test</span><br><span class=\"line\">Erlang R15B (erts-5.9) [source] [smp:2:2] [async-threads:0] [hipe] [kernel-poll:false]</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">=PROGRESS REPORT==== 1-Jul-2015::12:10:49 ===</span><br><span class=\"line\">          supervisor: &#123;local,sasl_safe_sup&#125;</span><br><span class=\"line\">             started: [&#123;pid,&lt;0.35.0&gt;&#125;,</span><br><span class=\"line\">                       &#123;name,alarm_handler&#125;,</span><br><span class=\"line\">                       &#123;mfargs,&#123;alarm_handler,start_link,[]&#125;&#125;,</span><br><span class=\"line\">                       &#123;restart_type,permanent&#125;,</span><br><span class=\"line\">                       &#123;shutdown,2000&#125;,</span><br><span class=\"line\">                       &#123;child_type,worker&#125;]</span><br><span class=\"line\"></span><br><span class=\"line\">=PROGRESS REPORT==== 1-Jul-2015::12:10:49 ===</span><br><span class=\"line\">          supervisor: &#123;local,sasl_safe_sup&#125;</span><br><span class=\"line\">             started: [&#123;pid,&lt;0.36.0&gt;&#125;,</span><br><span class=\"line\">                       &#123;name,overload&#125;,</span><br><span class=\"line\">                       &#123;mfargs,&#123;overload,start_link,[]&#125;&#125;,</span><br><span class=\"line\">                       &#123;restart_type,permanent&#125;,</span><br><span class=\"line\">                       &#123;shutdown,2000&#125;,</span><br><span class=\"line\">                       &#123;child_type,worker&#125;]</span><br><span class=\"line\"></span><br><span class=\"line\">=PROGRESS REPORT==== 1-Jul-2015::12:10:49 ===</span><br><span class=\"line\">          supervisor: &#123;local,sasl_sup&#125;</span><br><span class=\"line\">             started: [&#123;pid,&lt;0.34.0&gt;&#125;,</span><br><span class=\"line\">                       &#123;name,sasl_safe_sup&#125;,</span><br><span class=\"line\">                       &#123;mfargs,</span><br><span class=\"line\">                           &#123;supervisor,start_link,</span><br><span class=\"line\">                               [&#123;local,sasl_safe_sup&#125;,sasl,safe]&#125;&#125;,</span><br><span class=\"line\">                       &#123;restart_type,permanent&#125;,</span><br><span class=\"line\">                       &#123;shutdown,infinity&#125;,</span><br><span class=\"line\">                       &#123;child_type,supervisor&#125;]</span><br><span class=\"line\"></span><br><span class=\"line\">=PROGRESS REPORT==== 1-Jul-2015::12:10:49 ===</span><br><span class=\"line\">          supervisor: &#123;local,sasl_sup&#125;</span><br><span class=\"line\">             started: [&#123;pid,&lt;0.37.0&gt;&#125;,</span><br><span class=\"line\">                       &#123;name,release_handler&#125;,</span><br><span class=\"line\">                       &#123;mfargs,&#123;release_handler,start_link,[]&#125;&#125;,</span><br><span class=\"line\">                       &#123;restart_type,permanent&#125;,</span><br><span class=\"line\">                       &#123;shutdown,2000&#125;,</span><br><span class=\"line\">                       &#123;child_type,worker&#125;]</span><br><span class=\"line\"></span><br><span class=\"line\">=PROGRESS REPORT==== 1-Jul-2015::12:10:49 ===</span><br><span class=\"line\">         application: sasl</span><br><span class=\"line\">          started_at: nonode@nohost</span><br><span class=\"line\"></span><br><span class=\"line\">=PROGRESS REPORT==== 1-Jul-2015::12:10:49 ===</span><br><span class=\"line\">          supervisor: &#123;local,crypto_sup&#125;</span><br><span class=\"line\">             started: [&#123;pid,&lt;0.43.0&gt;&#125;,</span><br><span class=\"line\">                       &#123;name,crypto_server&#125;,</span><br><span class=\"line\">                       &#123;mfargs,&#123;crypto_server,start_link,[]&#125;&#125;,</span><br><span class=\"line\">                       &#123;restart_type,permanent&#125;,</span><br><span class=\"line\">                       &#123;shutdown,2000&#125;,</span><br><span class=\"line\">                       &#123;child_type,worker&#125;]</span><br><span class=\"line\"></span><br><span class=\"line\">=PROGRESS REPORT==== 1-Jul-2015::12:10:49 ===</span><br><span class=\"line\">         application: crypto</span><br><span class=\"line\">          started_at: nonode@nohost</span><br><span class=\"line\">** Found 0 name clashes in code paths </span><br><span class=\"line\"></span><br><span class=\"line\">=PROGRESS REPORT==== 1-Jul-2015::12:10:49 ===</span><br><span class=\"line\">          supervisor: &#123;local,helloworld_sup&#125;</span><br><span class=\"line\">             started: [&#123;pid,&lt;0.48.0&gt;&#125;,</span><br><span class=\"line\">                       &#123;name,helloworld_web&#125;,</span><br><span class=\"line\">                       &#123;mfargs,</span><br><span class=\"line\">                           &#123;helloworld_web,start,</span><br><span class=\"line\">                               [[&#123;ip,&#123;0,0,0,0&#125;&#125;,</span><br><span class=\"line\">                                 &#123;port,8080&#125;,</span><br><span class=\"line\">                                 &#123;docroot,</span><br><span class=\"line\">                                     &quot;/home/yuyouqi/Erlang/helloworld/priv/www&quot;&#125;]]&#125;&#125;,</span><br><span class=\"line\">                       &#123;restart_type,permanent&#125;,</span><br><span class=\"line\">                       &#123;shutdown,5000&#125;,</span><br><span class=\"line\">                       &#123;child_type,worker&#125;]</span><br><span class=\"line\"></span><br><span class=\"line\">=PROGRESS REPORT==== 1-Jul-2015::12:10:49 ===</span><br><span class=\"line\">         application: helloworld</span><br><span class=\"line\">          started_at: nonode@nohost</span><br><span class=\"line\">Eshell V5.9  (abort with ^G)</span><br><span class=\"line\">1&gt; </span><br></pre></td></tr></table></figure></p>\n<h3 id=\"-boot_var_Var_Dir\">-boot_var Var Dir</h3><p>指定一个变量Var的路径为Dir，主要用于systools:make_script的{variables, [{&quot;Var&quot;, &quot;Prefix&quot;}]},<br>因为默认的script路径都是在$ROOT/lib下寻找，当在make_script中加入variables选项时，</p>\n<h3 id=\"-code_path_cache\">-code_path_cache</h3><p>使用codepath的缓存，这样做的好处是加载模块更快，而且可以在常数时间找到模块，如果没加则需要search这个codepath才能找到对应模块，在模块数量很多时，可以使用。</p>\n<h3 id=\"-compile_Mod1_Mod2_-\">-compile Mod1 Mod2 ...</h3><p>编译Mod1 Mod2 ... 如果失败会返回非零的错误码 默认同时使用了-noinput参数.<strong>不推荐使用，推荐erlc</strong></p>\n<h3 id=\"connect_all_true|false\">connect_all true|false</h3><p>是否全联通（N1-N2， N2-N3 -&gt; N1-N2-N3），如果是false那么global模块的注册名字的相关机制无法使用</p>\n<h3 id=\"-config_Config\">-config Config</h3><p>读取Config文件，名字为AppName.config.<br>格式</p>\n<blockquote>\n<p>[{AppName, [{Key1, Value1}...]}, {AppName2, [...]}].</p>\n</blockquote>\n<p>见<a href=\"http://www.erlang.org/doc/man/config.html\">config file</a>.<br>例如新建helloworld.config<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[&#123;helloworld, [&#123;key1, val1&#125;, &#123;key2, val2&#125;]&#125;].</span><br></pre></td></tr></table></figure></p>\n<p>并在start脚本中加入-config helloworld.config<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/sh</span><br><span class=\"line\">exec erl \\</span><br><span class=\"line\">    -pa ebin deps/*/ebin \\</span><br><span class=\"line\">    -boot start_sasl \\</span><br><span class=\"line\">    -sname helloworld_dev \\</span><br><span class=\"line\">    -s helloworld \\</span><br><span class=\"line\">    -s reloader \\</span><br><span class=\"line\">    -config helloworld.config</span><br></pre></td></tr></table></figure></p>\n<p>如下看到在env中多了写入的config值</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(helloworld_dev@Ubuntu-desktop)1&gt; application:get_all_key(helloworld).</span><br><span class=\"line\">&#123;ok,[&#123;description,&quot;helloworld&quot;&#125;,</span><br><span class=\"line\">     &#123;id,[]&#125;,</span><br><span class=\"line\">     &#123;vsn,&quot;0.1&quot;&#125;,</span><br><span class=\"line\">     &#123;modules,[helloworld,helloworld_app,helloworld_deps,</span><br><span class=\"line\">               helloworld_dtl,helloworld_sup,helloworld_web]&#125;,</span><br><span class=\"line\">     &#123;maxP,infinity&#125;,</span><br><span class=\"line\">     &#123;maxT,infinity&#125;,</span><br><span class=\"line\">     &#123;registered,[]&#125;,</span><br><span class=\"line\">     &#123;included_applications,[]&#125;,</span><br><span class=\"line\">     &#123;applications,[kernel,stdlib,crypto]&#125;,</span><br><span class=\"line\">     &#123;env,[&#123;included_applications,[]&#125;,&#123;key2,val2&#125;,&#123;key1,val1&#125;]&#125;,</span><br><span class=\"line\">     &#123;mod,&#123;helloworld_app,[]&#125;&#125;,</span><br><span class=\"line\">     &#123;start_phases,undefined&#125;]&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"-cookie_Cookie\">-cookie Cookie</h3><p>过时的没有任何效果的标志，是setcookie的错误拼写，用setcookie代替。</p>\n<h3 id=\"-setcookie_Cookie\">-setcookie Cookie</h3><p>和erlang:set_cookie(Node, Cookie)的效果一样。给本地结点设置需要给本地结点起个名字-name/sname</p>\n<h3 id=\"-detached\">-detached</h3><p>以background的形式运行erl，与当前shell分离开，但是需要知道如何停止这个系统<br><a href=\"http://stackoverflow.com/questions/15464606/erlang-kill-all-processes-running-in-background\">How to stop</a>.</p>\n<h3 id=\"-emu_args\">-emu_args</h3><p>打印传给emulator的参数，比如在start-dev.sh脚本中加入它，可以看到<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ ./start-dev.sh </span><br><span class=\"line\">Executing: /usr/local/lib/erlang/erts-5.9/bin/beam.smp /usr/local/lib/erlang/erts-5.9/bin/beam.smp -- -root /usr/local/lib/erlang -progname erl -- -home /home/yuyouqi -- -pa ebin deps/erlydtl/ebin deps/eunit_formatters/ebin deps/merl/ebin deps/mochiweb/ebin -boot start_sasl -sname helloworld_dev -s helloworld -s reloader</span><br><span class=\"line\"></span><br><span class=\"line\">Erlang R15B (erts-5.9) [source] [smp:2:2] [async-threads:0] [hipe] [kernel-poll:false]</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"-env_Variable_Value\">-env Variable Value</h3><p>设置OS模块的环境变量Variable为Value.<br>通过os:getenv/0 getenv/1可以得到</p>\n<h3 id=\"-heart\">-heart</h3><p>开启心跳检测，尽管erlang有各种supervisor监管机制，但是如果emulator down掉了就完了，-heart会开启一个heart进程监控整个emulator，在规定时间内如果没有收到心跳，这个进程就会执行HEART_COMMAND参数，如果这个参数没有设定，那么只会弹出警告，而不会重启。一般HEART_COMMAND就是重启emulator。麻烦的是如果设定了heart，但是没有用-sname，是无法回到这个erlang shell的，也就是无法调用init：stop()来终止heart的监控策略。</p>\n<p>在没有开启任何erl shell的情况下调用<code>ps -ef|grep erl</code>看到跟erl有关的进程如下<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ ps -ef |grep erl</span><br><span class=\"line\">yuyouqi   2475  2345  0 10:23 ?        00:00:01 /usr/bin/perl /usr/bin/shutter --min_at_startup</span><br><span class=\"line\">yuyouqi   3329  2862  0 10:58 pts/2    00:00:00 grep --color=auto erl</span><br></pre></td></tr></table></figure></p>\n<p>启动一个erl emulator,然后Ctrl + z放到挂起<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ erl </span><br><span class=\"line\">Erlang R15B (erts-5.9) [source] [smp:2:2] [async-threads:0] [hipe] [kernel-poll:false]</span><br><span class=\"line\"></span><br><span class=\"line\">Eshell V5.9  (abort with ^G)</span><br><span class=\"line\">1&gt; </span><br><span class=\"line\">[1]+  已停止               erl</span><br><span class=\"line\">yuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ ps -ef |grep erl</span><br><span class=\"line\">yuyouqi   2475  2345  0 10:23 ?        00:00:01 /usr/bin/perl /usr/bin/shutter --min_at_startup</span><br><span class=\"line\">yuyouqi   3333  2862  0 11:01 pts/2    00:00:00 /usr/local/lib/erlang/erts-5.9/bin/beam.smp -- -root /usr/local/lib/erlang -progname erl -- -home /home/yuyouqi --</span><br><span class=\"line\">yuyouqi   3346  2862  0 11:01 pts/2    00:00:00 grep --color=auto erl</span><br></pre></td></tr></table></figure></p>\n<p>可以看到3333这个进程后面的命令是开启一个erl emulator的<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ kill -9 3333</span><br><span class=\"line\">yuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ ps -ef | grep erl</span><br><span class=\"line\">yuyouqi   2475  2345  0 10:23 ?        00:00:01 /usr/bin/perl /usr/bin/shutter --min_at_startup</span><br><span class=\"line\">yuyouqi   3366  2862  0 11:04 pts/2    00:00:00 grep --color=auto erl</span><br><span class=\"line\">[1]+  已杀死               erl</span><br></pre></td></tr></table></figure></p>\n<p>可以看到将他kill掉是没问题的<br>下面启动一个-heart erl shell<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ erl -sname test1 -heart -env HEART_COMMAND &quot;erl -sname test1 -heart&quot;</span><br><span class=\"line\">heart_beat_kill_pid = 3369</span><br><span class=\"line\">Erlang R15B (erts-5.9) [source] [smp:2:2] [async-threads:0] [hipe] [kernel-poll:false]</span><br><span class=\"line\"></span><br><span class=\"line\">Eshell V5.9  (abort with ^G)</span><br><span class=\"line\">(test1@yuyouqi-desktop)1&gt; </span><br><span class=\"line\">[1]+  已停止               erl -sname test1 -heart -env HEART_COMMAND &quot;erl -sname test1 -heart&quot;</span><br><span class=\"line\">yuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ ps -ef | grep erl</span><br><span class=\"line\">yuyouqi   2475  2345  0 10:23 ?        00:00:01 /usr/bin/perl /usr/bin/shutter --min_at_startup</span><br><span class=\"line\">yuyouqi   3369  2862  1 11:05 pts/2    00:00:00 /usr/local/lib/erlang/erts-5.9/bin/beam.smp -- -root /usr/local/lib/erlang -progname erl -- -home /home/yuyouqi -- -sname test1 -heart</span><br><span class=\"line\">yuyouqi   3376  2219  0 11:05 ?        00:00:00 /usr/local/lib/erlang/erts-5.9/bin/epmd -daemon</span><br><span class=\"line\">yuyouqi   3387  2862  0 11:06 pts/2    00:00:00 grep --color=auto erl</span><br><span class=\"line\"></span><br><span class=\"line\">yuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ heart: Fri Jul  3 11:06:57 2015: heart-beat time-out.</span><br><span class=\"line\">heart_beat_kill_pid = 3390</span><br><span class=\"line\">yuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ ps -ef | grep erl</span><br><span class=\"line\">yuyouqi   2475  2345  0 10:23 ?        00:00:01 /usr/bin/perl /usr/bin/shutter --min_at_startup</span><br><span class=\"line\">yuyouqi   3376  2219  0 11:05 ?        00:00:00 /usr/local/lib/erlang/erts-5.9/bin/epmd -daemon</span><br><span class=\"line\">yuyouqi   3389  3383  0 11:06 ?        00:00:00 sh -c erl -sname test1 -heart</span><br><span class=\"line\">yuyouqi   3390  3389  0 11:06 ?        00:00:00 /usr/local/lib/erlang/erts-5.9/bin/beam.smp -- -root /usr/local/lib/erlang -progname erl -- -home /home/yuyouqi -- -sname test1 -heart</span><br><span class=\"line\">yuyouqi   3410  2862  0 11:07 pts/2    00:00:00 grep --color=auto erl</span><br></pre></td></tr></table></figure></p>\n<p>上面命令是我用-heart启动一个erl shell，可以看到多了3369 和3376这两个进程，把erl shell挂起，一段时间后，由于heart进程没有接收到“心跳”，重启了erl shell,pid变为3390。而且多出了一个3389这个进程，而3390这个erl shell是3389的子进程。可以看到3389就是执行我们的HEART_COMMAND<br>如果不指定HEART_COMMAND<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ erl -sname test2 -heart</span><br><span class=\"line\">heart_beat_kill_pid = 3685</span><br><span class=\"line\">Erlang R15B (erts-5.9) [source] [smp:2:2] [async-threads:0] [hipe] [kernel-poll:false]</span><br><span class=\"line\"></span><br><span class=\"line\">Eshell V5.9  (abort with ^G)</span><br><span class=\"line\">(test2@yuyouqi-desktop)1&gt; </span><br><span class=\"line\">[1]+  已停止               erl -sname test2 -heart</span><br><span class=\"line\">yuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ ps -ef|grep erl</span><br><span class=\"line\">yuyouqi   2475  2345  0 10:23 ?        00:00:01 /usr/bin/perl /usr/bin/shutter --min_at_startup</span><br><span class=\"line\">yuyouqi   3376  2219  0 11:05 ?        00:00:00 /usr/local/lib/erlang/erts-5.9/bin/epmd -daemon</span><br><span class=\"line\">yuyouqi   3389  3383  0 11:06 ?        00:00:00 sh -c erl -sname test1 -heart</span><br><span class=\"line\">yuyouqi   3390  3389  0 11:06 ?        00:00:00 /usr/local/lib/erlang/erts-5.9/bin/beam.smp -- -root /usr/local/lib/erlang -progname erl -- -home /home/yuyouqi -- -sname test1 -heart</span><br><span class=\"line\">yuyouqi   3685  2862  2 12:15 pts/2    00:00:00 /usr/local/lib/erlang/erts-5.9/bin/beam.smp -- -root /usr/local/lib/erlang -progname erl -- -home /home/yuyouqi -- -sname test2 -heart</span><br><span class=\"line\">yuyouqi   3703  2862  0 12:15 pts/2    00:00:00 grep --color=auto erl</span><br><span class=\"line\">yuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ jobs</span><br><span class=\"line\">[1]+  已停止               erl -sname test2 -heart</span><br><span class=\"line\">yuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ fg</span><br><span class=\"line\">erl -sname test2 -heart</span><br><span class=\"line\"></span><br><span class=\"line\">(test2@yuyouqi-desktop)1&gt; </span><br><span class=\"line\">User switch command</span><br><span class=\"line\"> --&gt; q</span><br><span class=\"line\">yuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ heart: Fri Jul  3 12:16:10 2015: Erlang has closed.</span><br><span class=\"line\">heart: Fri Jul  3 12:16:10 2015: Would reboot. Terminating.</span><br><span class=\"line\"></span><br><span class=\"line\">yuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ ps -ef|grep erl</span><br><span class=\"line\">yuyouqi   2475  2345  0 10:23 ?        00:00:01 /usr/bin/perl /usr/bin/shutter --min_at_startup</span><br><span class=\"line\">yuyouqi   3376  2219  0 11:05 ?        00:00:00 /usr/local/lib/erlang/erts-5.9/bin/epmd -daemon</span><br><span class=\"line\">yuyouqi   3389  3383  0 11:06 ?        00:00:00 sh -c erl -sname test1 -heart</span><br><span class=\"line\">yuyouqi   3390  3389  0 11:06 ?        00:00:00 /usr/local/lib/erlang/erts-5.9/bin/beam.smp -- -root /usr/local/lib/erlang -progname erl -- -home /home/yuyouqi -- -sname test1 -heart</span><br><span class=\"line\">yuyouqi   3705  2862  0 12:16 pts/2    00:00:00 grep --color=auto erl</span><br></pre></td></tr></table></figure></p>\n<p>新建一个test2 shell，不设置HEART_COMMAND，<br>可以看到如果没有设置HEART_COMMAND 使用ctrl g退出后不会重启，但是test1是会重启的。<br>而且新建节点后发现-daemon进程并没有增加，我猜测-daemon有可能是heart监控进程。<br>但是无论怎样kill都是无效的，依然会重启<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ kill -9 3376 3389 3390</span><br><span class=\"line\">yuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ heart: Fri Jul  3 12:21:15 2015: Executed &quot;erl -sname test1 -heart&quot;. Terminating.</span><br><span class=\"line\">heart: Fri Jul  3 12:21:15 2015: Erlang has closed.</span><br><span class=\"line\">heart_beat_kill_pid = 3716</span><br><span class=\"line\"></span><br><span class=\"line\">yuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ ps -ef|grep erl</span><br><span class=\"line\">yuyouqi   2475  2345  0 10:23 ?        00:00:01 /usr/bin/perl /usr/bin/shutter --min_at_startup</span><br><span class=\"line\">yuyouqi   3715  3404  0 12:21 ?        00:00:00 sh -c erl -sname test1 -heart</span><br><span class=\"line\">yuyouqi   3716  3715  3 12:21 ?        00:00:00 /usr/local/lib/erlang/erts-5.9/bin/beam.smp -- -root /usr/local/lib/erlang -progname erl -- -home /home/yuyouqi -- -sname test1 -heart</span><br><span class=\"line\">yuyouqi   3723  2219  0 12:21 ?        00:00:00 /usr/local/lib/erlang/erts-5.9/bin/epmd -daemon</span><br><span class=\"line\">yuyouqi   3734  2862  0 12:21 pts/2    00:00:00 grep --color=auto erl</span><br></pre></td></tr></table></figure></p>\n<p>这时就需要进入test1，调用init:stop()来结束<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ erl -sname test2</span><br><span class=\"line\">Erlang R15B (erts-5.9) [source] [smp:2:2] [async-threads:0] [hipe] [kernel-poll:false]</span><br><span class=\"line\"></span><br><span class=\"line\">Eshell V5.9  (abort with ^G)</span><br><span class=\"line\">(test2@yuyouqi-desktop)1&gt; </span><br><span class=\"line\">User switch command</span><br><span class=\"line\"> --&gt; r &#x27;test1@yuyouqi-desktop&#x27;</span><br><span class=\"line\"> --&gt; c</span><br><span class=\"line\">Eshell V5.9  (abort with ^G)</span><br><span class=\"line\">(test1@yuyouqi-desktop)1&gt; init:stop().</span><br><span class=\"line\">*** ERROR: Shell process terminated! (^G to start new job) ***</span><br><span class=\"line\">heart: Fri Jul  3 12:23:40 2015: Executed &quot;erl -sname test1 -heart&quot;. Terminating.</span><br><span class=\"line\"></span><br><span class=\"line\">User switch command</span><br><span class=\"line\"> --&gt; j</span><br><span class=\"line\">   1  &#123;shell,start,[init]&#125;</span><br><span class=\"line\"> --&gt; c 1</span><br><span class=\"line\"></span><br><span class=\"line\">(test2@yuyouqi-desktop)1&gt;        </span><br><span class=\"line\">User switch command</span><br><span class=\"line\"> --&gt; q</span><br><span class=\"line\">yuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ ps -ef|grep erl</span><br><span class=\"line\">yuyouqi   2475  2345  0 10:23 ?        00:00:01 /usr/bin/perl /usr/bin/shutter --min_at_startup</span><br><span class=\"line\">yuyouqi   3723  2219  0 12:21 ?        00:00:00 /usr/local/lib/erlang/erts-5.9/bin/epmd -daemon</span><br><span class=\"line\">yuyouqi   3760  2862  0 12:24 pts/2    00:00:00 grep --color=auto erl</span><br></pre></td></tr></table></figure></p>\n<p>这样才能将heart监控的shell关闭(或者使用rpc)<br>参考<a href=\"http://stackoverflow.com/questions/7217892/is-there-a-way-to-kill-the-erlang-vm-when-it-is-running-with-heart\">Is there a way to kill the erlang vm when it is running with -heart</a></p>\n<h3 id=\"-hidden\">-hidden</h3><p>已hidden启动的结点在于其他结点连接时，他的连接时隐藏的，不会再nodes()中得到自己的名字。只有与自己同属于一个<a href=\"http://www.erlang.org/doc/man/global_group.html#type-group_name\">global_group</a>的其他结点才能知道自己。<br>比如建立一个kernel.config,定义一个global_group<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[&#123;kernel, [&#123;global_groups, [&#123;test, [&#x27;test1@yuyouqi-desktop&#x27;, &#x27;test2@yuyouqi-desktop&#x27;]&#125;]&#125;]&#125;].</span><br></pre></td></tr></table></figure></p>\n<p>然后启动3个结点test1，test2，test3<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ erl -sname test1 -config kernel.config </span><br><span class=\"line\">Erlang R15B (erts-5.9) [source] [smp:2:2] [async-threads:0] [hipe] [kernel-poll:false]</span><br><span class=\"line\"></span><br><span class=\"line\">Eshell V5.9  (abort with ^G)</span><br><span class=\"line\">(test1@yuyouqi-desktop)1&gt; global_group:global_groups().</span><br><span class=\"line\">&#123;test,[]&#125;</span><br><span class=\"line\">yuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ erl -sname test2 -hidden -config kernel.config </span><br><span class=\"line\">Erlang R15B (erts-5.9) [source] [smp:2:2] [async-threads:0] [hipe] [kernel-poll:false]</span><br><span class=\"line\"></span><br><span class=\"line\">Eshell V5.9  (abort with ^G)</span><br><span class=\"line\">(test2@yuyouqi-desktop)1&gt; global_group:global_groups().</span><br><span class=\"line\">&#123;test,[]&#125;</span><br><span class=\"line\">yuyouqi@yuyouqi-desktop:~/Erlang/mochiweb/helloworld$ erl -sname test3 -config kernel.config </span><br><span class=\"line\">Erlang R15B (erts-5.9) [source] [smp:2:2] [async-threads:0] [hipe] [kernel-poll:false]</span><br><span class=\"line\"></span><br><span class=\"line\">Eshell V5.9  (abort with ^G)</span><br><span class=\"line\">(test3@yuyouqi-desktop)1&gt; global_group:global_groups().</span><br><span class=\"line\">&#123;no_name,[test]&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其中test2已hidden形式启动，test3不在global_group中，可以看到test1和test2返回自己的global_group为test。<br>用<code>net_kernel:connect</code>将它们互联。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(test2@yuyouqi-desktop)2&gt; net_kernel:connect(&#x27;test1@yuyouqi-desktop&#x27;).</span><br><span class=\"line\">true</span><br><span class=\"line\">(test2@yuyouqi-desktop)3&gt; nodes().</span><br><span class=\"line\">[&#x27;test1@yuyouqi-desktop&#x27;]</span><br><span class=\"line\">(test2@yuyouqi-desktop)5&gt; net_kernel:connect(&#x27;test3@yuyouqi-desktop&#x27;).</span><br><span class=\"line\">true</span><br><span class=\"line\">(test2@yuyouqi-desktop)6&gt; nodes().</span><br><span class=\"line\">[&#x27;test1@yuyouqi-desktop&#x27;]</span><br><span class=\"line\">(test1@yuyouqi-desktop)2&gt; nodes().</span><br><span class=\"line\">[&#x27;test2@yuyouqi-desktop&#x27;]</span><br><span class=\"line\">(test3@yuyouqi-desktop)2&gt; nodes().</span><br><span class=\"line\">[]</span><br></pre></td></tr></table></figure></p>\n<p>test1和test2是可以互相看到的，而test3的nodes()返回的是空</p>\n<h3 id=\"-init_debug\">-init_debug</h3><p>启动的时候打印调试参数。可以尝试下<code>erl -init_debug</code> 然后对照着<code>/usr/local/lib/erlang/releases/RXXB/start.script</code></p>\n<h3 id=\"-make\">-make</h3><p>相当于make:all(),见<br><a href=\"http://www.erlang.org/doc/man/make.html\">make</a></p>\n<h3 id=\"-man_Module\">-man Module</h3><p>查询某个模块的手册，首先需要去官网下载相应的手册</p>\n<h3 id=\"-mode_interactive|embedded\">-mode interactive|embedded</h3><p>erlang system载入代码的方式，interactive模式下，系统只载入一部分代码，当使用为载入的代码时，会尝试自动载入这个模块。如果是embeded模式，实在系统初始化时，根据启动的script文件载入所有代码，如果文件上没有提到，不会载入，如果调用为载入模块的函数，会报exception error</p>\n<h3 id=\"-name/sname_NAME\">-name/sname NAME</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">erl -sname test1</span><br><span class=\"line\">erl -name test2@192.168.1.10</span><br></pre></td></tr></table></figure>\n<p>sname 与name之间的结点不能通信，必须命名方式相同才可以。 sname只能用于同一子网内的机器。</p>\n<h3 id=\"-noinput\">-noinput</h3><p>erl不读入任何参数</p>\n<h3 id=\"-noshell\">-noshell</h3><p>常用，不显示erl shell。一般都是执行一系列的-eval，-s，-ran，然后init:stop().</p>\n<h3 id=\"-pa/-pz\">-pa/-pz</h3><p>添加code路径，没什么可说的同code:addpathsa/addpathsz</p>\n<h3 id=\"-remsh_Node\">-remsh Node</h3><p>远程链接一个节点。例如在shell1中启动一个mochiweb例子<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">youthy@youthy:~/code/helloworld$ ./start-dev.sh </span><br><span class=\"line\">...=PROGRESS REPORT==== 17-Jul-2015::12:20:43 ===</span><br><span class=\"line\">          supervisor: &#123;local,kernel_safe_sup&#125;</span><br><span class=\"line\">             started: [&#123;pid,&lt;0.74.0&gt;&#125;,</span><br><span class=\"line\">                       &#123;id,timer_server&#125;,</span><br><span class=\"line\">                       &#123;mfargs,&#123;timer,start_link,[]&#125;&#125;,</span><br><span class=\"line\">                       &#123;restart_type,permanent&#125;,</span><br><span class=\"line\">                       &#123;shutdown,1000&#125;,</span><br><span class=\"line\">                       &#123;child_type,worker&#125;]</span><br><span class=\"line\"></span><br><span class=\"line\">(helloworld_dev@youthy)1&gt; </span><br></pre></td></tr></table></figure></p>\n<p>然后在shell2中链接这个节点。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">youthy@youthy:~$ erl -sname test2 -remsh helloworld_dev@youthy</span><br><span class=\"line\">Erlang R15B (erts-5.9) [source] [64-bit] [smp:4:4] [async-threads:0] [hipe] [kernel-poll:false]</span><br><span class=\"line\"></span><br><span class=\"line\">Eshell V7.0  (abort with ^G)</span><br><span class=\"line\">(helloworld_dev@youthy)1&gt; helloworld_web:</span><br><span class=\"line\">loop/2         module_info/0  module_info/1  start/1        stop/0         </span><br><span class=\"line\"></span><br><span class=\"line\">(helloworld_dev@youthy)1&gt; helloworld_web:module_info().</span><br><span class=\"line\">[&#123;module,helloworld_web&#125;,</span><br><span class=\"line\"> &#123;exports,[&#123;start,1&#125;,</span><br><span class=\"line\">           &#123;stop,0&#125;,</span><br><span class=\"line\">           &#123;loop,2&#125;,</span><br><span class=\"line\">           &#123;module_info,0&#125;,</span><br><span class=\"line\">           &#123;module_info,1&#125;]&#125;,</span><br><span class=\"line\"> &#123;attributes,[&#123;vsn,[243820355007545606700617893262330487884]&#125;,</span><br><span class=\"line\">              &#123;author,&quot;Mochi Media &lt;dev@mochimedia.com&gt;&quot;&#125;]&#125;,</span><br><span class=\"line\"> &#123;compile,[&#123;options,[&#123;outdir,&quot;ebin&quot;&#125;,</span><br><span class=\"line\">                     debug_info,debug_info,</span><br><span class=\"line\">                     &#123;i,&quot;include&quot;&#125;]&#125;,</span><br><span class=\"line\">           &#123;version,&quot;6.0&quot;&#125;,</span><br><span class=\"line\">           &#123;time,&#123;2015,7,17,4,17,8&#125;&#125;,</span><br><span class=\"line\">           &#123;source,&quot;/home/youthy/code/helloworld/src/helloworld_web.erl&quot;&#125;]&#125;,</span><br><span class=\"line\"> &#123;native,false&#125;,</span><br><span class=\"line\"> &#123;md5,&lt;&lt;183,110,23,159,102,166,62,91,144,171,107,229,135,</span><br><span class=\"line\">        128,228,76&gt;&gt;&#125;]</span><br><span class=\"line\">(helloworld_dev@youthy)2&gt; </span><br><span class=\"line\">User switch command</span><br><span class=\"line\"> --&gt; q</span><br><span class=\"line\">youthy@youthy:~$ </span><br></pre></td></tr></table></figure></p>\n<p>值得注意的是1 必须给节点一个名字且命名方式需要一致。2退出时，不要用q()之类的，否则退出的时对面的节点。需要用ctrl+G然后q的方式。</p>\n<h3 id=\"-rsh_Program\">-rsh Program</h3><p>一般用来启用slave节点时用到。下面例子一开始我们进程中没有erl shell先启动一个master节点。然后在master节点里调用slave:start_link(Host, Name, Args)的方式。启动一个slave节点。这时我们看到进程里面有了两个erl shell。其中一个是已-noshell, noinput等方式启动的。这个就是slave启动的奴隶节点。我们可以用rpc调用一个功能，然后结果会返回给master节点。<br>因为我只有一台机器，如果不用&quot;-rsh ssh&quot;也是可以成功的。但是如果真是在其他机器上还是要加上ssh。两台节点环境，erl版本需一致。master节点退出后，不管时start_link启动还是start启动的slave节点都会退出。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">youthy@youthy:~$ ps -ef | grep erl</span><br><span class=\"line\">youthy   13884  2086  0 14:47 ?        00:00:00 /home/youthy/erls/R15B/erts-5.9/bin/epmd -daemon</span><br><span class=\"line\">youthy   23280 13177  0 15:19 pts/0    00:00:00 grep --color=auto erl</span><br><span class=\"line\">youthy@youthy:~$ erl -sname master</span><br><span class=\"line\">Erlang R15B (erts-5.9) [source] [64-bit] [smp:4:4] [async-threads:0] [hipe] [kernel-poll:false]</span><br><span class=\"line\"></span><br><span class=\"line\">Eshell V5.9  (abort with ^G)</span><br><span class=\"line\">(master@youthy)1&gt; </span><br><span class=\"line\">[1]+  已停止               erl -sname master</span><br><span class=\"line\">youthy@youthy:~$ ps -ef | grep erl</span><br><span class=\"line\">youthy   13884  2086  0 14:47 ?        00:00:00 /home/youthy/erls/R15B/erts-5.9/bin/epmd -daemon</span><br><span class=\"line\">youthy   23299 13177  1 15:19 pts/0    00:00:00 /home/youthy/erls/R15B/erts-5.9/bin/beam.smp -- -root /home/youthy/erls/R15B -progname erl -- -home /home/youthy -- -sname master</span><br><span class=\"line\">youthy   23336 13177  0 15:19 pts/0    00:00:00 grep --color=auto erl</span><br><span class=\"line\">youthy@youthy:~$ fg</span><br><span class=\"line\">erl -sname master</span><br><span class=\"line\"></span><br><span class=\"line\">(master@youthy)1&gt; slave:start_link(&#x27;youthy&#x27;, &#x27;slave&#x27;, &quot;-rsh ssh&quot;).</span><br><span class=\"line\">&#123;ok,slave@youthy&#125;</span><br><span class=\"line\">(master@youthy)2&gt; </span><br><span class=\"line\">[1]+  已停止               erl -sname master</span><br><span class=\"line\">youthy@youthy:~$ ps -ef | grep erl</span><br><span class=\"line\">youthy   13884  2086  0 14:47 ?        00:00:00 /home/youthy/erls/R15B/erts-5.9/bin/epmd -daemon</span><br><span class=\"line\">youthy   23299 13177  0 15:19 pts/0    00:00:00 /home/youthy/erls/R15B/erts-5.9/bin/beam.smp -- -root /home/youthy/erls/R15B -progname erl -- -home /home/youthy -- -sname master</span><br><span class=\"line\">youthy   23546  2086  0 15:20 ?        00:00:00 /home/youthy/erls/R15B/erts-5.9/bin/beam.smp -- -root /home/youthy/erls/R15B -progname erl -- -home /home/youthy -- -noshell -noinput -noshell -noinput -master master@youthy -sname slave@youthy -s slave slave_start master@youthy slave_waiter_0 -rsh ssh</span><br><span class=\"line\">youthy   23587 13177  0 15:20 pts/0    00:00:00 grep --color=auto erl</span><br><span class=\"line\">youthy@youthy:~$ fg</span><br><span class=\"line\">erl -sname master</span><br><span class=\"line\"></span><br><span class=\"line\">(master@youthy)2&gt; rpc:call(&#x27;slave@youthy&#x27;, lists, sum, [[2,3,4]]).</span><br><span class=\"line\">9</span><br><span class=\"line\">(master@youthy)3&gt; </span><br></pre></td></tr></table></figure></p>\n<h3 id=\"-set_cookie_Cookie\">-set_cookie Cookie</h3><p>等同于erlang:set_cookie/2</p>\n<h3 id=\"-shutdown_time_Time\">-shutdown_time Time</h3><p>Time是ms毫秒。设置关闭erl节点的时间，如果时间到了还没有结束完，就强制结束掉还存在的进程。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">youthy@youthy:~$ erl -shutdown_time 1000</span><br><span class=\"line\">Erlang R15B (erts-5.9) [source] [64-bit] [smp:4:4] [async-threads:0] [hipe] [kernel-poll:false]</span><br><span class=\"line\"></span><br><span class=\"line\">Eshell V5.9  (abort with ^G)</span><br><span class=\"line\">1&gt; q().</span><br><span class=\"line\">ok</span><br><span class=\"line\">2&gt; &#123;init,shutdown_timeout&#125;</span><br><span class=\"line\">youthy@youthy:~$ </span><br><span class=\"line\">youthy@youthy:~$ erl -shutdown_time 4000</span><br><span class=\"line\">Erlang R15B (erts-5.9) [source] [64-bit] [smp:4:4] [async-threads:0] [hipe] [kernel-poll:false]</span><br><span class=\"line\"></span><br><span class=\"line\">Eshell V5.9  (abort with ^G)</span><br><span class=\"line\">1&gt; q().</span><br><span class=\"line\">ok</span><br><span class=\"line\">2&gt; youthy@youthy:~$ </span><br></pre></td></tr></table></figure></p>\n<p>如上，1秒的时间看来时不够用的。</p>\n<h3 id=\"-smp_enable/auto/disable\">-smp enable/auto/disable</h3><p>是否启用smp，默认时auto。auto自动检测。如果符合会自动开启smp。<br><a href=\"http://www.cnblogs.com/me-sa/archive/2012/02/01/erlang0035.html\">关于smp</a>.</p>\n<h3 id=\"-version\">-version</h3><p>打印version信息。</p>"},{"title":"github屏蔽百度爬虫的解决办法","date":"2015-08-04T06:57:55.000Z","_content":"\ngoogle上可以搜到github博客的内容，但是百度是搜不到的。用百度的站长工具抓取也总是抓取失败。是因为github把百度爬虫给屏蔽了，而且将会长期下去。导致百度是无法收录自己的网站。\n<!--more-->\n[如何解决百度爬虫无法爬取搭建在Github上的个人博客的问题--知乎](http://www.zhihu.com/question/30898326)\ngoogle下github + 百度爬虫也有很多文章。\n有几种方案 \n  * 通过CDN加速，弊端是由于缓存的关系，会导致经常出现404的错误\n  * 用gitcafe镜像\n  * 用vps，让百度从自己的vps爬虫。\n \n虽然自己有vps，但是其实目前对我来说操作起来最简单的还是用gitcafe做镜像。我只需要修改下hexo的config文件添加一个deploy的对象就可以将博客部署到gitcafe和github两个地方，然后在dnspod上添加一条域名解析就可以了。\n\n## 创建gitcafe账号并建立一个repo，名字要和用户名一致\n![](/img/gitcafe1.png)\n\n默认分支这时候如果没有先不用管。等到之后在hexo的_config里面直接加就好了，之后再回来修改它为gitcafe-pages\n\n![](/img/gitcafe2.png)\n\n在ssh公钥管理里面添加和github一样的内容就好了，我的在~/.ssh/rsa_pub文件里。\n然后在\n![](/img/gitcafe3.png)\n在hexo的_config.yml里面加入gitcafe的地址。并改成如上形式。之后hexo d就可以部署到github和gitcafe上了。\n\n## 到dnspod修改域名解析。\n![](/img/gitcafe4.png)\n\n在dnspod里面让百度走gitcafe，其他人还是走github。 也可以在细化让国内也走gitcafe，国外走github。\n\n之后用百度站长工具看到百度可以成功抓取了\n![](/img/gitcafe5.png)\n\n（无论在github还是gitcafe移动UA都是可以成功抓取的）。\n\n## 关于404 not found\n\n要确保\n * gitcafe的项目名一定要和用户名一致，并且branch是gitcafe-pages，且为默认branch\n * 如果绑定了域名，一定要在设置里加入域名，比如我的\n![](/img/gitcafe6.png)\n\n以上任意一项不足都可能导致404 not found。\n","source":"_posts/github屏蔽百度爬虫的解决办法.md","raw":"title: github屏蔽百度爬虫的解决办法\ndate: 2015-08-04 14:57:55\ntags: [hexo, github]\n---\n\ngoogle上可以搜到github博客的内容，但是百度是搜不到的。用百度的站长工具抓取也总是抓取失败。是因为github把百度爬虫给屏蔽了，而且将会长期下去。导致百度是无法收录自己的网站。\n<!--more-->\n[如何解决百度爬虫无法爬取搭建在Github上的个人博客的问题--知乎](http://www.zhihu.com/question/30898326)\ngoogle下github + 百度爬虫也有很多文章。\n有几种方案 \n  * 通过CDN加速，弊端是由于缓存的关系，会导致经常出现404的错误\n  * 用gitcafe镜像\n  * 用vps，让百度从自己的vps爬虫。\n \n虽然自己有vps，但是其实目前对我来说操作起来最简单的还是用gitcafe做镜像。我只需要修改下hexo的config文件添加一个deploy的对象就可以将博客部署到gitcafe和github两个地方，然后在dnspod上添加一条域名解析就可以了。\n\n## 创建gitcafe账号并建立一个repo，名字要和用户名一致\n![](/img/gitcafe1.png)\n\n默认分支这时候如果没有先不用管。等到之后在hexo的_config里面直接加就好了，之后再回来修改它为gitcafe-pages\n\n![](/img/gitcafe2.png)\n\n在ssh公钥管理里面添加和github一样的内容就好了，我的在~/.ssh/rsa_pub文件里。\n然后在\n![](/img/gitcafe3.png)\n在hexo的_config.yml里面加入gitcafe的地址。并改成如上形式。之后hexo d就可以部署到github和gitcafe上了。\n\n## 到dnspod修改域名解析。\n![](/img/gitcafe4.png)\n\n在dnspod里面让百度走gitcafe，其他人还是走github。 也可以在细化让国内也走gitcafe，国外走github。\n\n之后用百度站长工具看到百度可以成功抓取了\n![](/img/gitcafe5.png)\n\n（无论在github还是gitcafe移动UA都是可以成功抓取的）。\n\n## 关于404 not found\n\n要确保\n * gitcafe的项目名一定要和用户名一致，并且branch是gitcafe-pages，且为默认branch\n * 如果绑定了域名，一定要在设置里加入域名，比如我的\n![](/img/gitcafe6.png)\n\n以上任意一项不足都可能导致404 not found。\n","slug":"github屏蔽百度爬虫的解决办法","published":1,"updated":"2018-06-26T09:49:27.735Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqw7jdw600146f1rau1vakwg","content":"<p>google上可以搜到github博客的内容，但是百度是搜不到的。用百度的站长工具抓取也总是抓取失败。是因为github把百度爬虫给屏蔽了，而且将会长期下去。导致百度是无法收录自己的网站。<br><span id=\"more\"></span><br><a href=\"http://www.zhihu.com/question/30898326\">如何解决百度爬虫无法爬取搭建在Github上的个人博客的问题--知乎</a><br>google下github + 百度爬虫也有很多文章。<br>有几种方案 </p>\n<ul>\n<li>通过CDN加速，弊端是由于缓存的关系，会导致经常出现404的错误</li>\n<li>用gitcafe镜像</li>\n<li>用vps，让百度从自己的vps爬虫。</li>\n</ul>\n<p>虽然自己有vps，但是其实目前对我来说操作起来最简单的还是用gitcafe做镜像。我只需要修改下hexo的config文件添加一个deploy的对象就可以将博客部署到gitcafe和github两个地方，然后在dnspod上添加一条域名解析就可以了。</p>\n<h2 id=\"创建gitcafe账号并建立一个repo，名字要和用户名一致\">创建gitcafe账号并建立一个repo，名字要和用户名一致</h2><p><img src=\"/img/gitcafe1.png\" alt=\"\"></p>\n<p>默认分支这时候如果没有先不用管。等到之后在hexo的_config里面直接加就好了，之后再回来修改它为gitcafe-pages</p>\n<p><img src=\"/img/gitcafe2.png\" alt=\"\"></p>\n<p>在ssh公钥管理里面添加和github一样的内容就好了，我的在~/.ssh/rsa_pub文件里。<br>然后在<br><img src=\"/img/gitcafe3.png\" alt=\"\"><br>在hexo的_config.yml里面加入gitcafe的地址。并改成如上形式。之后hexo d就可以部署到github和gitcafe上了。</p>\n<h2 id=\"到dnspod修改域名解析。\">到dnspod修改域名解析。</h2><p><img src=\"/img/gitcafe4.png\" alt=\"\"></p>\n<p>在dnspod里面让百度走gitcafe，其他人还是走github。 也可以在细化让国内也走gitcafe，国外走github。</p>\n<p>之后用百度站长工具看到百度可以成功抓取了<br><img src=\"/img/gitcafe5.png\" alt=\"\"></p>\n<p>（无论在github还是gitcafe移动UA都是可以成功抓取的）。</p>\n<h2 id=\"关于404_not_found\">关于404 not found</h2><p>要确保</p>\n<ul>\n<li>gitcafe的项目名一定要和用户名一致，并且branch是gitcafe-pages，且为默认branch</li>\n<li>如果绑定了域名，一定要在设置里加入域名，比如我的<br><img src=\"/img/gitcafe6.png\" alt=\"\"></li>\n</ul>\n<p>以上任意一项不足都可能导致404 not found。</p>\n","site":{"data":{}},"excerpt":"<p>google上可以搜到github博客的内容，但是百度是搜不到的。用百度的站长工具抓取也总是抓取失败。是因为github把百度爬虫给屏蔽了，而且将会长期下去。导致百度是无法收录自己的网站。<br>","more":"<br><a href=\"http://www.zhihu.com/question/30898326\">如何解决百度爬虫无法爬取搭建在Github上的个人博客的问题--知乎</a><br>google下github + 百度爬虫也有很多文章。<br>有几种方案 </p>\n<ul>\n<li>通过CDN加速，弊端是由于缓存的关系，会导致经常出现404的错误</li>\n<li>用gitcafe镜像</li>\n<li>用vps，让百度从自己的vps爬虫。</li>\n</ul>\n<p>虽然自己有vps，但是其实目前对我来说操作起来最简单的还是用gitcafe做镜像。我只需要修改下hexo的config文件添加一个deploy的对象就可以将博客部署到gitcafe和github两个地方，然后在dnspod上添加一条域名解析就可以了。</p>\n<h2 id=\"创建gitcafe账号并建立一个repo，名字要和用户名一致\">创建gitcafe账号并建立一个repo，名字要和用户名一致</h2><p><img src=\"/img/gitcafe1.png\" alt=\"\"></p>\n<p>默认分支这时候如果没有先不用管。等到之后在hexo的_config里面直接加就好了，之后再回来修改它为gitcafe-pages</p>\n<p><img src=\"/img/gitcafe2.png\" alt=\"\"></p>\n<p>在ssh公钥管理里面添加和github一样的内容就好了，我的在~/.ssh/rsa_pub文件里。<br>然后在<br><img src=\"/img/gitcafe3.png\" alt=\"\"><br>在hexo的_config.yml里面加入gitcafe的地址。并改成如上形式。之后hexo d就可以部署到github和gitcafe上了。</p>\n<h2 id=\"到dnspod修改域名解析。\">到dnspod修改域名解析。</h2><p><img src=\"/img/gitcafe4.png\" alt=\"\"></p>\n<p>在dnspod里面让百度走gitcafe，其他人还是走github。 也可以在细化让国内也走gitcafe，国外走github。</p>\n<p>之后用百度站长工具看到百度可以成功抓取了<br><img src=\"/img/gitcafe5.png\" alt=\"\"></p>\n<p>（无论在github还是gitcafe移动UA都是可以成功抓取的）。</p>\n<h2 id=\"关于404_not_found\">关于404 not found</h2><p>要确保</p>\n<ul>\n<li>gitcafe的项目名一定要和用户名一致，并且branch是gitcafe-pages，且为默认branch</li>\n<li>如果绑定了域名，一定要在设置里加入域名，比如我的<br><img src=\"/img/gitcafe6.png\" alt=\"\"></li>\n</ul>\n<p>以上任意一项不足都可能导致404 not found。</p>"},{"title":"linux修改键盘映射capslock为ctrl","date":"2014-07-12T14:36:35.000Z","_content":"\n> 由于在vim下需要经常使用ctrl键，比如ctrl+]在tags之间跳，ctrl+v进入列可视模式等等，但是由于ctrl键按起来比较麻烦\n所以一般将capslock映射为ctrl。\n\n<!--more-->\n\n需要xmodmap支持\n\n首先，安装xmodmap\n\n> sudo apt-get install xmodmap\n\n如果提示没有则安装\n\n> sudo apt-get install x11-xserver-utils\n\n之后在自己的工作目录home里新建一个.xmodmaprc的文件，\n里面键入\n```\n     remove Lock = Caps_Lock\n     keysym Caps_Lock = Control_L\n     add Control = Control_L\n```\n\n保存。\n\n在shell里面cd到xmodmaprc所在目录执行\n\n>  xmodmap .xmodmaprc\n\n使映射生效。\n\n如不生效注销一下应该就可以了\n","source":"_posts/linux修改键盘映射.md","raw":"title: linux修改键盘映射capslock为ctrl\ndate: 2014-07-12 22:36:35\ntags: [xmodmap，vim]\ncategories: 教程\n---\n\n> 由于在vim下需要经常使用ctrl键，比如ctrl+]在tags之间跳，ctrl+v进入列可视模式等等，但是由于ctrl键按起来比较麻烦\n所以一般将capslock映射为ctrl。\n\n<!--more-->\n\n需要xmodmap支持\n\n首先，安装xmodmap\n\n> sudo apt-get install xmodmap\n\n如果提示没有则安装\n\n> sudo apt-get install x11-xserver-utils\n\n之后在自己的工作目录home里新建一个.xmodmaprc的文件，\n里面键入\n```\n     remove Lock = Caps_Lock\n     keysym Caps_Lock = Control_L\n     add Control = Control_L\n```\n\n保存。\n\n在shell里面cd到xmodmaprc所在目录执行\n\n>  xmodmap .xmodmaprc\n\n使映射生效。\n\n如不生效注销一下应该就可以了\n","slug":"linux修改键盘映射","published":1,"updated":"2018-06-26T09:49:27.736Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqw7jdw700176f1r3b2t7zzj","content":"<blockquote>\n<p>由于在vim下需要经常使用ctrl键，比如ctrl+]在tags之间跳，ctrl+v进入列可视模式等等，但是由于ctrl键按起来比较麻烦<br>所以一般将capslock映射为ctrl。</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>需要xmodmap支持</p>\n<p>首先，安装xmodmap</p>\n<blockquote>\n<p>sudo apt-get install xmodmap</p>\n</blockquote>\n<p>如果提示没有则安装</p>\n<blockquote>\n<p>sudo apt-get install x11-xserver-utils</p>\n</blockquote>\n<p>之后在自己的工作目录home里新建一个.xmodmaprc的文件，<br>里面键入<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">remove Lock = Caps_Lock</span><br><span class=\"line\">keysym Caps_Lock = Control_L</span><br><span class=\"line\">add Control = Control_L</span><br></pre></td></tr></table></figure></p>\n<p>保存。</p>\n<p>在shell里面cd到xmodmaprc所在目录执行</p>\n<blockquote>\n<p> xmodmap .xmodmaprc</p>\n</blockquote>\n<p>使映射生效。</p>\n<p>如不生效注销一下应该就可以了</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>由于在vim下需要经常使用ctrl键，比如ctrl+]在tags之间跳，ctrl+v进入列可视模式等等，但是由于ctrl键按起来比较麻烦<br>所以一般将capslock映射为ctrl。</p>\n</blockquote>","more":"<p>需要xmodmap支持</p>\n<p>首先，安装xmodmap</p>\n<blockquote>\n<p>sudo apt-get install xmodmap</p>\n</blockquote>\n<p>如果提示没有则安装</p>\n<blockquote>\n<p>sudo apt-get install x11-xserver-utils</p>\n</blockquote>\n<p>之后在自己的工作目录home里新建一个.xmodmaprc的文件，<br>里面键入<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">remove Lock = Caps_Lock</span><br><span class=\"line\">keysym Caps_Lock = Control_L</span><br><span class=\"line\">add Control = Control_L</span><br></pre></td></tr></table></figure></p>\n<p>保存。</p>\n<p>在shell里面cd到xmodmaprc所在目录执行</p>\n<blockquote>\n<p> xmodmap .xmodmaprc</p>\n</blockquote>\n<p>使映射生效。</p>\n<p>如不生效注销一下应该就可以了</p>"},{"title":"ranch笔记","date":"2015-09-28T03:58:51.000Z","_content":"\n任何使用ranch的程序第一步需要启动ranch_app\n## start ranch application\n入口\n`ranch_app:`\n```\nstart(_, _) ->\n\t_ = consider_profiling(), %% 是否启动eprof\n\tranch_sup:start_link().\n```\n\n<!-- more -->\n\n`ranch_sup:` \n整个应用的最顶级sup， 它建立ranch_server ets,并启动ranch_server这个gen_server,将ranch_server这个ets归属于ranch_sup提高容错.防止数据丢失。\n```\nstart_link() ->\n\tsupervisor:start_link({local, ?MODULE}, ?MODULE, []).\n\ninit([]) ->\n\tranch_server = ets:new(ranch_server, [\n\t\tordered_set, public, named_table]),\n\tProcs = [\n\t\t{ranch_server, {ranch_server, start_link, []},\n\t\t\tpermanent, 5000, worker, [ranch_server]}\n\t],\n\t{ok, {{one_for_one, 10, 10}, Procs}}.\n```\n\n`ranch_server:`\n是一个gen_server,init中从ranch_server ets中恢复数据\n```\ninit([]) ->\n\tMonitors = [{{erlang:monitor(process, Pid), Pid}, Ref} ||\n\t\t[Ref, Pid] <- ets:match(?TAB, {{conns_sup, '$1'}, '$2'})],\n\t{ok, #state{monitors=Monitors}}.\n```\n**ranch初始化完成**\n![](/img/ranch_1.png)\n----\n至此ranch实际上没有做任何事情，它并没有监听任何端口，需要使用者在自己的app中显示的调用ranch:start_listener来启动acceptor_pool.\n\n在作者的demo中是这样：\n### tcp_echo_app:\n```\nstart(_Type, _Args) ->\n\t{ok, _} = ranch:start_listener(tcp_echo, 1,\n\t\tranch_tcp, [{port, 5555}], echo_protocol, []),\n\ttcp_echo_sup:start_link().\n```\n\n`ranch:start_listner`接受6个参数 \n1. 名字: tcp_echo,\n2. acceptor数量: 1\n**此处不是connection的数量!! wiki说:**\n> First of all, it should not be confused with the maximum number of connections. Acceptor processes are only used for accepting and have nothing else in common with connection processes. Therefore there is nothing to be gained from setting this number too high, in fact it can slow everything else down.\n\n> Second, this number should be high enough to allow Ranch to accept connections concurrently. But the number of cores available doesn’t seem to be the only factor for choosing this number, as we can observe faster accepts if we have more acceptors than cores. It might be entirely dependent on the protocol, however.\n\n总之就是太少太多都不好，他们的观测得到100较为合适\n\n3. transport的方式: ranch_tcp\n4. transport options: [{port, 5555}], \n`ranch_tcp:`\n```\nlisten(Opts) ->\n\tOpts2 = ranch:set_option_default(Opts, backlog, 1024),\n\tOpts3 = ranch:set_option_default(Opts2, nodelay, true),\n\tOpts4 = ranch:set_option_default(Opts3, send_timeout, 30000),\n\tOpts5 = ranch:set_option_default(Opts4, send_timeout_close, true),\n\tgen_tcp:listen(0, ranch:filter_options(Opts5, listen_options(),\n\t\t[binary, {active, false}, {packet, raw}, {reuseaddr, true}])).\n```\n可以看出ranch_tcp代码中默认使用binary, {active,false}, 等设置，所以无法通过options更改。可以在start_listener之后的通过Transport:setopts/2更改.\n但是backlog, nodelay等可以通过Opts在start的时候就设置好.\n**port**:未指定的话，则会随意一个端口.还有，不要设置1024以上的。原因如下\n> Some systems limit access to ports below 1024 for security reasons.The methods for listening on privileged ports vary between systems, please refer to your system’s documentation for more information.\n\n**max_connections**: {max_connections, Number|infinity}Number默认是1024.尽量不要infinity。\n还可以通过`ranch:set_max_connections`设置.有时有个别进程是长链接，不希望它计入connections的计数。可以通过`ranch:remove_conections/1`移除1.\n5. protocol_handler mod: echo_protocol\n6. protocol options: []\n\n### ranch:\nlistener的实现:\n```\nstart_listener(tcp_echo, 1, ranch_tcp, [{port, 5555}], echo_protocol, []) ->\n    ...\n\tChildSpec = {{ranch_listener_sup, tcp_echo}, {ranch_listener_sup, start_link, [\n\t\ttcp_echo, 1, ranch_tcp, [{port, 5555}], echo_protocol, [] \n\t]}, permanent, infinity, supervisor, [ranch_listener_sup]}.\n\tRes = supervisor:start_child(ranch_sup, ChildSpec),\n\tSocket = proplists:get_value(socket, [{port, 5555}]),\n\tcase Res of\n\t\t{ok, Pid} when Socket =/= undefined ->\n\t\t    %% 此处更改socket的拥有者,暂不管\n\t\t  \tChildren = supervisor:which_children(Pid),\n\t\t  \t{_, AcceptorsSup, _, _}\n\t\t  \t\t= lists:keyfind(ranch_acceptors_sup, 1, Children),\n\t\t   catch Transport:controlling_process(Socket, AcceptorsSup);\n\t\t_ ->\n\t\t\tok\n\tend,\n\tRes\n\t...\n```\n\n在未指定socket的情况，start_listener通过`supervisor:start_child/2`启动了`ranch_listener_sup`\n\n\n### ranch_listener_sup:\nlistener_sup 仍然是个supervisor，它得到一个max_connections(默认1024）, 通知ranch_server储存max_connection,和Opts。\n```\nstart_link(Ref, NbAcceptors, Transport, TransOpts, Protocol, ProtoOpts) ->\n\tMaxConns = proplists:get_value(max_connections, TransOpts, 1024),\n\tranch_server:set_new_listener_opts(Ref, MaxConns, ProtoOpts),\n\t%% 注意此处没有注册名字\n\tsupervisor:start_link(?MODULE, {\n\t\tRef, NbAcceptors, Transport, TransOpts, Protocol\n\t}).\n```\n\n`ranch_server:`\n```\nhandle_call({set_new_listener_opts, Ref, MaxConns, Opts}, _, State) ->\n    %% 将数据存入rank_server ets.\n\tets:insert(rank_server, {{max_conns, Ref}, MaxConns}),\n\tets:insert(rank_server, {{opts, Ref}, Opts}),\n\t{reply, ok, State};\n```\n\n`ranch_listener_sup:`\n```\ninit({tcp_echo, 1, ranch_tcp, [{port, 5555}], echo_protocol}) ->\n\tAckTimeout = proplists:get_value(ack_timeout, TransOpts, 5000),\n\tConnType = proplists:get_value(connection_type, TransOpts, worker),\n\tShutdown = proplists:get_value(shutdown, TransOpts, 5000),\n\tChildSpecs = [\n\t\t{ranch_conns_sup, {ranch_conns_sup, start_link,\n\t\t\t\t[Ref, ConnType, Shutdown, Transport, AckTimeout, Protocol]},\n\t\t\tpermanent, infinity, supervisor, [ranch_conns_sup]},\n\t\t{ranch_acceptors_sup, {ranch_acceptors_sup, start_link,\n\t\t\t\t[Ref, NbAcceptors, Transport, TransOpts]},\n\t\t\tpermanent, infinity, supervisor, [ranch_acceptors_sup]}\n\t],\n\t{ok, {{rest_for_one, 10, 10}, ChildSpecs}}.\n```\n\nlistener_sup 启动 conns_sup和acceptors_sup,这两个都是supervisor 所以shutdown都设置成infinity\n但是其中conns_sup是个自定义的supervisor，作者解释是为了优化create和accept connection。\n> Ranch uses a custom supervisor for managing connections. This supervisor keeps track of the number of connections and handles connection limits directly. While it is heavily optimized to perform the task of creating connection processes for accepted connections, it is still following the OTP principles and the usual sys and supervisor calls will work on it as expected.\n\n### Ranch_conns_sup:\n```\nstart_link(Ref, ConnType, Shutdown, Transport, AckTimeout, Protocol) ->\n\tproc_lib:start_link(?MODULE, init,\n\t[self(), Ref, ConnType, Shutdown, Transport, AckTimeout, Protocol]).\n\t\ninit(Parent, Ref, ConnType, Shutdown, Transport, AckTimeout, Protocol) ->\n\tprocess_flag(trap_exit, true),\n\tok = ranch_server:set_connections_sup(Ref, self()),\n\tMaxConns = ranch_server:get_max_connections(Ref),\n\tOpts = ranch_server:get_protocol_options(Ref),\n\tok = proc_lib:init_ack(Parent, {ok, self()}),\n\tloop(#state{parent=Parent, ref=Ref, conn_type=ConnType,\n\t\tshutdown=Shutdown, transport=Transport, protocol=Protocol,\n\t\topts=Opts, ack_timeout=AckTimeout, max_conns=MaxConns}, 0, 0, []).\n```\n\n```\n14> rp(sys:get_status(ConnsSup)).\n{status,<0.43.0>,\n        {module,ranch_conns_sup},\n        [[{'$ancestors',[<0.42.0>,ranch_sup,<0.34.0>]},\n          {'$initial_call',{ranch_conns_sup,init,7}}],\n         running,<0.42.0>,[],\n         {{state,<0.42.0>,tcp_echo,worker,5000,ranch_tcp,\n                 echo_protocol,[],5000,1024},\n          0,0,[]}]}\n```\n\n上面使用`sys:get_status(Name|Pid)`得到ranch_conns_sup的#state{}。\n\n### Ranch_acceptor_sup:\n```\nstart_link(Ref, NbAcceptors, Transport, TransOpts) ->\n\tsupervisor:start_link(?MODULE, [Ref, NbAcceptors, Transport, TransOpts]).\n\ninit([Ref, NbAcceptors, Transport, TransOpts]) ->\n\tConnsSup = ranch_server:get_connections_sup(Ref),\n\tLSocket = case proplists:get_value(socket, TransOpts) of\n\t\tundefined ->\n\t\t\tTransOpts2 = proplists:delete(ack_timeout,\n\t\t\t\tproplists:delete(connection_type,\n\t\t\t\tproplists:delete(max_connections,\n\t\t\t\tproplists:delete(shutdown,\n\t\t\t\tproplists:delete(socket, TransOpts))))),\n\t\t\tcase Transport:listen(TransOpts2) of\n\t\t\t\t{ok, Socket} -> Socket;\n\t\t\t\t{error, Reason} -> listen_error(Ref, Transport, TransOpts2, Reason)\n\t\t\tend;\n\t\tSocket ->\n\t\t\tSocket\n\tend,\n\t{ok, Addr} = Transport:sockname(LSocket),\n\tranch_server:set_addr(Ref, Addr),\n\tProcs = [\n\t\t{{acceptor, self(), N}, {ranch_acceptor, start_link, [\n\t\t\tLSocket, Transport, ConnsSup\n\t\t]}, permanent, brutal_kill, worker, []}\n\t\t\t|| N <- lists:seq(1, NbAcceptors)],\n\t{ok, {{one_for_one, 10, 10}, Procs}}.\n```\n\nacceptor_sup完成了得到一个ListenSocket, 然后启动N个acceptor进程，这些acceptor的loop等待`gen_tcp:accept` | `ssl:transport_accept`\n`Transport:listen`的本质就是`gen_tcp:listen`或者`ssl:listen` 它返回一个ListenSocket\n`Transport:sockname` :: `inet:sockname` | `ssl:sockname`\n```\n13> sys:get_status(AccepterSup).\n{status,<0.44.0>,\n        {module,gen_server},\n        [[{'$ancestors',[<0.42.0>,ranch_sup,<0.34.0>]},\n          {'$initial_call',{supervisor,ranch_acceptors_sup,1}}],\n         running,<0.42.0>,[],\n         [{header,\"Status for generic server <0.44.0>\"},\n          {data,[{\"Status\",running},\n                 {\"Parent\",<0.42.0>},\n                 {\"Logged events\",[]}]},\n          {data,[{\"State\",\n                  {state,{<0.44.0>,ranch_acceptors_sup},\n                         one_for_one,\n                         [{child,<0.45.0>,\n                                 {acceptor,<0.44.0>,1},\n                                 {ranch_acceptor,start_link,\n                                                 [#Port<0.917>,ranch_tcp,<0.43.0>]},\n                                 permanent,brutal_kill,worker,[]}],\n                         undefined,10,10,[],ranch_acceptors_sup,\n                         [tcp_echo,1,ranch_tcp,[{port,5555}]]}}]}]]}\n```\n\ndemo中只启动了一个acceptor\n至此完了了所有进程的启动。等待connection进来。\n![](/img/ranch_2.png)\n\n### Acceptor:\nacceptor的作用是`accept(ListenSocket) -> Socket.` 通过`Transport:controlling_process`,将端口控制交给`conns_sup`, 然后向conns_sup发送`{ranch_conns_sup, start_protocol, AcceptorPid, Socket}`\n\n```\nstart_link(LSocket, Transport, ConnsSup) ->\n\tPid = spawn_link(?MODULE, loop, [LSocket, Transport, ConnsSup]),\n\t{ok, Pid}.\n\n-spec loop(inet:socket(), module(), pid()) -> no_return().\nloop(LSocket, Transport, ConnsSup) ->\n\t_ = case Transport:accept(LSocket, infinity) of\n\t\t{ok, CSocket} ->\n\t\t\tcase Transport:controlling_process(CSocket, ConnsSup) of\n\t\t\t\tok ->\n\t\t\t\t\tranch_conns_sup:start_protocol(ConnsSup, CSocket);\n\t\t\t\t{error, _} ->\n\t\t\t\t\tTransport:close(CSocket)\n\t\t\tend;\n\t\t{error, emfile} ->\n\t\t\treceive after 100 -> ok end;\n\t\t{error, Reason} when Reason =/= closed ->\n\t\t\tok\n\tend,\n\tflush(),\n\t?MODULE:loop(LSocket, Transport, ConnsSup).\n```\n\n`ranch_conns_sup`:\n```\nstart_protocol(SupPid, Socket) ->\n\tSupPid ! {?MODULE, start_protocol, self(), Socket},\n\treceive SupPid -> ok end.\n```\n\n```receive\n\t\t{?MODULE, start_protocol, To, Socket} ->\n\t\t\ttry Protocol:start_link(Ref, Socket, Transport, Opts) of\n\t\t\t\t{ok, Pid} ->\n\t\t\t\t\tshoot(State, CurConns, NbChildren, Sleepers, To, Socket, Pid, Pid);\n\t\t\t\t{ok, SupPid, ProtocolPid} when ConnType =:= supervisor ->\n\t\t\t\t\tshoot(State, CurConns, NbChildren, Sleepers, To, Socket, SupPid, ProtocolPid);\n\t\t\t\tRet ->\n\t\t\t\t\tTo ! self(),\n\t\t\t\t\terror_logger:error_msg(\n\t\t\t\t\t\t\"Ranch listener ~p connection process start failure; \"\n\t\t\t\t\t\t\"~p:start_link/4 returned: ~999999p~n\",\n\t\t\t\t\t\t[Ref, Protocol, Ret]),\n\t\t\t\t\tTransport:close(Socket),\n\t\t\t\t\tloop(State, CurConns, NbChildren, Sleepers)\n\t\t\t\t\t......\n```\n\n```\nshoot(State=#state{ref=Ref, transport=Transport, ack_timeout=AckTimeout, max_conns=MaxConns},\n\t\tCurConns, NbChildren, Sleepers, To, Socket, SupPid, ProtocolPid) ->\n\tcase Transport:controlling_process(Socket, ProtocolPid) of\n\t\tok ->\n\t\t    %% 通知echo_protocol进程控制权已转移。\n\t\t\tProtocolPid ! {shoot, Ref, Transport, Socket, AckTimeout},\n\t\t\tput(SupPid, true),\n\t\t\tCurConns2 = CurConns + 1,\n\t\t\tif CurConns2 < MaxConns ->\n\t\t\t\t\tTo ! self(),\n\t\t\t\t\tloop(State, CurConns2, NbChildren + 1, Sleepers);\n\t\t\t\ttrue ->\n\t\t\t\t\tloop(State, CurConns2, NbChildren + 1, [To|Sleepers])\n\t\t\tend;\n\t\t{error, _} ->\n\t\t\tTransport:close(Socket),\n\t\t\t%% Only kill the supervised pid, because the connection's pid,\n\t\t\t%% when different, is supposed to be sitting under it and linked.\n\t\t\texit(SupPid, kill),\n\t\t\tloop(State, CurConns, NbChildren, Sleepers)\n\tend.\n```\n\n### ranch_protocol:\nconns_sup在完成`controlling_process`后要通知protocol进程完成了转移。因为此时protocol的init还没有执行结束，一直在等着控制权转移。因为控制权没转移是不能进入loop的.spawn_link及时将自己的pid告诉了conns_sup.如果是gen_server等需要init结束才返回的进程需要特殊处理, 在下面分析.同时完成转移后conns_sup还给acceptor发送一条自己的pid，告诉acceptor转移完成。因为这之前acceptor一直处在receive状态，等待conns_sup完成工作。不完成他不会再次参与accept操作.\n`echo_protocol:`\n```\nstart_link(Ref, Socket, Transport, Opts) ->\n\tPid = spawn_link(?MODULE, init, [Ref, Socket, Transport, Opts]),\n\t{ok, Pid}.\n\ninit(Ref, Socket, Transport, _Opts = []) ->\n  %% 必须调用 accept_ack，确保socket控制权\n\tok = ranch:accept_ack(Ref),\n\tloop(Socket, Transport).\n```\n\n`ranch:`\n```\naccept_ack(Ref) ->\n\treceive {shoot, Ref, Transport, Socket, AckTimeout} ->\n\t\tTransport:accept_ack(Socket, AckTimeout)\n\tend.\n```\n\n链接套接字的逻辑进程都要有\n1. -behavior(ranch_protocol). 定义了一个start_link/4 callback而已。\n2. 在任何对端口的操作之前一定要确保执行过ranch:accept_ack(Ref)(确保端口控制权交给自己).在此之后可以运行ranch_tcp|ranch_ssl:setopts(Opt)完成自定义对端口的设置\n如果同时他是个gen_server,gen_fsm等有自己的start_link, 会产生一个问题，因为init中放入ranch:accept_ack/1会形成死锁。(见上面，即`conns_sup` 在等待`ranch_protocol`进程的pid返回。而`ranch_protocol`在等待`conns_sup`将端口控制交给自己)见问题说明\n[ranch_protocol_doc](https://github.com/ninenines/ranch/blob/master/doc/src/guide/protocols.asciidoc).\n作者再上面给出了两种解决办法:\n1. 在start_link 中用proc_lib:start_link代替gen_server:start_link,然后在init中主动调用proc_lib：init_ack通知父进程初始化完毕，然后调用ranch:accept_ack，再之后手动用gen_server:enter_loop进入循环。在之前这里分析过gen_server的初始化过程。\n[gen_server和init](/2015/07/31/erlang-question-gen-server-and-init/)\n2. 作者在init中返回timeout为0，然后通过handle_info(timeout...)调用ranch:accept_ack。实际上最好不要这么用，原因还是见上面的文章。具体剖析过为什么不能这么用。还是用 self()!timeout替代这种方法吧。\n![](/img/ranch_3.png)\n","source":"_posts/ranch笔记.md","raw":"title: ranch笔记\ndate: 2015-09-28 11:58:51\ntags: [erlang, ranch]\n---\n\n任何使用ranch的程序第一步需要启动ranch_app\n## start ranch application\n入口\n`ranch_app:`\n```\nstart(_, _) ->\n\t_ = consider_profiling(), %% 是否启动eprof\n\tranch_sup:start_link().\n```\n\n<!-- more -->\n\n`ranch_sup:` \n整个应用的最顶级sup， 它建立ranch_server ets,并启动ranch_server这个gen_server,将ranch_server这个ets归属于ranch_sup提高容错.防止数据丢失。\n```\nstart_link() ->\n\tsupervisor:start_link({local, ?MODULE}, ?MODULE, []).\n\ninit([]) ->\n\tranch_server = ets:new(ranch_server, [\n\t\tordered_set, public, named_table]),\n\tProcs = [\n\t\t{ranch_server, {ranch_server, start_link, []},\n\t\t\tpermanent, 5000, worker, [ranch_server]}\n\t],\n\t{ok, {{one_for_one, 10, 10}, Procs}}.\n```\n\n`ranch_server:`\n是一个gen_server,init中从ranch_server ets中恢复数据\n```\ninit([]) ->\n\tMonitors = [{{erlang:monitor(process, Pid), Pid}, Ref} ||\n\t\t[Ref, Pid] <- ets:match(?TAB, {{conns_sup, '$1'}, '$2'})],\n\t{ok, #state{monitors=Monitors}}.\n```\n**ranch初始化完成**\n![](/img/ranch_1.png)\n----\n至此ranch实际上没有做任何事情，它并没有监听任何端口，需要使用者在自己的app中显示的调用ranch:start_listener来启动acceptor_pool.\n\n在作者的demo中是这样：\n### tcp_echo_app:\n```\nstart(_Type, _Args) ->\n\t{ok, _} = ranch:start_listener(tcp_echo, 1,\n\t\tranch_tcp, [{port, 5555}], echo_protocol, []),\n\ttcp_echo_sup:start_link().\n```\n\n`ranch:start_listner`接受6个参数 \n1. 名字: tcp_echo,\n2. acceptor数量: 1\n**此处不是connection的数量!! wiki说:**\n> First of all, it should not be confused with the maximum number of connections. Acceptor processes are only used for accepting and have nothing else in common with connection processes. Therefore there is nothing to be gained from setting this number too high, in fact it can slow everything else down.\n\n> Second, this number should be high enough to allow Ranch to accept connections concurrently. But the number of cores available doesn’t seem to be the only factor for choosing this number, as we can observe faster accepts if we have more acceptors than cores. It might be entirely dependent on the protocol, however.\n\n总之就是太少太多都不好，他们的观测得到100较为合适\n\n3. transport的方式: ranch_tcp\n4. transport options: [{port, 5555}], \n`ranch_tcp:`\n```\nlisten(Opts) ->\n\tOpts2 = ranch:set_option_default(Opts, backlog, 1024),\n\tOpts3 = ranch:set_option_default(Opts2, nodelay, true),\n\tOpts4 = ranch:set_option_default(Opts3, send_timeout, 30000),\n\tOpts5 = ranch:set_option_default(Opts4, send_timeout_close, true),\n\tgen_tcp:listen(0, ranch:filter_options(Opts5, listen_options(),\n\t\t[binary, {active, false}, {packet, raw}, {reuseaddr, true}])).\n```\n可以看出ranch_tcp代码中默认使用binary, {active,false}, 等设置，所以无法通过options更改。可以在start_listener之后的通过Transport:setopts/2更改.\n但是backlog, nodelay等可以通过Opts在start的时候就设置好.\n**port**:未指定的话，则会随意一个端口.还有，不要设置1024以上的。原因如下\n> Some systems limit access to ports below 1024 for security reasons.The methods for listening on privileged ports vary between systems, please refer to your system’s documentation for more information.\n\n**max_connections**: {max_connections, Number|infinity}Number默认是1024.尽量不要infinity。\n还可以通过`ranch:set_max_connections`设置.有时有个别进程是长链接，不希望它计入connections的计数。可以通过`ranch:remove_conections/1`移除1.\n5. protocol_handler mod: echo_protocol\n6. protocol options: []\n\n### ranch:\nlistener的实现:\n```\nstart_listener(tcp_echo, 1, ranch_tcp, [{port, 5555}], echo_protocol, []) ->\n    ...\n\tChildSpec = {{ranch_listener_sup, tcp_echo}, {ranch_listener_sup, start_link, [\n\t\ttcp_echo, 1, ranch_tcp, [{port, 5555}], echo_protocol, [] \n\t]}, permanent, infinity, supervisor, [ranch_listener_sup]}.\n\tRes = supervisor:start_child(ranch_sup, ChildSpec),\n\tSocket = proplists:get_value(socket, [{port, 5555}]),\n\tcase Res of\n\t\t{ok, Pid} when Socket =/= undefined ->\n\t\t    %% 此处更改socket的拥有者,暂不管\n\t\t  \tChildren = supervisor:which_children(Pid),\n\t\t  \t{_, AcceptorsSup, _, _}\n\t\t  \t\t= lists:keyfind(ranch_acceptors_sup, 1, Children),\n\t\t   catch Transport:controlling_process(Socket, AcceptorsSup);\n\t\t_ ->\n\t\t\tok\n\tend,\n\tRes\n\t...\n```\n\n在未指定socket的情况，start_listener通过`supervisor:start_child/2`启动了`ranch_listener_sup`\n\n\n### ranch_listener_sup:\nlistener_sup 仍然是个supervisor，它得到一个max_connections(默认1024）, 通知ranch_server储存max_connection,和Opts。\n```\nstart_link(Ref, NbAcceptors, Transport, TransOpts, Protocol, ProtoOpts) ->\n\tMaxConns = proplists:get_value(max_connections, TransOpts, 1024),\n\tranch_server:set_new_listener_opts(Ref, MaxConns, ProtoOpts),\n\t%% 注意此处没有注册名字\n\tsupervisor:start_link(?MODULE, {\n\t\tRef, NbAcceptors, Transport, TransOpts, Protocol\n\t}).\n```\n\n`ranch_server:`\n```\nhandle_call({set_new_listener_opts, Ref, MaxConns, Opts}, _, State) ->\n    %% 将数据存入rank_server ets.\n\tets:insert(rank_server, {{max_conns, Ref}, MaxConns}),\n\tets:insert(rank_server, {{opts, Ref}, Opts}),\n\t{reply, ok, State};\n```\n\n`ranch_listener_sup:`\n```\ninit({tcp_echo, 1, ranch_tcp, [{port, 5555}], echo_protocol}) ->\n\tAckTimeout = proplists:get_value(ack_timeout, TransOpts, 5000),\n\tConnType = proplists:get_value(connection_type, TransOpts, worker),\n\tShutdown = proplists:get_value(shutdown, TransOpts, 5000),\n\tChildSpecs = [\n\t\t{ranch_conns_sup, {ranch_conns_sup, start_link,\n\t\t\t\t[Ref, ConnType, Shutdown, Transport, AckTimeout, Protocol]},\n\t\t\tpermanent, infinity, supervisor, [ranch_conns_sup]},\n\t\t{ranch_acceptors_sup, {ranch_acceptors_sup, start_link,\n\t\t\t\t[Ref, NbAcceptors, Transport, TransOpts]},\n\t\t\tpermanent, infinity, supervisor, [ranch_acceptors_sup]}\n\t],\n\t{ok, {{rest_for_one, 10, 10}, ChildSpecs}}.\n```\n\nlistener_sup 启动 conns_sup和acceptors_sup,这两个都是supervisor 所以shutdown都设置成infinity\n但是其中conns_sup是个自定义的supervisor，作者解释是为了优化create和accept connection。\n> Ranch uses a custom supervisor for managing connections. This supervisor keeps track of the number of connections and handles connection limits directly. While it is heavily optimized to perform the task of creating connection processes for accepted connections, it is still following the OTP principles and the usual sys and supervisor calls will work on it as expected.\n\n### Ranch_conns_sup:\n```\nstart_link(Ref, ConnType, Shutdown, Transport, AckTimeout, Protocol) ->\n\tproc_lib:start_link(?MODULE, init,\n\t[self(), Ref, ConnType, Shutdown, Transport, AckTimeout, Protocol]).\n\t\ninit(Parent, Ref, ConnType, Shutdown, Transport, AckTimeout, Protocol) ->\n\tprocess_flag(trap_exit, true),\n\tok = ranch_server:set_connections_sup(Ref, self()),\n\tMaxConns = ranch_server:get_max_connections(Ref),\n\tOpts = ranch_server:get_protocol_options(Ref),\n\tok = proc_lib:init_ack(Parent, {ok, self()}),\n\tloop(#state{parent=Parent, ref=Ref, conn_type=ConnType,\n\t\tshutdown=Shutdown, transport=Transport, protocol=Protocol,\n\t\topts=Opts, ack_timeout=AckTimeout, max_conns=MaxConns}, 0, 0, []).\n```\n\n```\n14> rp(sys:get_status(ConnsSup)).\n{status,<0.43.0>,\n        {module,ranch_conns_sup},\n        [[{'$ancestors',[<0.42.0>,ranch_sup,<0.34.0>]},\n          {'$initial_call',{ranch_conns_sup,init,7}}],\n         running,<0.42.0>,[],\n         {{state,<0.42.0>,tcp_echo,worker,5000,ranch_tcp,\n                 echo_protocol,[],5000,1024},\n          0,0,[]}]}\n```\n\n上面使用`sys:get_status(Name|Pid)`得到ranch_conns_sup的#state{}。\n\n### Ranch_acceptor_sup:\n```\nstart_link(Ref, NbAcceptors, Transport, TransOpts) ->\n\tsupervisor:start_link(?MODULE, [Ref, NbAcceptors, Transport, TransOpts]).\n\ninit([Ref, NbAcceptors, Transport, TransOpts]) ->\n\tConnsSup = ranch_server:get_connections_sup(Ref),\n\tLSocket = case proplists:get_value(socket, TransOpts) of\n\t\tundefined ->\n\t\t\tTransOpts2 = proplists:delete(ack_timeout,\n\t\t\t\tproplists:delete(connection_type,\n\t\t\t\tproplists:delete(max_connections,\n\t\t\t\tproplists:delete(shutdown,\n\t\t\t\tproplists:delete(socket, TransOpts))))),\n\t\t\tcase Transport:listen(TransOpts2) of\n\t\t\t\t{ok, Socket} -> Socket;\n\t\t\t\t{error, Reason} -> listen_error(Ref, Transport, TransOpts2, Reason)\n\t\t\tend;\n\t\tSocket ->\n\t\t\tSocket\n\tend,\n\t{ok, Addr} = Transport:sockname(LSocket),\n\tranch_server:set_addr(Ref, Addr),\n\tProcs = [\n\t\t{{acceptor, self(), N}, {ranch_acceptor, start_link, [\n\t\t\tLSocket, Transport, ConnsSup\n\t\t]}, permanent, brutal_kill, worker, []}\n\t\t\t|| N <- lists:seq(1, NbAcceptors)],\n\t{ok, {{one_for_one, 10, 10}, Procs}}.\n```\n\nacceptor_sup完成了得到一个ListenSocket, 然后启动N个acceptor进程，这些acceptor的loop等待`gen_tcp:accept` | `ssl:transport_accept`\n`Transport:listen`的本质就是`gen_tcp:listen`或者`ssl:listen` 它返回一个ListenSocket\n`Transport:sockname` :: `inet:sockname` | `ssl:sockname`\n```\n13> sys:get_status(AccepterSup).\n{status,<0.44.0>,\n        {module,gen_server},\n        [[{'$ancestors',[<0.42.0>,ranch_sup,<0.34.0>]},\n          {'$initial_call',{supervisor,ranch_acceptors_sup,1}}],\n         running,<0.42.0>,[],\n         [{header,\"Status for generic server <0.44.0>\"},\n          {data,[{\"Status\",running},\n                 {\"Parent\",<0.42.0>},\n                 {\"Logged events\",[]}]},\n          {data,[{\"State\",\n                  {state,{<0.44.0>,ranch_acceptors_sup},\n                         one_for_one,\n                         [{child,<0.45.0>,\n                                 {acceptor,<0.44.0>,1},\n                                 {ranch_acceptor,start_link,\n                                                 [#Port<0.917>,ranch_tcp,<0.43.0>]},\n                                 permanent,brutal_kill,worker,[]}],\n                         undefined,10,10,[],ranch_acceptors_sup,\n                         [tcp_echo,1,ranch_tcp,[{port,5555}]]}}]}]]}\n```\n\ndemo中只启动了一个acceptor\n至此完了了所有进程的启动。等待connection进来。\n![](/img/ranch_2.png)\n\n### Acceptor:\nacceptor的作用是`accept(ListenSocket) -> Socket.` 通过`Transport:controlling_process`,将端口控制交给`conns_sup`, 然后向conns_sup发送`{ranch_conns_sup, start_protocol, AcceptorPid, Socket}`\n\n```\nstart_link(LSocket, Transport, ConnsSup) ->\n\tPid = spawn_link(?MODULE, loop, [LSocket, Transport, ConnsSup]),\n\t{ok, Pid}.\n\n-spec loop(inet:socket(), module(), pid()) -> no_return().\nloop(LSocket, Transport, ConnsSup) ->\n\t_ = case Transport:accept(LSocket, infinity) of\n\t\t{ok, CSocket} ->\n\t\t\tcase Transport:controlling_process(CSocket, ConnsSup) of\n\t\t\t\tok ->\n\t\t\t\t\tranch_conns_sup:start_protocol(ConnsSup, CSocket);\n\t\t\t\t{error, _} ->\n\t\t\t\t\tTransport:close(CSocket)\n\t\t\tend;\n\t\t{error, emfile} ->\n\t\t\treceive after 100 -> ok end;\n\t\t{error, Reason} when Reason =/= closed ->\n\t\t\tok\n\tend,\n\tflush(),\n\t?MODULE:loop(LSocket, Transport, ConnsSup).\n```\n\n`ranch_conns_sup`:\n```\nstart_protocol(SupPid, Socket) ->\n\tSupPid ! {?MODULE, start_protocol, self(), Socket},\n\treceive SupPid -> ok end.\n```\n\n```receive\n\t\t{?MODULE, start_protocol, To, Socket} ->\n\t\t\ttry Protocol:start_link(Ref, Socket, Transport, Opts) of\n\t\t\t\t{ok, Pid} ->\n\t\t\t\t\tshoot(State, CurConns, NbChildren, Sleepers, To, Socket, Pid, Pid);\n\t\t\t\t{ok, SupPid, ProtocolPid} when ConnType =:= supervisor ->\n\t\t\t\t\tshoot(State, CurConns, NbChildren, Sleepers, To, Socket, SupPid, ProtocolPid);\n\t\t\t\tRet ->\n\t\t\t\t\tTo ! self(),\n\t\t\t\t\terror_logger:error_msg(\n\t\t\t\t\t\t\"Ranch listener ~p connection process start failure; \"\n\t\t\t\t\t\t\"~p:start_link/4 returned: ~999999p~n\",\n\t\t\t\t\t\t[Ref, Protocol, Ret]),\n\t\t\t\t\tTransport:close(Socket),\n\t\t\t\t\tloop(State, CurConns, NbChildren, Sleepers)\n\t\t\t\t\t......\n```\n\n```\nshoot(State=#state{ref=Ref, transport=Transport, ack_timeout=AckTimeout, max_conns=MaxConns},\n\t\tCurConns, NbChildren, Sleepers, To, Socket, SupPid, ProtocolPid) ->\n\tcase Transport:controlling_process(Socket, ProtocolPid) of\n\t\tok ->\n\t\t    %% 通知echo_protocol进程控制权已转移。\n\t\t\tProtocolPid ! {shoot, Ref, Transport, Socket, AckTimeout},\n\t\t\tput(SupPid, true),\n\t\t\tCurConns2 = CurConns + 1,\n\t\t\tif CurConns2 < MaxConns ->\n\t\t\t\t\tTo ! self(),\n\t\t\t\t\tloop(State, CurConns2, NbChildren + 1, Sleepers);\n\t\t\t\ttrue ->\n\t\t\t\t\tloop(State, CurConns2, NbChildren + 1, [To|Sleepers])\n\t\t\tend;\n\t\t{error, _} ->\n\t\t\tTransport:close(Socket),\n\t\t\t%% Only kill the supervised pid, because the connection's pid,\n\t\t\t%% when different, is supposed to be sitting under it and linked.\n\t\t\texit(SupPid, kill),\n\t\t\tloop(State, CurConns, NbChildren, Sleepers)\n\tend.\n```\n\n### ranch_protocol:\nconns_sup在完成`controlling_process`后要通知protocol进程完成了转移。因为此时protocol的init还没有执行结束，一直在等着控制权转移。因为控制权没转移是不能进入loop的.spawn_link及时将自己的pid告诉了conns_sup.如果是gen_server等需要init结束才返回的进程需要特殊处理, 在下面分析.同时完成转移后conns_sup还给acceptor发送一条自己的pid，告诉acceptor转移完成。因为这之前acceptor一直处在receive状态，等待conns_sup完成工作。不完成他不会再次参与accept操作.\n`echo_protocol:`\n```\nstart_link(Ref, Socket, Transport, Opts) ->\n\tPid = spawn_link(?MODULE, init, [Ref, Socket, Transport, Opts]),\n\t{ok, Pid}.\n\ninit(Ref, Socket, Transport, _Opts = []) ->\n  %% 必须调用 accept_ack，确保socket控制权\n\tok = ranch:accept_ack(Ref),\n\tloop(Socket, Transport).\n```\n\n`ranch:`\n```\naccept_ack(Ref) ->\n\treceive {shoot, Ref, Transport, Socket, AckTimeout} ->\n\t\tTransport:accept_ack(Socket, AckTimeout)\n\tend.\n```\n\n链接套接字的逻辑进程都要有\n1. -behavior(ranch_protocol). 定义了一个start_link/4 callback而已。\n2. 在任何对端口的操作之前一定要确保执行过ranch:accept_ack(Ref)(确保端口控制权交给自己).在此之后可以运行ranch_tcp|ranch_ssl:setopts(Opt)完成自定义对端口的设置\n如果同时他是个gen_server,gen_fsm等有自己的start_link, 会产生一个问题，因为init中放入ranch:accept_ack/1会形成死锁。(见上面，即`conns_sup` 在等待`ranch_protocol`进程的pid返回。而`ranch_protocol`在等待`conns_sup`将端口控制交给自己)见问题说明\n[ranch_protocol_doc](https://github.com/ninenines/ranch/blob/master/doc/src/guide/protocols.asciidoc).\n作者再上面给出了两种解决办法:\n1. 在start_link 中用proc_lib:start_link代替gen_server:start_link,然后在init中主动调用proc_lib：init_ack通知父进程初始化完毕，然后调用ranch:accept_ack，再之后手动用gen_server:enter_loop进入循环。在之前这里分析过gen_server的初始化过程。\n[gen_server和init](/2015/07/31/erlang-question-gen-server-and-init/)\n2. 作者在init中返回timeout为0，然后通过handle_info(timeout...)调用ranch:accept_ack。实际上最好不要这么用，原因还是见上面的文章。具体剖析过为什么不能这么用。还是用 self()!timeout替代这种方法吧。\n![](/img/ranch_3.png)\n","slug":"ranch笔记","published":1,"updated":"2018-06-26T09:49:27.736Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqw7jdw9001b6f1re3aa54su","content":"<p>任何使用ranch的程序第一步需要启动ranch_app</p>\n<h2 id=\"start_ranch_application\">start ranch application</h2><p>入口<br><code>ranch_app:</code><br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start(_, _) -&gt;</span><br><span class=\"line\">\t_ = consider_profiling(), %% 是否启动eprof</span><br><span class=\"line\">\tranch_sup:start_link().</span><br></pre></td></tr></table></figure></p>\n<span id=\"more\"></span>\n<p><code>ranch_sup:</code><br>整个应用的最顶级sup， 它建立ranch_server ets,并启动ranch_server这个gen_server,将ranch_server这个ets归属于ranch_sup提高容错.防止数据丢失。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start_link() -&gt;</span><br><span class=\"line\">\tsupervisor:start_link(&#123;local, ?MODULE&#125;, ?MODULE, []).</span><br><span class=\"line\"></span><br><span class=\"line\">init([]) -&gt;</span><br><span class=\"line\">\tranch_server = ets:new(ranch_server, [</span><br><span class=\"line\">\t\tordered_set, public, named_table]),</span><br><span class=\"line\">\tProcs = [</span><br><span class=\"line\">\t\t&#123;ranch_server, &#123;ranch_server, start_link, []&#125;,</span><br><span class=\"line\">\t\t\tpermanent, 5000, worker, [ranch_server]&#125;</span><br><span class=\"line\">\t],</span><br><span class=\"line\">\t&#123;ok, &#123;&#123;one_for_one, 10, 10&#125;, Procs&#125;&#125;.</span><br></pre></td></tr></table></figure></p>\n<p><code>ranch_server:</code><br>是一个gen_server,init中从ranch_server ets中恢复数据<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">init([]) -&gt;</span><br><span class=\"line\">\tMonitors = [&#123;&#123;erlang:monitor(process, Pid), Pid&#125;, Ref&#125; ||</span><br><span class=\"line\">\t\t[Ref, Pid] &lt;- ets:match(?TAB, &#123;&#123;conns_sup, &#x27;$1&#x27;&#125;, &#x27;$2&#x27;&#125;)],</span><br><span class=\"line\">\t&#123;ok, #state&#123;monitors=Monitors&#125;&#125;.</span><br></pre></td></tr></table></figure><br><strong>ranch初始化完成</strong></p>\n<h2 id=\"\"><img src=\"/img/ranch_1.png\" alt=\"\"></h2><p>至此ranch实际上没有做任何事情，它并没有监听任何端口，需要使用者在自己的app中显示的调用ranch:start_listener来启动acceptor_pool.</p>\n<p>在作者的demo中是这样：</p>\n<h3 id=\"tcp_echo_app:\">tcp_echo_app:</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start(_Type, _Args) -&gt;</span><br><span class=\"line\">\t&#123;ok, _&#125; = ranch:start_listener(tcp_echo, 1,</span><br><span class=\"line\">\t\tranch_tcp, [&#123;port, 5555&#125;], echo_protocol, []),</span><br><span class=\"line\">\ttcp_echo_sup:start_link().</span><br></pre></td></tr></table></figure>\n<p><code>ranch:start_listner</code>接受6个参数 </p>\n<ol>\n<li>名字: tcp_echo,</li>\n<li>acceptor数量: 1<br><strong>此处不是connection的数量!! wiki说:</strong><blockquote>\n<p>First of all, it should not be confused with the maximum number of connections. Acceptor processes are only used for accepting and have nothing else in common with connection processes. Therefore there is nothing to be gained from setting this number too high, in fact it can slow everything else down.</p>\n</blockquote>\n</li>\n</ol>\n<blockquote>\n<p>Second, this number should be high enough to allow Ranch to accept connections concurrently. But the number of cores available doesn’t seem to be the only factor for choosing this number, as we can observe faster accepts if we have more acceptors than cores. It might be entirely dependent on the protocol, however.</p>\n</blockquote>\n<p>总之就是太少太多都不好，他们的观测得到100较为合适</p>\n<ol start=\"3\">\n<li>transport的方式: ranch_tcp</li>\n<li>transport options: [{port, 5555}],<br><code>ranch_tcp:</code><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">listen(Opts) -&gt;</span><br><span class=\"line\">\tOpts2 = ranch:set_option_default(Opts, backlog, 1024),</span><br><span class=\"line\">\tOpts3 = ranch:set_option_default(Opts2, nodelay, true),</span><br><span class=\"line\">\tOpts4 = ranch:set_option_default(Opts3, send_timeout, 30000),</span><br><span class=\"line\">\tOpts5 = ranch:set_option_default(Opts4, send_timeout_close, true),</span><br><span class=\"line\">\tgen_tcp:listen(0, ranch:filter_options(Opts5, listen_options(),</span><br><span class=\"line\">\t\t[binary, &#123;active, false&#125;, &#123;packet, raw&#125;, &#123;reuseaddr, true&#125;])).</span><br></pre></td></tr></table></figure>\n可以看出ranch_tcp代码中默认使用binary, {active,false}, 等设置，所以无法通过options更改。可以在start_listener之后的通过Transport:setopts/2更改.<br>但是backlog, nodelay等可以通过Opts在start的时候就设置好.<br><strong>port</strong>:未指定的话，则会随意一个端口.还有，不要设置1024以上的。原因如下<blockquote>\n<p>Some systems limit access to ports below 1024 for security reasons.The methods for listening on privileged ports vary between systems, please refer to your system’s documentation for more information.</p>\n</blockquote>\n</li>\n</ol>\n<p><strong>max_connections</strong>: {max_connections, Number|infinity}Number默认是1024.尽量不要infinity。<br>还可以通过<code>ranch:set_max_connections</code>设置.有时有个别进程是长链接，不希望它计入connections的计数。可以通过<code>ranch:remove_conections/1</code>移除1.</p>\n<ol start=\"5\">\n<li>protocol_handler mod: echo_protocol</li>\n<li>protocol options: []</li>\n</ol>\n<h3 id=\"ranch:\">ranch:</h3><p>listener的实现:<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start_listener(tcp_echo, 1, ranch_tcp, [&#123;port, 5555&#125;], echo_protocol, []) -&gt;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">\tChildSpec = &#123;&#123;ranch_listener_sup, tcp_echo&#125;, &#123;ranch_listener_sup, start_link, [</span><br><span class=\"line\">\t\ttcp_echo, 1, ranch_tcp, [&#123;port, 5555&#125;], echo_protocol, [] </span><br><span class=\"line\">\t]&#125;, permanent, infinity, supervisor, [ranch_listener_sup]&#125;.</span><br><span class=\"line\">\tRes = supervisor:start_child(ranch_sup, ChildSpec),</span><br><span class=\"line\">\tSocket = proplists:get_value(socket, [&#123;port, 5555&#125;]),</span><br><span class=\"line\">\tcase Res of</span><br><span class=\"line\">\t\t&#123;ok, Pid&#125; when Socket =/= undefined -&gt;</span><br><span class=\"line\">\t\t    %% 此处更改socket的拥有者,暂不管</span><br><span class=\"line\">\t\t  \tChildren = supervisor:which_children(Pid),</span><br><span class=\"line\">\t\t  \t&#123;_, AcceptorsSup, _, _&#125;</span><br><span class=\"line\">\t\t  \t\t= lists:keyfind(ranch_acceptors_sup, 1, Children),</span><br><span class=\"line\">\t\t   catch Transport:controlling_process(Socket, AcceptorsSup);</span><br><span class=\"line\">\t\t_ -&gt;</span><br><span class=\"line\">\t\t\tok</span><br><span class=\"line\">\tend,</span><br><span class=\"line\">\tRes</span><br><span class=\"line\">\t...</span><br></pre></td></tr></table></figure></p>\n<p>在未指定socket的情况，start_listener通过<code>supervisor:start_child/2</code>启动了<code>ranch_listener_sup</code></p>\n<h3 id=\"ranch_listener_sup:\">ranch_listener_sup:</h3><p>listener_sup 仍然是个supervisor，它得到一个max_connections(默认1024）, 通知ranch_server储存max_connection,和Opts。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start_link(Ref, NbAcceptors, Transport, TransOpts, Protocol, ProtoOpts) -&gt;</span><br><span class=\"line\">\tMaxConns = proplists:get_value(max_connections, TransOpts, 1024),</span><br><span class=\"line\">\tranch_server:set_new_listener_opts(Ref, MaxConns, ProtoOpts),</span><br><span class=\"line\">\t%% 注意此处没有注册名字</span><br><span class=\"line\">\tsupervisor:start_link(?MODULE, &#123;</span><br><span class=\"line\">\t\tRef, NbAcceptors, Transport, TransOpts, Protocol</span><br><span class=\"line\">\t&#125;).</span><br></pre></td></tr></table></figure></p>\n<p><code>ranch_server:</code><br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">handle_call(&#123;set_new_listener_opts, Ref, MaxConns, Opts&#125;, _, State) -&gt;</span><br><span class=\"line\">    %% 将数据存入rank_server ets.</span><br><span class=\"line\">\tets:insert(rank_server, &#123;&#123;max_conns, Ref&#125;, MaxConns&#125;),</span><br><span class=\"line\">\tets:insert(rank_server, &#123;&#123;opts, Ref&#125;, Opts&#125;),</span><br><span class=\"line\">\t&#123;reply, ok, State&#125;;</span><br></pre></td></tr></table></figure></p>\n<p><code>ranch_listener_sup:</code><br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">init(&#123;tcp_echo, 1, ranch_tcp, [&#123;port, 5555&#125;], echo_protocol&#125;) -&gt;</span><br><span class=\"line\">\tAckTimeout = proplists:get_value(ack_timeout, TransOpts, 5000),</span><br><span class=\"line\">\tConnType = proplists:get_value(connection_type, TransOpts, worker),</span><br><span class=\"line\">\tShutdown = proplists:get_value(shutdown, TransOpts, 5000),</span><br><span class=\"line\">\tChildSpecs = [</span><br><span class=\"line\">\t\t&#123;ranch_conns_sup, &#123;ranch_conns_sup, start_link,</span><br><span class=\"line\">\t\t\t\t[Ref, ConnType, Shutdown, Transport, AckTimeout, Protocol]&#125;,</span><br><span class=\"line\">\t\t\tpermanent, infinity, supervisor, [ranch_conns_sup]&#125;,</span><br><span class=\"line\">\t\t&#123;ranch_acceptors_sup, &#123;ranch_acceptors_sup, start_link,</span><br><span class=\"line\">\t\t\t\t[Ref, NbAcceptors, Transport, TransOpts]&#125;,</span><br><span class=\"line\">\t\t\tpermanent, infinity, supervisor, [ranch_acceptors_sup]&#125;</span><br><span class=\"line\">\t],</span><br><span class=\"line\">\t&#123;ok, &#123;&#123;rest_for_one, 10, 10&#125;, ChildSpecs&#125;&#125;.</span><br></pre></td></tr></table></figure></p>\n<p>listener_sup 启动 conns_sup和acceptors_sup,这两个都是supervisor 所以shutdown都设置成infinity<br>但是其中conns_sup是个自定义的supervisor，作者解释是为了优化create和accept connection。</p>\n<blockquote>\n<p>Ranch uses a custom supervisor for managing connections. This supervisor keeps track of the number of connections and handles connection limits directly. While it is heavily optimized to perform the task of creating connection processes for accepted connections, it is still following the OTP principles and the usual sys and supervisor calls will work on it as expected.</p>\n</blockquote>\n<h3 id=\"Ranch_conns_sup:\">Ranch_conns_sup:</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start_link(Ref, ConnType, Shutdown, Transport, AckTimeout, Protocol) -&gt;</span><br><span class=\"line\">\tproc_lib:start_link(?MODULE, init,</span><br><span class=\"line\">\t[self(), Ref, ConnType, Shutdown, Transport, AckTimeout, Protocol]).</span><br><span class=\"line\">\t</span><br><span class=\"line\">init(Parent, Ref, ConnType, Shutdown, Transport, AckTimeout, Protocol) -&gt;</span><br><span class=\"line\">\tprocess_flag(trap_exit, true),</span><br><span class=\"line\">\tok = ranch_server:set_connections_sup(Ref, self()),</span><br><span class=\"line\">\tMaxConns = ranch_server:get_max_connections(Ref),</span><br><span class=\"line\">\tOpts = ranch_server:get_protocol_options(Ref),</span><br><span class=\"line\">\tok = proc_lib:init_ack(Parent, &#123;ok, self()&#125;),</span><br><span class=\"line\">\tloop(#state&#123;parent=Parent, ref=Ref, conn_type=ConnType,</span><br><span class=\"line\">\t\tshutdown=Shutdown, transport=Transport, protocol=Protocol,</span><br><span class=\"line\">\t\topts=Opts, ack_timeout=AckTimeout, max_conns=MaxConns&#125;, 0, 0, []).</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">14&gt; rp(sys:get_status(ConnsSup)).</span><br><span class=\"line\">&#123;status,&lt;0.43.0&gt;,</span><br><span class=\"line\">        &#123;module,ranch_conns_sup&#125;,</span><br><span class=\"line\">        [[&#123;&#x27;$ancestors&#x27;,[&lt;0.42.0&gt;,ranch_sup,&lt;0.34.0&gt;]&#125;,</span><br><span class=\"line\">          &#123;&#x27;$initial_call&#x27;,&#123;ranch_conns_sup,init,7&#125;&#125;],</span><br><span class=\"line\">         running,&lt;0.42.0&gt;,[],</span><br><span class=\"line\">         &#123;&#123;state,&lt;0.42.0&gt;,tcp_echo,worker,5000,ranch_tcp,</span><br><span class=\"line\">                 echo_protocol,[],5000,1024&#125;,</span><br><span class=\"line\">          0,0,[]&#125;]&#125;</span><br></pre></td></tr></table></figure>\n<p>上面使用<code>sys:get_status(Name|Pid)</code>得到ranch_conns_sup的#state{}。</p>\n<h3 id=\"Ranch_acceptor_sup:\">Ranch_acceptor_sup:</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start_link(Ref, NbAcceptors, Transport, TransOpts) -&gt;</span><br><span class=\"line\">\tsupervisor:start_link(?MODULE, [Ref, NbAcceptors, Transport, TransOpts]).</span><br><span class=\"line\"></span><br><span class=\"line\">init([Ref, NbAcceptors, Transport, TransOpts]) -&gt;</span><br><span class=\"line\">\tConnsSup = ranch_server:get_connections_sup(Ref),</span><br><span class=\"line\">\tLSocket = case proplists:get_value(socket, TransOpts) of</span><br><span class=\"line\">\t\tundefined -&gt;</span><br><span class=\"line\">\t\t\tTransOpts2 = proplists:delete(ack_timeout,</span><br><span class=\"line\">\t\t\t\tproplists:delete(connection_type,</span><br><span class=\"line\">\t\t\t\tproplists:delete(max_connections,</span><br><span class=\"line\">\t\t\t\tproplists:delete(shutdown,</span><br><span class=\"line\">\t\t\t\tproplists:delete(socket, TransOpts))))),</span><br><span class=\"line\">\t\t\tcase Transport:listen(TransOpts2) of</span><br><span class=\"line\">\t\t\t\t&#123;ok, Socket&#125; -&gt; Socket;</span><br><span class=\"line\">\t\t\t\t&#123;error, Reason&#125; -&gt; listen_error(Ref, Transport, TransOpts2, Reason)</span><br><span class=\"line\">\t\t\tend;</span><br><span class=\"line\">\t\tSocket -&gt;</span><br><span class=\"line\">\t\t\tSocket</span><br><span class=\"line\">\tend,</span><br><span class=\"line\">\t&#123;ok, Addr&#125; = Transport:sockname(LSocket),</span><br><span class=\"line\">\tranch_server:set_addr(Ref, Addr),</span><br><span class=\"line\">\tProcs = [</span><br><span class=\"line\">\t\t&#123;&#123;acceptor, self(), N&#125;, &#123;ranch_acceptor, start_link, [</span><br><span class=\"line\">\t\t\tLSocket, Transport, ConnsSup</span><br><span class=\"line\">\t\t]&#125;, permanent, brutal_kill, worker, []&#125;</span><br><span class=\"line\">\t\t\t|| N &lt;- lists:seq(1, NbAcceptors)],</span><br><span class=\"line\">\t&#123;ok, &#123;&#123;one_for_one, 10, 10&#125;, Procs&#125;&#125;.</span><br></pre></td></tr></table></figure>\n<p>acceptor_sup完成了得到一个ListenSocket, 然后启动N个acceptor进程，这些acceptor的loop等待<code>gen_tcp:accept</code> | <code>ssl:transport_accept</code><br><code>Transport:listen</code>的本质就是<code>gen_tcp:listen</code>或者<code>ssl:listen</code> 它返回一个ListenSocket<br><code>Transport:sockname</code> :: <code>inet:sockname</code> | <code>ssl:sockname</code><br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">13&gt; sys:get_status(AccepterSup).</span><br><span class=\"line\">&#123;status,&lt;0.44.0&gt;,</span><br><span class=\"line\">        &#123;module,gen_server&#125;,</span><br><span class=\"line\">        [[&#123;&#x27;$ancestors&#x27;,[&lt;0.42.0&gt;,ranch_sup,&lt;0.34.0&gt;]&#125;,</span><br><span class=\"line\">          &#123;&#x27;$initial_call&#x27;,&#123;supervisor,ranch_acceptors_sup,1&#125;&#125;],</span><br><span class=\"line\">         running,&lt;0.42.0&gt;,[],</span><br><span class=\"line\">         [&#123;header,&quot;Status for generic server &lt;0.44.0&gt;&quot;&#125;,</span><br><span class=\"line\">          &#123;data,[&#123;&quot;Status&quot;,running&#125;,</span><br><span class=\"line\">                 &#123;&quot;Parent&quot;,&lt;0.42.0&gt;&#125;,</span><br><span class=\"line\">                 &#123;&quot;Logged events&quot;,[]&#125;]&#125;,</span><br><span class=\"line\">          &#123;data,[&#123;&quot;State&quot;,</span><br><span class=\"line\">                  &#123;state,&#123;&lt;0.44.0&gt;,ranch_acceptors_sup&#125;,</span><br><span class=\"line\">                         one_for_one,</span><br><span class=\"line\">                         [&#123;child,&lt;0.45.0&gt;,</span><br><span class=\"line\">                                 &#123;acceptor,&lt;0.44.0&gt;,1&#125;,</span><br><span class=\"line\">                                 &#123;ranch_acceptor,start_link,</span><br><span class=\"line\">                                                 [#Port&lt;0.917&gt;,ranch_tcp,&lt;0.43.0&gt;]&#125;,</span><br><span class=\"line\">                                 permanent,brutal_kill,worker,[]&#125;],</span><br><span class=\"line\">                         undefined,10,10,[],ranch_acceptors_sup,</span><br><span class=\"line\">                         [tcp_echo,1,ranch_tcp,[&#123;port,5555&#125;]]&#125;&#125;]&#125;]]&#125;</span><br></pre></td></tr></table></figure></p>\n<p>demo中只启动了一个acceptor<br>至此完了了所有进程的启动。等待connection进来。<br><img src=\"/img/ranch_2.png\" alt=\"\"></p>\n<h3 id=\"Acceptor:\">Acceptor:</h3><p>acceptor的作用是<code>accept(ListenSocket) -&gt; Socket.</code> 通过<code>Transport:controlling_process</code>,将端口控制交给<code>conns_sup</code>, 然后向conns_sup发送<code>&#123;ranch_conns_sup, start_protocol, AcceptorPid, Socket&#125;</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start_link(LSocket, Transport, ConnsSup) -&gt;</span><br><span class=\"line\">\tPid = spawn_link(?MODULE, loop, [LSocket, Transport, ConnsSup]),</span><br><span class=\"line\">\t&#123;ok, Pid&#125;.</span><br><span class=\"line\"></span><br><span class=\"line\">-spec loop(inet:socket(), module(), pid()) -&gt; no_return().</span><br><span class=\"line\">loop(LSocket, Transport, ConnsSup) -&gt;</span><br><span class=\"line\">\t_ = case Transport:accept(LSocket, infinity) of</span><br><span class=\"line\">\t\t&#123;ok, CSocket&#125; -&gt;</span><br><span class=\"line\">\t\t\tcase Transport:controlling_process(CSocket, ConnsSup) of</span><br><span class=\"line\">\t\t\t\tok -&gt;</span><br><span class=\"line\">\t\t\t\t\tranch_conns_sup:start_protocol(ConnsSup, CSocket);</span><br><span class=\"line\">\t\t\t\t&#123;error, _&#125; -&gt;</span><br><span class=\"line\">\t\t\t\t\tTransport:close(CSocket)</span><br><span class=\"line\">\t\t\tend;</span><br><span class=\"line\">\t\t&#123;error, emfile&#125; -&gt;</span><br><span class=\"line\">\t\t\treceive after 100 -&gt; ok end;</span><br><span class=\"line\">\t\t&#123;error, Reason&#125; when Reason =/= closed -&gt;</span><br><span class=\"line\">\t\t\tok</span><br><span class=\"line\">\tend,</span><br><span class=\"line\">\tflush(),</span><br><span class=\"line\">\t?MODULE:loop(LSocket, Transport, ConnsSup).</span><br></pre></td></tr></table></figure>\n<p><code>ranch_conns_sup</code>:<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start_protocol(SupPid, Socket) -&gt;</span><br><span class=\"line\">\tSupPid ! &#123;?MODULE, start_protocol, self(), Socket&#125;,</span><br><span class=\"line\">\treceive SupPid -&gt; ok end.</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;?MODULE, start_protocol, To, Socket&#125; -&gt;</span><br><span class=\"line\">\ttry Protocol:start_link(Ref, Socket, Transport, Opts) of</span><br><span class=\"line\">\t\t&#123;ok, Pid&#125; -&gt;</span><br><span class=\"line\">\t\t\tshoot(State, CurConns, NbChildren, Sleepers, To, Socket, Pid, Pid);</span><br><span class=\"line\">\t\t&#123;ok, SupPid, ProtocolPid&#125; when ConnType =:= supervisor -&gt;</span><br><span class=\"line\">\t\t\tshoot(State, CurConns, NbChildren, Sleepers, To, Socket, SupPid, ProtocolPid);</span><br><span class=\"line\">\t\tRet -&gt;</span><br><span class=\"line\">\t\t\tTo ! self(),</span><br><span class=\"line\">\t\t\terror_logger:error_msg(</span><br><span class=\"line\">\t\t\t\t&quot;Ranch listener ~p connection process start failure; &quot;</span><br><span class=\"line\">\t\t\t\t&quot;~p:start_link/4 returned: ~999999p~n&quot;,</span><br><span class=\"line\">\t\t\t\t[Ref, Protocol, Ret]),</span><br><span class=\"line\">\t\t\tTransport:close(Socket),</span><br><span class=\"line\">\t\t\tloop(State, CurConns, NbChildren, Sleepers)</span><br><span class=\"line\">\t\t\t......</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shoot(State=#state&#123;ref=Ref, transport=Transport, ack_timeout=AckTimeout, max_conns=MaxConns&#125;,</span><br><span class=\"line\">\t\tCurConns, NbChildren, Sleepers, To, Socket, SupPid, ProtocolPid) -&gt;</span><br><span class=\"line\">\tcase Transport:controlling_process(Socket, ProtocolPid) of</span><br><span class=\"line\">\t\tok -&gt;</span><br><span class=\"line\">\t\t    %% 通知echo_protocol进程控制权已转移。</span><br><span class=\"line\">\t\t\tProtocolPid ! &#123;shoot, Ref, Transport, Socket, AckTimeout&#125;,</span><br><span class=\"line\">\t\t\tput(SupPid, true),</span><br><span class=\"line\">\t\t\tCurConns2 = CurConns + 1,</span><br><span class=\"line\">\t\t\tif CurConns2 &lt; MaxConns -&gt;</span><br><span class=\"line\">\t\t\t\t\tTo ! self(),</span><br><span class=\"line\">\t\t\t\t\tloop(State, CurConns2, NbChildren + 1, Sleepers);</span><br><span class=\"line\">\t\t\t\ttrue -&gt;</span><br><span class=\"line\">\t\t\t\t\tloop(State, CurConns2, NbChildren + 1, [To|Sleepers])</span><br><span class=\"line\">\t\t\tend;</span><br><span class=\"line\">\t\t&#123;error, _&#125; -&gt;</span><br><span class=\"line\">\t\t\tTransport:close(Socket),</span><br><span class=\"line\">\t\t\t%% Only kill the supervised pid, because the connection&#x27;s pid,</span><br><span class=\"line\">\t\t\t%% when different, is supposed to be sitting under it and linked.</span><br><span class=\"line\">\t\t\texit(SupPid, kill),</span><br><span class=\"line\">\t\t\tloop(State, CurConns, NbChildren, Sleepers)</span><br><span class=\"line\">\tend.</span><br></pre></td></tr></table></figure>\n<h3 id=\"ranch_protocol:\">ranch_protocol:</h3><p>conns_sup在完成<code>controlling_process</code>后要通知protocol进程完成了转移。因为此时protocol的init还没有执行结束，一直在等着控制权转移。因为控制权没转移是不能进入loop的.spawn_link及时将自己的pid告诉了conns_sup.如果是gen_server等需要init结束才返回的进程需要特殊处理, 在下面分析.同时完成转移后conns_sup还给acceptor发送一条自己的pid，告诉acceptor转移完成。因为这之前acceptor一直处在receive状态，等待conns_sup完成工作。不完成他不会再次参与accept操作.<br><code>echo_protocol:</code><br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start_link(Ref, Socket, Transport, Opts) -&gt;</span><br><span class=\"line\">\tPid = spawn_link(?MODULE, init, [Ref, Socket, Transport, Opts]),</span><br><span class=\"line\">\t&#123;ok, Pid&#125;.</span><br><span class=\"line\"></span><br><span class=\"line\">init(Ref, Socket, Transport, _Opts = []) -&gt;</span><br><span class=\"line\">  %% 必须调用 accept_ack，确保socket控制权</span><br><span class=\"line\">\tok = ranch:accept_ack(Ref),</span><br><span class=\"line\">\tloop(Socket, Transport).</span><br></pre></td></tr></table></figure></p>\n<p><code>ranch:</code><br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">accept_ack(Ref) -&gt;</span><br><span class=\"line\">\treceive &#123;shoot, Ref, Transport, Socket, AckTimeout&#125; -&gt;</span><br><span class=\"line\">\t\tTransport:accept_ack(Socket, AckTimeout)</span><br><span class=\"line\">\tend.</span><br></pre></td></tr></table></figure></p>\n<p>链接套接字的逻辑进程都要有</p>\n<ol>\n<li>-behavior(ranch_protocol). 定义了一个start_link/4 callback而已。</li>\n<li>在任何对端口的操作之前一定要确保执行过ranch:accept_ack(Ref)(确保端口控制权交给自己).在此之后可以运行ranch_tcp|ranch_ssl:setopts(Opt)完成自定义对端口的设置<br>如果同时他是个gen_server,gen_fsm等有自己的start_link, 会产生一个问题，因为init中放入ranch:accept_ack/1会形成死锁。(见上面，即<code>conns_sup</code> 在等待<code>ranch_protocol</code>进程的pid返回。而<code>ranch_protocol</code>在等待<code>conns_sup</code>将端口控制交给自己)见问题说明<br><a href=\"https://github.com/ninenines/ranch/blob/master/doc/src/guide/protocols.asciidoc\">ranch_protocol_doc</a>.<br>作者再上面给出了两种解决办法:</li>\n<li>在start_link 中用proc_lib:start_link代替gen_server:start_link,然后在init中主动调用proc_lib：init_ack通知父进程初始化完毕，然后调用ranch:accept_ack，再之后手动用gen_server:enter_loop进入循环。在之前这里分析过gen_server的初始化过程。<br><a href=\"/2015/07/31/erlang-question-gen-server-and-init/\">gen_server和init</a></li>\n<li>作者在init中返回timeout为0，然后通过handle_info(timeout...)调用ranch:accept_ack。实际上最好不要这么用，原因还是见上面的文章。具体剖析过为什么不能这么用。还是用 self()!timeout替代这种方法吧。<br><img src=\"/img/ranch_3.png\" alt=\"\"></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>任何使用ranch的程序第一步需要启动ranch_app</p>\n<h2 id=\"start_ranch_application\">start ranch application</h2><p>入口<br><code>ranch_app:</code><br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start(_, _) -&gt;</span><br><span class=\"line\">\t_ = consider_profiling(), %% 是否启动eprof</span><br><span class=\"line\">\tranch_sup:start_link().</span><br></pre></td></tr></table></figure></p>","more":"<p><code>ranch_sup:</code><br>整个应用的最顶级sup， 它建立ranch_server ets,并启动ranch_server这个gen_server,将ranch_server这个ets归属于ranch_sup提高容错.防止数据丢失。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start_link() -&gt;</span><br><span class=\"line\">\tsupervisor:start_link(&#123;local, ?MODULE&#125;, ?MODULE, []).</span><br><span class=\"line\"></span><br><span class=\"line\">init([]) -&gt;</span><br><span class=\"line\">\tranch_server = ets:new(ranch_server, [</span><br><span class=\"line\">\t\tordered_set, public, named_table]),</span><br><span class=\"line\">\tProcs = [</span><br><span class=\"line\">\t\t&#123;ranch_server, &#123;ranch_server, start_link, []&#125;,</span><br><span class=\"line\">\t\t\tpermanent, 5000, worker, [ranch_server]&#125;</span><br><span class=\"line\">\t],</span><br><span class=\"line\">\t&#123;ok, &#123;&#123;one_for_one, 10, 10&#125;, Procs&#125;&#125;.</span><br></pre></td></tr></table></figure></p>\n<p><code>ranch_server:</code><br>是一个gen_server,init中从ranch_server ets中恢复数据<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">init([]) -&gt;</span><br><span class=\"line\">\tMonitors = [&#123;&#123;erlang:monitor(process, Pid), Pid&#125;, Ref&#125; ||</span><br><span class=\"line\">\t\t[Ref, Pid] &lt;- ets:match(?TAB, &#123;&#123;conns_sup, &#x27;$1&#x27;&#125;, &#x27;$2&#x27;&#125;)],</span><br><span class=\"line\">\t&#123;ok, #state&#123;monitors=Monitors&#125;&#125;.</span><br></pre></td></tr></table></figure><br><strong>ranch初始化完成</strong></p>\n<h2 id=\"\"><img src=\"/img/ranch_1.png\" alt=\"\"></h2><p>至此ranch实际上没有做任何事情，它并没有监听任何端口，需要使用者在自己的app中显示的调用ranch:start_listener来启动acceptor_pool.</p>\n<p>在作者的demo中是这样：</p>\n<h3 id=\"tcp_echo_app:\">tcp_echo_app:</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start(_Type, _Args) -&gt;</span><br><span class=\"line\">\t&#123;ok, _&#125; = ranch:start_listener(tcp_echo, 1,</span><br><span class=\"line\">\t\tranch_tcp, [&#123;port, 5555&#125;], echo_protocol, []),</span><br><span class=\"line\">\ttcp_echo_sup:start_link().</span><br></pre></td></tr></table></figure>\n<p><code>ranch:start_listner</code>接受6个参数 </p>\n<ol>\n<li>名字: tcp_echo,</li>\n<li>acceptor数量: 1<br><strong>此处不是connection的数量!! wiki说:</strong><blockquote>\n<p>First of all, it should not be confused with the maximum number of connections. Acceptor processes are only used for accepting and have nothing else in common with connection processes. Therefore there is nothing to be gained from setting this number too high, in fact it can slow everything else down.</p>\n</blockquote>\n</li>\n</ol>\n<blockquote>\n<p>Second, this number should be high enough to allow Ranch to accept connections concurrently. But the number of cores available doesn’t seem to be the only factor for choosing this number, as we can observe faster accepts if we have more acceptors than cores. It might be entirely dependent on the protocol, however.</p>\n</blockquote>\n<p>总之就是太少太多都不好，他们的观测得到100较为合适</p>\n<ol start=\"3\">\n<li>transport的方式: ranch_tcp</li>\n<li>transport options: [{port, 5555}],<br><code>ranch_tcp:</code><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">listen(Opts) -&gt;</span><br><span class=\"line\">\tOpts2 = ranch:set_option_default(Opts, backlog, 1024),</span><br><span class=\"line\">\tOpts3 = ranch:set_option_default(Opts2, nodelay, true),</span><br><span class=\"line\">\tOpts4 = ranch:set_option_default(Opts3, send_timeout, 30000),</span><br><span class=\"line\">\tOpts5 = ranch:set_option_default(Opts4, send_timeout_close, true),</span><br><span class=\"line\">\tgen_tcp:listen(0, ranch:filter_options(Opts5, listen_options(),</span><br><span class=\"line\">\t\t[binary, &#123;active, false&#125;, &#123;packet, raw&#125;, &#123;reuseaddr, true&#125;])).</span><br></pre></td></tr></table></figure>\n可以看出ranch_tcp代码中默认使用binary, {active,false}, 等设置，所以无法通过options更改。可以在start_listener之后的通过Transport:setopts/2更改.<br>但是backlog, nodelay等可以通过Opts在start的时候就设置好.<br><strong>port</strong>:未指定的话，则会随意一个端口.还有，不要设置1024以上的。原因如下<blockquote>\n<p>Some systems limit access to ports below 1024 for security reasons.The methods for listening on privileged ports vary between systems, please refer to your system’s documentation for more information.</p>\n</blockquote>\n</li>\n</ol>\n<p><strong>max_connections</strong>: {max_connections, Number|infinity}Number默认是1024.尽量不要infinity。<br>还可以通过<code>ranch:set_max_connections</code>设置.有时有个别进程是长链接，不希望它计入connections的计数。可以通过<code>ranch:remove_conections/1</code>移除1.</p>\n<ol start=\"5\">\n<li>protocol_handler mod: echo_protocol</li>\n<li>protocol options: []</li>\n</ol>\n<h3 id=\"ranch:\">ranch:</h3><p>listener的实现:<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start_listener(tcp_echo, 1, ranch_tcp, [&#123;port, 5555&#125;], echo_protocol, []) -&gt;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">\tChildSpec = &#123;&#123;ranch_listener_sup, tcp_echo&#125;, &#123;ranch_listener_sup, start_link, [</span><br><span class=\"line\">\t\ttcp_echo, 1, ranch_tcp, [&#123;port, 5555&#125;], echo_protocol, [] </span><br><span class=\"line\">\t]&#125;, permanent, infinity, supervisor, [ranch_listener_sup]&#125;.</span><br><span class=\"line\">\tRes = supervisor:start_child(ranch_sup, ChildSpec),</span><br><span class=\"line\">\tSocket = proplists:get_value(socket, [&#123;port, 5555&#125;]),</span><br><span class=\"line\">\tcase Res of</span><br><span class=\"line\">\t\t&#123;ok, Pid&#125; when Socket =/= undefined -&gt;</span><br><span class=\"line\">\t\t    %% 此处更改socket的拥有者,暂不管</span><br><span class=\"line\">\t\t  \tChildren = supervisor:which_children(Pid),</span><br><span class=\"line\">\t\t  \t&#123;_, AcceptorsSup, _, _&#125;</span><br><span class=\"line\">\t\t  \t\t= lists:keyfind(ranch_acceptors_sup, 1, Children),</span><br><span class=\"line\">\t\t   catch Transport:controlling_process(Socket, AcceptorsSup);</span><br><span class=\"line\">\t\t_ -&gt;</span><br><span class=\"line\">\t\t\tok</span><br><span class=\"line\">\tend,</span><br><span class=\"line\">\tRes</span><br><span class=\"line\">\t...</span><br></pre></td></tr></table></figure></p>\n<p>在未指定socket的情况，start_listener通过<code>supervisor:start_child/2</code>启动了<code>ranch_listener_sup</code></p>\n<h3 id=\"ranch_listener_sup:\">ranch_listener_sup:</h3><p>listener_sup 仍然是个supervisor，它得到一个max_connections(默认1024）, 通知ranch_server储存max_connection,和Opts。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start_link(Ref, NbAcceptors, Transport, TransOpts, Protocol, ProtoOpts) -&gt;</span><br><span class=\"line\">\tMaxConns = proplists:get_value(max_connections, TransOpts, 1024),</span><br><span class=\"line\">\tranch_server:set_new_listener_opts(Ref, MaxConns, ProtoOpts),</span><br><span class=\"line\">\t%% 注意此处没有注册名字</span><br><span class=\"line\">\tsupervisor:start_link(?MODULE, &#123;</span><br><span class=\"line\">\t\tRef, NbAcceptors, Transport, TransOpts, Protocol</span><br><span class=\"line\">\t&#125;).</span><br></pre></td></tr></table></figure></p>\n<p><code>ranch_server:</code><br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">handle_call(&#123;set_new_listener_opts, Ref, MaxConns, Opts&#125;, _, State) -&gt;</span><br><span class=\"line\">    %% 将数据存入rank_server ets.</span><br><span class=\"line\">\tets:insert(rank_server, &#123;&#123;max_conns, Ref&#125;, MaxConns&#125;),</span><br><span class=\"line\">\tets:insert(rank_server, &#123;&#123;opts, Ref&#125;, Opts&#125;),</span><br><span class=\"line\">\t&#123;reply, ok, State&#125;;</span><br></pre></td></tr></table></figure></p>\n<p><code>ranch_listener_sup:</code><br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">init(&#123;tcp_echo, 1, ranch_tcp, [&#123;port, 5555&#125;], echo_protocol&#125;) -&gt;</span><br><span class=\"line\">\tAckTimeout = proplists:get_value(ack_timeout, TransOpts, 5000),</span><br><span class=\"line\">\tConnType = proplists:get_value(connection_type, TransOpts, worker),</span><br><span class=\"line\">\tShutdown = proplists:get_value(shutdown, TransOpts, 5000),</span><br><span class=\"line\">\tChildSpecs = [</span><br><span class=\"line\">\t\t&#123;ranch_conns_sup, &#123;ranch_conns_sup, start_link,</span><br><span class=\"line\">\t\t\t\t[Ref, ConnType, Shutdown, Transport, AckTimeout, Protocol]&#125;,</span><br><span class=\"line\">\t\t\tpermanent, infinity, supervisor, [ranch_conns_sup]&#125;,</span><br><span class=\"line\">\t\t&#123;ranch_acceptors_sup, &#123;ranch_acceptors_sup, start_link,</span><br><span class=\"line\">\t\t\t\t[Ref, NbAcceptors, Transport, TransOpts]&#125;,</span><br><span class=\"line\">\t\t\tpermanent, infinity, supervisor, [ranch_acceptors_sup]&#125;</span><br><span class=\"line\">\t],</span><br><span class=\"line\">\t&#123;ok, &#123;&#123;rest_for_one, 10, 10&#125;, ChildSpecs&#125;&#125;.</span><br></pre></td></tr></table></figure></p>\n<p>listener_sup 启动 conns_sup和acceptors_sup,这两个都是supervisor 所以shutdown都设置成infinity<br>但是其中conns_sup是个自定义的supervisor，作者解释是为了优化create和accept connection。</p>\n<blockquote>\n<p>Ranch uses a custom supervisor for managing connections. This supervisor keeps track of the number of connections and handles connection limits directly. While it is heavily optimized to perform the task of creating connection processes for accepted connections, it is still following the OTP principles and the usual sys and supervisor calls will work on it as expected.</p>\n</blockquote>\n<h3 id=\"Ranch_conns_sup:\">Ranch_conns_sup:</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start_link(Ref, ConnType, Shutdown, Transport, AckTimeout, Protocol) -&gt;</span><br><span class=\"line\">\tproc_lib:start_link(?MODULE, init,</span><br><span class=\"line\">\t[self(), Ref, ConnType, Shutdown, Transport, AckTimeout, Protocol]).</span><br><span class=\"line\">\t</span><br><span class=\"line\">init(Parent, Ref, ConnType, Shutdown, Transport, AckTimeout, Protocol) -&gt;</span><br><span class=\"line\">\tprocess_flag(trap_exit, true),</span><br><span class=\"line\">\tok = ranch_server:set_connections_sup(Ref, self()),</span><br><span class=\"line\">\tMaxConns = ranch_server:get_max_connections(Ref),</span><br><span class=\"line\">\tOpts = ranch_server:get_protocol_options(Ref),</span><br><span class=\"line\">\tok = proc_lib:init_ack(Parent, &#123;ok, self()&#125;),</span><br><span class=\"line\">\tloop(#state&#123;parent=Parent, ref=Ref, conn_type=ConnType,</span><br><span class=\"line\">\t\tshutdown=Shutdown, transport=Transport, protocol=Protocol,</span><br><span class=\"line\">\t\topts=Opts, ack_timeout=AckTimeout, max_conns=MaxConns&#125;, 0, 0, []).</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">14&gt; rp(sys:get_status(ConnsSup)).</span><br><span class=\"line\">&#123;status,&lt;0.43.0&gt;,</span><br><span class=\"line\">        &#123;module,ranch_conns_sup&#125;,</span><br><span class=\"line\">        [[&#123;&#x27;$ancestors&#x27;,[&lt;0.42.0&gt;,ranch_sup,&lt;0.34.0&gt;]&#125;,</span><br><span class=\"line\">          &#123;&#x27;$initial_call&#x27;,&#123;ranch_conns_sup,init,7&#125;&#125;],</span><br><span class=\"line\">         running,&lt;0.42.0&gt;,[],</span><br><span class=\"line\">         &#123;&#123;state,&lt;0.42.0&gt;,tcp_echo,worker,5000,ranch_tcp,</span><br><span class=\"line\">                 echo_protocol,[],5000,1024&#125;,</span><br><span class=\"line\">          0,0,[]&#125;]&#125;</span><br></pre></td></tr></table></figure>\n<p>上面使用<code>sys:get_status(Name|Pid)</code>得到ranch_conns_sup的#state{}。</p>\n<h3 id=\"Ranch_acceptor_sup:\">Ranch_acceptor_sup:</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start_link(Ref, NbAcceptors, Transport, TransOpts) -&gt;</span><br><span class=\"line\">\tsupervisor:start_link(?MODULE, [Ref, NbAcceptors, Transport, TransOpts]).</span><br><span class=\"line\"></span><br><span class=\"line\">init([Ref, NbAcceptors, Transport, TransOpts]) -&gt;</span><br><span class=\"line\">\tConnsSup = ranch_server:get_connections_sup(Ref),</span><br><span class=\"line\">\tLSocket = case proplists:get_value(socket, TransOpts) of</span><br><span class=\"line\">\t\tundefined -&gt;</span><br><span class=\"line\">\t\t\tTransOpts2 = proplists:delete(ack_timeout,</span><br><span class=\"line\">\t\t\t\tproplists:delete(connection_type,</span><br><span class=\"line\">\t\t\t\tproplists:delete(max_connections,</span><br><span class=\"line\">\t\t\t\tproplists:delete(shutdown,</span><br><span class=\"line\">\t\t\t\tproplists:delete(socket, TransOpts))))),</span><br><span class=\"line\">\t\t\tcase Transport:listen(TransOpts2) of</span><br><span class=\"line\">\t\t\t\t&#123;ok, Socket&#125; -&gt; Socket;</span><br><span class=\"line\">\t\t\t\t&#123;error, Reason&#125; -&gt; listen_error(Ref, Transport, TransOpts2, Reason)</span><br><span class=\"line\">\t\t\tend;</span><br><span class=\"line\">\t\tSocket -&gt;</span><br><span class=\"line\">\t\t\tSocket</span><br><span class=\"line\">\tend,</span><br><span class=\"line\">\t&#123;ok, Addr&#125; = Transport:sockname(LSocket),</span><br><span class=\"line\">\tranch_server:set_addr(Ref, Addr),</span><br><span class=\"line\">\tProcs = [</span><br><span class=\"line\">\t\t&#123;&#123;acceptor, self(), N&#125;, &#123;ranch_acceptor, start_link, [</span><br><span class=\"line\">\t\t\tLSocket, Transport, ConnsSup</span><br><span class=\"line\">\t\t]&#125;, permanent, brutal_kill, worker, []&#125;</span><br><span class=\"line\">\t\t\t|| N &lt;- lists:seq(1, NbAcceptors)],</span><br><span class=\"line\">\t&#123;ok, &#123;&#123;one_for_one, 10, 10&#125;, Procs&#125;&#125;.</span><br></pre></td></tr></table></figure>\n<p>acceptor_sup完成了得到一个ListenSocket, 然后启动N个acceptor进程，这些acceptor的loop等待<code>gen_tcp:accept</code> | <code>ssl:transport_accept</code><br><code>Transport:listen</code>的本质就是<code>gen_tcp:listen</code>或者<code>ssl:listen</code> 它返回一个ListenSocket<br><code>Transport:sockname</code> :: <code>inet:sockname</code> | <code>ssl:sockname</code><br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">13&gt; sys:get_status(AccepterSup).</span><br><span class=\"line\">&#123;status,&lt;0.44.0&gt;,</span><br><span class=\"line\">        &#123;module,gen_server&#125;,</span><br><span class=\"line\">        [[&#123;&#x27;$ancestors&#x27;,[&lt;0.42.0&gt;,ranch_sup,&lt;0.34.0&gt;]&#125;,</span><br><span class=\"line\">          &#123;&#x27;$initial_call&#x27;,&#123;supervisor,ranch_acceptors_sup,1&#125;&#125;],</span><br><span class=\"line\">         running,&lt;0.42.0&gt;,[],</span><br><span class=\"line\">         [&#123;header,&quot;Status for generic server &lt;0.44.0&gt;&quot;&#125;,</span><br><span class=\"line\">          &#123;data,[&#123;&quot;Status&quot;,running&#125;,</span><br><span class=\"line\">                 &#123;&quot;Parent&quot;,&lt;0.42.0&gt;&#125;,</span><br><span class=\"line\">                 &#123;&quot;Logged events&quot;,[]&#125;]&#125;,</span><br><span class=\"line\">          &#123;data,[&#123;&quot;State&quot;,</span><br><span class=\"line\">                  &#123;state,&#123;&lt;0.44.0&gt;,ranch_acceptors_sup&#125;,</span><br><span class=\"line\">                         one_for_one,</span><br><span class=\"line\">                         [&#123;child,&lt;0.45.0&gt;,</span><br><span class=\"line\">                                 &#123;acceptor,&lt;0.44.0&gt;,1&#125;,</span><br><span class=\"line\">                                 &#123;ranch_acceptor,start_link,</span><br><span class=\"line\">                                                 [#Port&lt;0.917&gt;,ranch_tcp,&lt;0.43.0&gt;]&#125;,</span><br><span class=\"line\">                                 permanent,brutal_kill,worker,[]&#125;],</span><br><span class=\"line\">                         undefined,10,10,[],ranch_acceptors_sup,</span><br><span class=\"line\">                         [tcp_echo,1,ranch_tcp,[&#123;port,5555&#125;]]&#125;&#125;]&#125;]]&#125;</span><br></pre></td></tr></table></figure></p>\n<p>demo中只启动了一个acceptor<br>至此完了了所有进程的启动。等待connection进来。<br><img src=\"/img/ranch_2.png\" alt=\"\"></p>\n<h3 id=\"Acceptor:\">Acceptor:</h3><p>acceptor的作用是<code>accept(ListenSocket) -&gt; Socket.</code> 通过<code>Transport:controlling_process</code>,将端口控制交给<code>conns_sup</code>, 然后向conns_sup发送<code>&#123;ranch_conns_sup, start_protocol, AcceptorPid, Socket&#125;</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start_link(LSocket, Transport, ConnsSup) -&gt;</span><br><span class=\"line\">\tPid = spawn_link(?MODULE, loop, [LSocket, Transport, ConnsSup]),</span><br><span class=\"line\">\t&#123;ok, Pid&#125;.</span><br><span class=\"line\"></span><br><span class=\"line\">-spec loop(inet:socket(), module(), pid()) -&gt; no_return().</span><br><span class=\"line\">loop(LSocket, Transport, ConnsSup) -&gt;</span><br><span class=\"line\">\t_ = case Transport:accept(LSocket, infinity) of</span><br><span class=\"line\">\t\t&#123;ok, CSocket&#125; -&gt;</span><br><span class=\"line\">\t\t\tcase Transport:controlling_process(CSocket, ConnsSup) of</span><br><span class=\"line\">\t\t\t\tok -&gt;</span><br><span class=\"line\">\t\t\t\t\tranch_conns_sup:start_protocol(ConnsSup, CSocket);</span><br><span class=\"line\">\t\t\t\t&#123;error, _&#125; -&gt;</span><br><span class=\"line\">\t\t\t\t\tTransport:close(CSocket)</span><br><span class=\"line\">\t\t\tend;</span><br><span class=\"line\">\t\t&#123;error, emfile&#125; -&gt;</span><br><span class=\"line\">\t\t\treceive after 100 -&gt; ok end;</span><br><span class=\"line\">\t\t&#123;error, Reason&#125; when Reason =/= closed -&gt;</span><br><span class=\"line\">\t\t\tok</span><br><span class=\"line\">\tend,</span><br><span class=\"line\">\tflush(),</span><br><span class=\"line\">\t?MODULE:loop(LSocket, Transport, ConnsSup).</span><br></pre></td></tr></table></figure>\n<p><code>ranch_conns_sup</code>:<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start_protocol(SupPid, Socket) -&gt;</span><br><span class=\"line\">\tSupPid ! &#123;?MODULE, start_protocol, self(), Socket&#125;,</span><br><span class=\"line\">\treceive SupPid -&gt; ok end.</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;?MODULE, start_protocol, To, Socket&#125; -&gt;</span><br><span class=\"line\">\ttry Protocol:start_link(Ref, Socket, Transport, Opts) of</span><br><span class=\"line\">\t\t&#123;ok, Pid&#125; -&gt;</span><br><span class=\"line\">\t\t\tshoot(State, CurConns, NbChildren, Sleepers, To, Socket, Pid, Pid);</span><br><span class=\"line\">\t\t&#123;ok, SupPid, ProtocolPid&#125; when ConnType =:= supervisor -&gt;</span><br><span class=\"line\">\t\t\tshoot(State, CurConns, NbChildren, Sleepers, To, Socket, SupPid, ProtocolPid);</span><br><span class=\"line\">\t\tRet -&gt;</span><br><span class=\"line\">\t\t\tTo ! self(),</span><br><span class=\"line\">\t\t\terror_logger:error_msg(</span><br><span class=\"line\">\t\t\t\t&quot;Ranch listener ~p connection process start failure; &quot;</span><br><span class=\"line\">\t\t\t\t&quot;~p:start_link/4 returned: ~999999p~n&quot;,</span><br><span class=\"line\">\t\t\t\t[Ref, Protocol, Ret]),</span><br><span class=\"line\">\t\t\tTransport:close(Socket),</span><br><span class=\"line\">\t\t\tloop(State, CurConns, NbChildren, Sleepers)</span><br><span class=\"line\">\t\t\t......</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shoot(State=#state&#123;ref=Ref, transport=Transport, ack_timeout=AckTimeout, max_conns=MaxConns&#125;,</span><br><span class=\"line\">\t\tCurConns, NbChildren, Sleepers, To, Socket, SupPid, ProtocolPid) -&gt;</span><br><span class=\"line\">\tcase Transport:controlling_process(Socket, ProtocolPid) of</span><br><span class=\"line\">\t\tok -&gt;</span><br><span class=\"line\">\t\t    %% 通知echo_protocol进程控制权已转移。</span><br><span class=\"line\">\t\t\tProtocolPid ! &#123;shoot, Ref, Transport, Socket, AckTimeout&#125;,</span><br><span class=\"line\">\t\t\tput(SupPid, true),</span><br><span class=\"line\">\t\t\tCurConns2 = CurConns + 1,</span><br><span class=\"line\">\t\t\tif CurConns2 &lt; MaxConns -&gt;</span><br><span class=\"line\">\t\t\t\t\tTo ! self(),</span><br><span class=\"line\">\t\t\t\t\tloop(State, CurConns2, NbChildren + 1, Sleepers);</span><br><span class=\"line\">\t\t\t\ttrue -&gt;</span><br><span class=\"line\">\t\t\t\t\tloop(State, CurConns2, NbChildren + 1, [To|Sleepers])</span><br><span class=\"line\">\t\t\tend;</span><br><span class=\"line\">\t\t&#123;error, _&#125; -&gt;</span><br><span class=\"line\">\t\t\tTransport:close(Socket),</span><br><span class=\"line\">\t\t\t%% Only kill the supervised pid, because the connection&#x27;s pid,</span><br><span class=\"line\">\t\t\t%% when different, is supposed to be sitting under it and linked.</span><br><span class=\"line\">\t\t\texit(SupPid, kill),</span><br><span class=\"line\">\t\t\tloop(State, CurConns, NbChildren, Sleepers)</span><br><span class=\"line\">\tend.</span><br></pre></td></tr></table></figure>\n<h3 id=\"ranch_protocol:\">ranch_protocol:</h3><p>conns_sup在完成<code>controlling_process</code>后要通知protocol进程完成了转移。因为此时protocol的init还没有执行结束，一直在等着控制权转移。因为控制权没转移是不能进入loop的.spawn_link及时将自己的pid告诉了conns_sup.如果是gen_server等需要init结束才返回的进程需要特殊处理, 在下面分析.同时完成转移后conns_sup还给acceptor发送一条自己的pid，告诉acceptor转移完成。因为这之前acceptor一直处在receive状态，等待conns_sup完成工作。不完成他不会再次参与accept操作.<br><code>echo_protocol:</code><br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start_link(Ref, Socket, Transport, Opts) -&gt;</span><br><span class=\"line\">\tPid = spawn_link(?MODULE, init, [Ref, Socket, Transport, Opts]),</span><br><span class=\"line\">\t&#123;ok, Pid&#125;.</span><br><span class=\"line\"></span><br><span class=\"line\">init(Ref, Socket, Transport, _Opts = []) -&gt;</span><br><span class=\"line\">  %% 必须调用 accept_ack，确保socket控制权</span><br><span class=\"line\">\tok = ranch:accept_ack(Ref),</span><br><span class=\"line\">\tloop(Socket, Transport).</span><br></pre></td></tr></table></figure></p>\n<p><code>ranch:</code><br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">accept_ack(Ref) -&gt;</span><br><span class=\"line\">\treceive &#123;shoot, Ref, Transport, Socket, AckTimeout&#125; -&gt;</span><br><span class=\"line\">\t\tTransport:accept_ack(Socket, AckTimeout)</span><br><span class=\"line\">\tend.</span><br></pre></td></tr></table></figure></p>\n<p>链接套接字的逻辑进程都要有</p>\n<ol>\n<li>-behavior(ranch_protocol). 定义了一个start_link/4 callback而已。</li>\n<li>在任何对端口的操作之前一定要确保执行过ranch:accept_ack(Ref)(确保端口控制权交给自己).在此之后可以运行ranch_tcp|ranch_ssl:setopts(Opt)完成自定义对端口的设置<br>如果同时他是个gen_server,gen_fsm等有自己的start_link, 会产生一个问题，因为init中放入ranch:accept_ack/1会形成死锁。(见上面，即<code>conns_sup</code> 在等待<code>ranch_protocol</code>进程的pid返回。而<code>ranch_protocol</code>在等待<code>conns_sup</code>将端口控制交给自己)见问题说明<br><a href=\"https://github.com/ninenines/ranch/blob/master/doc/src/guide/protocols.asciidoc\">ranch_protocol_doc</a>.<br>作者再上面给出了两种解决办法:</li>\n<li>在start_link 中用proc_lib:start_link代替gen_server:start_link,然后在init中主动调用proc_lib：init_ack通知父进程初始化完毕，然后调用ranch:accept_ack，再之后手动用gen_server:enter_loop进入循环。在之前这里分析过gen_server的初始化过程。<br><a href=\"/2015/07/31/erlang-question-gen-server-and-init/\">gen_server和init</a></li>\n<li>作者在init中返回timeout为0，然后通过handle_info(timeout...)调用ranch:accept_ack。实际上最好不要这么用，原因还是见上面的文章。具体剖析过为什么不能这么用。还是用 self()!timeout替代这种方法吧。<br><img src=\"/img/ranch_3.png\" alt=\"\"></li>\n</ol>"},{"title":"ssh登陆远程主机","date":"2015-11-04T03:36:41.000Z","_content":"###方法一：\n将.ssh/id_rsa.pub内容加入到远程主机**.ssh/authorized_keys**下\n```\nyouthy@youthy:~$ scp .ssh/id_rsa.pub user@remote_host:~\n输入密码\nssh user@remote_host\n输入密码\n[root@li1166-59 ~] cat id_rsa.pub >> .ssh/authorized_keys\n```\n\n注意文件是**authorized_keys** 不是authorize_keys\n\n###方法二:\n```\nssh-copy-id -i .ssh/id_rsa.pub user@remote_host\n```\n\n将id_rsa.pub自动添加到authorized_keys尾部.\n\n**文件名必须是id_rsa.pub**\n\n###attention\n.ssh文件夹权限必须是700\n\n.ssh/authorized_keys必须是600\n\n无效时清理下主机.ssh/known_hosts　","source":"_posts/ssh登陆远程主机.md","raw":"title: ssh登陆远程主机\ndate: 2015-11-04 11:36:41\ntags: linux\n---\n###方法一：\n将.ssh/id_rsa.pub内容加入到远程主机**.ssh/authorized_keys**下\n```\nyouthy@youthy:~$ scp .ssh/id_rsa.pub user@remote_host:~\n输入密码\nssh user@remote_host\n输入密码\n[root@li1166-59 ~] cat id_rsa.pub >> .ssh/authorized_keys\n```\n\n注意文件是**authorized_keys** 不是authorize_keys\n\n###方法二:\n```\nssh-copy-id -i .ssh/id_rsa.pub user@remote_host\n```\n\n将id_rsa.pub自动添加到authorized_keys尾部.\n\n**文件名必须是id_rsa.pub**\n\n###attention\n.ssh文件夹权限必须是700\n\n.ssh/authorized_keys必须是600\n\n无效时清理下主机.ssh/known_hosts　","slug":"ssh登陆远程主机","published":1,"updated":"2018-06-26T09:49:27.737Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqw7jdwa001e6f1rem5rbdpv","content":"<p>###方法一：<br>将.ssh/id_rsa.pub内容加入到远程主机<strong>.ssh/authorized_keys</strong>下<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">youthy@youthy:~$ scp .ssh/id_rsa.pub user@remote_host:~</span><br><span class=\"line\">输入密码</span><br><span class=\"line\">ssh user@remote_host</span><br><span class=\"line\">输入密码</span><br><span class=\"line\">[root@li1166-59 ~] cat id_rsa.pub &gt;&gt; .ssh/authorized_keys</span><br></pre></td></tr></table></figure></p>\n<p>注意文件是<strong>authorized_keys</strong> 不是authorize_keys</p>\n<p>###方法二:<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-copy-id -i .ssh/id_rsa.pub user@remote_host</span><br></pre></td></tr></table></figure></p>\n<p>将id_rsa.pub自动添加到authorized_keys尾部.</p>\n<p><strong>文件名必须是id_rsa.pub</strong></p>\n<p>###attention<br>.ssh文件夹权限必须是700</p>\n<p>.ssh/authorized_keys必须是600</p>\n<p>无效时清理下主机.ssh/known_hosts</p>\n","site":{"data":{}},"excerpt":"","more":"<p>###方法一：<br>将.ssh/id_rsa.pub内容加入到远程主机<strong>.ssh/authorized_keys</strong>下<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">youthy@youthy:~$ scp .ssh/id_rsa.pub user@remote_host:~</span><br><span class=\"line\">输入密码</span><br><span class=\"line\">ssh user@remote_host</span><br><span class=\"line\">输入密码</span><br><span class=\"line\">[root@li1166-59 ~] cat id_rsa.pub &gt;&gt; .ssh/authorized_keys</span><br></pre></td></tr></table></figure></p>\n<p>注意文件是<strong>authorized_keys</strong> 不是authorize_keys</p>\n<p>###方法二:<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-copy-id -i .ssh/id_rsa.pub user@remote_host</span><br></pre></td></tr></table></figure></p>\n<p>将id_rsa.pub自动添加到authorized_keys尾部.</p>\n<p><strong>文件名必须是id_rsa.pub</strong></p>\n<p>###attention<br>.ssh文件夹权限必须是700</p>\n<p>.ssh/authorized_keys必须是600</p>\n<p>无效时清理下主机.ssh/known_hosts</p>\n"},{"title":"gitnote","date":"2015-09-19T04:22:10.000Z","_content":"# git \n\n##startup\n\n配置文件  \n   1. /etc/.gitconfig 最顶级\n   2. /home/$USERNAME/.gitconfig 用户设定\n   3. project/.gitconfig 当前项目\n下面会把上面的设定覆盖.\n\n`git config --global user.name \"XXX\"`\n修改/home/username config\n`git config (--local) user.name \"YY\" `\n修改当前项目下的gitconfig\n`git config --system user.name \"ZZZ\"`\n系统通用配置文件\n\n`git config --global|system|local --get user.name  -> XXX`\n`git config user.name ` 简写\n\n<!-- more -->\n\n##2nd\n`git init` -> generate .git file\n`git add` -> 可以跟踪新文件，也可以将修改文件放入暂存区\n\ngitignore遵循glob匹配\n  1. `#`之后是注释\n  2. 名字后面是/表示目录\n  3. !表示取反\n  4. *匹配一个或多个字符\n  5. [abc]匹配ａｂｃ中任意一个字符\n  6. ？表示任意一个字符\n  7. [0-9], [a-z] 两个字符之间\n  \n`git diff` 比较暂存和未暂存的区别\n`git diff --cached`　比较暂存和上次提交的区别\n\n`git commit` 提交暂存区\n`git commit -a` 跳过git add 步骤，跳过暂存区, 直接提交\n`git rm` 删除跟踪的某个文件,如果文件已在暂存区需要`-f`,该命令同时删除文件\n`git rm --cached` 不删除文件,只删除暂存去或者跟踪\n`git mv` 重命名\n\n`git log`: `-p` 显示差异 `-2` 最近两次log `--name-status` 显示文件状态 `--relative-data`显示诸如几周前这种相对时间 `--pretty=oneline|short|full|fuller|format`定制显示格式\n`git log --since=2.weeks` 两周以内 `--since=\"2015-08-01\"` 指定日期之后 `--until=\"2015-08-01\"` 指定日期之前\n`git log　--author=XXX --grep= sometest --all-match(与关系)`\n###gitk　\ngit log 图形化界面\n\n`git --amend` 修改上一次提交,如果上一次commit落下了一些文件没有提交可以在commit之后 git add等操作之后amend，之产生一次提交\n\n`git reset HEAD <filename>` 移除暂存区\n`git checkout --<filename>` 撤销为加入暂存区的文件的修改\n\n`git remote -v` 显示远程仓库\n`git tag (-l \"0.4.*|[0-9]\")` 显示特定标签 glob匹配\n\n分支的原理\n[pro git](http://git.oschina.net/progit/3-Git-%E5%88%86%E6%94%AF.html#3.1-%E4%BD%95%E8%B0%93%E5%88%86%E6%94%AF)\n建立分支步骤：\n`git branch (-v)` 列出所有分支\n`git branch branchname` (建立） -> `git checkout branchname` (跳到对应branch).\n以上等同于\n`git checkout -b branchname`\n`git branch -d branchname` 删除分支\n`git branch --merged(--no-merged)`\n\n##搭建git服务器\n以下例子是在我自己的linode的vps上搭的步骤\n由于买的vps自带ssh-server. 不需要安装ssh-server\n如果是自己的需要执行(ubuntu下)\n```\nsudo apt-get install openssh-server\nsudo /etc/init.d/ssh start(sshd start)\nsudo apt-get install git\n```\ncentos用yum安装\n安装ssh_server. 客户端默认安装了ssh_client.\n安装完成后可以通过shell\n```\nssh username@ip\n```\n\n的方式登陆远程服务器\n如果提示connect to host xxx.xxx.xxx.xxxport 22: Connection refused\n说明openssh_server没安装成功或者没有start\n\n```\nyouthy@youthy:~$ ssh  root@XXX.XXX.XXX.XXX\nroot@xxx.xxx.xxx.xxx's password: \nLast login: Sat Sep 19 07:09:43 2015 from xxx.xxx.xxx.xxx\n[root@li1166-59 ~]# adduser test\n[root@li1166-59 ~]# passwd test\n更改用户 test 的密码 。\n新的 密码：\n重新输入新的 密码：\npasswd： 所有的身份验证令牌已经成功更新。\n[root@li1166-59 ~]# su test\n[test@li1166-59 root]$ \n```\n\n输入exit退出ssh\n接下来创建需要传到服务器上的文件(例子用是博客的源文件)\n```\ngit clone --bare https://github.com/youthy/youthy.github.io test.git\nyouthy@youthy:~$ ls test.git/\nbranches  config  description  HEAD  hooks  info  objects  packed-refs  refs\n```\n\n--bare 用来创建裸版本库。`git clone --bare REPOS NAME.git` REPOS 可以为本地文件\n```\nyouthy@youthy:~$ scp -r test.git test@xxx.xxx.xxx.xxx:/home/test\ntest@xxx.xxx.xxx.xxx's password: \nHEAD                                                                                                                                                                       100%   23     0.0KB/s   00:00    \npacked-refs                                                                                                                                                                100%   98     0.1KB/s   00:00    \nprepare-commit-msg.sample                                                                                                                                                  100% 1239     1.2KB/s   00:00    \npre-rebase.sample                                                                                                                                                          100% 4898     4.8KB/s   00:00    \ncommit-msg.sample                                                                                                                                                          100%  896     0.9KB/s   00:00    \npost-update.sample                                                                                                                                                         100%  189     0.2KB/s   00:00    \npre-applypatch.sample                                                                                                                                                      100%  398     0.4KB/s   00:00    \npre-push.sample                                                                                                                                                            100% 1352     1.3KB/s   00:00    \napplypatch-msg.sample                                                                                                                                                      100%  452     0.4KB/s   00:00    \npre-commit.sample                                                                                                                                                          100% 1642     1.6KB/s   00:00    \nupdate.sample                                                                                                                                                              100% 3611     3.5KB/s   00:00    \nexclude                                                                                                                                                                    100%  240     0.2KB/s   00:00    \ndescription                                                                                                                                                                100%   73     0.1KB/s   00:00    \npack-b7cb7743297b04547b0401b940914333ed2d513b.pack                                                                                                                         100% 3025KB 504.2KB/s   00:06    \n```\n\n此时所有安装git的用户可以通过输入密码的方式`git clone test@XXX.XXX.XXX.XXX:/home/test/test.git`\n克隆这个库和修改这个库，\n####免密码\n为了在不用每次提交都输入密码\n需要将自己的.ssh/id_rsa.pub 公钥加入到test/.ssh/authorize_keys 中，如果没有需要自己建立。没有公钥的话，用\n`ssh-kegen (-t rsa|dsa)` 生成(默认时dsa加密方式)\n但是需要注意以下两点\n***authorize_keys***需要权限是600 `chmod 600 test/.ssh/authorized_keys`\n***将自己的私钥***加入到ssh_agent中：在客户端执行`ssh-add   ~/.ssh/id_rsa`\n否则会出现`Agent admitted failure to sign using the key.` 无法免密码登陆\n\n**有时候github上面自己的项目虽然加入了公钥，但是每次push仍需要密码**\n那是因为这个项目clone时用的时https方式。\n```\nyouthy@youthy:~/hexoblog$ git remote -v\norigin\thttps://github.com/youthy/blogfiles.git (fetch)\norigin\thttps://github.com/youthy/blogfiles.git (push)\n```\n\n通过`git remote rm origin`的方式删掉在添加ssh方式\n```\nyouthy@youthy:~/hexoblog$ git remote add origin git@github.com:youthy/blogfiles.git\nyouthy@youthy:~/hexoblog$ git remote -v\norigin\tgit@github.com:youthy/blogfiles.git (fetch)\norigin\tgit@github.com:youthy/blogfiles.git (push)\n```\n\n\n####安全措施：\n以上完成之后参与者都可以通过`ssh test@XXX.XXX.XXX.XXX`登陆我的vps，可以通过以下方式\n\n```\n[root@li1166-59 ~]# which git-shell\n/usr/bin/git-shell\n[root@li1166-59 ~]# vim /etc/passwd\n```\n\npasswd文件内容如下\n```\n...\nNTP:X:38:38::/ETC/NTP:/SBIN/NOLOGIN\ntest:x:500:500::/home/git:/bin/bash\n...\n```\n\n将 test用户的bin/bash改为git-shell或者去掉\n```\ntest:x:500:500::/home/git:/usr/bin/git-shell\n```\n\n这样就无法通过test登陆服务器\n更多参考\n[pro git](http://git.oschina.net/progit/4-%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git.html#)\n","source":"_posts/gitnote.md","raw":"title: gitnote\ndate: 2015-09-19 12:22:10\ntags: git\n---\n# git \n\n##startup\n\n配置文件  \n   1. /etc/.gitconfig 最顶级\n   2. /home/$USERNAME/.gitconfig 用户设定\n   3. project/.gitconfig 当前项目\n下面会把上面的设定覆盖.\n\n`git config --global user.name \"XXX\"`\n修改/home/username config\n`git config (--local) user.name \"YY\" `\n修改当前项目下的gitconfig\n`git config --system user.name \"ZZZ\"`\n系统通用配置文件\n\n`git config --global|system|local --get user.name  -> XXX`\n`git config user.name ` 简写\n\n<!-- more -->\n\n##2nd\n`git init` -> generate .git file\n`git add` -> 可以跟踪新文件，也可以将修改文件放入暂存区\n\ngitignore遵循glob匹配\n  1. `#`之后是注释\n  2. 名字后面是/表示目录\n  3. !表示取反\n  4. *匹配一个或多个字符\n  5. [abc]匹配ａｂｃ中任意一个字符\n  6. ？表示任意一个字符\n  7. [0-9], [a-z] 两个字符之间\n  \n`git diff` 比较暂存和未暂存的区别\n`git diff --cached`　比较暂存和上次提交的区别\n\n`git commit` 提交暂存区\n`git commit -a` 跳过git add 步骤，跳过暂存区, 直接提交\n`git rm` 删除跟踪的某个文件,如果文件已在暂存区需要`-f`,该命令同时删除文件\n`git rm --cached` 不删除文件,只删除暂存去或者跟踪\n`git mv` 重命名\n\n`git log`: `-p` 显示差异 `-2` 最近两次log `--name-status` 显示文件状态 `--relative-data`显示诸如几周前这种相对时间 `--pretty=oneline|short|full|fuller|format`定制显示格式\n`git log --since=2.weeks` 两周以内 `--since=\"2015-08-01\"` 指定日期之后 `--until=\"2015-08-01\"` 指定日期之前\n`git log　--author=XXX --grep= sometest --all-match(与关系)`\n###gitk　\ngit log 图形化界面\n\n`git --amend` 修改上一次提交,如果上一次commit落下了一些文件没有提交可以在commit之后 git add等操作之后amend，之产生一次提交\n\n`git reset HEAD <filename>` 移除暂存区\n`git checkout --<filename>` 撤销为加入暂存区的文件的修改\n\n`git remote -v` 显示远程仓库\n`git tag (-l \"0.4.*|[0-9]\")` 显示特定标签 glob匹配\n\n分支的原理\n[pro git](http://git.oschina.net/progit/3-Git-%E5%88%86%E6%94%AF.html#3.1-%E4%BD%95%E8%B0%93%E5%88%86%E6%94%AF)\n建立分支步骤：\n`git branch (-v)` 列出所有分支\n`git branch branchname` (建立） -> `git checkout branchname` (跳到对应branch).\n以上等同于\n`git checkout -b branchname`\n`git branch -d branchname` 删除分支\n`git branch --merged(--no-merged)`\n\n##搭建git服务器\n以下例子是在我自己的linode的vps上搭的步骤\n由于买的vps自带ssh-server. 不需要安装ssh-server\n如果是自己的需要执行(ubuntu下)\n```\nsudo apt-get install openssh-server\nsudo /etc/init.d/ssh start(sshd start)\nsudo apt-get install git\n```\ncentos用yum安装\n安装ssh_server. 客户端默认安装了ssh_client.\n安装完成后可以通过shell\n```\nssh username@ip\n```\n\n的方式登陆远程服务器\n如果提示connect to host xxx.xxx.xxx.xxxport 22: Connection refused\n说明openssh_server没安装成功或者没有start\n\n```\nyouthy@youthy:~$ ssh  root@XXX.XXX.XXX.XXX\nroot@xxx.xxx.xxx.xxx's password: \nLast login: Sat Sep 19 07:09:43 2015 from xxx.xxx.xxx.xxx\n[root@li1166-59 ~]# adduser test\n[root@li1166-59 ~]# passwd test\n更改用户 test 的密码 。\n新的 密码：\n重新输入新的 密码：\npasswd： 所有的身份验证令牌已经成功更新。\n[root@li1166-59 ~]# su test\n[test@li1166-59 root]$ \n```\n\n输入exit退出ssh\n接下来创建需要传到服务器上的文件(例子用是博客的源文件)\n```\ngit clone --bare https://github.com/youthy/youthy.github.io test.git\nyouthy@youthy:~$ ls test.git/\nbranches  config  description  HEAD  hooks  info  objects  packed-refs  refs\n```\n\n--bare 用来创建裸版本库。`git clone --bare REPOS NAME.git` REPOS 可以为本地文件\n```\nyouthy@youthy:~$ scp -r test.git test@xxx.xxx.xxx.xxx:/home/test\ntest@xxx.xxx.xxx.xxx's password: \nHEAD                                                                                                                                                                       100%   23     0.0KB/s   00:00    \npacked-refs                                                                                                                                                                100%   98     0.1KB/s   00:00    \nprepare-commit-msg.sample                                                                                                                                                  100% 1239     1.2KB/s   00:00    \npre-rebase.sample                                                                                                                                                          100% 4898     4.8KB/s   00:00    \ncommit-msg.sample                                                                                                                                                          100%  896     0.9KB/s   00:00    \npost-update.sample                                                                                                                                                         100%  189     0.2KB/s   00:00    \npre-applypatch.sample                                                                                                                                                      100%  398     0.4KB/s   00:00    \npre-push.sample                                                                                                                                                            100% 1352     1.3KB/s   00:00    \napplypatch-msg.sample                                                                                                                                                      100%  452     0.4KB/s   00:00    \npre-commit.sample                                                                                                                                                          100% 1642     1.6KB/s   00:00    \nupdate.sample                                                                                                                                                              100% 3611     3.5KB/s   00:00    \nexclude                                                                                                                                                                    100%  240     0.2KB/s   00:00    \ndescription                                                                                                                                                                100%   73     0.1KB/s   00:00    \npack-b7cb7743297b04547b0401b940914333ed2d513b.pack                                                                                                                         100% 3025KB 504.2KB/s   00:06    \n```\n\n此时所有安装git的用户可以通过输入密码的方式`git clone test@XXX.XXX.XXX.XXX:/home/test/test.git`\n克隆这个库和修改这个库，\n####免密码\n为了在不用每次提交都输入密码\n需要将自己的.ssh/id_rsa.pub 公钥加入到test/.ssh/authorize_keys 中，如果没有需要自己建立。没有公钥的话，用\n`ssh-kegen (-t rsa|dsa)` 生成(默认时dsa加密方式)\n但是需要注意以下两点\n***authorize_keys***需要权限是600 `chmod 600 test/.ssh/authorized_keys`\n***将自己的私钥***加入到ssh_agent中：在客户端执行`ssh-add   ~/.ssh/id_rsa`\n否则会出现`Agent admitted failure to sign using the key.` 无法免密码登陆\n\n**有时候github上面自己的项目虽然加入了公钥，但是每次push仍需要密码**\n那是因为这个项目clone时用的时https方式。\n```\nyouthy@youthy:~/hexoblog$ git remote -v\norigin\thttps://github.com/youthy/blogfiles.git (fetch)\norigin\thttps://github.com/youthy/blogfiles.git (push)\n```\n\n通过`git remote rm origin`的方式删掉在添加ssh方式\n```\nyouthy@youthy:~/hexoblog$ git remote add origin git@github.com:youthy/blogfiles.git\nyouthy@youthy:~/hexoblog$ git remote -v\norigin\tgit@github.com:youthy/blogfiles.git (fetch)\norigin\tgit@github.com:youthy/blogfiles.git (push)\n```\n\n\n####安全措施：\n以上完成之后参与者都可以通过`ssh test@XXX.XXX.XXX.XXX`登陆我的vps，可以通过以下方式\n\n```\n[root@li1166-59 ~]# which git-shell\n/usr/bin/git-shell\n[root@li1166-59 ~]# vim /etc/passwd\n```\n\npasswd文件内容如下\n```\n...\nNTP:X:38:38::/ETC/NTP:/SBIN/NOLOGIN\ntest:x:500:500::/home/git:/bin/bash\n...\n```\n\n将 test用户的bin/bash改为git-shell或者去掉\n```\ntest:x:500:500::/home/git:/usr/bin/git-shell\n```\n\n这样就无法通过test登陆服务器\n更多参考\n[pro git](http://git.oschina.net/progit/4-%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git.html#)\n","slug":"gitnote","published":1,"updated":"2018-06-26T09:49:27.736Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqw7jdwb001h6f1rabrv5tye","content":"<h1 id=\"git\">git</h1><p>##startup</p>\n<p>配置文件  </p>\n<ol>\n<li>/etc/.gitconfig 最顶级</li>\n<li>/home/$USERNAME/.gitconfig 用户设定</li>\n<li>project/.gitconfig 当前项目<br>下面会把上面的设定覆盖.</li>\n</ol>\n<p><code>git config --global user.name &quot;XXX&quot;</code><br>修改/home/username config<br><code>git config (--local) user.name &quot;YY&quot;</code><br>修改当前项目下的gitconfig<br><code>git config --system user.name &quot;ZZZ&quot;</code><br>系统通用配置文件</p>\n<p><code>git config --global|system|local --get user.name  -&gt; XXX</code><br><code>git config user.name</code> 简写</p>\n<span id=\"more\"></span>\n<p>##2nd<br><code>git init</code> -&gt; generate .git file<br><code>git add</code> -&gt; 可以跟踪新文件，也可以将修改文件放入暂存区</p>\n<p>gitignore遵循glob匹配</p>\n<ol>\n<li><code>#</code>之后是注释</li>\n<li>名字后面是/表示目录</li>\n<li>!表示取反</li>\n<li>*匹配一个或多个字符</li>\n<li>[abc]匹配ａｂｃ中任意一个字符</li>\n<li>？表示任意一个字符</li>\n<li>[0-9], [a-z] 两个字符之间</li>\n</ol>\n<p><code>git diff</code> 比较暂存和未暂存的区别<br><code>git diff --cached</code>　比较暂存和上次提交的区别</p>\n<p><code>git commit</code> 提交暂存区<br><code>git commit -a</code> 跳过git add 步骤，跳过暂存区, 直接提交<br><code>git rm</code> 删除跟踪的某个文件,如果文件已在暂存区需要<code>-f</code>,该命令同时删除文件<br><code>git rm --cached</code> 不删除文件,只删除暂存去或者跟踪<br><code>git mv</code> 重命名</p>\n<p><code>git log</code>: <code>-p</code> 显示差异 <code>-2</code> 最近两次log <code>--name-status</code> 显示文件状态 <code>--relative-data</code>显示诸如几周前这种相对时间 <code>--pretty=oneline|short|full|fuller|format</code>定制显示格式<br><code>git log --since=2.weeks</code> 两周以内 <code>--since=&quot;2015-08-01&quot;</code> 指定日期之后 <code>--until=&quot;2015-08-01&quot;</code> 指定日期之前<br><code>git log　--author=XXX --grep= sometest --all-match(与关系)</code></p>\n<p>###gitk　<br>git log 图形化界面</p>\n<p><code>git --amend</code> 修改上一次提交,如果上一次commit落下了一些文件没有提交可以在commit之后 git add等操作之后amend，之产生一次提交</p>\n<p><code>git reset HEAD &lt;filename&gt;</code> 移除暂存区<br><code>git checkout --&lt;filename&gt;</code> 撤销为加入暂存区的文件的修改</p>\n<p><code>git remote -v</code> 显示远程仓库<br><code>git tag (-l &quot;0.4.*|[0-9]&quot;)</code> 显示特定标签 glob匹配</p>\n<p>分支的原理<br><a href=\"http://git.oschina.net/progit/3-Git-%E5%88%86%E6%94%AF.html#3.1-%E4%BD%95%E8%B0%93%E5%88%86%E6%94%AF\">pro git</a><br>建立分支步骤：<br><code>git branch (-v)</code> 列出所有分支<br><code>git branch branchname</code> (建立） -&gt; <code>git checkout branchname</code> (跳到对应branch).<br>以上等同于<br><code>git checkout -b branchname</code><br><code>git branch -d branchname</code> 删除分支<br><code>git branch --merged(--no-merged)</code></p>\n<p>##搭建git服务器<br>以下例子是在我自己的linode的vps上搭的步骤<br>由于买的vps自带ssh-server. 不需要安装ssh-server<br>如果是自己的需要执行(ubuntu下)<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install openssh-server</span><br><span class=\"line\">sudo /etc/init.d/ssh start(sshd start)</span><br><span class=\"line\">sudo apt-get install git</span><br></pre></td></tr></table></figure><br>centos用yum安装<br>安装ssh_server. 客户端默认安装了ssh_client.<br>安装完成后可以通过shell<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh username@ip</span><br></pre></td></tr></table></figure></p>\n<p>的方式登陆远程服务器<br>如果提示connect to host xxx.xxx.xxx.xxxport 22: Connection refused<br>说明openssh_server没安装成功或者没有start</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">youthy@youthy:~$ ssh  root@XXX.XXX.XXX.XXX</span><br><span class=\"line\">root@xxx.xxx.xxx.xxx&#x27;s password: </span><br><span class=\"line\">Last login: Sat Sep 19 07:09:43 2015 from xxx.xxx.xxx.xxx</span><br><span class=\"line\">[root@li1166-59 ~]# adduser test</span><br><span class=\"line\">[root@li1166-59 ~]# passwd test</span><br><span class=\"line\">更改用户 test 的密码 。</span><br><span class=\"line\">新的 密码：</span><br><span class=\"line\">重新输入新的 密码：</span><br><span class=\"line\">passwd： 所有的身份验证令牌已经成功更新。</span><br><span class=\"line\">[root@li1166-59 ~]# su test</span><br><span class=\"line\">[test@li1166-59 root]$ </span><br></pre></td></tr></table></figure>\n<p>输入exit退出ssh<br>接下来创建需要传到服务器上的文件(例子用是博客的源文件)<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone --bare https://github.com/youthy/youthy.github.io test.git</span><br><span class=\"line\">youthy@youthy:~$ ls test.git/</span><br><span class=\"line\">branches  config  description  HEAD  hooks  info  objects  packed-refs  refs</span><br></pre></td></tr></table></figure></p>\n<p>--bare 用来创建裸版本库。<code>git clone --bare REPOS NAME.git</code> REPOS 可以为本地文件<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">youthy@youthy:~$ scp -r test.git test@xxx.xxx.xxx.xxx:/home/test</span><br><span class=\"line\">test@xxx.xxx.xxx.xxx&#x27;s password: </span><br><span class=\"line\">HEAD                                                                                                                                                                       100%   23     0.0KB/s   00:00    </span><br><span class=\"line\">packed-refs                                                                                                                                                                100%   98     0.1KB/s   00:00    </span><br><span class=\"line\">prepare-commit-msg.sample                                                                                                                                                  100% 1239     1.2KB/s   00:00    </span><br><span class=\"line\">pre-rebase.sample                                                                                                                                                          100% 4898     4.8KB/s   00:00    </span><br><span class=\"line\">commit-msg.sample                                                                                                                                                          100%  896     0.9KB/s   00:00    </span><br><span class=\"line\">post-update.sample                                                                                                                                                         100%  189     0.2KB/s   00:00    </span><br><span class=\"line\">pre-applypatch.sample                                                                                                                                                      100%  398     0.4KB/s   00:00    </span><br><span class=\"line\">pre-push.sample                                                                                                                                                            100% 1352     1.3KB/s   00:00    </span><br><span class=\"line\">applypatch-msg.sample                                                                                                                                                      100%  452     0.4KB/s   00:00    </span><br><span class=\"line\">pre-commit.sample                                                                                                                                                          100% 1642     1.6KB/s   00:00    </span><br><span class=\"line\">update.sample                                                                                                                                                              100% 3611     3.5KB/s   00:00    </span><br><span class=\"line\">exclude                                                                                                                                                                    100%  240     0.2KB/s   00:00    </span><br><span class=\"line\">description                                                                                                                                                                100%   73     0.1KB/s   00:00    </span><br><span class=\"line\">pack-b7cb7743297b04547b0401b940914333ed2d513b.pack                                                                                                                         100% 3025KB 504.2KB/s   00:06    </span><br></pre></td></tr></table></figure></p>\n<p>此时所有安装git的用户可以通过输入密码的方式<code>git clone test@XXX.XXX.XXX.XXX:/home/test/test.git</code><br>克隆这个库和修改这个库，</p>\n<p>####免密码<br>为了在不用每次提交都输入密码<br>需要将自己的.ssh/id_rsa.pub 公钥加入到test/.ssh/authorize_keys 中，如果没有需要自己建立。没有公钥的话，用<br><code>ssh-kegen (-t rsa|dsa)</code> 生成(默认时dsa加密方式)<br>但是需要注意以下两点<br><strong><em>authorize_keys</em></strong>需要权限是600 <code>chmod 600 test/.ssh/authorized_keys</code><br><strong><em>将自己的私钥</em></strong>加入到ssh_agent中：在客户端执行<code>ssh-add   ~/.ssh/id_rsa</code><br>否则会出现<code>Agent admitted failure to sign using the key.</code> 无法免密码登陆</p>\n<p><strong>有时候github上面自己的项目虽然加入了公钥，但是每次push仍需要密码</strong><br>那是因为这个项目clone时用的时https方式。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">youthy@youthy:~/hexoblog$ git remote -v</span><br><span class=\"line\">origin\thttps://github.com/youthy/blogfiles.git (fetch)</span><br><span class=\"line\">origin\thttps://github.com/youthy/blogfiles.git (push)</span><br></pre></td></tr></table></figure></p>\n<p>通过<code>git remote rm origin</code>的方式删掉在添加ssh方式<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">youthy@youthy:~/hexoblog$ git remote add origin git@github.com:youthy/blogfiles.git</span><br><span class=\"line\">youthy@youthy:~/hexoblog$ git remote -v</span><br><span class=\"line\">origin\tgit@github.com:youthy/blogfiles.git (fetch)</span><br><span class=\"line\">origin\tgit@github.com:youthy/blogfiles.git (push)</span><br></pre></td></tr></table></figure></p>\n<p>####安全措施：<br>以上完成之后参与者都可以通过<code>ssh test@XXX.XXX.XXX.XXX</code>登陆我的vps，可以通过以下方式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@li1166-59 ~]# which git-shell</span><br><span class=\"line\">/usr/bin/git-shell</span><br><span class=\"line\">[root@li1166-59 ~]# vim /etc/passwd</span><br></pre></td></tr></table></figure>\n<p>passwd文件内容如下<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">NTP:X:38:38::/ETC/NTP:/SBIN/NOLOGIN</span><br><span class=\"line\">test:x:500:500::/home/git:/bin/bash</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<p>将 test用户的bin/bash改为git-shell或者去掉<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test:x:500:500::/home/git:/usr/bin/git-shell</span><br></pre></td></tr></table></figure></p>\n<p>这样就无法通过test登陆服务器<br>更多参考<br><a href=\"http://git.oschina.net/progit/4-%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git.html#\">pro git</a></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"git\">git</h1><p>##startup</p>\n<p>配置文件  </p>\n<ol>\n<li>/etc/.gitconfig 最顶级</li>\n<li>/home/$USERNAME/.gitconfig 用户设定</li>\n<li>project/.gitconfig 当前项目<br>下面会把上面的设定覆盖.</li>\n</ol>\n<p><code>git config --global user.name &quot;XXX&quot;</code><br>修改/home/username config<br><code>git config (--local) user.name &quot;YY&quot;</code><br>修改当前项目下的gitconfig<br><code>git config --system user.name &quot;ZZZ&quot;</code><br>系统通用配置文件</p>\n<p><code>git config --global|system|local --get user.name  -&gt; XXX</code><br><code>git config user.name</code> 简写</p>","more":"<p>##2nd<br><code>git init</code> -&gt; generate .git file<br><code>git add</code> -&gt; 可以跟踪新文件，也可以将修改文件放入暂存区</p>\n<p>gitignore遵循glob匹配</p>\n<ol>\n<li><code>#</code>之后是注释</li>\n<li>名字后面是/表示目录</li>\n<li>!表示取反</li>\n<li>*匹配一个或多个字符</li>\n<li>[abc]匹配ａｂｃ中任意一个字符</li>\n<li>？表示任意一个字符</li>\n<li>[0-9], [a-z] 两个字符之间</li>\n</ol>\n<p><code>git diff</code> 比较暂存和未暂存的区别<br><code>git diff --cached</code>　比较暂存和上次提交的区别</p>\n<p><code>git commit</code> 提交暂存区<br><code>git commit -a</code> 跳过git add 步骤，跳过暂存区, 直接提交<br><code>git rm</code> 删除跟踪的某个文件,如果文件已在暂存区需要<code>-f</code>,该命令同时删除文件<br><code>git rm --cached</code> 不删除文件,只删除暂存去或者跟踪<br><code>git mv</code> 重命名</p>\n<p><code>git log</code>: <code>-p</code> 显示差异 <code>-2</code> 最近两次log <code>--name-status</code> 显示文件状态 <code>--relative-data</code>显示诸如几周前这种相对时间 <code>--pretty=oneline|short|full|fuller|format</code>定制显示格式<br><code>git log --since=2.weeks</code> 两周以内 <code>--since=&quot;2015-08-01&quot;</code> 指定日期之后 <code>--until=&quot;2015-08-01&quot;</code> 指定日期之前<br><code>git log　--author=XXX --grep= sometest --all-match(与关系)</code></p>\n<p>###gitk　<br>git log 图形化界面</p>\n<p><code>git --amend</code> 修改上一次提交,如果上一次commit落下了一些文件没有提交可以在commit之后 git add等操作之后amend，之产生一次提交</p>\n<p><code>git reset HEAD &lt;filename&gt;</code> 移除暂存区<br><code>git checkout --&lt;filename&gt;</code> 撤销为加入暂存区的文件的修改</p>\n<p><code>git remote -v</code> 显示远程仓库<br><code>git tag (-l &quot;0.4.*|[0-9]&quot;)</code> 显示特定标签 glob匹配</p>\n<p>分支的原理<br><a href=\"http://git.oschina.net/progit/3-Git-%E5%88%86%E6%94%AF.html#3.1-%E4%BD%95%E8%B0%93%E5%88%86%E6%94%AF\">pro git</a><br>建立分支步骤：<br><code>git branch (-v)</code> 列出所有分支<br><code>git branch branchname</code> (建立） -&gt; <code>git checkout branchname</code> (跳到对应branch).<br>以上等同于<br><code>git checkout -b branchname</code><br><code>git branch -d branchname</code> 删除分支<br><code>git branch --merged(--no-merged)</code></p>\n<p>##搭建git服务器<br>以下例子是在我自己的linode的vps上搭的步骤<br>由于买的vps自带ssh-server. 不需要安装ssh-server<br>如果是自己的需要执行(ubuntu下)<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install openssh-server</span><br><span class=\"line\">sudo /etc/init.d/ssh start(sshd start)</span><br><span class=\"line\">sudo apt-get install git</span><br></pre></td></tr></table></figure><br>centos用yum安装<br>安装ssh_server. 客户端默认安装了ssh_client.<br>安装完成后可以通过shell<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh username@ip</span><br></pre></td></tr></table></figure></p>\n<p>的方式登陆远程服务器<br>如果提示connect to host xxx.xxx.xxx.xxxport 22: Connection refused<br>说明openssh_server没安装成功或者没有start</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">youthy@youthy:~$ ssh  root@XXX.XXX.XXX.XXX</span><br><span class=\"line\">root@xxx.xxx.xxx.xxx&#x27;s password: </span><br><span class=\"line\">Last login: Sat Sep 19 07:09:43 2015 from xxx.xxx.xxx.xxx</span><br><span class=\"line\">[root@li1166-59 ~]# adduser test</span><br><span class=\"line\">[root@li1166-59 ~]# passwd test</span><br><span class=\"line\">更改用户 test 的密码 。</span><br><span class=\"line\">新的 密码：</span><br><span class=\"line\">重新输入新的 密码：</span><br><span class=\"line\">passwd： 所有的身份验证令牌已经成功更新。</span><br><span class=\"line\">[root@li1166-59 ~]# su test</span><br><span class=\"line\">[test@li1166-59 root]$ </span><br></pre></td></tr></table></figure>\n<p>输入exit退出ssh<br>接下来创建需要传到服务器上的文件(例子用是博客的源文件)<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone --bare https://github.com/youthy/youthy.github.io test.git</span><br><span class=\"line\">youthy@youthy:~$ ls test.git/</span><br><span class=\"line\">branches  config  description  HEAD  hooks  info  objects  packed-refs  refs</span><br></pre></td></tr></table></figure></p>\n<p>--bare 用来创建裸版本库。<code>git clone --bare REPOS NAME.git</code> REPOS 可以为本地文件<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">youthy@youthy:~$ scp -r test.git test@xxx.xxx.xxx.xxx:/home/test</span><br><span class=\"line\">test@xxx.xxx.xxx.xxx&#x27;s password: </span><br><span class=\"line\">HEAD                                                                                                                                                                       100%   23     0.0KB/s   00:00    </span><br><span class=\"line\">packed-refs                                                                                                                                                                100%   98     0.1KB/s   00:00    </span><br><span class=\"line\">prepare-commit-msg.sample                                                                                                                                                  100% 1239     1.2KB/s   00:00    </span><br><span class=\"line\">pre-rebase.sample                                                                                                                                                          100% 4898     4.8KB/s   00:00    </span><br><span class=\"line\">commit-msg.sample                                                                                                                                                          100%  896     0.9KB/s   00:00    </span><br><span class=\"line\">post-update.sample                                                                                                                                                         100%  189     0.2KB/s   00:00    </span><br><span class=\"line\">pre-applypatch.sample                                                                                                                                                      100%  398     0.4KB/s   00:00    </span><br><span class=\"line\">pre-push.sample                                                                                                                                                            100% 1352     1.3KB/s   00:00    </span><br><span class=\"line\">applypatch-msg.sample                                                                                                                                                      100%  452     0.4KB/s   00:00    </span><br><span class=\"line\">pre-commit.sample                                                                                                                                                          100% 1642     1.6KB/s   00:00    </span><br><span class=\"line\">update.sample                                                                                                                                                              100% 3611     3.5KB/s   00:00    </span><br><span class=\"line\">exclude                                                                                                                                                                    100%  240     0.2KB/s   00:00    </span><br><span class=\"line\">description                                                                                                                                                                100%   73     0.1KB/s   00:00    </span><br><span class=\"line\">pack-b7cb7743297b04547b0401b940914333ed2d513b.pack                                                                                                                         100% 3025KB 504.2KB/s   00:06    </span><br></pre></td></tr></table></figure></p>\n<p>此时所有安装git的用户可以通过输入密码的方式<code>git clone test@XXX.XXX.XXX.XXX:/home/test/test.git</code><br>克隆这个库和修改这个库，</p>\n<p>####免密码<br>为了在不用每次提交都输入密码<br>需要将自己的.ssh/id_rsa.pub 公钥加入到test/.ssh/authorize_keys 中，如果没有需要自己建立。没有公钥的话，用<br><code>ssh-kegen (-t rsa|dsa)</code> 生成(默认时dsa加密方式)<br>但是需要注意以下两点<br><strong><em>authorize_keys</em></strong>需要权限是600 <code>chmod 600 test/.ssh/authorized_keys</code><br><strong><em>将自己的私钥</em></strong>加入到ssh_agent中：在客户端执行<code>ssh-add   ~/.ssh/id_rsa</code><br>否则会出现<code>Agent admitted failure to sign using the key.</code> 无法免密码登陆</p>\n<p><strong>有时候github上面自己的项目虽然加入了公钥，但是每次push仍需要密码</strong><br>那是因为这个项目clone时用的时https方式。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">youthy@youthy:~/hexoblog$ git remote -v</span><br><span class=\"line\">origin\thttps://github.com/youthy/blogfiles.git (fetch)</span><br><span class=\"line\">origin\thttps://github.com/youthy/blogfiles.git (push)</span><br></pre></td></tr></table></figure></p>\n<p>通过<code>git remote rm origin</code>的方式删掉在添加ssh方式<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">youthy@youthy:~/hexoblog$ git remote add origin git@github.com:youthy/blogfiles.git</span><br><span class=\"line\">youthy@youthy:~/hexoblog$ git remote -v</span><br><span class=\"line\">origin\tgit@github.com:youthy/blogfiles.git (fetch)</span><br><span class=\"line\">origin\tgit@github.com:youthy/blogfiles.git (push)</span><br></pre></td></tr></table></figure></p>\n<p>####安全措施：<br>以上完成之后参与者都可以通过<code>ssh test@XXX.XXX.XXX.XXX</code>登陆我的vps，可以通过以下方式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@li1166-59 ~]# which git-shell</span><br><span class=\"line\">/usr/bin/git-shell</span><br><span class=\"line\">[root@li1166-59 ~]# vim /etc/passwd</span><br></pre></td></tr></table></figure>\n<p>passwd文件内容如下<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">NTP:X:38:38::/ETC/NTP:/SBIN/NOLOGIN</span><br><span class=\"line\">test:x:500:500::/home/git:/bin/bash</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<p>将 test用户的bin/bash改为git-shell或者去掉<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test:x:500:500::/home/git:/usr/bin/git-shell</span><br></pre></td></tr></table></figure></p>\n<p>这样就无法通过test登陆服务器<br>更多参考<br><a href=\"http://git.oschina.net/progit/4-%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git.html#\">pro git</a></p>"},{"title":"ubuntu下lamp(apache2+php5+mysql)搭建","date":"2015-07-31T05:20:15.000Z","_content":"\nubuntu下lamp(apache2+php5+mysql)搭建\n<!--more-->\n\n<!-- toc -->\n\n## 安装apache2  \n```\nsudo apt-get install apache2\n```\n\n此时浏览器进入localhost会显示It works界面。\n\n## 安装php\n```\nsudo apt-get install php5  \nsudo apt-get install libapache2-mod-php5  \nsudo /etc/init.d/apache2 restart \n```\n\n```\nsudo vim /var/www/html/info.php\n```\n\n输入下面的内容：\n```\n<?php\nphpinfo();\n?>\n```\n\n然后打开浏览器访问 (http://127.0.0.1/info.php):\n你可以看到一些已经支持的模块。\n\n> 如果在www下没有html文件夹，info就建在www下。\n\n## 安装mysql\n```\nsudo apt-get install mysql-server  \n```\n\n输入root用户密码。\n\n## 让apache、php支持mysql  \n```\nsudo apt-get install libapache2-mod-auth-mysql  \nsudo apt-get install php5-mysql  \nsudo apt-get install php5-mcrypt\nsudo php5enmod mcrypt\nsudo /etc/init.d/apache2 restart\n```\n\n可选（apt-get install php5-mysqlnd\nsudo apt-get install php5 libapache2-mod-php5 php5-cgi php5-cli php5-common php5-curl php5-gd php5-mysql php5-pgsql）\n\n## 安装phpmyadmin\n```\napt-get install phpmyadmin\n```\n\n选择apache2.\n安装完成后，建立软链。\n```\nsudo ln -s /usr/share/phpmyadmin /var/www/html \n```\n\n此时可以进入localhost/phpmyadmin\n\n## 配置\n### php\n```\nsudo vim /etc/php5/apache2/php.ini\n```\n\n找到default_charset改为utf-8\n`default_charset = “UTF-8″`\n\n\n### apache\n```\nsudo gedit /etc/apache2/apache2.conf\n```\n\n结尾添加\n`AddDefaultCharset UTF-8`\n`ServerName 127.0.0.1`\n\n完成。\n\n## 参考\nhttp://www.2cto.com/os/201211/165190.html\nhttp://www.jb51.net/article/39127.htm\nhttp://forum.ubuntu.org.cn/viewtopic.php?t=251355\n","source":"_posts/ubuntu-LAMP搭建.md","raw":"title: ubuntu下lamp(apache2+php5+mysql)搭建\ndate: 2015-07-31 13:20:15\ntags: ubuntu\n\n---\n\nubuntu下lamp(apache2+php5+mysql)搭建\n<!--more-->\n\n<!-- toc -->\n\n## 安装apache2  \n```\nsudo apt-get install apache2\n```\n\n此时浏览器进入localhost会显示It works界面。\n\n## 安装php\n```\nsudo apt-get install php5  \nsudo apt-get install libapache2-mod-php5  \nsudo /etc/init.d/apache2 restart \n```\n\n```\nsudo vim /var/www/html/info.php\n```\n\n输入下面的内容：\n```\n<?php\nphpinfo();\n?>\n```\n\n然后打开浏览器访问 (http://127.0.0.1/info.php):\n你可以看到一些已经支持的模块。\n\n> 如果在www下没有html文件夹，info就建在www下。\n\n## 安装mysql\n```\nsudo apt-get install mysql-server  \n```\n\n输入root用户密码。\n\n## 让apache、php支持mysql  \n```\nsudo apt-get install libapache2-mod-auth-mysql  \nsudo apt-get install php5-mysql  \nsudo apt-get install php5-mcrypt\nsudo php5enmod mcrypt\nsudo /etc/init.d/apache2 restart\n```\n\n可选（apt-get install php5-mysqlnd\nsudo apt-get install php5 libapache2-mod-php5 php5-cgi php5-cli php5-common php5-curl php5-gd php5-mysql php5-pgsql）\n\n## 安装phpmyadmin\n```\napt-get install phpmyadmin\n```\n\n选择apache2.\n安装完成后，建立软链。\n```\nsudo ln -s /usr/share/phpmyadmin /var/www/html \n```\n\n此时可以进入localhost/phpmyadmin\n\n## 配置\n### php\n```\nsudo vim /etc/php5/apache2/php.ini\n```\n\n找到default_charset改为utf-8\n`default_charset = “UTF-8″`\n\n\n### apache\n```\nsudo gedit /etc/apache2/apache2.conf\n```\n\n结尾添加\n`AddDefaultCharset UTF-8`\n`ServerName 127.0.0.1`\n\n完成。\n\n## 参考\nhttp://www.2cto.com/os/201211/165190.html\nhttp://www.jb51.net/article/39127.htm\nhttp://forum.ubuntu.org.cn/viewtopic.php?t=251355\n","slug":"ubuntu-LAMP搭建","published":1,"updated":"2018-06-26T09:49:27.737Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqw7jdwd001l6f1rez4p779o","content":"<p>ubuntu下lamp(apache2+php5+mysql)搭建<br><span id=\"more\"></span></p>\n<!-- toc -->\n<ul>\n<li><a href=\"#--apache2\">安装apache2</a></li>\n<li><a href=\"#--php\">安装php</a></li>\n<li><a href=\"#--mysql\">安装mysql</a></li>\n<li><a href=\"#-apache-php--mysql\">让apache、php支持mysql</a></li>\n<li><a href=\"#--phpmyadmin\">安装phpmyadmin</a></li>\n<li><a href=\"#--\">配置</a><ul>\n<li><a href=\"#php\">php</a></li>\n<li><a href=\"#apache\">apache</a></li>\n</ul>\n</li>\n<li><a href=\"#--\">参考</a></li>\n</ul>\n<!-- tocstop -->\n<h2 id=\"安装apache2\">安装apache2</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install apache2</span><br></pre></td></tr></table></figure>\n<p>此时浏览器进入localhost会显示It works界面。</p>\n<h2 id=\"安装php\">安装php</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install php5  </span><br><span class=\"line\">sudo apt-get install libapache2-mod-php5  </span><br><span class=\"line\">sudo /etc/init.d/apache2 restart </span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo vim /var/www/html/info.php</span><br></pre></td></tr></table></figure>\n<p>输入下面的内容：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?php</span><br><span class=\"line\">phpinfo();</span><br><span class=\"line\">?&gt;</span><br></pre></td></tr></table></figure></p>\n<p>然后打开浏览器访问 (<a href=\"http://127.0.0.1/info.php)\">http://127.0.0.1/info.php)</a>:<br>你可以看到一些已经支持的模块。</p>\n<blockquote>\n<p>如果在www下没有html文件夹，info就建在www下。</p>\n</blockquote>\n<h2 id=\"安装mysql\">安装mysql</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install mysql-server  </span><br></pre></td></tr></table></figure>\n<p>输入root用户密码。</p>\n<h2 id=\"让apache、php支持mysql\">让apache、php支持mysql</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install libapache2-mod-auth-mysql  </span><br><span class=\"line\">sudo apt-get install php5-mysql  </span><br><span class=\"line\">sudo apt-get install php5-mcrypt</span><br><span class=\"line\">sudo php5enmod mcrypt</span><br><span class=\"line\">sudo /etc/init.d/apache2 restart</span><br></pre></td></tr></table></figure>\n<p>可选（apt-get install php5-mysqlnd<br>sudo apt-get install php5 libapache2-mod-php5 php5-cgi php5-cli php5-common php5-curl php5-gd php5-mysql php5-pgsql）</p>\n<h2 id=\"安装phpmyadmin\">安装phpmyadmin</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apt-get install phpmyadmin</span><br></pre></td></tr></table></figure>\n<p>选择apache2.<br>安装完成后，建立软链。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo ln -s /usr/share/phpmyadmin /var/www/html </span><br></pre></td></tr></table></figure></p>\n<p>此时可以进入localhost/phpmyadmin</p>\n<h2 id=\"配置\">配置</h2><h3 id=\"php\">php</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo vim /etc/php5/apache2/php.ini</span><br></pre></td></tr></table></figure>\n<p>找到default_charset改为utf-8<br><code>default_charset = “UTF-8″</code></p>\n<h3 id=\"apache\">apache</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo gedit /etc/apache2/apache2.conf</span><br></pre></td></tr></table></figure>\n<p>结尾添加<br><code>AddDefaultCharset UTF-8</code><br><code>ServerName 127.0.0.1</code></p>\n<p>完成。</p>\n<h2 id=\"参考\">参考</h2><p><a href=\"http://www.2cto.com/os/201211/165190.html\">http://www.2cto.com/os/201211/165190.html</a><br><a href=\"http://www.jb51.net/article/39127.htm\">http://www.jb51.net/article/39127.htm</a><br><a href=\"http://forum.ubuntu.org.cn/viewtopic.php?t=251355\">http://forum.ubuntu.org.cn/viewtopic.php?t=251355</a></p>\n","site":{"data":{}},"excerpt":"<p>ubuntu下lamp(apache2+php5+mysql)搭建<br>","more":"</p>\n<!-- toc -->\n<ul>\n<li><a href=\"#--apache2\">安装apache2</a></li>\n<li><a href=\"#--php\">安装php</a></li>\n<li><a href=\"#--mysql\">安装mysql</a></li>\n<li><a href=\"#-apache-php--mysql\">让apache、php支持mysql</a></li>\n<li><a href=\"#--phpmyadmin\">安装phpmyadmin</a></li>\n<li><a href=\"#--\">配置</a><ul>\n<li><a href=\"#php\">php</a></li>\n<li><a href=\"#apache\">apache</a></li>\n</ul>\n</li>\n<li><a href=\"#--\">参考</a></li>\n</ul>\n<!-- tocstop -->\n<h2 id=\"安装apache2\">安装apache2</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install apache2</span><br></pre></td></tr></table></figure>\n<p>此时浏览器进入localhost会显示It works界面。</p>\n<h2 id=\"安装php\">安装php</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install php5  </span><br><span class=\"line\">sudo apt-get install libapache2-mod-php5  </span><br><span class=\"line\">sudo /etc/init.d/apache2 restart </span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo vim /var/www/html/info.php</span><br></pre></td></tr></table></figure>\n<p>输入下面的内容：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?php</span><br><span class=\"line\">phpinfo();</span><br><span class=\"line\">?&gt;</span><br></pre></td></tr></table></figure></p>\n<p>然后打开浏览器访问 (<a href=\"http://127.0.0.1/info.php)\">http://127.0.0.1/info.php)</a>:<br>你可以看到一些已经支持的模块。</p>\n<blockquote>\n<p>如果在www下没有html文件夹，info就建在www下。</p>\n</blockquote>\n<h2 id=\"安装mysql\">安装mysql</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install mysql-server  </span><br></pre></td></tr></table></figure>\n<p>输入root用户密码。</p>\n<h2 id=\"让apache、php支持mysql\">让apache、php支持mysql</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install libapache2-mod-auth-mysql  </span><br><span class=\"line\">sudo apt-get install php5-mysql  </span><br><span class=\"line\">sudo apt-get install php5-mcrypt</span><br><span class=\"line\">sudo php5enmod mcrypt</span><br><span class=\"line\">sudo /etc/init.d/apache2 restart</span><br></pre></td></tr></table></figure>\n<p>可选（apt-get install php5-mysqlnd<br>sudo apt-get install php5 libapache2-mod-php5 php5-cgi php5-cli php5-common php5-curl php5-gd php5-mysql php5-pgsql）</p>\n<h2 id=\"安装phpmyadmin\">安装phpmyadmin</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apt-get install phpmyadmin</span><br></pre></td></tr></table></figure>\n<p>选择apache2.<br>安装完成后，建立软链。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo ln -s /usr/share/phpmyadmin /var/www/html </span><br></pre></td></tr></table></figure></p>\n<p>此时可以进入localhost/phpmyadmin</p>\n<h2 id=\"配置\">配置</h2><h3 id=\"php\">php</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo vim /etc/php5/apache2/php.ini</span><br></pre></td></tr></table></figure>\n<p>找到default_charset改为utf-8<br><code>default_charset = “UTF-8″</code></p>\n<h3 id=\"apache\">apache</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo gedit /etc/apache2/apache2.conf</span><br></pre></td></tr></table></figure>\n<p>结尾添加<br><code>AddDefaultCharset UTF-8</code><br><code>ServerName 127.0.0.1</code></p>\n<p>完成。</p>\n<h2 id=\"参考\">参考</h2><p><a href=\"http://www.2cto.com/os/201211/165190.html\">http://www.2cto.com/os/201211/165190.html</a><br><a href=\"http://www.jb51.net/article/39127.htm\">http://www.jb51.net/article/39127.htm</a><br><a href=\"http://forum.ubuntu.org.cn/viewtopic.php?t=251355\">http://forum.ubuntu.org.cn/viewtopic.php?t=251355</a></p>"},{"title":"vim复制到系统剪切板","date":"2014-07-11T06:22:29.000Z","_content":"\n在vim中一般都是按v进入可视化,然后hjkl移动光标选择范围,然后按y复制所选内容,然而这样复制的内容并不在系统剪切板中,而在vim自己的剪切板,要复制到系统gedit或者浏览器里我一般是用鼠标选中范围,然后右键复制,但是蛋疼的是代码行号总是被复制,像这样\n![](../../../../img/选区_035.png)\n\n<!--more-->\n\n所以我尝试找找有没有更方便的方法,网上说复制的时候不要用y而是用\"+y的形式将内容复制到全局寄存器,这样就可以粘贴到别的地方了.\n但是我试了好几次都不行,之后在vim中用\n>  :reg\n\n\n命令查看下自己的寄存器,\n![](../../../../img/选区_034.png)\n我的一开始是没有 \"+这个寄存器的.\n也可以在shell中用\n> vim --version | grep xterm_clipboard\n\n查看下xterm_clipboard前面是+还是_\n![](../../../../img/选区_033.png)\n如果是\"-\"说明不支持这个功能.\n我还以为需要从装一遍vim,怕自己那么多插件又得从装,其实只需要执行\n> sudo apt-get install vim-gui-common\n\n就可以支持+储存器了,这时我们选中范围后按\"+y就复制到+寄存器中,在外面就可以ctrl+v复制了.\n*******\n当然这个命令还是麻烦\n我们可以修改.vimrc,在其中添加一条map映射\n> vmap &lt;C-c> \"+y\n\nvmap是在VISUAL模式下的映射,是在按了v进入可视化之后才启用,<C-c>是ctrl+c,这样相当于\"+y这个命令.\n\n将系统剪切板的东西复制进vim比较简单,可以进入插入模式,直接右键粘贴,也可以shift+insert.这个不需要+寄存器的支持也可以用.\n","source":"_posts/vim复制到系统剪切板.md","raw":"title: vim复制到系统剪切板\ndate: 2014-07-11 14:22:29\ntags: [vim, 教程]\ncategories: 教程\n---\n\n在vim中一般都是按v进入可视化,然后hjkl移动光标选择范围,然后按y复制所选内容,然而这样复制的内容并不在系统剪切板中,而在vim自己的剪切板,要复制到系统gedit或者浏览器里我一般是用鼠标选中范围,然后右键复制,但是蛋疼的是代码行号总是被复制,像这样\n![](../../../../img/选区_035.png)\n\n<!--more-->\n\n所以我尝试找找有没有更方便的方法,网上说复制的时候不要用y而是用\"+y的形式将内容复制到全局寄存器,这样就可以粘贴到别的地方了.\n但是我试了好几次都不行,之后在vim中用\n>  :reg\n\n\n命令查看下自己的寄存器,\n![](../../../../img/选区_034.png)\n我的一开始是没有 \"+这个寄存器的.\n也可以在shell中用\n> vim --version | grep xterm_clipboard\n\n查看下xterm_clipboard前面是+还是_\n![](../../../../img/选区_033.png)\n如果是\"-\"说明不支持这个功能.\n我还以为需要从装一遍vim,怕自己那么多插件又得从装,其实只需要执行\n> sudo apt-get install vim-gui-common\n\n就可以支持+储存器了,这时我们选中范围后按\"+y就复制到+寄存器中,在外面就可以ctrl+v复制了.\n*******\n当然这个命令还是麻烦\n我们可以修改.vimrc,在其中添加一条map映射\n> vmap &lt;C-c> \"+y\n\nvmap是在VISUAL模式下的映射,是在按了v进入可视化之后才启用,<C-c>是ctrl+c,这样相当于\"+y这个命令.\n\n将系统剪切板的东西复制进vim比较简单,可以进入插入模式,直接右键粘贴,也可以shift+insert.这个不需要+寄存器的支持也可以用.\n","slug":"vim复制到系统剪切板","published":1,"updated":"2018-06-26T09:49:27.737Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqw7jdwd001o6f1r26iy7v0g","content":"<p>在vim中一般都是按v进入可视化,然后hjkl移动光标选择范围,然后按y复制所选内容,然而这样复制的内容并不在系统剪切板中,而在vim自己的剪切板,要复制到系统gedit或者浏览器里我一般是用鼠标选中范围,然后右键复制,但是蛋疼的是代码行号总是被复制,像这样<br><img src=\"../../../../img/选区_035.png\" alt=\"\"></p>\n<span id=\"more\"></span>\n<p>所以我尝试找找有没有更方便的方法,网上说复制的时候不要用y而是用&quot;+y的形式将内容复制到全局寄存器,这样就可以粘贴到别的地方了.<br>但是我试了好几次都不行,之后在vim中用</p>\n<blockquote>\n<p> :reg</p>\n</blockquote>\n<p>命令查看下自己的寄存器,<br><img src=\"../../../../img/选区_034.png\" alt=\"\"><br>我的一开始是没有 &quot;+这个寄存器的.<br>也可以在shell中用</p>\n<blockquote>\n<p>vim --version | grep xterm_clipboard</p>\n</blockquote>\n<p>查看下xterm_clipboard前面是+还是_<br><img src=\"../../../../img/选区_033.png\" alt=\"\"><br>如果是&quot;-&quot;说明不支持这个功能.<br>我还以为需要从装一遍vim,怕自己那么多插件又得从装,其实只需要执行</p>\n<blockquote>\n<p>sudo apt-get install vim-gui-common</p>\n</blockquote>\n<p>就可以支持+储存器了,这时我们选中范围后按&quot;+y就复制到+寄存器中,在外面就可以ctrl+v复制了.</p>\n<hr>\n<p>当然这个命令还是麻烦<br>我们可以修改.vimrc,在其中添加一条map映射</p>\n<blockquote>\n<p>vmap &lt;C-c&gt; &quot;+y</p>\n</blockquote>\n<p>vmap是在VISUAL模式下的映射,是在按了v进入可视化之后才启用,<C-c>是ctrl+c,这样相当于&quot;+y这个命令.</p>\n<p>将系统剪切板的东西复制进vim比较简单,可以进入插入模式,直接右键粘贴,也可以shift+insert.这个不需要+寄存器的支持也可以用.</p>\n","site":{"data":{}},"excerpt":"<p>在vim中一般都是按v进入可视化,然后hjkl移动光标选择范围,然后按y复制所选内容,然而这样复制的内容并不在系统剪切板中,而在vim自己的剪切板,要复制到系统gedit或者浏览器里我一般是用鼠标选中范围,然后右键复制,但是蛋疼的是代码行号总是被复制,像这样<br><img src=\"../../../../img/选区_035.png\" alt=\"\"></p>","more":"<p>所以我尝试找找有没有更方便的方法,网上说复制的时候不要用y而是用&quot;+y的形式将内容复制到全局寄存器,这样就可以粘贴到别的地方了.<br>但是我试了好几次都不行,之后在vim中用</p>\n<blockquote>\n<p> :reg</p>\n</blockquote>\n<p>命令查看下自己的寄存器,<br><img src=\"../../../../img/选区_034.png\" alt=\"\"><br>我的一开始是没有 &quot;+这个寄存器的.<br>也可以在shell中用</p>\n<blockquote>\n<p>vim --version | grep xterm_clipboard</p>\n</blockquote>\n<p>查看下xterm_clipboard前面是+还是_<br><img src=\"../../../../img/选区_033.png\" alt=\"\"><br>如果是&quot;-&quot;说明不支持这个功能.<br>我还以为需要从装一遍vim,怕自己那么多插件又得从装,其实只需要执行</p>\n<blockquote>\n<p>sudo apt-get install vim-gui-common</p>\n</blockquote>\n<p>就可以支持+储存器了,这时我们选中范围后按&quot;+y就复制到+寄存器中,在外面就可以ctrl+v复制了.</p>\n<hr>\n<p>当然这个命令还是麻烦<br>我们可以修改.vimrc,在其中添加一条map映射</p>\n<blockquote>\n<p>vmap &lt;C-c&gt; &quot;+y</p>\n</blockquote>\n<p>vmap是在VISUAL模式下的映射,是在按了v进入可视化之后才启用,<C-c>是ctrl+c,这样相当于&quot;+y这个命令.</p>\n<p>将系统剪切板的东西复制进vim比较简单,可以进入插入模式,直接右键粘贴,也可以shift+insert.这个不需要+寄存器的支持也可以用.</p>"},{"title":"一辈子の好朋友劵","date":"2014-07-03T04:32:45.000Z","_content":"\n![](http://youthy-picture.qiniudn.com/1.jpg)\n\n<!--more-->\n\n  最近由于刚刚毕业的缘故,脑海中时常无意识的就想到日常中这个镜头,故事是\"蓝毛\"美绪无意看到自己喜欢的学长和其他喜欢他的女孩子走在一起,心情很是失落,一阵狂奔暴走(这段暴走剧情是整剧最高能最搞笑的一段),好友黑长直,柚子和机器人东云为了安慰失恋的她,三人假冒大福让美绪在街头抽奖,美绪抽到了这个大奖,美绪走在街头慢慢打开信封,里面是一张如上的纸条.\n ![](http://youthy-picture.qiniudn.com/9387_KH8a7.jpg)\n ![](http://youthy-picture.qiniudn.com/3.jpg)\n  **\"呐,失恋算什么,有我们呢\"**\n\n  日常这部动漫在我心中比其他任何动漫的地位都高,它没有热血的剧情,没有远大的少年梦想,没有绚丽的战斗画面,它描述了一个又一个平凡的故事,一个又一个普通的日常,\n  > **我们度过的每个平凡的日常,也许就是连续发生的奇迹**\n\n这是日常最后始终强调的,你会发现如此普通的小事,如此普通的日常,会发生怎样的连锁,产生怎样的奇迹.\n我看过不管多么优秀的作品,我觉得它剧情多么多么好,基本上都是看过一遍就不会再看了,但是日常我看了不止一遍,每次看都会笑的像个baka,如果你觉得它很无聊,真的很正常,因为我们的电波对不上而已.\n\n一辈子的好朋友啊,真的很难呢,我始终觉得朋友有两种:\n一种是和你一起长大,经历那些幼稚,青葱,为各种考试闷头苦读,结束后有举杯向庆的小伙伴,庆幸我有9个这样的哥们,我们这样大概10年了,每次放假都会一起玩耍.基本上对方的父母都认识我们,因为经常蹭吃蹭喝.\n另一种是和你有着共同梦想,一起为同一个目标奋斗,你们在狭小的工作室挥汗拼搏,在失意时把酒流泪.我还没有遇到.\n剩下的人,时间早晚会将我们的身形涂掉,将我们的声音打散,让我们的脸慢慢沉没于众生之中,让我们想不起彼此.\n现实如此残酷.\n  \n  这些天班里的微信群异常活跃,大家的关系明显亲近了很多,各种相互拆台,相互揭底,真的很温馨,不知道会持续多久,但是拥有这些记忆也是十分美好的.其实有很多人我多想跟你们在多说一些话,在多看一看你们的眼睛,工作的人有很多的苦楚,有很多感悟,就像那天和我喝多了和某人哭着哭诉一样,\"我以后不会再有同学了\",说出来真的就像朝胸口闷了一拳.如果我们有一点更多的时间会不会就是从同学成为了朋友呢?\n      \nFarewell,一切就这样吧,仿佛自己站在一直横亘在时间恒河的桥边,向过去频频回首,然而这漂泊在时间洪流上的小帆终逆不过前进的力量,再见了,祝福你们,我的同学们.\n","source":"_posts/一辈子の好朋友劵.md","raw":"title: 一辈子の好朋友劵\ndate: 2014-07-03 12:32:45\ntags: 情感\ncategories: 杂谈\n---\n\n![](http://youthy-picture.qiniudn.com/1.jpg)\n\n<!--more-->\n\n  最近由于刚刚毕业的缘故,脑海中时常无意识的就想到日常中这个镜头,故事是\"蓝毛\"美绪无意看到自己喜欢的学长和其他喜欢他的女孩子走在一起,心情很是失落,一阵狂奔暴走(这段暴走剧情是整剧最高能最搞笑的一段),好友黑长直,柚子和机器人东云为了安慰失恋的她,三人假冒大福让美绪在街头抽奖,美绪抽到了这个大奖,美绪走在街头慢慢打开信封,里面是一张如上的纸条.\n ![](http://youthy-picture.qiniudn.com/9387_KH8a7.jpg)\n ![](http://youthy-picture.qiniudn.com/3.jpg)\n  **\"呐,失恋算什么,有我们呢\"**\n\n  日常这部动漫在我心中比其他任何动漫的地位都高,它没有热血的剧情,没有远大的少年梦想,没有绚丽的战斗画面,它描述了一个又一个平凡的故事,一个又一个普通的日常,\n  > **我们度过的每个平凡的日常,也许就是连续发生的奇迹**\n\n这是日常最后始终强调的,你会发现如此普通的小事,如此普通的日常,会发生怎样的连锁,产生怎样的奇迹.\n我看过不管多么优秀的作品,我觉得它剧情多么多么好,基本上都是看过一遍就不会再看了,但是日常我看了不止一遍,每次看都会笑的像个baka,如果你觉得它很无聊,真的很正常,因为我们的电波对不上而已.\n\n一辈子的好朋友啊,真的很难呢,我始终觉得朋友有两种:\n一种是和你一起长大,经历那些幼稚,青葱,为各种考试闷头苦读,结束后有举杯向庆的小伙伴,庆幸我有9个这样的哥们,我们这样大概10年了,每次放假都会一起玩耍.基本上对方的父母都认识我们,因为经常蹭吃蹭喝.\n另一种是和你有着共同梦想,一起为同一个目标奋斗,你们在狭小的工作室挥汗拼搏,在失意时把酒流泪.我还没有遇到.\n剩下的人,时间早晚会将我们的身形涂掉,将我们的声音打散,让我们的脸慢慢沉没于众生之中,让我们想不起彼此.\n现实如此残酷.\n  \n  这些天班里的微信群异常活跃,大家的关系明显亲近了很多,各种相互拆台,相互揭底,真的很温馨,不知道会持续多久,但是拥有这些记忆也是十分美好的.其实有很多人我多想跟你们在多说一些话,在多看一看你们的眼睛,工作的人有很多的苦楚,有很多感悟,就像那天和我喝多了和某人哭着哭诉一样,\"我以后不会再有同学了\",说出来真的就像朝胸口闷了一拳.如果我们有一点更多的时间会不会就是从同学成为了朋友呢?\n      \nFarewell,一切就这样吧,仿佛自己站在一直横亘在时间恒河的桥边,向过去频频回首,然而这漂泊在时间洪流上的小帆终逆不过前进的力量,再见了,祝福你们,我的同学们.\n","slug":"一辈子の好朋友劵","published":1,"updated":"2018-06-26T09:49:27.739Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqw7jdwe001r6f1reqyuds8k","content":"<p><img src=\"http://youthy-picture.qiniudn.com/1.jpg\" alt=\"\"></p>\n<span id=\"more\"></span>\n<p>  最近由于刚刚毕业的缘故,脑海中时常无意识的就想到日常中这个镜头,故事是&quot;蓝毛&quot;美绪无意看到自己喜欢的学长和其他喜欢他的女孩子走在一起,心情很是失落,一阵狂奔暴走(这段暴走剧情是整剧最高能最搞笑的一段),好友黑长直,柚子和机器人东云为了安慰失恋的她,三人假冒大福让美绪在街头抽奖,美绪抽到了这个大奖,美绪走在街头慢慢打开信封,里面是一张如上的纸条.<br> <img src=\"http://youthy-picture.qiniudn.com/9387_KH8a7.jpg\" alt=\"\"><br> <img src=\"http://youthy-picture.qiniudn.com/3.jpg\" alt=\"\"><br>  <strong>&quot;呐,失恋算什么,有我们呢&quot;</strong></p>\n<p>  日常这部动漫在我心中比其他任何动漫的地位都高,它没有热血的剧情,没有远大的少年梦想,没有绚丽的战斗画面,它描述了一个又一个平凡的故事,一个又一个普通的日常,</p>\n<blockquote>\n<p><strong>我们度过的每个平凡的日常,也许就是连续发生的奇迹</strong></p>\n</blockquote>\n<p>这是日常最后始终强调的,你会发现如此普通的小事,如此普通的日常,会发生怎样的连锁,产生怎样的奇迹.<br>我看过不管多么优秀的作品,我觉得它剧情多么多么好,基本上都是看过一遍就不会再看了,但是日常我看了不止一遍,每次看都会笑的像个baka,如果你觉得它很无聊,真的很正常,因为我们的电波对不上而已.</p>\n<p>一辈子的好朋友啊,真的很难呢,我始终觉得朋友有两种:<br>一种是和你一起长大,经历那些幼稚,青葱,为各种考试闷头苦读,结束后有举杯向庆的小伙伴,庆幸我有9个这样的哥们,我们这样大概10年了,每次放假都会一起玩耍.基本上对方的父母都认识我们,因为经常蹭吃蹭喝.<br>另一种是和你有着共同梦想,一起为同一个目标奋斗,你们在狭小的工作室挥汗拼搏,在失意时把酒流泪.我还没有遇到.<br>剩下的人,时间早晚会将我们的身形涂掉,将我们的声音打散,让我们的脸慢慢沉没于众生之中,让我们想不起彼此.<br>现实如此残酷.</p>\n<p>  这些天班里的微信群异常活跃,大家的关系明显亲近了很多,各种相互拆台,相互揭底,真的很温馨,不知道会持续多久,但是拥有这些记忆也是十分美好的.其实有很多人我多想跟你们在多说一些话,在多看一看你们的眼睛,工作的人有很多的苦楚,有很多感悟,就像那天和我喝多了和某人哭着哭诉一样,&quot;我以后不会再有同学了&quot;,说出来真的就像朝胸口闷了一拳.如果我们有一点更多的时间会不会就是从同学成为了朋友呢?</p>\n<p>Farewell,一切就这样吧,仿佛自己站在一直横亘在时间恒河的桥边,向过去频频回首,然而这漂泊在时间洪流上的小帆终逆不过前进的力量,再见了,祝福你们,我的同学们.</p>\n","site":{"data":{}},"excerpt":"<p><img src=\"http://youthy-picture.qiniudn.com/1.jpg\" alt=\"\"></p>","more":"<p>  最近由于刚刚毕业的缘故,脑海中时常无意识的就想到日常中这个镜头,故事是&quot;蓝毛&quot;美绪无意看到自己喜欢的学长和其他喜欢他的女孩子走在一起,心情很是失落,一阵狂奔暴走(这段暴走剧情是整剧最高能最搞笑的一段),好友黑长直,柚子和机器人东云为了安慰失恋的她,三人假冒大福让美绪在街头抽奖,美绪抽到了这个大奖,美绪走在街头慢慢打开信封,里面是一张如上的纸条.<br> <img src=\"http://youthy-picture.qiniudn.com/9387_KH8a7.jpg\" alt=\"\"><br> <img src=\"http://youthy-picture.qiniudn.com/3.jpg\" alt=\"\"><br>  <strong>&quot;呐,失恋算什么,有我们呢&quot;</strong></p>\n<p>  日常这部动漫在我心中比其他任何动漫的地位都高,它没有热血的剧情,没有远大的少年梦想,没有绚丽的战斗画面,它描述了一个又一个平凡的故事,一个又一个普通的日常,</p>\n<blockquote>\n<p><strong>我们度过的每个平凡的日常,也许就是连续发生的奇迹</strong></p>\n</blockquote>\n<p>这是日常最后始终强调的,你会发现如此普通的小事,如此普通的日常,会发生怎样的连锁,产生怎样的奇迹.<br>我看过不管多么优秀的作品,我觉得它剧情多么多么好,基本上都是看过一遍就不会再看了,但是日常我看了不止一遍,每次看都会笑的像个baka,如果你觉得它很无聊,真的很正常,因为我们的电波对不上而已.</p>\n<p>一辈子的好朋友啊,真的很难呢,我始终觉得朋友有两种:<br>一种是和你一起长大,经历那些幼稚,青葱,为各种考试闷头苦读,结束后有举杯向庆的小伙伴,庆幸我有9个这样的哥们,我们这样大概10年了,每次放假都会一起玩耍.基本上对方的父母都认识我们,因为经常蹭吃蹭喝.<br>另一种是和你有着共同梦想,一起为同一个目标奋斗,你们在狭小的工作室挥汗拼搏,在失意时把酒流泪.我还没有遇到.<br>剩下的人,时间早晚会将我们的身形涂掉,将我们的声音打散,让我们的脸慢慢沉没于众生之中,让我们想不起彼此.<br>现实如此残酷.</p>\n<p>  这些天班里的微信群异常活跃,大家的关系明显亲近了很多,各种相互拆台,相互揭底,真的很温馨,不知道会持续多久,但是拥有这些记忆也是十分美好的.其实有很多人我多想跟你们在多说一些话,在多看一看你们的眼睛,工作的人有很多的苦楚,有很多感悟,就像那天和我喝多了和某人哭着哭诉一样,&quot;我以后不会再有同学了&quot;,说出来真的就像朝胸口闷了一拳.如果我们有一点更多的时间会不会就是从同学成为了朋友呢?</p>\n<p>Farewell,一切就这样吧,仿佛自己站在一直横亘在时间恒河的桥边,向过去频频回首,然而这漂泊在时间洪流上的小帆终逆不过前进的力量,再见了,祝福你们,我的同学们.</p>"},{"title":"youthy的番剧历史(持续补全中)","date":"2014-09-17T16:17:19.000Z","_content":"\n> 一直都有想法想把看过的番剧列一个表,我会慢慢想起看过的番剧,然后在这里补全,写一些自己的评价,以供回忆\n\n<!--more-->\n<!-- toc -->\n\n## 2014 年\n** ---------------------------9月18日更新--------------------------------------**\n#### 少女革命 ★★★★★\n\n> 90年代3大OTAKU神作之一,以少女寻找王子的故事线表现女权的解放与抗争,少女的自我救赎,主旨上与今年的迪士尼的冰雪女王一样,很多表现手法很超前,甚至觉得有些梗真不像是90年代的,不得不佩服几原老贼的超前思想.\n\n#### 月刊少女野崎君 ★★★★★\n\n> 典型的少女漫画般的开场,色调浪漫,少女表白,以为是一部校园恋情剧你就输了,实际上是部搞笑剧,女主意外的萌,男主无口且木讷.几位配角刻画非常成功,不是典型的校园剧,很难得\n\n#### 生存游戏部 ★★★★★\n\n> 这个月新番也就认真追了生存游戏部和月刊少女,两部在我看来都很有突破,生存游戏部女主也不是按正常套路出牌,内心比较黑暗,在善与恶的选择中肯定会选择恶的人格.而且很搞笑.\n\n#### 舞-hime ★★★★☆\n\n> 补了部老番,冲着静夏去的.貌似对有点东京口音或者大阪口音的声优有种莫名的喜欢-.-\n\n** ---------------------------7月29日更新--------------------------------------**\n#### kill la kill (斩服少女)    ★★★★★  \n\n<img src=\"../../../../img/killlakill.jpg\" width=\"40%\" height=\"40%\">\n\n> 十分推荐,热血,超展开,世界观奇特(衣服和人类的战斗,啊--剧透了),百合,bgm燃,有泽野大神和小林未郁的合作\n\n\n#### 目隐都市的演绎者    ★★★★★  \n![](../../../../img/yangyan.jpg)\n> 很cool的动漫,风格很像物语系列,画风我很喜欢,剧情也不错,前几集完全不明白剧情,看完之后似懂非懂,不是那种看开头就猜到结尾的类型,新房独特的意识流作画方式,还有各种45°角,各种我有姿势我自豪的表现手法,可以说作品很有特色.音乐简直好赞,ed是国歌演唱者Lia唱的,很好听,op更别说,配合各种彩喷画,目隐团集体兜帽衫,真的cool到爆.各种插入曲也很好听,这部作品音乐方面也是上乘之作.喜欢物语系列的一定要看\n\n#### Love Live 第一季/第二季  ★★★★☆\n![](../../../../img/lovelive.jpg)\n> lovelive可以说是一款很现象级的作品,手游月流水将近过亿,第二季首周BD销量8w+,上海地铁都有lovelive的包装,这些现象其实与动画的质量是不相称的,其实我在补完两季动画后觉得这动画真的不算神作或者上乘之作,它火的背后其实有很多原因可以探讨,包括企划,宣传什么的,就动画本身而言,塑造了9个性格不同的角色,吸引不同的人群,每次看弹幕都会看到\"niconico美如画\"\"我姬美如画\"之类的.我都觉得烦,也看不出美在哪里,音乐方面我到现在想不起什么印象深刻的歌,只记得配角组A-rise的歌很好听,远不是当初轻音no thank you,listen,don't say lazy, 相遇天使,带我给我的深刻印象.love live第一季的时候还没有这么火,第二季没出之前网上就各种宣传LL大法,只能说LL力量大,企划宣传好,人民群众喜闻乐见的跟风态度.\n\n** ---------------------------7月29日更新--------------------------------------**\n\n\n#### 悠哉日常大王 ★★★★\n> 画质真心很好，风景亮丽，画面党表示很满足，nano.ripe清新的op也很符合我胃口，这部剧诞生了风靡一时的台词“喵帕斯～”，这个台词在动漫里真的很萌，作为一部极其了萝莉，痴女，万年受，炮姐，永远没有台词的神一样的哥哥的日常番，很适合休闲的时候补下。\n\n#### 噬魂师Not  ★★★\n> 虽然我不是原著党，原著噬魂师我只看了几集。（原著很好，只看了几集是因为一直没时间补），但是仍然想吐槽下这部剧，卖着百合的题材，又到处埋雷是要闹哪样啊喂～而且画质真是不忍直视，这都14年了是在有些觉得粗糙，还没当初噬魂师给我的感觉好。最后还有几集没看完，回头补上。\n\n#### 虫师 序章  ★★★★★☆\n> 时隔10年,虫师果然没有让人失望,它携带着固有的迷离之音,戴着氤氲的雾气,回到荧屏,片头曲一如既往的让人陶醉,演唱者的声线有点像王若琳,略有成熟,沙哑的感觉.配音依然惯用前作的风格,就像在耳边真实回响,充满生活感.画面不用多说,而且依然是一集一个ED,每首都很好听.我一直觉得任何续作都很大程度上会远远比上作差,尤其虫师这种高质量的动画,实际上没有,是在让我感到欣慰与感动.\n\n#### 请问您今天要来点兔子吗  ★★★☆\n> 普普通通的卖萌番,话说居然有爷爷变成兔子的设定,兔子那么萌,一想到是爷爷顿时都觉得略有X父的感脚...\n\n#### 恶魔之谜 ★★★☆\n![](../../../../img/emozhimi.jpg)\n> 本来看画面还不错的.但是剧情实在是无趣,打起来也很没有杀手的样子,而且官方各种把漫画的经典百合镜头省掉了.真想给官方寄刀片.不过cp组什么的在p站还是挺火的.\n\n#### 天才麻将少女全国篇 ★★★★★\n<img src=\"../../../../img/tiancaimajiangshaonv.jpg\" width=\"50%\" height=\"50%\">\n> 基本上是国民级动漫了..知名度很高,基本上全是女生,各种超燃的打麻将方式,各种暧昧的女生友情,简称外挂百合少女.(图片:看我大魔王把你们这些渣渣pia飞~)\n\n#### 妄想学生会第二季 ★★★★☆\n![](../../../../img/wangxiangxueshenghui.png)\n> 从没想到曾经轻音里害羞的mio酱,开朗的律队,在这里摇身一变,成了满口黄笑话的学生会长和副会长..男主的存在纯粹是为了吐槽会长的黄笑话...第二季开头画质惊人,漫天飘舞的粉色樱花仿佛告诉你这是一个充满青春气息的校园爱情短篇,然而阳子会用面不改色的讲黄笑话的方式打你的脸.俗称黄段子学生会.\n\n#### 中二病也要谈恋爱第二季★★★★☆\n> 其实中二病异常的火爆我也不太明白,作为早已远离后宫番的我,森凸是我唯一坚持下去的动力..森大人在角色歌里和第一季ed里面的御姐声线是在太迷人了.不过京都一如既往的高画质水准让中二场景展开时的画面很是惊艳.福山润鲁鲁修的声线也是我看下去的动力把.抛出后宫在我心中的不良印象,这部番还是不错的.\n\n#### 樱Trick★★★★\n> 第一集的时候看到满弹幕的\"我好兴奋\",着实吃了一惊,芳文社作为百合社真是业界良心,第一集就送上各种赤裸裸的接吻镜头,还有呻吟声....不过作为日常来说,我觉得最重要的不是搞笑就是治愈,而这部我感觉有些太赤裸导致的对各种镜头都无感了. \n\n#### 境界的彼方★★★\n> 我不明白为何当初这部番那么火,出了一贯的高清画质,没有什么可圈可点的地方,难道是因为眼镜控众多?⊙﹏⊙b汗.\n唯一吸引我的也就是有意思的大阪口音和茅原实里的配音了.哎,对这种整天\"我不高兴\"的口癖仿佛可以加上去般的生硬的女主,是在提不起兴趣.\n\n#### 弹丸论破之希望的学园和绝望高中生★★★★☆\n![](../../../../img/danwanlunpo.jpg)\n> 弹丸论破是部不错的动漫,根据游戏改编,其实剧情什么的也就那样,主要是风格与众不同,有点当初看海猫鸣泣之时的感觉,有些游戏里的设定显得与众不同,而且画风也很忠于游戏,熊校长也算是风极一时的角色了.到处可见.而且开头音乐风格简直32个赞.一般动画很少有这种风格.值得一看\n\n#### 蔷薇少女第三季★★★★\n> 还没看完,作为看过前两季的人来说第三季来的好晚好晚,都已经把之前的剧情忘得差不多了.不过惊喜的当然是画质随着时代的进步终于不再是av画质了.加入了平行世界的情节,感觉比以前好看了,但是怎么感觉少女们怎么有点变小了..\n\n#### 黄金拼图★★★★\n> 俗称黄图,其实这么叫很容易误解成肉番,实质上是个轻百合,还好当初忍过了第一集,因为第一集描写小时候的画风实在是难以忍受,之后长大后突然画风就好了..最近要出第二季了,准备看看.\n\n## 2014 年以前----->\n\n*****\n\n#### 虫师       ★★★★★☆\n> 大概在大二暑假补了虫师,虫师是个典型的阳春白雪的类型,我一直把<夏目友人帐>当作下里巴人,并不是多贬低夏目,而是觉得和虫师比起来确实很有这种强烈的对比感,夏目是个大众治愈系,被推荐的太多,而它给我的感觉就是很多故事都很幼稚,刻画也不如虫师那般细腻而又绵绵无声,虫师的有三:其一是音乐,在bangumi的音乐排行上虫师排在第二,它每集的ed都不一样,而且每首都给人以打入感,十分空灵而又优美,契合虫师的妖怪世界.第二:背景画,虫师的人物不是很美形,但是习惯了就觉得有韵味,背景确是十分大气,优美,时常有游走在水墨画的感觉,而且当时负责背景的是一家中国外包公司,很有中国风的味道.放张图你们感受下\n![](http://youthy-picture.qiniudn.com/857KT6C351H90003.jpg)\n最后是配音.虫师的声优大都不是很出名,但是就是感觉这个声音非常适合这个角色,而且里面的小孩都是找的真实的小孩配的音,不是专业声优,有时你会感觉他们说话是如此的真实.总之虫师是治愈系的良作.\n\n#### 叛逆的鲁路修      ★★★★\n> 高中时鲁路修很火,可是我对机甲类实在不感冒,直到大二才补了这部,当时从早上一直看到凌晨3点,看了鲁路修第一部和第二部前7集,我也不知道为什么停不下来,就是很让人想知道接下来的发展.\n\n#### 魔法少女小圆   ★★★★★\n<img src=\"../../../../img/xiaoyuan.jpg\" width=\"50%\" height=\"50%\">\n> 百合启蒙作,在被晓美焰对圆神执着的付出的感动下我走上了不归路...也就是这部剧奠定了神剧标准:第三集开始死人--小圆的题材是很古老的马猴烧酒题材,然后老虚不愧是老虚,把这个快要拍烂的题材拍出了一样的哲学,整部剧围绕着付出,牺牲,时间,循环.沙耶香为了上条定下了契约,她的愿望是为了他而许,然而之后的绝望让她堕落为魔女,而杏子为此内疚,一心想要唤醒沙耶香,甚至为此与沙耶香同归于尽.黑长直更不用说了,为了阻止小圆重蹈魔法少女们的悲剧,她在时间中孤独的行走,孤独的战斗.从一开始我就想要知道,黑长直为什么这么专一的对待小圆,他们之间发生了什么,究竟小圆什么时候才能成为魔法少女,直到最后一集老虚才给我答案...当时看完是夜里3点,为剧情不能自已.小圆的成绩有目共睹,13年新篇剧场版狂卷20亿日元,而这个成绩只有宫崎骏和几部还有口袋妖怪和机器猫那些好多年前的动画电影可以超过,这个数字对于13集的番剧已成神话.\n\n\n#### 凉宫春日的忧郁    ★★★★\n> 在二次元众很多人喊着要脱团，这个团最初就是指凉宫春日所见的SOS团，这是个神奇的动漫，本来我以为只是个普通的吐槽番，结果然让我一看就一发不可收拾。我也不明白为何当时就找了迷一样一口气看完20多集，而且之后又去补了漫画，补了只有网络放送的小剧场。就是看起来让人很想看下去。剧场版凉宫春日的消失当时也是缔造了票房神话，而且制作水准很高。总之很值得一看。\n\n#### 日常  ★★★★★★\n> 占位\n\n#### 男子高中生的日常 ★★★\n> 当初看这个纯粹是出于他有日常这两个字，除了第一集给我点惊喜外，之后我就感觉很普通了，可能是由于日常的影响在，我甚至觉得这个想要模仿日常可能没模仿好，毕竟男孩子没有女孩子可爱嘛（pia～飞）。\n\n#### 黑礁 ★★★★\n![](../../../../img/heijiao.jpg)\n> 黑礁已经有3季了，如果不是同类较优秀的作品是不会有3季的。军火题材，女主莱维是中国人，非常帅气，（对拿枪械的美女没有抵抗力啊～～～）有时经常会蹦出些有哲理的台词。音乐很好听。\n\n#### 未闻花名 ★★★★\n> 画面制作水准很高，讲述从孩童一直到高中时代的朋友间的羁绊。虽然我觉得剧情很幼稚，甚至有些无脑粉的行为让我觉得很无聊，但是在最后一集还是流泪了。音乐给动画增了不少分，每集结尾的ed插入的非常好。\n\n#### 命运石之门 ★★★★★\n<img src=\"../../../../img/mingyunshizhimen.jpg\" width=\"80%\" height=\"80%\">\n>  终于轮到讲我大命运石之门了，什么?图片上为什么没有凶真？要什么凶真！\n有我大助手就够了！！好吧，开玩笑。说实话，命运石之门真的是很优秀的作品，由游戏改编，有良好的剧本支撑。这也许是个慢热的作品，刚开始面对凶真中二的不能更中二的行为，也许有些觉得无厘头，但是之后你会慢慢的随着剧情扣紧心心弦，看着凶真不断地在时间跳跃中想要拯救“嘟嘟噜”，但是一次又一次失败，还好，无论在哪个世界，助手的头脑都可以很快的理解并帮助他，这也是纠结所在，最后得知只有在助手死后的世界中“嘟嘟噜”才能活下来，一个是青梅竹马，一个是头脑与自己相当的知音，得力助手，谁都难以抉择..最后助手与凶真的擦身而过，画面更是仍人心动。情节扣人心弦，音乐脍炙人口，人物深得人心，这就是命运石之门，让我们高喊“EL Phy Congroo！！”\n\n#### 钢之炼金术师FA\n> 占位\n\n#### 全金属狂潮第二季     ★★★★★\n> 我只看了全金属狂潮的第二季，因为当初是为了找搞笑番看的，这个是个番外，与正统剧情基本没啥关系，发生在校园里，画风比较老，但是论搞笑程度来说，只能说它绝对值五颗星。\n\n#### 超元气三姐妹  ★★★★★\n> 又称 “超色情三姐妹”，真的是部很神奇的片子。。。。主角都是类似幼稚园的小学生，有整天拿着小黄书看的老三，有力大无穷的天然呆老大，有坏心眼的老二，有画风与众不同的爸爸，有整天带着“69”帽子的小色鬼，还有略显无能的班主任，这部真的很值得一看，因为实在是很好笑～也很H（有那么一点啦）\n\n#### 南家三姐妹 ★★★★\n> 南家三姐妹去年貌似出的第四季。三个姐妹的声优都是美女，而且都是现声优界的一把手。剧情就是高中，初中，小学三个姐妹的日常生活，大姐负责吸引人妻控，二姐是个元气妹，三妹是个腹黑的萝莉。作为个生活日常番质量还是很高的。\n\n#### 某科学的超电磁炮 ★★★★★\n![](../../../../img/chaodiancipao.gif)\n> 作为为数不多的番外比本片更好看的动漫,炮姐算是很典型的一例,我入B站较晚,4年前才直到B站,也不清楚是炮姐带红了B站还是B站让炮姐在国内火了.剧情爽快,不拖拉,任务个性鲜明,值得一看. \n\n#### 某科学的超电磁炮S ★★★★\n> 扣了1星,因为第二季,当妈的戏份太多了!!!到处施展把妹之手,尤其是打了一方通行的脸,让我彻底坚信炮姐已经抛弃了黑子,好替黑子伤心>_<.剧情还延续前作的风格,不过炮姐与克隆妹妹之间的互动着实非常有爱,有其抢瓜太徽章的时候,很搞笑,可以说妹妹们为第二季添了不少色彩.\n\n#### Fate/Zero  ★★★★★☆\n![](../../../../img/fatezero.jpg)\n> 绝对的大制作,大手笔,画面特效什么的十分精致,而且有老虚坐镇,剧情肯定不是普通日常番能比,唯一觉得遗憾的就是老虚把zero表现的过于倾向于战争了.感情戏份很少,没有想staynight结尾时的saber安静的站在山顶的那种温馨感人的画面.不过仍然是上等之作.\n\n#### Fate stay night  ★★★★★\n> 唯一的缺点看来也就是时代所不可避免的画质了吧,至今仍然忘不了结局时吾王在湖边醒来那有点睡眼惺忪又有点望穿一切的眼神,以及站在山顶,一个360度旋转的镜头,真的非常美好.\n\n#### 龙与虎 ★★★★\n> 龙与虎很多人都喜欢,可能不是很和我胃口,我对校园爱情剧不是特别感冒,而且对卷毛萝莉提不起什么兴趣,反倒举得实乃梨这种元气妹应该和男主在一起,或者蓝毛御姐,总觉得tigar还太小...没到谈婚论嫁的年龄..\n\n#### 幸运星 ★★★★★\n> 幸运星的剧情实在是想不起来了,⊙﹏⊙b汗,本来就是日常番,其实也没什么剧情可言,不过当初觉得很好看就是了..\n\n#### 一起一起,这里那里 ★★★★\n![](../../../../img/yiqiyiqi.gif)\n![](../../../../img/yiqiyiqi2.gif)\n> 和幸运星放在了一起,因为人设实在很像,而且也很有爱,动漫的名字都可以看出来就是萌+有爱.\n\n#### 白兔糖 ★★★★\n![](../../../../img/baitutang.jpg)\n> 孤儿萝莉和单身老男人的生活?动画还算是个治愈系,写的就是小萝莉是老男人的爷爷与年轻女仆的私生女,爷爷去世了,女仆一时消失,面临无人抚养的时候,30岁的老男人挑起了抚养她的担子,写的很贴近生活,很朴素.而且有电影版,主演还是死亡笔记的L松山健一.动画是小萝莉小时候的事,据说漫画之后发展成父嫁了..汗.\n\n#### 寒蝉鸣泣之时 ★★★★\n> 喜欢寒蝉的人也挺多的.我只看了一季,也就只看了迷,而没有看解,所以发生了什么还是云里雾里.就是个男主不断做错误的抉择而被杀死,而又从新读档,再被杀死的故事....根据游戏改编的.\n\n#### 玉子市场  ★★★★\n> 其实没什么特别的.主要是主任在片中各种卖萌捧场,普通的日常番.本来还挺期待小绿和玉子的cp,结果官方都透露无情的bg结局.哎,看了一季,准备弃了.\n\n#### 我女友与青梅竹马的惨烈修罗场 ★★★★\n> 很明显的后宫番,我也纳闷年轻的自己竟然能看得下去后宫番,大概因为斋藤千和和田村打大魔王作为主役声优把.\n还好,男主是有实力的人,而不是无脑男主坐拥一大堆后宫.还可以接受.\n\n#### 青之驱魔师 ★☆\n> 我实在是很想吐槽这个番，当初是因为看了corepride的现场live才去补的这个动漫，实在是太渣了！！自古渣片出燃曲，白瞎了corepride这么燃个歌了。剧情简直有够了，没有什么吸引力，主要是难住太气人了，我看着都难受啊～哪有这么笨，这么不会说话，这么没大脑的男主！！哎，想起来就来气，剧情一般就算了，主要是男主有够白痴，让我一点都不想看下去。就这样了，继续走百合路线吧。。。\n\n(未完...)\n","source":"_posts/youthy的番剧历史.md","raw":"title: youthy的番剧历史(持续补全中)\ndate: 2014-09-18 0:17:19\ntags: [二次元]\ncategories: 二次元 \n---\n\n> 一直都有想法想把看过的番剧列一个表,我会慢慢想起看过的番剧,然后在这里补全,写一些自己的评价,以供回忆\n\n<!--more-->\n<!-- toc -->\n\n## 2014 年\n** ---------------------------9月18日更新--------------------------------------**\n#### 少女革命 ★★★★★\n\n> 90年代3大OTAKU神作之一,以少女寻找王子的故事线表现女权的解放与抗争,少女的自我救赎,主旨上与今年的迪士尼的冰雪女王一样,很多表现手法很超前,甚至觉得有些梗真不像是90年代的,不得不佩服几原老贼的超前思想.\n\n#### 月刊少女野崎君 ★★★★★\n\n> 典型的少女漫画般的开场,色调浪漫,少女表白,以为是一部校园恋情剧你就输了,实际上是部搞笑剧,女主意外的萌,男主无口且木讷.几位配角刻画非常成功,不是典型的校园剧,很难得\n\n#### 生存游戏部 ★★★★★\n\n> 这个月新番也就认真追了生存游戏部和月刊少女,两部在我看来都很有突破,生存游戏部女主也不是按正常套路出牌,内心比较黑暗,在善与恶的选择中肯定会选择恶的人格.而且很搞笑.\n\n#### 舞-hime ★★★★☆\n\n> 补了部老番,冲着静夏去的.貌似对有点东京口音或者大阪口音的声优有种莫名的喜欢-.-\n\n** ---------------------------7月29日更新--------------------------------------**\n#### kill la kill (斩服少女)    ★★★★★  \n\n<img src=\"../../../../img/killlakill.jpg\" width=\"40%\" height=\"40%\">\n\n> 十分推荐,热血,超展开,世界观奇特(衣服和人类的战斗,啊--剧透了),百合,bgm燃,有泽野大神和小林未郁的合作\n\n\n#### 目隐都市的演绎者    ★★★★★  \n![](../../../../img/yangyan.jpg)\n> 很cool的动漫,风格很像物语系列,画风我很喜欢,剧情也不错,前几集完全不明白剧情,看完之后似懂非懂,不是那种看开头就猜到结尾的类型,新房独特的意识流作画方式,还有各种45°角,各种我有姿势我自豪的表现手法,可以说作品很有特色.音乐简直好赞,ed是国歌演唱者Lia唱的,很好听,op更别说,配合各种彩喷画,目隐团集体兜帽衫,真的cool到爆.各种插入曲也很好听,这部作品音乐方面也是上乘之作.喜欢物语系列的一定要看\n\n#### Love Live 第一季/第二季  ★★★★☆\n![](../../../../img/lovelive.jpg)\n> lovelive可以说是一款很现象级的作品,手游月流水将近过亿,第二季首周BD销量8w+,上海地铁都有lovelive的包装,这些现象其实与动画的质量是不相称的,其实我在补完两季动画后觉得这动画真的不算神作或者上乘之作,它火的背后其实有很多原因可以探讨,包括企划,宣传什么的,就动画本身而言,塑造了9个性格不同的角色,吸引不同的人群,每次看弹幕都会看到\"niconico美如画\"\"我姬美如画\"之类的.我都觉得烦,也看不出美在哪里,音乐方面我到现在想不起什么印象深刻的歌,只记得配角组A-rise的歌很好听,远不是当初轻音no thank you,listen,don't say lazy, 相遇天使,带我给我的深刻印象.love live第一季的时候还没有这么火,第二季没出之前网上就各种宣传LL大法,只能说LL力量大,企划宣传好,人民群众喜闻乐见的跟风态度.\n\n** ---------------------------7月29日更新--------------------------------------**\n\n\n#### 悠哉日常大王 ★★★★\n> 画质真心很好，风景亮丽，画面党表示很满足，nano.ripe清新的op也很符合我胃口，这部剧诞生了风靡一时的台词“喵帕斯～”，这个台词在动漫里真的很萌，作为一部极其了萝莉，痴女，万年受，炮姐，永远没有台词的神一样的哥哥的日常番，很适合休闲的时候补下。\n\n#### 噬魂师Not  ★★★\n> 虽然我不是原著党，原著噬魂师我只看了几集。（原著很好，只看了几集是因为一直没时间补），但是仍然想吐槽下这部剧，卖着百合的题材，又到处埋雷是要闹哪样啊喂～而且画质真是不忍直视，这都14年了是在有些觉得粗糙，还没当初噬魂师给我的感觉好。最后还有几集没看完，回头补上。\n\n#### 虫师 序章  ★★★★★☆\n> 时隔10年,虫师果然没有让人失望,它携带着固有的迷离之音,戴着氤氲的雾气,回到荧屏,片头曲一如既往的让人陶醉,演唱者的声线有点像王若琳,略有成熟,沙哑的感觉.配音依然惯用前作的风格,就像在耳边真实回响,充满生活感.画面不用多说,而且依然是一集一个ED,每首都很好听.我一直觉得任何续作都很大程度上会远远比上作差,尤其虫师这种高质量的动画,实际上没有,是在让我感到欣慰与感动.\n\n#### 请问您今天要来点兔子吗  ★★★☆\n> 普普通通的卖萌番,话说居然有爷爷变成兔子的设定,兔子那么萌,一想到是爷爷顿时都觉得略有X父的感脚...\n\n#### 恶魔之谜 ★★★☆\n![](../../../../img/emozhimi.jpg)\n> 本来看画面还不错的.但是剧情实在是无趣,打起来也很没有杀手的样子,而且官方各种把漫画的经典百合镜头省掉了.真想给官方寄刀片.不过cp组什么的在p站还是挺火的.\n\n#### 天才麻将少女全国篇 ★★★★★\n<img src=\"../../../../img/tiancaimajiangshaonv.jpg\" width=\"50%\" height=\"50%\">\n> 基本上是国民级动漫了..知名度很高,基本上全是女生,各种超燃的打麻将方式,各种暧昧的女生友情,简称外挂百合少女.(图片:看我大魔王把你们这些渣渣pia飞~)\n\n#### 妄想学生会第二季 ★★★★☆\n![](../../../../img/wangxiangxueshenghui.png)\n> 从没想到曾经轻音里害羞的mio酱,开朗的律队,在这里摇身一变,成了满口黄笑话的学生会长和副会长..男主的存在纯粹是为了吐槽会长的黄笑话...第二季开头画质惊人,漫天飘舞的粉色樱花仿佛告诉你这是一个充满青春气息的校园爱情短篇,然而阳子会用面不改色的讲黄笑话的方式打你的脸.俗称黄段子学生会.\n\n#### 中二病也要谈恋爱第二季★★★★☆\n> 其实中二病异常的火爆我也不太明白,作为早已远离后宫番的我,森凸是我唯一坚持下去的动力..森大人在角色歌里和第一季ed里面的御姐声线是在太迷人了.不过京都一如既往的高画质水准让中二场景展开时的画面很是惊艳.福山润鲁鲁修的声线也是我看下去的动力把.抛出后宫在我心中的不良印象,这部番还是不错的.\n\n#### 樱Trick★★★★\n> 第一集的时候看到满弹幕的\"我好兴奋\",着实吃了一惊,芳文社作为百合社真是业界良心,第一集就送上各种赤裸裸的接吻镜头,还有呻吟声....不过作为日常来说,我觉得最重要的不是搞笑就是治愈,而这部我感觉有些太赤裸导致的对各种镜头都无感了. \n\n#### 境界的彼方★★★\n> 我不明白为何当初这部番那么火,出了一贯的高清画质,没有什么可圈可点的地方,难道是因为眼镜控众多?⊙﹏⊙b汗.\n唯一吸引我的也就是有意思的大阪口音和茅原实里的配音了.哎,对这种整天\"我不高兴\"的口癖仿佛可以加上去般的生硬的女主,是在提不起兴趣.\n\n#### 弹丸论破之希望的学园和绝望高中生★★★★☆\n![](../../../../img/danwanlunpo.jpg)\n> 弹丸论破是部不错的动漫,根据游戏改编,其实剧情什么的也就那样,主要是风格与众不同,有点当初看海猫鸣泣之时的感觉,有些游戏里的设定显得与众不同,而且画风也很忠于游戏,熊校长也算是风极一时的角色了.到处可见.而且开头音乐风格简直32个赞.一般动画很少有这种风格.值得一看\n\n#### 蔷薇少女第三季★★★★\n> 还没看完,作为看过前两季的人来说第三季来的好晚好晚,都已经把之前的剧情忘得差不多了.不过惊喜的当然是画质随着时代的进步终于不再是av画质了.加入了平行世界的情节,感觉比以前好看了,但是怎么感觉少女们怎么有点变小了..\n\n#### 黄金拼图★★★★\n> 俗称黄图,其实这么叫很容易误解成肉番,实质上是个轻百合,还好当初忍过了第一集,因为第一集描写小时候的画风实在是难以忍受,之后长大后突然画风就好了..最近要出第二季了,准备看看.\n\n## 2014 年以前----->\n\n*****\n\n#### 虫师       ★★★★★☆\n> 大概在大二暑假补了虫师,虫师是个典型的阳春白雪的类型,我一直把<夏目友人帐>当作下里巴人,并不是多贬低夏目,而是觉得和虫师比起来确实很有这种强烈的对比感,夏目是个大众治愈系,被推荐的太多,而它给我的感觉就是很多故事都很幼稚,刻画也不如虫师那般细腻而又绵绵无声,虫师的有三:其一是音乐,在bangumi的音乐排行上虫师排在第二,它每集的ed都不一样,而且每首都给人以打入感,十分空灵而又优美,契合虫师的妖怪世界.第二:背景画,虫师的人物不是很美形,但是习惯了就觉得有韵味,背景确是十分大气,优美,时常有游走在水墨画的感觉,而且当时负责背景的是一家中国外包公司,很有中国风的味道.放张图你们感受下\n![](http://youthy-picture.qiniudn.com/857KT6C351H90003.jpg)\n最后是配音.虫师的声优大都不是很出名,但是就是感觉这个声音非常适合这个角色,而且里面的小孩都是找的真实的小孩配的音,不是专业声优,有时你会感觉他们说话是如此的真实.总之虫师是治愈系的良作.\n\n#### 叛逆的鲁路修      ★★★★\n> 高中时鲁路修很火,可是我对机甲类实在不感冒,直到大二才补了这部,当时从早上一直看到凌晨3点,看了鲁路修第一部和第二部前7集,我也不知道为什么停不下来,就是很让人想知道接下来的发展.\n\n#### 魔法少女小圆   ★★★★★\n<img src=\"../../../../img/xiaoyuan.jpg\" width=\"50%\" height=\"50%\">\n> 百合启蒙作,在被晓美焰对圆神执着的付出的感动下我走上了不归路...也就是这部剧奠定了神剧标准:第三集开始死人--小圆的题材是很古老的马猴烧酒题材,然后老虚不愧是老虚,把这个快要拍烂的题材拍出了一样的哲学,整部剧围绕着付出,牺牲,时间,循环.沙耶香为了上条定下了契约,她的愿望是为了他而许,然而之后的绝望让她堕落为魔女,而杏子为此内疚,一心想要唤醒沙耶香,甚至为此与沙耶香同归于尽.黑长直更不用说了,为了阻止小圆重蹈魔法少女们的悲剧,她在时间中孤独的行走,孤独的战斗.从一开始我就想要知道,黑长直为什么这么专一的对待小圆,他们之间发生了什么,究竟小圆什么时候才能成为魔法少女,直到最后一集老虚才给我答案...当时看完是夜里3点,为剧情不能自已.小圆的成绩有目共睹,13年新篇剧场版狂卷20亿日元,而这个成绩只有宫崎骏和几部还有口袋妖怪和机器猫那些好多年前的动画电影可以超过,这个数字对于13集的番剧已成神话.\n\n\n#### 凉宫春日的忧郁    ★★★★\n> 在二次元众很多人喊着要脱团，这个团最初就是指凉宫春日所见的SOS团，这是个神奇的动漫，本来我以为只是个普通的吐槽番，结果然让我一看就一发不可收拾。我也不明白为何当时就找了迷一样一口气看完20多集，而且之后又去补了漫画，补了只有网络放送的小剧场。就是看起来让人很想看下去。剧场版凉宫春日的消失当时也是缔造了票房神话，而且制作水准很高。总之很值得一看。\n\n#### 日常  ★★★★★★\n> 占位\n\n#### 男子高中生的日常 ★★★\n> 当初看这个纯粹是出于他有日常这两个字，除了第一集给我点惊喜外，之后我就感觉很普通了，可能是由于日常的影响在，我甚至觉得这个想要模仿日常可能没模仿好，毕竟男孩子没有女孩子可爱嘛（pia～飞）。\n\n#### 黑礁 ★★★★\n![](../../../../img/heijiao.jpg)\n> 黑礁已经有3季了，如果不是同类较优秀的作品是不会有3季的。军火题材，女主莱维是中国人，非常帅气，（对拿枪械的美女没有抵抗力啊～～～）有时经常会蹦出些有哲理的台词。音乐很好听。\n\n#### 未闻花名 ★★★★\n> 画面制作水准很高，讲述从孩童一直到高中时代的朋友间的羁绊。虽然我觉得剧情很幼稚，甚至有些无脑粉的行为让我觉得很无聊，但是在最后一集还是流泪了。音乐给动画增了不少分，每集结尾的ed插入的非常好。\n\n#### 命运石之门 ★★★★★\n<img src=\"../../../../img/mingyunshizhimen.jpg\" width=\"80%\" height=\"80%\">\n>  终于轮到讲我大命运石之门了，什么?图片上为什么没有凶真？要什么凶真！\n有我大助手就够了！！好吧，开玩笑。说实话，命运石之门真的是很优秀的作品，由游戏改编，有良好的剧本支撑。这也许是个慢热的作品，刚开始面对凶真中二的不能更中二的行为，也许有些觉得无厘头，但是之后你会慢慢的随着剧情扣紧心心弦，看着凶真不断地在时间跳跃中想要拯救“嘟嘟噜”，但是一次又一次失败，还好，无论在哪个世界，助手的头脑都可以很快的理解并帮助他，这也是纠结所在，最后得知只有在助手死后的世界中“嘟嘟噜”才能活下来，一个是青梅竹马，一个是头脑与自己相当的知音，得力助手，谁都难以抉择..最后助手与凶真的擦身而过，画面更是仍人心动。情节扣人心弦，音乐脍炙人口，人物深得人心，这就是命运石之门，让我们高喊“EL Phy Congroo！！”\n\n#### 钢之炼金术师FA\n> 占位\n\n#### 全金属狂潮第二季     ★★★★★\n> 我只看了全金属狂潮的第二季，因为当初是为了找搞笑番看的，这个是个番外，与正统剧情基本没啥关系，发生在校园里，画风比较老，但是论搞笑程度来说，只能说它绝对值五颗星。\n\n#### 超元气三姐妹  ★★★★★\n> 又称 “超色情三姐妹”，真的是部很神奇的片子。。。。主角都是类似幼稚园的小学生，有整天拿着小黄书看的老三，有力大无穷的天然呆老大，有坏心眼的老二，有画风与众不同的爸爸，有整天带着“69”帽子的小色鬼，还有略显无能的班主任，这部真的很值得一看，因为实在是很好笑～也很H（有那么一点啦）\n\n#### 南家三姐妹 ★★★★\n> 南家三姐妹去年貌似出的第四季。三个姐妹的声优都是美女，而且都是现声优界的一把手。剧情就是高中，初中，小学三个姐妹的日常生活，大姐负责吸引人妻控，二姐是个元气妹，三妹是个腹黑的萝莉。作为个生活日常番质量还是很高的。\n\n#### 某科学的超电磁炮 ★★★★★\n![](../../../../img/chaodiancipao.gif)\n> 作为为数不多的番外比本片更好看的动漫,炮姐算是很典型的一例,我入B站较晚,4年前才直到B站,也不清楚是炮姐带红了B站还是B站让炮姐在国内火了.剧情爽快,不拖拉,任务个性鲜明,值得一看. \n\n#### 某科学的超电磁炮S ★★★★\n> 扣了1星,因为第二季,当妈的戏份太多了!!!到处施展把妹之手,尤其是打了一方通行的脸,让我彻底坚信炮姐已经抛弃了黑子,好替黑子伤心>_<.剧情还延续前作的风格,不过炮姐与克隆妹妹之间的互动着实非常有爱,有其抢瓜太徽章的时候,很搞笑,可以说妹妹们为第二季添了不少色彩.\n\n#### Fate/Zero  ★★★★★☆\n![](../../../../img/fatezero.jpg)\n> 绝对的大制作,大手笔,画面特效什么的十分精致,而且有老虚坐镇,剧情肯定不是普通日常番能比,唯一觉得遗憾的就是老虚把zero表现的过于倾向于战争了.感情戏份很少,没有想staynight结尾时的saber安静的站在山顶的那种温馨感人的画面.不过仍然是上等之作.\n\n#### Fate stay night  ★★★★★\n> 唯一的缺点看来也就是时代所不可避免的画质了吧,至今仍然忘不了结局时吾王在湖边醒来那有点睡眼惺忪又有点望穿一切的眼神,以及站在山顶,一个360度旋转的镜头,真的非常美好.\n\n#### 龙与虎 ★★★★\n> 龙与虎很多人都喜欢,可能不是很和我胃口,我对校园爱情剧不是特别感冒,而且对卷毛萝莉提不起什么兴趣,反倒举得实乃梨这种元气妹应该和男主在一起,或者蓝毛御姐,总觉得tigar还太小...没到谈婚论嫁的年龄..\n\n#### 幸运星 ★★★★★\n> 幸运星的剧情实在是想不起来了,⊙﹏⊙b汗,本来就是日常番,其实也没什么剧情可言,不过当初觉得很好看就是了..\n\n#### 一起一起,这里那里 ★★★★\n![](../../../../img/yiqiyiqi.gif)\n![](../../../../img/yiqiyiqi2.gif)\n> 和幸运星放在了一起,因为人设实在很像,而且也很有爱,动漫的名字都可以看出来就是萌+有爱.\n\n#### 白兔糖 ★★★★\n![](../../../../img/baitutang.jpg)\n> 孤儿萝莉和单身老男人的生活?动画还算是个治愈系,写的就是小萝莉是老男人的爷爷与年轻女仆的私生女,爷爷去世了,女仆一时消失,面临无人抚养的时候,30岁的老男人挑起了抚养她的担子,写的很贴近生活,很朴素.而且有电影版,主演还是死亡笔记的L松山健一.动画是小萝莉小时候的事,据说漫画之后发展成父嫁了..汗.\n\n#### 寒蝉鸣泣之时 ★★★★\n> 喜欢寒蝉的人也挺多的.我只看了一季,也就只看了迷,而没有看解,所以发生了什么还是云里雾里.就是个男主不断做错误的抉择而被杀死,而又从新读档,再被杀死的故事....根据游戏改编的.\n\n#### 玉子市场  ★★★★\n> 其实没什么特别的.主要是主任在片中各种卖萌捧场,普通的日常番.本来还挺期待小绿和玉子的cp,结果官方都透露无情的bg结局.哎,看了一季,准备弃了.\n\n#### 我女友与青梅竹马的惨烈修罗场 ★★★★\n> 很明显的后宫番,我也纳闷年轻的自己竟然能看得下去后宫番,大概因为斋藤千和和田村打大魔王作为主役声优把.\n还好,男主是有实力的人,而不是无脑男主坐拥一大堆后宫.还可以接受.\n\n#### 青之驱魔师 ★☆\n> 我实在是很想吐槽这个番，当初是因为看了corepride的现场live才去补的这个动漫，实在是太渣了！！自古渣片出燃曲，白瞎了corepride这么燃个歌了。剧情简直有够了，没有什么吸引力，主要是难住太气人了，我看着都难受啊～哪有这么笨，这么不会说话，这么没大脑的男主！！哎，想起来就来气，剧情一般就算了，主要是男主有够白痴，让我一点都不想看下去。就这样了，继续走百合路线吧。。。\n\n(未完...)\n","slug":"youthy的番剧历史","published":1,"updated":"2018-06-26T09:49:27.737Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqw7jdwf001t6f1rh8uw5lb4","content":"<blockquote>\n<p>一直都有想法想把看过的番剧列一个表,我会慢慢想起看过的番剧,然后在这里补全,写一些自己的评价,以供回忆</p>\n</blockquote>\n<span id=\"more\"></span>\n<!-- toc -->\n<ul>\n<li><a href=\"#2014--\">2014 年</a><ul>\n<li><a href=\"#----------\">少女革命 ★★★★★</a></li>\n<li><a href=\"#-------------\">月刊少女野崎君 ★★★★★</a></li>\n<li><a href=\"#-----------\">生存游戏部 ★★★★★</a></li>\n<li><a href=\"#--hime------\">舞-hime ★★★★☆</a></li>\n<li><a href=\"#kill-la-kill----------------\">kill la kill (斩服少女)    ★★★★★</a></li>\n<li><a href=\"#-----------------\">目隐都市的演绎者    ★★★★★</a></li>\n<li><a href=\"#love-live---------------\">Love Live 第一季/第二季  ★★★★☆</a></li>\n<li><a href=\"#-----------\">悠哉日常大王 ★★★★</a></li>\n<li><a href=\"#---not-----\">噬魂师Not  ★★★</a></li>\n<li><a href=\"#-------------\">虫师 序章  ★★★★★☆</a></li>\n<li><a href=\"#-----------------\">请问您今天要来点兔子吗  ★★★☆</a></li>\n<li><a href=\"#---------\">恶魔之谜 ★★★☆</a></li>\n<li><a href=\"#---------------\">天才麻将少女全国篇 ★★★★★</a></li>\n<li><a href=\"#--------------\">妄想学生会第二季 ★★★★☆</a></li>\n<li><a href=\"#----------------\">中二病也要谈恋爱第二季★★★★☆</a></li>\n<li><a href=\"#-trick----\">樱Trick★★★★</a></li>\n<li><a href=\"#--------\">境界的彼方★★★</a></li>\n<li><a href=\"#---------------------\">弹丸论破之希望的学园和绝望高中生★★★★☆</a></li>\n<li><a href=\"#-----------\">蔷薇少女第三季★★★★</a></li>\n<li><a href=\"#--------\">黄金拼图★★★★</a></li>\n</ul>\n</li>\n<li><a href=\"#2014----------\">2014 年以前-----&gt;</a><ul>\n<li><a href=\"#---------------\">虫师       ★★★★★☆</a></li>\n<li><a href=\"#----------------\">叛逆的鲁路修      ★★★★</a></li>\n<li><a href=\"#--------------\">魔法少女小圆   ★★★★★</a></li>\n<li><a href=\"#---------------\">凉宫春日的忧郁    ★★★★</a></li>\n<li><a href=\"#----------\">日常  ★★★★★★</a></li>\n<li><a href=\"#------------\">男子高中生的日常 ★★★</a></li>\n<li><a href=\"#-------\">黑礁 ★★★★</a></li>\n<li><a href=\"#---------\">未闻花名 ★★★★</a></li>\n<li><a href=\"#-----------\">命运石之门 ★★★★★</a></li>\n<li><a href=\"#------fa\">钢之炼金术师FA</a></li>\n<li><a href=\"#------------------\">全金属狂潮第二季     ★★★★★</a></li>\n<li><a href=\"#-------------\">超元气三姐妹  ★★★★★</a></li>\n<li><a href=\"#----------\">南家三姐妹 ★★★★</a></li>\n<li><a href=\"#--------------\">某科学的超电磁炮 ★★★★★</a></li>\n<li><a href=\"#--------s-----\">某科学的超电磁炮S ★★★★</a></li>\n<li><a href=\"#fate-zero--------\">Fate/Zero  ★★★★★☆</a></li>\n<li><a href=\"#fate-stay-night-------\">Fate stay night  ★★★★★</a></li>\n<li><a href=\"#--------\">龙与虎 ★★★★</a></li>\n<li><a href=\"#---------\">幸运星 ★★★★★</a></li>\n<li><a href=\"#--------------\">一起一起,这里那里 ★★★★</a></li>\n<li><a href=\"#--------\">白兔糖 ★★★★</a></li>\n<li><a href=\"#-----------\">寒蝉鸣泣之时 ★★★★</a></li>\n<li><a href=\"#----------\">玉子市场  ★★★★</a></li>\n<li><a href=\"#-------------------\">我女友与青梅竹马的惨烈修罗场 ★★★★</a></li>\n<li><a href=\"#--------\">青之驱魔师 ★☆</a></li>\n</ul>\n</li>\n</ul>\n<!-- tocstop -->\n<h2 id=\"2014_年\">2014 年</h2><p><strong> ---------------------------9月18日更新--------------------------------------</strong></p>\n<h4 id=\"少女革命_★★★★★\">少女革命 ★★★★★</h4><blockquote>\n<p>90年代3大OTAKU神作之一,以少女寻找王子的故事线表现女权的解放与抗争,少女的自我救赎,主旨上与今年的迪士尼的冰雪女王一样,很多表现手法很超前,甚至觉得有些梗真不像是90年代的,不得不佩服几原老贼的超前思想.</p>\n</blockquote>\n<h4 id=\"月刊少女野崎君_★★★★★\">月刊少女野崎君 ★★★★★</h4><blockquote>\n<p>典型的少女漫画般的开场,色调浪漫,少女表白,以为是一部校园恋情剧你就输了,实际上是部搞笑剧,女主意外的萌,男主无口且木讷.几位配角刻画非常成功,不是典型的校园剧,很难得</p>\n</blockquote>\n<h4 id=\"生存游戏部_★★★★★\">生存游戏部 ★★★★★</h4><blockquote>\n<p>这个月新番也就认真追了生存游戏部和月刊少女,两部在我看来都很有突破,生存游戏部女主也不是按正常套路出牌,内心比较黑暗,在善与恶的选择中肯定会选择恶的人格.而且很搞笑.</p>\n</blockquote>\n<h4 id=\"舞-hime_★★★★☆\">舞-hime ★★★★☆</h4><blockquote>\n<p>补了部老番,冲着静夏去的.貌似对有点东京口音或者大阪口音的声优有种莫名的喜欢-.-</p>\n</blockquote>\n<p><strong> ---------------------------7月29日更新--------------------------------------</strong></p>\n<h4 id=\"kill_la_kill_(斩服少女)_★★★★★\">kill la kill (斩服少女)    ★★★★★</h4><p><img src=\"../../../../img/killlakill.jpg\" width=\"40%\" height=\"40%\"></p>\n<blockquote>\n<p>十分推荐,热血,超展开,世界观奇特(衣服和人类的战斗,啊--剧透了),百合,bgm燃,有泽野大神和小林未郁的合作</p>\n</blockquote>\n<h4 id=\"目隐都市的演绎者_★★★★★\">目隐都市的演绎者    ★★★★★</h4><p><img src=\"../../../../img/yangyan.jpg\" alt=\"\"></p>\n<blockquote>\n<p>很cool的动漫,风格很像物语系列,画风我很喜欢,剧情也不错,前几集完全不明白剧情,看完之后似懂非懂,不是那种看开头就猜到结尾的类型,新房独特的意识流作画方式,还有各种45°角,各种我有姿势我自豪的表现手法,可以说作品很有特色.音乐简直好赞,ed是国歌演唱者Lia唱的,很好听,op更别说,配合各种彩喷画,目隐团集体兜帽衫,真的cool到爆.各种插入曲也很好听,这部作品音乐方面也是上乘之作.喜欢物语系列的一定要看</p>\n</blockquote>\n<h4 id=\"Love_Live_第一季/第二季_★★★★☆\">Love Live 第一季/第二季  ★★★★☆</h4><p><img src=\"../../../../img/lovelive.jpg\" alt=\"\"></p>\n<blockquote>\n<p>lovelive可以说是一款很现象级的作品,手游月流水将近过亿,第二季首周BD销量8w+,上海地铁都有lovelive的包装,这些现象其实与动画的质量是不相称的,其实我在补完两季动画后觉得这动画真的不算神作或者上乘之作,它火的背后其实有很多原因可以探讨,包括企划,宣传什么的,就动画本身而言,塑造了9个性格不同的角色,吸引不同的人群,每次看弹幕都会看到&quot;niconico美如画&quot;&quot;我姬美如画&quot;之类的.我都觉得烦,也看不出美在哪里,音乐方面我到现在想不起什么印象深刻的歌,只记得配角组A-rise的歌很好听,远不是当初轻音no thank you,listen,don&#39;t say lazy, 相遇天使,带我给我的深刻印象.love live第一季的时候还没有这么火,第二季没出之前网上就各种宣传LL大法,只能说LL力量大,企划宣传好,人民群众喜闻乐见的跟风态度.</p>\n</blockquote>\n<p><strong> ---------------------------7月29日更新--------------------------------------</strong></p>\n<h4 id=\"悠哉日常大王_★★★★\">悠哉日常大王 ★★★★</h4><blockquote>\n<p>画质真心很好，风景亮丽，画面党表示很满足，nano.ripe清新的op也很符合我胃口，这部剧诞生了风靡一时的台词“喵帕斯～”，这个台词在动漫里真的很萌，作为一部极其了萝莉，痴女，万年受，炮姐，永远没有台词的神一样的哥哥的日常番，很适合休闲的时候补下。</p>\n</blockquote>\n<h4 id=\"噬魂师Not_★★★\">噬魂师Not  ★★★</h4><blockquote>\n<p>虽然我不是原著党，原著噬魂师我只看了几集。（原著很好，只看了几集是因为一直没时间补），但是仍然想吐槽下这部剧，卖着百合的题材，又到处埋雷是要闹哪样啊喂～而且画质真是不忍直视，这都14年了是在有些觉得粗糙，还没当初噬魂师给我的感觉好。最后还有几集没看完，回头补上。</p>\n</blockquote>\n<h4 id=\"虫师_序章_★★★★★☆\">虫师 序章  ★★★★★☆</h4><blockquote>\n<p>时隔10年,虫师果然没有让人失望,它携带着固有的迷离之音,戴着氤氲的雾气,回到荧屏,片头曲一如既往的让人陶醉,演唱者的声线有点像王若琳,略有成熟,沙哑的感觉.配音依然惯用前作的风格,就像在耳边真实回响,充满生活感.画面不用多说,而且依然是一集一个ED,每首都很好听.我一直觉得任何续作都很大程度上会远远比上作差,尤其虫师这种高质量的动画,实际上没有,是在让我感到欣慰与感动.</p>\n</blockquote>\n<h4 id=\"请问您今天要来点兔子吗_★★★☆\">请问您今天要来点兔子吗  ★★★☆</h4><blockquote>\n<p>普普通通的卖萌番,话说居然有爷爷变成兔子的设定,兔子那么萌,一想到是爷爷顿时都觉得略有X父的感脚...</p>\n</blockquote>\n<h4 id=\"恶魔之谜_★★★☆\">恶魔之谜 ★★★☆</h4><p><img src=\"../../../../img/emozhimi.jpg\" alt=\"\"></p>\n<blockquote>\n<p>本来看画面还不错的.但是剧情实在是无趣,打起来也很没有杀手的样子,而且官方各种把漫画的经典百合镜头省掉了.真想给官方寄刀片.不过cp组什么的在p站还是挺火的.</p>\n</blockquote>\n<h4 id=\"天才麻将少女全国篇_★★★★★\">天才麻将少女全国篇 ★★★★★</h4><p><img src=\"../../../../img/tiancaimajiangshaonv.jpg\" width=\"50%\" height=\"50%\"></p>\n<blockquote>\n<p>基本上是国民级动漫了..知名度很高,基本上全是女生,各种超燃的打麻将方式,各种暧昧的女生友情,简称外挂百合少女.(图片:看我大魔王把你们这些渣渣pia飞~)</p>\n</blockquote>\n<h4 id=\"妄想学生会第二季_★★★★☆\">妄想学生会第二季 ★★★★☆</h4><p><img src=\"../../../../img/wangxiangxueshenghui.png\" alt=\"\"></p>\n<blockquote>\n<p>从没想到曾经轻音里害羞的mio酱,开朗的律队,在这里摇身一变,成了满口黄笑话的学生会长和副会长..男主的存在纯粹是为了吐槽会长的黄笑话...第二季开头画质惊人,漫天飘舞的粉色樱花仿佛告诉你这是一个充满青春气息的校园爱情短篇,然而阳子会用面不改色的讲黄笑话的方式打你的脸.俗称黄段子学生会.</p>\n</blockquote>\n<h4 id=\"中二病也要谈恋爱第二季★★★★☆\">中二病也要谈恋爱第二季★★★★☆</h4><blockquote>\n<p>其实中二病异常的火爆我也不太明白,作为早已远离后宫番的我,森凸是我唯一坚持下去的动力..森大人在角色歌里和第一季ed里面的御姐声线是在太迷人了.不过京都一如既往的高画质水准让中二场景展开时的画面很是惊艳.福山润鲁鲁修的声线也是我看下去的动力把.抛出后宫在我心中的不良印象,这部番还是不错的.</p>\n</blockquote>\n<h4 id=\"樱Trick★★★★\">樱Trick★★★★</h4><blockquote>\n<p>第一集的时候看到满弹幕的&quot;我好兴奋&quot;,着实吃了一惊,芳文社作为百合社真是业界良心,第一集就送上各种赤裸裸的接吻镜头,还有呻吟声....不过作为日常来说,我觉得最重要的不是搞笑就是治愈,而这部我感觉有些太赤裸导致的对各种镜头都无感了. </p>\n</blockquote>\n<h4 id=\"境界的彼方★★★\">境界的彼方★★★</h4><blockquote>\n<p>我不明白为何当初这部番那么火,出了一贯的高清画质,没有什么可圈可点的地方,难道是因为眼镜控众多?⊙﹏⊙b汗.<br>唯一吸引我的也就是有意思的大阪口音和茅原实里的配音了.哎,对这种整天&quot;我不高兴&quot;的口癖仿佛可以加上去般的生硬的女主,是在提不起兴趣.</p>\n</blockquote>\n<h4 id=\"弹丸论破之希望的学园和绝望高中生★★★★☆\">弹丸论破之希望的学园和绝望高中生★★★★☆</h4><p><img src=\"../../../../img/danwanlunpo.jpg\" alt=\"\"></p>\n<blockquote>\n<p>弹丸论破是部不错的动漫,根据游戏改编,其实剧情什么的也就那样,主要是风格与众不同,有点当初看海猫鸣泣之时的感觉,有些游戏里的设定显得与众不同,而且画风也很忠于游戏,熊校长也算是风极一时的角色了.到处可见.而且开头音乐风格简直32个赞.一般动画很少有这种风格.值得一看</p>\n</blockquote>\n<h4 id=\"蔷薇少女第三季★★★★\">蔷薇少女第三季★★★★</h4><blockquote>\n<p>还没看完,作为看过前两季的人来说第三季来的好晚好晚,都已经把之前的剧情忘得差不多了.不过惊喜的当然是画质随着时代的进步终于不再是av画质了.加入了平行世界的情节,感觉比以前好看了,但是怎么感觉少女们怎么有点变小了..</p>\n</blockquote>\n<h4 id=\"黄金拼图★★★★\">黄金拼图★★★★</h4><blockquote>\n<p>俗称黄图,其实这么叫很容易误解成肉番,实质上是个轻百合,还好当初忍过了第一集,因为第一集描写小时候的画风实在是难以忍受,之后长大后突然画风就好了..最近要出第二季了,准备看看.</p>\n</blockquote>\n<h2 id=\"2014_年以前-&gt;\">2014 年以前-----&gt;</h2><hr>\n<h4 id=\"虫师_★★★★★☆\">虫师       ★★★★★☆</h4><blockquote>\n<p>大概在大二暑假补了虫师,虫师是个典型的阳春白雪的类型,我一直把&lt;夏目友人帐&gt;当作下里巴人,并不是多贬低夏目,而是觉得和虫师比起来确实很有这种强烈的对比感,夏目是个大众治愈系,被推荐的太多,而它给我的感觉就是很多故事都很幼稚,刻画也不如虫师那般细腻而又绵绵无声,虫师的有三:其一是音乐,在bangumi的音乐排行上虫师排在第二,它每集的ed都不一样,而且每首都给人以打入感,十分空灵而又优美,契合虫师的妖怪世界.第二:背景画,虫师的人物不是很美形,但是习惯了就觉得有韵味,背景确是十分大气,优美,时常有游走在水墨画的感觉,而且当时负责背景的是一家中国外包公司,很有中国风的味道.放张图你们感受下<br><img src=\"http://youthy-picture.qiniudn.com/857KT6C351H90003.jpg\" alt=\"\"><br>最后是配音.虫师的声优大都不是很出名,但是就是感觉这个声音非常适合这个角色,而且里面的小孩都是找的真实的小孩配的音,不是专业声优,有时你会感觉他们说话是如此的真实.总之虫师是治愈系的良作.</p>\n</blockquote>\n<h4 id=\"叛逆的鲁路修_★★★★\">叛逆的鲁路修      ★★★★</h4><blockquote>\n<p>高中时鲁路修很火,可是我对机甲类实在不感冒,直到大二才补了这部,当时从早上一直看到凌晨3点,看了鲁路修第一部和第二部前7集,我也不知道为什么停不下来,就是很让人想知道接下来的发展.</p>\n</blockquote>\n<h4 id=\"魔法少女小圆_★★★★★\">魔法少女小圆   ★★★★★</h4><p><img src=\"../../../../img/xiaoyuan.jpg\" width=\"50%\" height=\"50%\"></p>\n<blockquote>\n<p>百合启蒙作,在被晓美焰对圆神执着的付出的感动下我走上了不归路...也就是这部剧奠定了神剧标准:第三集开始死人--小圆的题材是很古老的马猴烧酒题材,然后老虚不愧是老虚,把这个快要拍烂的题材拍出了一样的哲学,整部剧围绕着付出,牺牲,时间,循环.沙耶香为了上条定下了契约,她的愿望是为了他而许,然而之后的绝望让她堕落为魔女,而杏子为此内疚,一心想要唤醒沙耶香,甚至为此与沙耶香同归于尽.黑长直更不用说了,为了阻止小圆重蹈魔法少女们的悲剧,她在时间中孤独的行走,孤独的战斗.从一开始我就想要知道,黑长直为什么这么专一的对待小圆,他们之间发生了什么,究竟小圆什么时候才能成为魔法少女,直到最后一集老虚才给我答案...当时看完是夜里3点,为剧情不能自已.小圆的成绩有目共睹,13年新篇剧场版狂卷20亿日元,而这个成绩只有宫崎骏和几部还有口袋妖怪和机器猫那些好多年前的动画电影可以超过,这个数字对于13集的番剧已成神话.</p>\n</blockquote>\n<h4 id=\"凉宫春日的忧郁_★★★★\">凉宫春日的忧郁    ★★★★</h4><blockquote>\n<p>在二次元众很多人喊着要脱团，这个团最初就是指凉宫春日所见的SOS团，这是个神奇的动漫，本来我以为只是个普通的吐槽番，结果然让我一看就一发不可收拾。我也不明白为何当时就找了迷一样一口气看完20多集，而且之后又去补了漫画，补了只有网络放送的小剧场。就是看起来让人很想看下去。剧场版凉宫春日的消失当时也是缔造了票房神话，而且制作水准很高。总之很值得一看。</p>\n</blockquote>\n<h4 id=\"日常_★★★★★★\">日常  ★★★★★★</h4><blockquote>\n<p>占位</p>\n</blockquote>\n<h4 id=\"男子高中生的日常_★★★\">男子高中生的日常 ★★★</h4><blockquote>\n<p>当初看这个纯粹是出于他有日常这两个字，除了第一集给我点惊喜外，之后我就感觉很普通了，可能是由于日常的影响在，我甚至觉得这个想要模仿日常可能没模仿好，毕竟男孩子没有女孩子可爱嘛（pia～飞）。</p>\n</blockquote>\n<h4 id=\"黑礁_★★★★\">黑礁 ★★★★</h4><p><img src=\"../../../../img/heijiao.jpg\" alt=\"\"></p>\n<blockquote>\n<p>黑礁已经有3季了，如果不是同类较优秀的作品是不会有3季的。军火题材，女主莱维是中国人，非常帅气，（对拿枪械的美女没有抵抗力啊～～～）有时经常会蹦出些有哲理的台词。音乐很好听。</p>\n</blockquote>\n<h4 id=\"未闻花名_★★★★\">未闻花名 ★★★★</h4><blockquote>\n<p>画面制作水准很高，讲述从孩童一直到高中时代的朋友间的羁绊。虽然我觉得剧情很幼稚，甚至有些无脑粉的行为让我觉得很无聊，但是在最后一集还是流泪了。音乐给动画增了不少分，每集结尾的ed插入的非常好。</p>\n</blockquote>\n<h4 id=\"命运石之门_★★★★★\">命运石之门 ★★★★★</h4><p><img src=\"../../../../img/mingyunshizhimen.jpg\" width=\"80%\" height=\"80%\"></p>\n<blockquote>\n<p> 终于轮到讲我大命运石之门了，什么?图片上为什么没有凶真？要什么凶真！<br>有我大助手就够了！！好吧，开玩笑。说实话，命运石之门真的是很优秀的作品，由游戏改编，有良好的剧本支撑。这也许是个慢热的作品，刚开始面对凶真中二的不能更中二的行为，也许有些觉得无厘头，但是之后你会慢慢的随着剧情扣紧心心弦，看着凶真不断地在时间跳跃中想要拯救“嘟嘟噜”，但是一次又一次失败，还好，无论在哪个世界，助手的头脑都可以很快的理解并帮助他，这也是纠结所在，最后得知只有在助手死后的世界中“嘟嘟噜”才能活下来，一个是青梅竹马，一个是头脑与自己相当的知音，得力助手，谁都难以抉择..最后助手与凶真的擦身而过，画面更是仍人心动。情节扣人心弦，音乐脍炙人口，人物深得人心，这就是命运石之门，让我们高喊“EL Phy Congroo！！”</p>\n</blockquote>\n<h4 id=\"钢之炼金术师FA\">钢之炼金术师FA</h4><blockquote>\n<p>占位</p>\n</blockquote>\n<h4 id=\"全金属狂潮第二季_★★★★★\">全金属狂潮第二季     ★★★★★</h4><blockquote>\n<p>我只看了全金属狂潮的第二季，因为当初是为了找搞笑番看的，这个是个番外，与正统剧情基本没啥关系，发生在校园里，画风比较老，但是论搞笑程度来说，只能说它绝对值五颗星。</p>\n</blockquote>\n<h4 id=\"超元气三姐妹_★★★★★\">超元气三姐妹  ★★★★★</h4><blockquote>\n<p>又称 “超色情三姐妹”，真的是部很神奇的片子。。。。主角都是类似幼稚园的小学生，有整天拿着小黄书看的老三，有力大无穷的天然呆老大，有坏心眼的老二，有画风与众不同的爸爸，有整天带着“69”帽子的小色鬼，还有略显无能的班主任，这部真的很值得一看，因为实在是很好笑～也很H（有那么一点啦）</p>\n</blockquote>\n<h4 id=\"南家三姐妹_★★★★\">南家三姐妹 ★★★★</h4><blockquote>\n<p>南家三姐妹去年貌似出的第四季。三个姐妹的声优都是美女，而且都是现声优界的一把手。剧情就是高中，初中，小学三个姐妹的日常生活，大姐负责吸引人妻控，二姐是个元气妹，三妹是个腹黑的萝莉。作为个生活日常番质量还是很高的。</p>\n</blockquote>\n<h4 id=\"某科学的超电磁炮_★★★★★\">某科学的超电磁炮 ★★★★★</h4><p><img src=\"../../../../img/chaodiancipao.gif\" alt=\"\"></p>\n<blockquote>\n<p>作为为数不多的番外比本片更好看的动漫,炮姐算是很典型的一例,我入B站较晚,4年前才直到B站,也不清楚是炮姐带红了B站还是B站让炮姐在国内火了.剧情爽快,不拖拉,任务个性鲜明,值得一看. </p>\n</blockquote>\n<h4 id=\"某科学的超电磁炮S_★★★★\">某科学的超电磁炮S ★★★★</h4><blockquote>\n<p>扣了1星,因为第二季,当妈的戏份太多了!!!到处施展把妹之手,尤其是打了一方通行的脸,让我彻底坚信炮姐已经抛弃了黑子,好替黑子伤心&gt;_&lt;.剧情还延续前作的风格,不过炮姐与克隆妹妹之间的互动着实非常有爱,有其抢瓜太徽章的时候,很搞笑,可以说妹妹们为第二季添了不少色彩.</p>\n</blockquote>\n<h4 id=\"Fate/Zero_★★★★★☆\">Fate/Zero  ★★★★★☆</h4><p><img src=\"../../../../img/fatezero.jpg\" alt=\"\"></p>\n<blockquote>\n<p>绝对的大制作,大手笔,画面特效什么的十分精致,而且有老虚坐镇,剧情肯定不是普通日常番能比,唯一觉得遗憾的就是老虚把zero表现的过于倾向于战争了.感情戏份很少,没有想staynight结尾时的saber安静的站在山顶的那种温馨感人的画面.不过仍然是上等之作.</p>\n</blockquote>\n<h4 id=\"Fate_stay_night_★★★★★\">Fate stay night  ★★★★★</h4><blockquote>\n<p>唯一的缺点看来也就是时代所不可避免的画质了吧,至今仍然忘不了结局时吾王在湖边醒来那有点睡眼惺忪又有点望穿一切的眼神,以及站在山顶,一个360度旋转的镜头,真的非常美好.</p>\n</blockquote>\n<h4 id=\"龙与虎_★★★★\">龙与虎 ★★★★</h4><blockquote>\n<p>龙与虎很多人都喜欢,可能不是很和我胃口,我对校园爱情剧不是特别感冒,而且对卷毛萝莉提不起什么兴趣,反倒举得实乃梨这种元气妹应该和男主在一起,或者蓝毛御姐,总觉得tigar还太小...没到谈婚论嫁的年龄..</p>\n</blockquote>\n<h4 id=\"幸运星_★★★★★\">幸运星 ★★★★★</h4><blockquote>\n<p>幸运星的剧情实在是想不起来了,⊙﹏⊙b汗,本来就是日常番,其实也没什么剧情可言,不过当初觉得很好看就是了..</p>\n</blockquote>\n<h4 id=\"一起一起,这里那里_★★★★\">一起一起,这里那里 ★★★★</h4><p><img src=\"../../../../img/yiqiyiqi.gif\" alt=\"\"><br><img src=\"../../../../img/yiqiyiqi2.gif\" alt=\"\"></p>\n<blockquote>\n<p>和幸运星放在了一起,因为人设实在很像,而且也很有爱,动漫的名字都可以看出来就是萌+有爱.</p>\n</blockquote>\n<h4 id=\"白兔糖_★★★★\">白兔糖 ★★★★</h4><p><img src=\"../../../../img/baitutang.jpg\" alt=\"\"></p>\n<blockquote>\n<p>孤儿萝莉和单身老男人的生活?动画还算是个治愈系,写的就是小萝莉是老男人的爷爷与年轻女仆的私生女,爷爷去世了,女仆一时消失,面临无人抚养的时候,30岁的老男人挑起了抚养她的担子,写的很贴近生活,很朴素.而且有电影版,主演还是死亡笔记的L松山健一.动画是小萝莉小时候的事,据说漫画之后发展成父嫁了..汗.</p>\n</blockquote>\n<h4 id=\"寒蝉鸣泣之时_★★★★\">寒蝉鸣泣之时 ★★★★</h4><blockquote>\n<p>喜欢寒蝉的人也挺多的.我只看了一季,也就只看了迷,而没有看解,所以发生了什么还是云里雾里.就是个男主不断做错误的抉择而被杀死,而又从新读档,再被杀死的故事....根据游戏改编的.</p>\n</blockquote>\n<h4 id=\"玉子市场_★★★★\">玉子市场  ★★★★</h4><blockquote>\n<p>其实没什么特别的.主要是主任在片中各种卖萌捧场,普通的日常番.本来还挺期待小绿和玉子的cp,结果官方都透露无情的bg结局.哎,看了一季,准备弃了.</p>\n</blockquote>\n<h4 id=\"我女友与青梅竹马的惨烈修罗场_★★★★\">我女友与青梅竹马的惨烈修罗场 ★★★★</h4><blockquote>\n<p>很明显的后宫番,我也纳闷年轻的自己竟然能看得下去后宫番,大概因为斋藤千和和田村打大魔王作为主役声优把.<br>还好,男主是有实力的人,而不是无脑男主坐拥一大堆后宫.还可以接受.</p>\n</blockquote>\n<h4 id=\"青之驱魔师_★☆\">青之驱魔师 ★☆</h4><blockquote>\n<p>我实在是很想吐槽这个番，当初是因为看了corepride的现场live才去补的这个动漫，实在是太渣了！！自古渣片出燃曲，白瞎了corepride这么燃个歌了。剧情简直有够了，没有什么吸引力，主要是难住太气人了，我看着都难受啊～哪有这么笨，这么不会说话，这么没大脑的男主！！哎，想起来就来气，剧情一般就算了，主要是男主有够白痴，让我一点都不想看下去。就这样了，继续走百合路线吧。。。</p>\n</blockquote>\n<p>(未完...)</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>一直都有想法想把看过的番剧列一个表,我会慢慢想起看过的番剧,然后在这里补全,写一些自己的评价,以供回忆</p>\n</blockquote>","more":"<!-- toc -->\n<ul>\n<li><a href=\"#2014--\">2014 年</a><ul>\n<li><a href=\"#----------\">少女革命 ★★★★★</a></li>\n<li><a href=\"#-------------\">月刊少女野崎君 ★★★★★</a></li>\n<li><a href=\"#-----------\">生存游戏部 ★★★★★</a></li>\n<li><a href=\"#--hime------\">舞-hime ★★★★☆</a></li>\n<li><a href=\"#kill-la-kill----------------\">kill la kill (斩服少女)    ★★★★★</a></li>\n<li><a href=\"#-----------------\">目隐都市的演绎者    ★★★★★</a></li>\n<li><a href=\"#love-live---------------\">Love Live 第一季/第二季  ★★★★☆</a></li>\n<li><a href=\"#-----------\">悠哉日常大王 ★★★★</a></li>\n<li><a href=\"#---not-----\">噬魂师Not  ★★★</a></li>\n<li><a href=\"#-------------\">虫师 序章  ★★★★★☆</a></li>\n<li><a href=\"#-----------------\">请问您今天要来点兔子吗  ★★★☆</a></li>\n<li><a href=\"#---------\">恶魔之谜 ★★★☆</a></li>\n<li><a href=\"#---------------\">天才麻将少女全国篇 ★★★★★</a></li>\n<li><a href=\"#--------------\">妄想学生会第二季 ★★★★☆</a></li>\n<li><a href=\"#----------------\">中二病也要谈恋爱第二季★★★★☆</a></li>\n<li><a href=\"#-trick----\">樱Trick★★★★</a></li>\n<li><a href=\"#--------\">境界的彼方★★★</a></li>\n<li><a href=\"#---------------------\">弹丸论破之希望的学园和绝望高中生★★★★☆</a></li>\n<li><a href=\"#-----------\">蔷薇少女第三季★★★★</a></li>\n<li><a href=\"#--------\">黄金拼图★★★★</a></li>\n</ul>\n</li>\n<li><a href=\"#2014----------\">2014 年以前-----&gt;</a><ul>\n<li><a href=\"#---------------\">虫师       ★★★★★☆</a></li>\n<li><a href=\"#----------------\">叛逆的鲁路修      ★★★★</a></li>\n<li><a href=\"#--------------\">魔法少女小圆   ★★★★★</a></li>\n<li><a href=\"#---------------\">凉宫春日的忧郁    ★★★★</a></li>\n<li><a href=\"#----------\">日常  ★★★★★★</a></li>\n<li><a href=\"#------------\">男子高中生的日常 ★★★</a></li>\n<li><a href=\"#-------\">黑礁 ★★★★</a></li>\n<li><a href=\"#---------\">未闻花名 ★★★★</a></li>\n<li><a href=\"#-----------\">命运石之门 ★★★★★</a></li>\n<li><a href=\"#------fa\">钢之炼金术师FA</a></li>\n<li><a href=\"#------------------\">全金属狂潮第二季     ★★★★★</a></li>\n<li><a href=\"#-------------\">超元气三姐妹  ★★★★★</a></li>\n<li><a href=\"#----------\">南家三姐妹 ★★★★</a></li>\n<li><a href=\"#--------------\">某科学的超电磁炮 ★★★★★</a></li>\n<li><a href=\"#--------s-----\">某科学的超电磁炮S ★★★★</a></li>\n<li><a href=\"#fate-zero--------\">Fate/Zero  ★★★★★☆</a></li>\n<li><a href=\"#fate-stay-night-------\">Fate stay night  ★★★★★</a></li>\n<li><a href=\"#--------\">龙与虎 ★★★★</a></li>\n<li><a href=\"#---------\">幸运星 ★★★★★</a></li>\n<li><a href=\"#--------------\">一起一起,这里那里 ★★★★</a></li>\n<li><a href=\"#--------\">白兔糖 ★★★★</a></li>\n<li><a href=\"#-----------\">寒蝉鸣泣之时 ★★★★</a></li>\n<li><a href=\"#----------\">玉子市场  ★★★★</a></li>\n<li><a href=\"#-------------------\">我女友与青梅竹马的惨烈修罗场 ★★★★</a></li>\n<li><a href=\"#--------\">青之驱魔师 ★☆</a></li>\n</ul>\n</li>\n</ul>\n<!-- tocstop -->\n<h2 id=\"2014_年\">2014 年</h2><p><strong> ---------------------------9月18日更新--------------------------------------</strong></p>\n<h4 id=\"少女革命_★★★★★\">少女革命 ★★★★★</h4><blockquote>\n<p>90年代3大OTAKU神作之一,以少女寻找王子的故事线表现女权的解放与抗争,少女的自我救赎,主旨上与今年的迪士尼的冰雪女王一样,很多表现手法很超前,甚至觉得有些梗真不像是90年代的,不得不佩服几原老贼的超前思想.</p>\n</blockquote>\n<h4 id=\"月刊少女野崎君_★★★★★\">月刊少女野崎君 ★★★★★</h4><blockquote>\n<p>典型的少女漫画般的开场,色调浪漫,少女表白,以为是一部校园恋情剧你就输了,实际上是部搞笑剧,女主意外的萌,男主无口且木讷.几位配角刻画非常成功,不是典型的校园剧,很难得</p>\n</blockquote>\n<h4 id=\"生存游戏部_★★★★★\">生存游戏部 ★★★★★</h4><blockquote>\n<p>这个月新番也就认真追了生存游戏部和月刊少女,两部在我看来都很有突破,生存游戏部女主也不是按正常套路出牌,内心比较黑暗,在善与恶的选择中肯定会选择恶的人格.而且很搞笑.</p>\n</blockquote>\n<h4 id=\"舞-hime_★★★★☆\">舞-hime ★★★★☆</h4><blockquote>\n<p>补了部老番,冲着静夏去的.貌似对有点东京口音或者大阪口音的声优有种莫名的喜欢-.-</p>\n</blockquote>\n<p><strong> ---------------------------7月29日更新--------------------------------------</strong></p>\n<h4 id=\"kill_la_kill_(斩服少女)_★★★★★\">kill la kill (斩服少女)    ★★★★★</h4><p><img src=\"../../../../img/killlakill.jpg\" width=\"40%\" height=\"40%\"></p>\n<blockquote>\n<p>十分推荐,热血,超展开,世界观奇特(衣服和人类的战斗,啊--剧透了),百合,bgm燃,有泽野大神和小林未郁的合作</p>\n</blockquote>\n<h4 id=\"目隐都市的演绎者_★★★★★\">目隐都市的演绎者    ★★★★★</h4><p><img src=\"../../../../img/yangyan.jpg\" alt=\"\"></p>\n<blockquote>\n<p>很cool的动漫,风格很像物语系列,画风我很喜欢,剧情也不错,前几集完全不明白剧情,看完之后似懂非懂,不是那种看开头就猜到结尾的类型,新房独特的意识流作画方式,还有各种45°角,各种我有姿势我自豪的表现手法,可以说作品很有特色.音乐简直好赞,ed是国歌演唱者Lia唱的,很好听,op更别说,配合各种彩喷画,目隐团集体兜帽衫,真的cool到爆.各种插入曲也很好听,这部作品音乐方面也是上乘之作.喜欢物语系列的一定要看</p>\n</blockquote>\n<h4 id=\"Love_Live_第一季/第二季_★★★★☆\">Love Live 第一季/第二季  ★★★★☆</h4><p><img src=\"../../../../img/lovelive.jpg\" alt=\"\"></p>\n<blockquote>\n<p>lovelive可以说是一款很现象级的作品,手游月流水将近过亿,第二季首周BD销量8w+,上海地铁都有lovelive的包装,这些现象其实与动画的质量是不相称的,其实我在补完两季动画后觉得这动画真的不算神作或者上乘之作,它火的背后其实有很多原因可以探讨,包括企划,宣传什么的,就动画本身而言,塑造了9个性格不同的角色,吸引不同的人群,每次看弹幕都会看到&quot;niconico美如画&quot;&quot;我姬美如画&quot;之类的.我都觉得烦,也看不出美在哪里,音乐方面我到现在想不起什么印象深刻的歌,只记得配角组A-rise的歌很好听,远不是当初轻音no thank you,listen,don&#39;t say lazy, 相遇天使,带我给我的深刻印象.love live第一季的时候还没有这么火,第二季没出之前网上就各种宣传LL大法,只能说LL力量大,企划宣传好,人民群众喜闻乐见的跟风态度.</p>\n</blockquote>\n<p><strong> ---------------------------7月29日更新--------------------------------------</strong></p>\n<h4 id=\"悠哉日常大王_★★★★\">悠哉日常大王 ★★★★</h4><blockquote>\n<p>画质真心很好，风景亮丽，画面党表示很满足，nano.ripe清新的op也很符合我胃口，这部剧诞生了风靡一时的台词“喵帕斯～”，这个台词在动漫里真的很萌，作为一部极其了萝莉，痴女，万年受，炮姐，永远没有台词的神一样的哥哥的日常番，很适合休闲的时候补下。</p>\n</blockquote>\n<h4 id=\"噬魂师Not_★★★\">噬魂师Not  ★★★</h4><blockquote>\n<p>虽然我不是原著党，原著噬魂师我只看了几集。（原著很好，只看了几集是因为一直没时间补），但是仍然想吐槽下这部剧，卖着百合的题材，又到处埋雷是要闹哪样啊喂～而且画质真是不忍直视，这都14年了是在有些觉得粗糙，还没当初噬魂师给我的感觉好。最后还有几集没看完，回头补上。</p>\n</blockquote>\n<h4 id=\"虫师_序章_★★★★★☆\">虫师 序章  ★★★★★☆</h4><blockquote>\n<p>时隔10年,虫师果然没有让人失望,它携带着固有的迷离之音,戴着氤氲的雾气,回到荧屏,片头曲一如既往的让人陶醉,演唱者的声线有点像王若琳,略有成熟,沙哑的感觉.配音依然惯用前作的风格,就像在耳边真实回响,充满生活感.画面不用多说,而且依然是一集一个ED,每首都很好听.我一直觉得任何续作都很大程度上会远远比上作差,尤其虫师这种高质量的动画,实际上没有,是在让我感到欣慰与感动.</p>\n</blockquote>\n<h4 id=\"请问您今天要来点兔子吗_★★★☆\">请问您今天要来点兔子吗  ★★★☆</h4><blockquote>\n<p>普普通通的卖萌番,话说居然有爷爷变成兔子的设定,兔子那么萌,一想到是爷爷顿时都觉得略有X父的感脚...</p>\n</blockquote>\n<h4 id=\"恶魔之谜_★★★☆\">恶魔之谜 ★★★☆</h4><p><img src=\"../../../../img/emozhimi.jpg\" alt=\"\"></p>\n<blockquote>\n<p>本来看画面还不错的.但是剧情实在是无趣,打起来也很没有杀手的样子,而且官方各种把漫画的经典百合镜头省掉了.真想给官方寄刀片.不过cp组什么的在p站还是挺火的.</p>\n</blockquote>\n<h4 id=\"天才麻将少女全国篇_★★★★★\">天才麻将少女全国篇 ★★★★★</h4><p><img src=\"../../../../img/tiancaimajiangshaonv.jpg\" width=\"50%\" height=\"50%\"></p>\n<blockquote>\n<p>基本上是国民级动漫了..知名度很高,基本上全是女生,各种超燃的打麻将方式,各种暧昧的女生友情,简称外挂百合少女.(图片:看我大魔王把你们这些渣渣pia飞~)</p>\n</blockquote>\n<h4 id=\"妄想学生会第二季_★★★★☆\">妄想学生会第二季 ★★★★☆</h4><p><img src=\"../../../../img/wangxiangxueshenghui.png\" alt=\"\"></p>\n<blockquote>\n<p>从没想到曾经轻音里害羞的mio酱,开朗的律队,在这里摇身一变,成了满口黄笑话的学生会长和副会长..男主的存在纯粹是为了吐槽会长的黄笑话...第二季开头画质惊人,漫天飘舞的粉色樱花仿佛告诉你这是一个充满青春气息的校园爱情短篇,然而阳子会用面不改色的讲黄笑话的方式打你的脸.俗称黄段子学生会.</p>\n</blockquote>\n<h4 id=\"中二病也要谈恋爱第二季★★★★☆\">中二病也要谈恋爱第二季★★★★☆</h4><blockquote>\n<p>其实中二病异常的火爆我也不太明白,作为早已远离后宫番的我,森凸是我唯一坚持下去的动力..森大人在角色歌里和第一季ed里面的御姐声线是在太迷人了.不过京都一如既往的高画质水准让中二场景展开时的画面很是惊艳.福山润鲁鲁修的声线也是我看下去的动力把.抛出后宫在我心中的不良印象,这部番还是不错的.</p>\n</blockquote>\n<h4 id=\"樱Trick★★★★\">樱Trick★★★★</h4><blockquote>\n<p>第一集的时候看到满弹幕的&quot;我好兴奋&quot;,着实吃了一惊,芳文社作为百合社真是业界良心,第一集就送上各种赤裸裸的接吻镜头,还有呻吟声....不过作为日常来说,我觉得最重要的不是搞笑就是治愈,而这部我感觉有些太赤裸导致的对各种镜头都无感了. </p>\n</blockquote>\n<h4 id=\"境界的彼方★★★\">境界的彼方★★★</h4><blockquote>\n<p>我不明白为何当初这部番那么火,出了一贯的高清画质,没有什么可圈可点的地方,难道是因为眼镜控众多?⊙﹏⊙b汗.<br>唯一吸引我的也就是有意思的大阪口音和茅原实里的配音了.哎,对这种整天&quot;我不高兴&quot;的口癖仿佛可以加上去般的生硬的女主,是在提不起兴趣.</p>\n</blockquote>\n<h4 id=\"弹丸论破之希望的学园和绝望高中生★★★★☆\">弹丸论破之希望的学园和绝望高中生★★★★☆</h4><p><img src=\"../../../../img/danwanlunpo.jpg\" alt=\"\"></p>\n<blockquote>\n<p>弹丸论破是部不错的动漫,根据游戏改编,其实剧情什么的也就那样,主要是风格与众不同,有点当初看海猫鸣泣之时的感觉,有些游戏里的设定显得与众不同,而且画风也很忠于游戏,熊校长也算是风极一时的角色了.到处可见.而且开头音乐风格简直32个赞.一般动画很少有这种风格.值得一看</p>\n</blockquote>\n<h4 id=\"蔷薇少女第三季★★★★\">蔷薇少女第三季★★★★</h4><blockquote>\n<p>还没看完,作为看过前两季的人来说第三季来的好晚好晚,都已经把之前的剧情忘得差不多了.不过惊喜的当然是画质随着时代的进步终于不再是av画质了.加入了平行世界的情节,感觉比以前好看了,但是怎么感觉少女们怎么有点变小了..</p>\n</blockquote>\n<h4 id=\"黄金拼图★★★★\">黄金拼图★★★★</h4><blockquote>\n<p>俗称黄图,其实这么叫很容易误解成肉番,实质上是个轻百合,还好当初忍过了第一集,因为第一集描写小时候的画风实在是难以忍受,之后长大后突然画风就好了..最近要出第二季了,准备看看.</p>\n</blockquote>\n<h2 id=\"2014_年以前-&gt;\">2014 年以前-----&gt;</h2><hr>\n<h4 id=\"虫师_★★★★★☆\">虫师       ★★★★★☆</h4><blockquote>\n<p>大概在大二暑假补了虫师,虫师是个典型的阳春白雪的类型,我一直把&lt;夏目友人帐&gt;当作下里巴人,并不是多贬低夏目,而是觉得和虫师比起来确实很有这种强烈的对比感,夏目是个大众治愈系,被推荐的太多,而它给我的感觉就是很多故事都很幼稚,刻画也不如虫师那般细腻而又绵绵无声,虫师的有三:其一是音乐,在bangumi的音乐排行上虫师排在第二,它每集的ed都不一样,而且每首都给人以打入感,十分空灵而又优美,契合虫师的妖怪世界.第二:背景画,虫师的人物不是很美形,但是习惯了就觉得有韵味,背景确是十分大气,优美,时常有游走在水墨画的感觉,而且当时负责背景的是一家中国外包公司,很有中国风的味道.放张图你们感受下<br><img src=\"http://youthy-picture.qiniudn.com/857KT6C351H90003.jpg\" alt=\"\"><br>最后是配音.虫师的声优大都不是很出名,但是就是感觉这个声音非常适合这个角色,而且里面的小孩都是找的真实的小孩配的音,不是专业声优,有时你会感觉他们说话是如此的真实.总之虫师是治愈系的良作.</p>\n</blockquote>\n<h4 id=\"叛逆的鲁路修_★★★★\">叛逆的鲁路修      ★★★★</h4><blockquote>\n<p>高中时鲁路修很火,可是我对机甲类实在不感冒,直到大二才补了这部,当时从早上一直看到凌晨3点,看了鲁路修第一部和第二部前7集,我也不知道为什么停不下来,就是很让人想知道接下来的发展.</p>\n</blockquote>\n<h4 id=\"魔法少女小圆_★★★★★\">魔法少女小圆   ★★★★★</h4><p><img src=\"../../../../img/xiaoyuan.jpg\" width=\"50%\" height=\"50%\"></p>\n<blockquote>\n<p>百合启蒙作,在被晓美焰对圆神执着的付出的感动下我走上了不归路...也就是这部剧奠定了神剧标准:第三集开始死人--小圆的题材是很古老的马猴烧酒题材,然后老虚不愧是老虚,把这个快要拍烂的题材拍出了一样的哲学,整部剧围绕着付出,牺牲,时间,循环.沙耶香为了上条定下了契约,她的愿望是为了他而许,然而之后的绝望让她堕落为魔女,而杏子为此内疚,一心想要唤醒沙耶香,甚至为此与沙耶香同归于尽.黑长直更不用说了,为了阻止小圆重蹈魔法少女们的悲剧,她在时间中孤独的行走,孤独的战斗.从一开始我就想要知道,黑长直为什么这么专一的对待小圆,他们之间发生了什么,究竟小圆什么时候才能成为魔法少女,直到最后一集老虚才给我答案...当时看完是夜里3点,为剧情不能自已.小圆的成绩有目共睹,13年新篇剧场版狂卷20亿日元,而这个成绩只有宫崎骏和几部还有口袋妖怪和机器猫那些好多年前的动画电影可以超过,这个数字对于13集的番剧已成神话.</p>\n</blockquote>\n<h4 id=\"凉宫春日的忧郁_★★★★\">凉宫春日的忧郁    ★★★★</h4><blockquote>\n<p>在二次元众很多人喊着要脱团，这个团最初就是指凉宫春日所见的SOS团，这是个神奇的动漫，本来我以为只是个普通的吐槽番，结果然让我一看就一发不可收拾。我也不明白为何当时就找了迷一样一口气看完20多集，而且之后又去补了漫画，补了只有网络放送的小剧场。就是看起来让人很想看下去。剧场版凉宫春日的消失当时也是缔造了票房神话，而且制作水准很高。总之很值得一看。</p>\n</blockquote>\n<h4 id=\"日常_★★★★★★\">日常  ★★★★★★</h4><blockquote>\n<p>占位</p>\n</blockquote>\n<h4 id=\"男子高中生的日常_★★★\">男子高中生的日常 ★★★</h4><blockquote>\n<p>当初看这个纯粹是出于他有日常这两个字，除了第一集给我点惊喜外，之后我就感觉很普通了，可能是由于日常的影响在，我甚至觉得这个想要模仿日常可能没模仿好，毕竟男孩子没有女孩子可爱嘛（pia～飞）。</p>\n</blockquote>\n<h4 id=\"黑礁_★★★★\">黑礁 ★★★★</h4><p><img src=\"../../../../img/heijiao.jpg\" alt=\"\"></p>\n<blockquote>\n<p>黑礁已经有3季了，如果不是同类较优秀的作品是不会有3季的。军火题材，女主莱维是中国人，非常帅气，（对拿枪械的美女没有抵抗力啊～～～）有时经常会蹦出些有哲理的台词。音乐很好听。</p>\n</blockquote>\n<h4 id=\"未闻花名_★★★★\">未闻花名 ★★★★</h4><blockquote>\n<p>画面制作水准很高，讲述从孩童一直到高中时代的朋友间的羁绊。虽然我觉得剧情很幼稚，甚至有些无脑粉的行为让我觉得很无聊，但是在最后一集还是流泪了。音乐给动画增了不少分，每集结尾的ed插入的非常好。</p>\n</blockquote>\n<h4 id=\"命运石之门_★★★★★\">命运石之门 ★★★★★</h4><p><img src=\"../../../../img/mingyunshizhimen.jpg\" width=\"80%\" height=\"80%\"></p>\n<blockquote>\n<p> 终于轮到讲我大命运石之门了，什么?图片上为什么没有凶真？要什么凶真！<br>有我大助手就够了！！好吧，开玩笑。说实话，命运石之门真的是很优秀的作品，由游戏改编，有良好的剧本支撑。这也许是个慢热的作品，刚开始面对凶真中二的不能更中二的行为，也许有些觉得无厘头，但是之后你会慢慢的随着剧情扣紧心心弦，看着凶真不断地在时间跳跃中想要拯救“嘟嘟噜”，但是一次又一次失败，还好，无论在哪个世界，助手的头脑都可以很快的理解并帮助他，这也是纠结所在，最后得知只有在助手死后的世界中“嘟嘟噜”才能活下来，一个是青梅竹马，一个是头脑与自己相当的知音，得力助手，谁都难以抉择..最后助手与凶真的擦身而过，画面更是仍人心动。情节扣人心弦，音乐脍炙人口，人物深得人心，这就是命运石之门，让我们高喊“EL Phy Congroo！！”</p>\n</blockquote>\n<h4 id=\"钢之炼金术师FA\">钢之炼金术师FA</h4><blockquote>\n<p>占位</p>\n</blockquote>\n<h4 id=\"全金属狂潮第二季_★★★★★\">全金属狂潮第二季     ★★★★★</h4><blockquote>\n<p>我只看了全金属狂潮的第二季，因为当初是为了找搞笑番看的，这个是个番外，与正统剧情基本没啥关系，发生在校园里，画风比较老，但是论搞笑程度来说，只能说它绝对值五颗星。</p>\n</blockquote>\n<h4 id=\"超元气三姐妹_★★★★★\">超元气三姐妹  ★★★★★</h4><blockquote>\n<p>又称 “超色情三姐妹”，真的是部很神奇的片子。。。。主角都是类似幼稚园的小学生，有整天拿着小黄书看的老三，有力大无穷的天然呆老大，有坏心眼的老二，有画风与众不同的爸爸，有整天带着“69”帽子的小色鬼，还有略显无能的班主任，这部真的很值得一看，因为实在是很好笑～也很H（有那么一点啦）</p>\n</blockquote>\n<h4 id=\"南家三姐妹_★★★★\">南家三姐妹 ★★★★</h4><blockquote>\n<p>南家三姐妹去年貌似出的第四季。三个姐妹的声优都是美女，而且都是现声优界的一把手。剧情就是高中，初中，小学三个姐妹的日常生活，大姐负责吸引人妻控，二姐是个元气妹，三妹是个腹黑的萝莉。作为个生活日常番质量还是很高的。</p>\n</blockquote>\n<h4 id=\"某科学的超电磁炮_★★★★★\">某科学的超电磁炮 ★★★★★</h4><p><img src=\"../../../../img/chaodiancipao.gif\" alt=\"\"></p>\n<blockquote>\n<p>作为为数不多的番外比本片更好看的动漫,炮姐算是很典型的一例,我入B站较晚,4年前才直到B站,也不清楚是炮姐带红了B站还是B站让炮姐在国内火了.剧情爽快,不拖拉,任务个性鲜明,值得一看. </p>\n</blockquote>\n<h4 id=\"某科学的超电磁炮S_★★★★\">某科学的超电磁炮S ★★★★</h4><blockquote>\n<p>扣了1星,因为第二季,当妈的戏份太多了!!!到处施展把妹之手,尤其是打了一方通行的脸,让我彻底坚信炮姐已经抛弃了黑子,好替黑子伤心&gt;_&lt;.剧情还延续前作的风格,不过炮姐与克隆妹妹之间的互动着实非常有爱,有其抢瓜太徽章的时候,很搞笑,可以说妹妹们为第二季添了不少色彩.</p>\n</blockquote>\n<h4 id=\"Fate/Zero_★★★★★☆\">Fate/Zero  ★★★★★☆</h4><p><img src=\"../../../../img/fatezero.jpg\" alt=\"\"></p>\n<blockquote>\n<p>绝对的大制作,大手笔,画面特效什么的十分精致,而且有老虚坐镇,剧情肯定不是普通日常番能比,唯一觉得遗憾的就是老虚把zero表现的过于倾向于战争了.感情戏份很少,没有想staynight结尾时的saber安静的站在山顶的那种温馨感人的画面.不过仍然是上等之作.</p>\n</blockquote>\n<h4 id=\"Fate_stay_night_★★★★★\">Fate stay night  ★★★★★</h4><blockquote>\n<p>唯一的缺点看来也就是时代所不可避免的画质了吧,至今仍然忘不了结局时吾王在湖边醒来那有点睡眼惺忪又有点望穿一切的眼神,以及站在山顶,一个360度旋转的镜头,真的非常美好.</p>\n</blockquote>\n<h4 id=\"龙与虎_★★★★\">龙与虎 ★★★★</h4><blockquote>\n<p>龙与虎很多人都喜欢,可能不是很和我胃口,我对校园爱情剧不是特别感冒,而且对卷毛萝莉提不起什么兴趣,反倒举得实乃梨这种元气妹应该和男主在一起,或者蓝毛御姐,总觉得tigar还太小...没到谈婚论嫁的年龄..</p>\n</blockquote>\n<h4 id=\"幸运星_★★★★★\">幸运星 ★★★★★</h4><blockquote>\n<p>幸运星的剧情实在是想不起来了,⊙﹏⊙b汗,本来就是日常番,其实也没什么剧情可言,不过当初觉得很好看就是了..</p>\n</blockquote>\n<h4 id=\"一起一起,这里那里_★★★★\">一起一起,这里那里 ★★★★</h4><p><img src=\"../../../../img/yiqiyiqi.gif\" alt=\"\"><br><img src=\"../../../../img/yiqiyiqi2.gif\" alt=\"\"></p>\n<blockquote>\n<p>和幸运星放在了一起,因为人设实在很像,而且也很有爱,动漫的名字都可以看出来就是萌+有爱.</p>\n</blockquote>\n<h4 id=\"白兔糖_★★★★\">白兔糖 ★★★★</h4><p><img src=\"../../../../img/baitutang.jpg\" alt=\"\"></p>\n<blockquote>\n<p>孤儿萝莉和单身老男人的生活?动画还算是个治愈系,写的就是小萝莉是老男人的爷爷与年轻女仆的私生女,爷爷去世了,女仆一时消失,面临无人抚养的时候,30岁的老男人挑起了抚养她的担子,写的很贴近生活,很朴素.而且有电影版,主演还是死亡笔记的L松山健一.动画是小萝莉小时候的事,据说漫画之后发展成父嫁了..汗.</p>\n</blockquote>\n<h4 id=\"寒蝉鸣泣之时_★★★★\">寒蝉鸣泣之时 ★★★★</h4><blockquote>\n<p>喜欢寒蝉的人也挺多的.我只看了一季,也就只看了迷,而没有看解,所以发生了什么还是云里雾里.就是个男主不断做错误的抉择而被杀死,而又从新读档,再被杀死的故事....根据游戏改编的.</p>\n</blockquote>\n<h4 id=\"玉子市场_★★★★\">玉子市场  ★★★★</h4><blockquote>\n<p>其实没什么特别的.主要是主任在片中各种卖萌捧场,普通的日常番.本来还挺期待小绿和玉子的cp,结果官方都透露无情的bg结局.哎,看了一季,准备弃了.</p>\n</blockquote>\n<h4 id=\"我女友与青梅竹马的惨烈修罗场_★★★★\">我女友与青梅竹马的惨烈修罗场 ★★★★</h4><blockquote>\n<p>很明显的后宫番,我也纳闷年轻的自己竟然能看得下去后宫番,大概因为斋藤千和和田村打大魔王作为主役声优把.<br>还好,男主是有实力的人,而不是无脑男主坐拥一大堆后宫.还可以接受.</p>\n</blockquote>\n<h4 id=\"青之驱魔师_★☆\">青之驱魔师 ★☆</h4><blockquote>\n<p>我实在是很想吐槽这个番，当初是因为看了corepride的现场live才去补的这个动漫，实在是太渣了！！自古渣片出燃曲，白瞎了corepride这么燃个歌了。剧情简直有够了，没有什么吸引力，主要是难住太气人了，我看着都难受啊～哪有这么笨，这么不会说话，这么没大脑的男主！！哎，想起来就来气，剧情一般就算了，主要是男主有够白痴，让我一点都不想看下去。就这样了，继续走百合路线吧。。。</p>\n</blockquote>\n<p>(未完...)</p>"},{"title":"今天看了变形金刚4","date":"2014-06-29T17:25:29.000Z","_content":"\n  今天12点多才回到的住房，和几个同学看了9点20的变形金刚4，足足2个小时40分钟！！超值的好嘛!\n\n<!--more-->\n\n我觉得45的票价很值了，毕竟画面那么好，不过比变3也没什么进步就是了。而且历来看变形金刚我就不知道\n剧情为何物！变三跟变四有什么联系！为何擎天柱一出来就是一个残废！这个变3怎么突变过来的！为何一个农民科学家各种刁，\n最后拿起冲锋剑，或者叫枪，替擎天柱打boss.\n  女主长的还不错，但是米国人好早熟啊，身材那么好还告诉我17岁！！\n  李冰冰真是到处演龙套啊～～～外国人是有多喜欢她，各种广告乱入啊～怡宝，舒化奶给个镜头也就算了，红牛居然还有台词！\n  女婿说：“我已经入选了红牛车队“（我就是很屌）\n  我擦，红牛你给了多少钱！\n  邹市明从屌丝男士那里学的爱跑龙套了，出来给那几个老外一顿拳，好不风骚，好，邹兄弟，我退役不用愁转型了\n  其实我感觉霸天虎他们复活后明明能力高了一个档次，都可以自由的变成碎片然后又汇合，为何还是给擎天柱打的全都死了，只剩\n霸天虎：“我还会回来的”\n  好吧，吐槽归吐槽，还是阻挡不了变形金刚就是一个经典，无可替代，他的制作水平我们仍然很难企及。\n  值得高兴的是我这是大学第一次坐在女同学旁边看电影呦～好吧，一个悲伤的故事。\n  总之，45块看变形金刚4还是值得的。尤其有美女陪着hiahiahia\n  就这样，太晚了 明还早起上班 sigh\n","source":"_posts/今天看了变形金刚4.md","raw":"title: 今天看了变形金刚4\ndate: 2014-06-30 01:25:29\ntags: 电影\ncategories: 杂谈\n---\n\n  今天12点多才回到的住房，和几个同学看了9点20的变形金刚4，足足2个小时40分钟！！超值的好嘛!\n\n<!--more-->\n\n我觉得45的票价很值了，毕竟画面那么好，不过比变3也没什么进步就是了。而且历来看变形金刚我就不知道\n剧情为何物！变三跟变四有什么联系！为何擎天柱一出来就是一个残废！这个变3怎么突变过来的！为何一个农民科学家各种刁，\n最后拿起冲锋剑，或者叫枪，替擎天柱打boss.\n  女主长的还不错，但是米国人好早熟啊，身材那么好还告诉我17岁！！\n  李冰冰真是到处演龙套啊～～～外国人是有多喜欢她，各种广告乱入啊～怡宝，舒化奶给个镜头也就算了，红牛居然还有台词！\n  女婿说：“我已经入选了红牛车队“（我就是很屌）\n  我擦，红牛你给了多少钱！\n  邹市明从屌丝男士那里学的爱跑龙套了，出来给那几个老外一顿拳，好不风骚，好，邹兄弟，我退役不用愁转型了\n  其实我感觉霸天虎他们复活后明明能力高了一个档次，都可以自由的变成碎片然后又汇合，为何还是给擎天柱打的全都死了，只剩\n霸天虎：“我还会回来的”\n  好吧，吐槽归吐槽，还是阻挡不了变形金刚就是一个经典，无可替代，他的制作水平我们仍然很难企及。\n  值得高兴的是我这是大学第一次坐在女同学旁边看电影呦～好吧，一个悲伤的故事。\n  总之，45块看变形金刚4还是值得的。尤其有美女陪着hiahiahia\n  就这样，太晚了 明还早起上班 sigh\n","slug":"今天看了变形金刚4","published":1,"updated":"2018-06-26T09:49:27.739Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqw7jdwh001w6f1r586z6dtv","content":"<p>今天12点多才回到的住房，和几个同学看了9点20的变形金刚4，足足2个小时40分钟！！超值的好嘛!</p>\n<span id=\"more\"></span>\n<p>我觉得45的票价很值了，毕竟画面那么好，不过比变3也没什么进步就是了。而且历来看变形金刚我就不知道<br>剧情为何物！变三跟变四有什么联系！为何擎天柱一出来就是一个残废！这个变3怎么突变过来的！为何一个农民科学家各种刁，<br>最后拿起冲锋剑，或者叫枪，替擎天柱打boss.<br>  女主长的还不错，但是米国人好早熟啊，身材那么好还告诉我17岁！！<br>  李冰冰真是到处演龙套啊～～～外国人是有多喜欢她，各种广告乱入啊～怡宝，舒化奶给个镜头也就算了，红牛居然还有台词！<br>  女婿说：“我已经入选了红牛车队“（我就是很屌）<br>  我擦，红牛你给了多少钱！<br>  邹市明从屌丝男士那里学的爱跑龙套了，出来给那几个老外一顿拳，好不风骚，好，邹兄弟，我退役不用愁转型了<br>  其实我感觉霸天虎他们复活后明明能力高了一个档次，都可以自由的变成碎片然后又汇合，为何还是给擎天柱打的全都死了，只剩<br>霸天虎：“我还会回来的”<br>  好吧，吐槽归吐槽，还是阻挡不了变形金刚就是一个经典，无可替代，他的制作水平我们仍然很难企及。<br>  值得高兴的是我这是大学第一次坐在女同学旁边看电影呦～好吧，一个悲伤的故事。<br>  总之，45块看变形金刚4还是值得的。尤其有美女陪着hiahiahia<br>  就这样，太晚了 明还早起上班 sigh</p>\n","site":{"data":{}},"excerpt":"<p>今天12点多才回到的住房，和几个同学看了9点20的变形金刚4，足足2个小时40分钟！！超值的好嘛!</p>","more":"<p>我觉得45的票价很值了，毕竟画面那么好，不过比变3也没什么进步就是了。而且历来看变形金刚我就不知道<br>剧情为何物！变三跟变四有什么联系！为何擎天柱一出来就是一个残废！这个变3怎么突变过来的！为何一个农民科学家各种刁，<br>最后拿起冲锋剑，或者叫枪，替擎天柱打boss.<br>  女主长的还不错，但是米国人好早熟啊，身材那么好还告诉我17岁！！<br>  李冰冰真是到处演龙套啊～～～外国人是有多喜欢她，各种广告乱入啊～怡宝，舒化奶给个镜头也就算了，红牛居然还有台词！<br>  女婿说：“我已经入选了红牛车队“（我就是很屌）<br>  我擦，红牛你给了多少钱！<br>  邹市明从屌丝男士那里学的爱跑龙套了，出来给那几个老外一顿拳，好不风骚，好，邹兄弟，我退役不用愁转型了<br>  其实我感觉霸天虎他们复活后明明能力高了一个档次，都可以自由的变成碎片然后又汇合，为何还是给擎天柱打的全都死了，只剩<br>霸天虎：“我还会回来的”<br>  好吧，吐槽归吐槽，还是阻挡不了变形金刚就是一个经典，无可替代，他的制作水平我们仍然很难企及。<br>  值得高兴的是我这是大学第一次坐在女同学旁边看电影呦～好吧，一个悲伤的故事。<br>  总之，45块看变形金刚4还是值得的。尤其有美女陪着hiahiahia<br>  就这样，太晚了 明还早起上班 sigh</p>"},{"title":"makefile笔记","date":"2015-09-29T11:33:58.000Z","_content":"\nMakefile\n<!-- toc -->\n\n<!--more-->\n\n## Base\n\n> target (目标) : prerequisites (依赖文件)\n     command (命令,生成规则）\n     \n依赖比目标新，command执行\n\n## Rule\n\n### 规则\n* 变量声明\nName = sth\n类似宏，$(Name)等同于等号右边的\n* `#`为注释，\\可以转义\n* 命令需要**Tab**键开始\n* 文件名一般为makefile，Makefile。也可通过`make -f/--file FileName` 指定\n* include <filename> 用filename替换当前内容\n  * include不能已Tab开始。\n  * 没指定路径\n     * 从当前目录\n     * `make -I/--include-dir`指定的路径\n     * /usr/local/bin, /usr/include\n     * -include 加上`-`可以让其忽略错误\n* 变量声明通配符不起作用。\n  object = *.erl 指的就是\"*.erl\", 可以使用`$(wildcard *.erl)`, 匹配所有erl文件.\n* 搜寻路径\n  * VPATH = DIR1:DIR2... (VPATH = /usr/lib:...)\n  * vpath FileName DIR1:DIR2 (vpath %.erl ../src:../deps)\n* 伪目标 .PHONY:target 伪目标是标签。它并不生成。\n* 静态规则： target：目标匹配：依赖匹配 . 通过匹配筛选出target中满足 目标匹配的，然后再进行依赖匹配\n```\nobjects=$(wildcard *.o)\nall: $(objects)\n$(objects):h?.o : h?.c\n...\n```\n\n### 命令\n* @command 不会输出命令内容 ex:`@echo haha`\n* `make -n/--just-print` 只显示，不执行\n* `make -s/--silent` 全部禁止显示 \n* 当命令依赖前一条命令时应该用分号隔开。 `cd test;pwd` ,如果写到两行里会不起作用\n* 同指定路径，`-`可以让命令忽略错误，而不至于因为一个命令的错误而终止。\n* 变量导出 export value1 =(:=) value2. MAKEFLAGS是make的参数与SHELL默认传递。\n* 定义命令包: `define Name function() endef`\n\n### 变量\n* 字符，数字，下划线。可以数字开头，大小写敏感\n* `A = $(B), B = somevalue` 变量定义可以用到后面定义的变量。\n* 使用`:=`时，不可以使用后面的变量\n* `A？= B` 用于当A前面没有定义时赋予它B，否则什么都不做。\n* 替换： \n```\nfoo = a.erl b.erl c.erl \nbeam = $(foo:.erl=.beam) \nbeam2 = $(foo:%.erl=%.beam)\n```\n\n两种方式都将erl替换成beam\n* `+=` 追加变量\n* 目标变量：target: 变量声明  将变量的赋值作用在某一规则里\nex:\n```\nall: DIR=./src\nall: a.erl\n   erl -pa $(DIR)\n```\n\n* 模式变量 设置所有匹配的目标的变量\n```\n%.beam: DIR=./src\n```\n\n\n### 条件判断\n* `ifeq (A, B) ... else ... endif`\n* `ifneq (A, B) ... else ... endif`\n* `ifdef A ... else ... endif`\n* `ifndef A ... else .... endif`\n* 不要把自动化变量`$@`等放入判断。因为判断实在加载Makefile时就计算出来的。运行时变量不能放入\n\n### 函数\n#### string\n* `$(function, arguments),` 或者用`{`扩起来\n* `$(subst, <from>, <to>, <text>)`  把text中的from替换成to\n* `$(patsubst, <pattern>, <replacement>, <text>)`\n* `$(strip, <string>)` 去掉开头和结尾的空格\n* `$(findstring, <find>, <text>)` 查找text中的find\n* `$(filter, <pattern> ,<text>)` 过滤，取出符合pattern的\n* `$(filter-out, <pattern> ,<text>)` 与上面相反\n* `$(sort, <list>)` 排序并取出重复的词 \n* `$(word, <n>, <text>)` 取出text第n个词\n* `$(wordlist, <begin>, <end>, <text>)` 取出text中begin到end之间的单词\n* `$(words, <text>)` 统计单词个数\n* `$(firstword, <text>)`  取出第一个\n* `$(lastword, <text>)`\n \n#### file\n* `$(dir <names>)` 返回name所在目录\n* `$(notdir <names>)` 返回非目录部分\n* `$(suffix <names>) 后缀函数` `a.erl b.erl -> \".erl .erl\"`\n* `$(basename <names>)` 前缀函数 `a.cpp -> a`\n* `$(addsuffix <suffix>, <names>)`  给name添加后缀  `addsuffix .erl, hello -> hello.erl`\n* `$(addprefix <prefix>, <names>)`\n#### list\n* `$(join <list1>, <list2>)` 连接list1和list2中的单词`join aaa bbb, 11 22 33 -> \"aaa11, bbb33, 33\"\n* `$(foreach <var>, <list>, <text>)` 类似于lists:foreach(fun(H) -> ....end, List), text就是fun, var是H,list是List\n* `$(if <condition>, <then>, <else>)` else可省略\n\n* `$(call <expression>, <param1>,<param2>...)`\n param1和param2就是$(1),$(2).expression是对这些变量的操作表达式。\n```\nreverse = $(2) $(1)\n$(call reverse, a,b) -> \"b a\"\n```\n\ncall的变量数量不限。\n\n* `$(origin <variable>)` \n* `$(shell cmd)`   例如 `Files = $(shell ls)`\n\n* `$(error msg)` `$(warning msg)`  error会终止， warn不会 \n\n### 隐含规则\n[ubuntu社区](http://wiki.ubuntu.org.cn/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile:%E9%9A%90%E5%90%AB%E8%A7%84%E5%88%99)\n[GUN make](https://www.gnu.org/software/make/manual/html_node/Catalogue-of-Rules.html#Catalogue-of-Rules)\n\n\n## SomeMore\n\n* 递归调用make的时候一般使用的是`$(MAKE)`代替make。它的的展开其实就是调用make的路径，比如`/usr/bin/make`\n它有个特点就是不会传递`-t -q -n`参数。详见\n[GUN MAKE variable](http://www.gnu.org/software/make/manual/html_node/MAKE-Variable.html#MAKE-Variable)\n* [make options summary](http://www.gnu.org/software/make/manual/html_node/Options-Summary.html#Options-Summary)\n","source":"_posts/makefile笔记.md","raw":"title: makefile笔记\ndate: 2015-09-29 19:33:58\ntags: makefile\n---\n\nMakefile\n<!-- toc -->\n\n<!--more-->\n\n## Base\n\n> target (目标) : prerequisites (依赖文件)\n     command (命令,生成规则）\n     \n依赖比目标新，command执行\n\n## Rule\n\n### 规则\n* 变量声明\nName = sth\n类似宏，$(Name)等同于等号右边的\n* `#`为注释，\\可以转义\n* 命令需要**Tab**键开始\n* 文件名一般为makefile，Makefile。也可通过`make -f/--file FileName` 指定\n* include <filename> 用filename替换当前内容\n  * include不能已Tab开始。\n  * 没指定路径\n     * 从当前目录\n     * `make -I/--include-dir`指定的路径\n     * /usr/local/bin, /usr/include\n     * -include 加上`-`可以让其忽略错误\n* 变量声明通配符不起作用。\n  object = *.erl 指的就是\"*.erl\", 可以使用`$(wildcard *.erl)`, 匹配所有erl文件.\n* 搜寻路径\n  * VPATH = DIR1:DIR2... (VPATH = /usr/lib:...)\n  * vpath FileName DIR1:DIR2 (vpath %.erl ../src:../deps)\n* 伪目标 .PHONY:target 伪目标是标签。它并不生成。\n* 静态规则： target：目标匹配：依赖匹配 . 通过匹配筛选出target中满足 目标匹配的，然后再进行依赖匹配\n```\nobjects=$(wildcard *.o)\nall: $(objects)\n$(objects):h?.o : h?.c\n...\n```\n\n### 命令\n* @command 不会输出命令内容 ex:`@echo haha`\n* `make -n/--just-print` 只显示，不执行\n* `make -s/--silent` 全部禁止显示 \n* 当命令依赖前一条命令时应该用分号隔开。 `cd test;pwd` ,如果写到两行里会不起作用\n* 同指定路径，`-`可以让命令忽略错误，而不至于因为一个命令的错误而终止。\n* 变量导出 export value1 =(:=) value2. MAKEFLAGS是make的参数与SHELL默认传递。\n* 定义命令包: `define Name function() endef`\n\n### 变量\n* 字符，数字，下划线。可以数字开头，大小写敏感\n* `A = $(B), B = somevalue` 变量定义可以用到后面定义的变量。\n* 使用`:=`时，不可以使用后面的变量\n* `A？= B` 用于当A前面没有定义时赋予它B，否则什么都不做。\n* 替换： \n```\nfoo = a.erl b.erl c.erl \nbeam = $(foo:.erl=.beam) \nbeam2 = $(foo:%.erl=%.beam)\n```\n\n两种方式都将erl替换成beam\n* `+=` 追加变量\n* 目标变量：target: 变量声明  将变量的赋值作用在某一规则里\nex:\n```\nall: DIR=./src\nall: a.erl\n   erl -pa $(DIR)\n```\n\n* 模式变量 设置所有匹配的目标的变量\n```\n%.beam: DIR=./src\n```\n\n\n### 条件判断\n* `ifeq (A, B) ... else ... endif`\n* `ifneq (A, B) ... else ... endif`\n* `ifdef A ... else ... endif`\n* `ifndef A ... else .... endif`\n* 不要把自动化变量`$@`等放入判断。因为判断实在加载Makefile时就计算出来的。运行时变量不能放入\n\n### 函数\n#### string\n* `$(function, arguments),` 或者用`{`扩起来\n* `$(subst, <from>, <to>, <text>)`  把text中的from替换成to\n* `$(patsubst, <pattern>, <replacement>, <text>)`\n* `$(strip, <string>)` 去掉开头和结尾的空格\n* `$(findstring, <find>, <text>)` 查找text中的find\n* `$(filter, <pattern> ,<text>)` 过滤，取出符合pattern的\n* `$(filter-out, <pattern> ,<text>)` 与上面相反\n* `$(sort, <list>)` 排序并取出重复的词 \n* `$(word, <n>, <text>)` 取出text第n个词\n* `$(wordlist, <begin>, <end>, <text>)` 取出text中begin到end之间的单词\n* `$(words, <text>)` 统计单词个数\n* `$(firstword, <text>)`  取出第一个\n* `$(lastword, <text>)`\n \n#### file\n* `$(dir <names>)` 返回name所在目录\n* `$(notdir <names>)` 返回非目录部分\n* `$(suffix <names>) 后缀函数` `a.erl b.erl -> \".erl .erl\"`\n* `$(basename <names>)` 前缀函数 `a.cpp -> a`\n* `$(addsuffix <suffix>, <names>)`  给name添加后缀  `addsuffix .erl, hello -> hello.erl`\n* `$(addprefix <prefix>, <names>)`\n#### list\n* `$(join <list1>, <list2>)` 连接list1和list2中的单词`join aaa bbb, 11 22 33 -> \"aaa11, bbb33, 33\"\n* `$(foreach <var>, <list>, <text>)` 类似于lists:foreach(fun(H) -> ....end, List), text就是fun, var是H,list是List\n* `$(if <condition>, <then>, <else>)` else可省略\n\n* `$(call <expression>, <param1>,<param2>...)`\n param1和param2就是$(1),$(2).expression是对这些变量的操作表达式。\n```\nreverse = $(2) $(1)\n$(call reverse, a,b) -> \"b a\"\n```\n\ncall的变量数量不限。\n\n* `$(origin <variable>)` \n* `$(shell cmd)`   例如 `Files = $(shell ls)`\n\n* `$(error msg)` `$(warning msg)`  error会终止， warn不会 \n\n### 隐含规则\n[ubuntu社区](http://wiki.ubuntu.org.cn/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile:%E9%9A%90%E5%90%AB%E8%A7%84%E5%88%99)\n[GUN make](https://www.gnu.org/software/make/manual/html_node/Catalogue-of-Rules.html#Catalogue-of-Rules)\n\n\n## SomeMore\n\n* 递归调用make的时候一般使用的是`$(MAKE)`代替make。它的的展开其实就是调用make的路径，比如`/usr/bin/make`\n它有个特点就是不会传递`-t -q -n`参数。详见\n[GUN MAKE variable](http://www.gnu.org/software/make/manual/html_node/MAKE-Variable.html#MAKE-Variable)\n* [make options summary](http://www.gnu.org/software/make/manual/html_node/Options-Summary.html#Options-Summary)\n","slug":"makefile笔记","published":1,"updated":"2018-06-26T09:49:27.736Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqw7jdwh001z6f1rh2n29x1c","content":"<p>Makefile</p>\n<!-- toc -->\n<ul>\n<li><a href=\"#base\">Base</a></li>\n<li><a href=\"#rule\">Rule</a><ul>\n<li><a href=\"#--\">规则</a></li>\n<li><a href=\"#--\">命令</a></li>\n<li><a href=\"#--\">变量</a></li>\n<li><a href=\"#----\">条件判断</a></li>\n<li><a href=\"#--\">函数</a><ul>\n<li><a href=\"#string\">string</a></li>\n<li><a href=\"#file\">file</a></li>\n<li><a href=\"#list\">list</a></li>\n</ul>\n</li>\n<li><a href=\"#----\">隐含规则</a></li>\n</ul>\n</li>\n<li><a href=\"#somemore\">SomeMore</a></li>\n</ul>\n<!-- tocstop -->\n<span id=\"more\"></span>\n<h2 id=\"Base\">Base</h2><blockquote>\n<p>target (目标) : prerequisites (依赖文件)<br>     command (命令,生成规则）</p>\n</blockquote>\n<p>依赖比目标新，command执行</p>\n<h2 id=\"Rule\">Rule</h2><h3 id=\"规则\">规则</h3><ul>\n<li>变量声明<br>Name = sth<br>类似宏，$(Name)等同于等号右边的</li>\n<li><code>#</code>为注释，\\可以转义</li>\n<li>命令需要<strong>Tab</strong>键开始</li>\n<li>文件名一般为makefile，Makefile。也可通过<code>make -f/--file FileName</code> 指定</li>\n<li>include <filename> 用filename替换当前内容<ul>\n<li>include不能已Tab开始。</li>\n<li>没指定路径<ul>\n<li>从当前目录</li>\n<li><code>make -I/--include-dir</code>指定的路径</li>\n<li>/usr/local/bin, /usr/include</li>\n<li>-include 加上<code>-</code>可以让其忽略错误</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>变量声明通配符不起作用。<br>object = <em>.erl 指的就是&quot;</em>.erl&quot;, 可以使用<code>$(wildcard *.erl)</code>, 匹配所有erl文件.</li>\n<li>搜寻路径<ul>\n<li>VPATH = DIR1:DIR2... (VPATH = /usr/lib:...)</li>\n<li>vpath FileName DIR1:DIR2 (vpath %.erl ../src:../deps)</li>\n</ul>\n</li>\n<li>伪目标 .PHONY:target 伪目标是标签。它并不生成。</li>\n<li>静态规则： target：目标匹配：依赖匹配 . 通过匹配筛选出target中满足 目标匹配的，然后再进行依赖匹配<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">objects=$(wildcard *.o)</span><br><span class=\"line\">all: $(objects)</span><br><span class=\"line\">$(objects):h?.o : h?.c</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"命令\">命令</h3><ul>\n<li>@command 不会输出命令内容 ex:<code>@echo haha</code></li>\n<li><code>make -n/--just-print</code> 只显示，不执行</li>\n<li><code>make -s/--silent</code> 全部禁止显示 </li>\n<li>当命令依赖前一条命令时应该用分号隔开。 <code>cd test;pwd</code> ,如果写到两行里会不起作用</li>\n<li>同指定路径，<code>-</code>可以让命令忽略错误，而不至于因为一个命令的错误而终止。</li>\n<li>变量导出 export value1 =(:=) value2. MAKEFLAGS是make的参数与SHELL默认传递。</li>\n<li>定义命令包: <code>define Name function() endef</code></li>\n</ul>\n<h3 id=\"变量\">变量</h3><ul>\n<li>字符，数字，下划线。可以数字开头，大小写敏感</li>\n<li><code>A = $(B), B = somevalue</code> 变量定义可以用到后面定义的变量。</li>\n<li>使用<code>:=</code>时，不可以使用后面的变量</li>\n<li><code>A？= B</code> 用于当A前面没有定义时赋予它B，否则什么都不做。</li>\n<li>替换： <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo = a.erl b.erl c.erl </span><br><span class=\"line\">beam = $(foo:.erl=.beam) </span><br><span class=\"line\">beam2 = $(foo:%.erl=%.beam)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>两种方式都将erl替换成beam</p>\n<ul>\n<li><code>+=</code> 追加变量</li>\n<li><p>目标变量：target: 变量声明  将变量的赋值作用在某一规则里<br>ex:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">all: DIR=./src</span><br><span class=\"line\">all: a.erl</span><br><span class=\"line\">   erl -pa $(DIR)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>模式变量 设置所有匹配的目标的变量</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">%.beam: DIR=./src</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"条件判断\">条件判断</h3><ul>\n<li><code>ifeq (A, B) ... else ... endif</code></li>\n<li><code>ifneq (A, B) ... else ... endif</code></li>\n<li><code>ifdef A ... else ... endif</code></li>\n<li><code>ifndef A ... else .... endif</code></li>\n<li>不要把自动化变量<code>$@</code>等放入判断。因为判断实在加载Makefile时就计算出来的。运行时变量不能放入</li>\n</ul>\n<h3 id=\"函数\">函数</h3><h4 id=\"string\">string</h4><ul>\n<li><code>$(function, arguments),</code> 或者用<code>&#123;</code>扩起来</li>\n<li><code>$(subst, &lt;from&gt;, &lt;to&gt;, &lt;text&gt;)</code>  把text中的from替换成to</li>\n<li><code>$(patsubst, &lt;pattern&gt;, &lt;replacement&gt;, &lt;text&gt;)</code></li>\n<li><code>$(strip, &lt;string&gt;)</code> 去掉开头和结尾的空格</li>\n<li><code>$(findstring, &lt;find&gt;, &lt;text&gt;)</code> 查找text中的find</li>\n<li><code>$(filter, &lt;pattern&gt; ,&lt;text&gt;)</code> 过滤，取出符合pattern的</li>\n<li><code>$(filter-out, &lt;pattern&gt; ,&lt;text&gt;)</code> 与上面相反</li>\n<li><code>$(sort, &lt;list&gt;)</code> 排序并取出重复的词 </li>\n<li><code>$(word, &lt;n&gt;, &lt;text&gt;)</code> 取出text第n个词</li>\n<li><code>$(wordlist, &lt;begin&gt;, &lt;end&gt;, &lt;text&gt;)</code> 取出text中begin到end之间的单词</li>\n<li><code>$(words, &lt;text&gt;)</code> 统计单词个数</li>\n<li><code>$(firstword, &lt;text&gt;)</code>  取出第一个</li>\n<li><code>$(lastword, &lt;text&gt;)</code></li>\n</ul>\n<h4 id=\"file\">file</h4><ul>\n<li><code>$(dir &lt;names&gt;)</code> 返回name所在目录</li>\n<li><code>$(notdir &lt;names&gt;)</code> 返回非目录部分</li>\n<li><code>$(suffix &lt;names&gt;) 后缀函数</code> <code>a.erl b.erl -&gt; &quot;.erl .erl&quot;</code></li>\n<li><code>$(basename &lt;names&gt;)</code> 前缀函数 <code>a.cpp -&gt; a</code></li>\n<li><code>$(addsuffix &lt;suffix&gt;, &lt;names&gt;)</code>  给name添加后缀  <code>addsuffix .erl, hello -&gt; hello.erl</code></li>\n<li><code>$(addprefix &lt;prefix&gt;, &lt;names&gt;)</code><h4 id=\"list\">list</h4></li>\n<li><code>$(join &lt;list1&gt;, &lt;list2&gt;)</code> 连接list1和list2中的单词`join aaa bbb, 11 22 33 -&gt; &quot;aaa11, bbb33, 33&quot;</li>\n<li><code>$(foreach &lt;var&gt;, &lt;list&gt;, &lt;text&gt;)</code> 类似于lists:foreach(fun(H) -&gt; ....end, List), text就是fun, var是H,list是List</li>\n<li><p><code>$(if &lt;condition&gt;, &lt;then&gt;, &lt;else&gt;)</code> else可省略</p>\n</li>\n<li><p><code>$(call &lt;expression&gt;, &lt;param1&gt;,&lt;param2&gt;...)</code><br>param1和param2就是$(1),$(2).expression是对这些变量的操作表达式。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">reverse = $(2) $(1)</span><br><span class=\"line\">$(call reverse, a,b) -&gt; &quot;b a&quot;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>call的变量数量不限。</p>\n<ul>\n<li><code>$(origin &lt;variable&gt;)</code> </li>\n<li><p><code>$(shell cmd)</code>   例如 <code>Files = $(shell ls)</code></p>\n</li>\n<li><p><code>$(error msg)</code> <code>$(warning msg)</code>  error会终止， warn不会 </p>\n</li>\n</ul>\n<h3 id=\"隐含规则\">隐含规则</h3><p><a href=\"http://wiki.ubuntu.org.cn/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile:%E9%9A%90%E5%90%AB%E8%A7%84%E5%88%99\">ubuntu社区</a><br><a href=\"https://www.gnu.org/software/make/manual/html_node/Catalogue-of-Rules.html#Catalogue-of-Rules\">GUN make</a></p>\n<h2 id=\"SomeMore\">SomeMore</h2><ul>\n<li>递归调用make的时候一般使用的是<code>$(MAKE)</code>代替make。它的的展开其实就是调用make的路径，比如<code>/usr/bin/make</code><br>它有个特点就是不会传递<code>-t -q -n</code>参数。详见<br><a href=\"http://www.gnu.org/software/make/manual/html_node/MAKE-Variable.html#MAKE-Variable\">GUN MAKE variable</a></li>\n<li><a href=\"http://www.gnu.org/software/make/manual/html_node/Options-Summary.html#Options-Summary\">make options summary</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>Makefile</p>\n<!-- toc -->\n<ul>\n<li><a href=\"#base\">Base</a></li>\n<li><a href=\"#rule\">Rule</a><ul>\n<li><a href=\"#--\">规则</a></li>\n<li><a href=\"#--\">命令</a></li>\n<li><a href=\"#--\">变量</a></li>\n<li><a href=\"#----\">条件判断</a></li>\n<li><a href=\"#--\">函数</a><ul>\n<li><a href=\"#string\">string</a></li>\n<li><a href=\"#file\">file</a></li>\n<li><a href=\"#list\">list</a></li>\n</ul>\n</li>\n<li><a href=\"#----\">隐含规则</a></li>\n</ul>\n</li>\n<li><a href=\"#somemore\">SomeMore</a></li>\n</ul>\n<!-- tocstop -->","more":"<h2 id=\"Base\">Base</h2><blockquote>\n<p>target (目标) : prerequisites (依赖文件)<br>     command (命令,生成规则）</p>\n</blockquote>\n<p>依赖比目标新，command执行</p>\n<h2 id=\"Rule\">Rule</h2><h3 id=\"规则\">规则</h3><ul>\n<li>变量声明<br>Name = sth<br>类似宏，$(Name)等同于等号右边的</li>\n<li><code>#</code>为注释，\\可以转义</li>\n<li>命令需要<strong>Tab</strong>键开始</li>\n<li>文件名一般为makefile，Makefile。也可通过<code>make -f/--file FileName</code> 指定</li>\n<li>include <filename> 用filename替换当前内容<ul>\n<li>include不能已Tab开始。</li>\n<li>没指定路径<ul>\n<li>从当前目录</li>\n<li><code>make -I/--include-dir</code>指定的路径</li>\n<li>/usr/local/bin, /usr/include</li>\n<li>-include 加上<code>-</code>可以让其忽略错误</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>变量声明通配符不起作用。<br>object = <em>.erl 指的就是&quot;</em>.erl&quot;, 可以使用<code>$(wildcard *.erl)</code>, 匹配所有erl文件.</li>\n<li>搜寻路径<ul>\n<li>VPATH = DIR1:DIR2... (VPATH = /usr/lib:...)</li>\n<li>vpath FileName DIR1:DIR2 (vpath %.erl ../src:../deps)</li>\n</ul>\n</li>\n<li>伪目标 .PHONY:target 伪目标是标签。它并不生成。</li>\n<li>静态规则： target：目标匹配：依赖匹配 . 通过匹配筛选出target中满足 目标匹配的，然后再进行依赖匹配<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">objects=$(wildcard *.o)</span><br><span class=\"line\">all: $(objects)</span><br><span class=\"line\">$(objects):h?.o : h?.c</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"命令\">命令</h3><ul>\n<li>@command 不会输出命令内容 ex:<code>@echo haha</code></li>\n<li><code>make -n/--just-print</code> 只显示，不执行</li>\n<li><code>make -s/--silent</code> 全部禁止显示 </li>\n<li>当命令依赖前一条命令时应该用分号隔开。 <code>cd test;pwd</code> ,如果写到两行里会不起作用</li>\n<li>同指定路径，<code>-</code>可以让命令忽略错误，而不至于因为一个命令的错误而终止。</li>\n<li>变量导出 export value1 =(:=) value2. MAKEFLAGS是make的参数与SHELL默认传递。</li>\n<li>定义命令包: <code>define Name function() endef</code></li>\n</ul>\n<h3 id=\"变量\">变量</h3><ul>\n<li>字符，数字，下划线。可以数字开头，大小写敏感</li>\n<li><code>A = $(B), B = somevalue</code> 变量定义可以用到后面定义的变量。</li>\n<li>使用<code>:=</code>时，不可以使用后面的变量</li>\n<li><code>A？= B</code> 用于当A前面没有定义时赋予它B，否则什么都不做。</li>\n<li>替换： <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo = a.erl b.erl c.erl </span><br><span class=\"line\">beam = $(foo:.erl=.beam) </span><br><span class=\"line\">beam2 = $(foo:%.erl=%.beam)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>两种方式都将erl替换成beam</p>\n<ul>\n<li><code>+=</code> 追加变量</li>\n<li><p>目标变量：target: 变量声明  将变量的赋值作用在某一规则里<br>ex:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">all: DIR=./src</span><br><span class=\"line\">all: a.erl</span><br><span class=\"line\">   erl -pa $(DIR)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>模式变量 设置所有匹配的目标的变量</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">%.beam: DIR=./src</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"条件判断\">条件判断</h3><ul>\n<li><code>ifeq (A, B) ... else ... endif</code></li>\n<li><code>ifneq (A, B) ... else ... endif</code></li>\n<li><code>ifdef A ... else ... endif</code></li>\n<li><code>ifndef A ... else .... endif</code></li>\n<li>不要把自动化变量<code>$@</code>等放入判断。因为判断实在加载Makefile时就计算出来的。运行时变量不能放入</li>\n</ul>\n<h3 id=\"函数\">函数</h3><h4 id=\"string\">string</h4><ul>\n<li><code>$(function, arguments),</code> 或者用<code>&#123;</code>扩起来</li>\n<li><code>$(subst, &lt;from&gt;, &lt;to&gt;, &lt;text&gt;)</code>  把text中的from替换成to</li>\n<li><code>$(patsubst, &lt;pattern&gt;, &lt;replacement&gt;, &lt;text&gt;)</code></li>\n<li><code>$(strip, &lt;string&gt;)</code> 去掉开头和结尾的空格</li>\n<li><code>$(findstring, &lt;find&gt;, &lt;text&gt;)</code> 查找text中的find</li>\n<li><code>$(filter, &lt;pattern&gt; ,&lt;text&gt;)</code> 过滤，取出符合pattern的</li>\n<li><code>$(filter-out, &lt;pattern&gt; ,&lt;text&gt;)</code> 与上面相反</li>\n<li><code>$(sort, &lt;list&gt;)</code> 排序并取出重复的词 </li>\n<li><code>$(word, &lt;n&gt;, &lt;text&gt;)</code> 取出text第n个词</li>\n<li><code>$(wordlist, &lt;begin&gt;, &lt;end&gt;, &lt;text&gt;)</code> 取出text中begin到end之间的单词</li>\n<li><code>$(words, &lt;text&gt;)</code> 统计单词个数</li>\n<li><code>$(firstword, &lt;text&gt;)</code>  取出第一个</li>\n<li><code>$(lastword, &lt;text&gt;)</code></li>\n</ul>\n<h4 id=\"file\">file</h4><ul>\n<li><code>$(dir &lt;names&gt;)</code> 返回name所在目录</li>\n<li><code>$(notdir &lt;names&gt;)</code> 返回非目录部分</li>\n<li><code>$(suffix &lt;names&gt;) 后缀函数</code> <code>a.erl b.erl -&gt; &quot;.erl .erl&quot;</code></li>\n<li><code>$(basename &lt;names&gt;)</code> 前缀函数 <code>a.cpp -&gt; a</code></li>\n<li><code>$(addsuffix &lt;suffix&gt;, &lt;names&gt;)</code>  给name添加后缀  <code>addsuffix .erl, hello -&gt; hello.erl</code></li>\n<li><code>$(addprefix &lt;prefix&gt;, &lt;names&gt;)</code><h4 id=\"list\">list</h4></li>\n<li><code>$(join &lt;list1&gt;, &lt;list2&gt;)</code> 连接list1和list2中的单词`join aaa bbb, 11 22 33 -&gt; &quot;aaa11, bbb33, 33&quot;</li>\n<li><code>$(foreach &lt;var&gt;, &lt;list&gt;, &lt;text&gt;)</code> 类似于lists:foreach(fun(H) -&gt; ....end, List), text就是fun, var是H,list是List</li>\n<li><p><code>$(if &lt;condition&gt;, &lt;then&gt;, &lt;else&gt;)</code> else可省略</p>\n</li>\n<li><p><code>$(call &lt;expression&gt;, &lt;param1&gt;,&lt;param2&gt;...)</code><br>param1和param2就是$(1),$(2).expression是对这些变量的操作表达式。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">reverse = $(2) $(1)</span><br><span class=\"line\">$(call reverse, a,b) -&gt; &quot;b a&quot;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>call的变量数量不限。</p>\n<ul>\n<li><code>$(origin &lt;variable&gt;)</code> </li>\n<li><p><code>$(shell cmd)</code>   例如 <code>Files = $(shell ls)</code></p>\n</li>\n<li><p><code>$(error msg)</code> <code>$(warning msg)</code>  error会终止， warn不会 </p>\n</li>\n</ul>\n<h3 id=\"隐含规则\">隐含规则</h3><p><a href=\"http://wiki.ubuntu.org.cn/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile:%E9%9A%90%E5%90%AB%E8%A7%84%E5%88%99\">ubuntu社区</a><br><a href=\"https://www.gnu.org/software/make/manual/html_node/Catalogue-of-Rules.html#Catalogue-of-Rules\">GUN make</a></p>\n<h2 id=\"SomeMore\">SomeMore</h2><ul>\n<li>递归调用make的时候一般使用的是<code>$(MAKE)</code>代替make。它的的展开其实就是调用make的路径，比如<code>/usr/bin/make</code><br>它有个特点就是不会传递<code>-t -q -n</code>参数。详见<br><a href=\"http://www.gnu.org/software/make/manual/html_node/MAKE-Variable.html#MAKE-Variable\">GUN MAKE variable</a></li>\n<li><a href=\"http://www.gnu.org/software/make/manual/html_node/Options-Summary.html#Options-Summary\">make options summary</a></li>\n</ul>"},{"title":"vimscript笔记","date":"2016-05-06T07:33:21.000Z","toc":true,"_content":"\n\n> Remeber `:help` always be with you  -- albert einstein\n记住`:help`　与你同在\n\n<!-- more -->\n<!-- toc -->\n\n### First of all\n首先`:help echo/function/....`　help可以查看一个关键词的帮助.首先要习惯使用它\n\n### echo echom  打印信息帮助调试\n```\n:echo \"test\"\n:echo \"test2\"\n:messages\n```\n\ntest2在message中，而test不在。\nechom 主要用来调试。\n\n### 注释\n```\n\" 这是注释\n```\n\n### (布尔)选项\n\n`:set` 用于设置内置的选项。有的是布尔选项，有的不是 see `:help set`\n```\n:set number\n:set nonumber\n:set number!\n:set number?\n:set number numberwidth=4\n:set omnifunc=XXX#complete\n```\n\nnumber是一个布尔选项。任何布尔选项都可以通过`set` ,`set no(Bool)`, 设置开启关闭`set Bool!`切换开关状态.\n`set {Option}?` 用来查看当前值. \n有些选项可以赋值.多选项用空格隔开一次赋值\nnumber是用来显示行号的布尔值\nomnifunc 是补全函数\n在脚本中如果要引用某个选项使用`&`, 比如\n```\nif &filetype == \"vim\"\n```\n\n判断当前文件类型是否是vimscript\n\n### map 映射!映射!\n`:help map-commands`\n```\n:map - x  //  任何模式下将'-'映射为'x'\n:map <space> x\n:map <c-d> x\n:nmap - x\n:vmap - x\n:imap - x\n:noremap - x\n:noremap \\ -\n```\n\nmap通用于所有模式下。nmap,vmap, imap分别映射在不同的模式下。\nnoremap不存在递归风险。任何时候都应该使用这种方式。**对，任何时候**\n\n### leader按键\n`:help mapleader`\n很多插件中存在各种映射都用的<leader>这个按键\n```\n:let mapleader=\"-\"\n:nnoremap <leader>d dd\nlet maplocalleader = \"\\\\\"\n:noremap <buffer> <localleader>d dd\n```\n\nleader 默认为`\\`, 如果修改可以通过`echo mapleader`查看\nlocalleader 只针对某个buffer\n> 除了map 还有各种其他地方指定`<buffer>`的设置。比如autocmd,加上buffer比较安全。\n\n同样有的选项也支持`:setlocal number`\n\n### iabbrev\n```\n:iabbrev waht what\n```\n\n自动替换。　可以将ｗａｈｔ　替换为ｗｈａｔ\niabbrev是结束insert mode时发生的。 如果what前后有别的则不会发生替换.这点与`inoremap waht what`不同\n同样可以接受`:iabbrev <buffer> XXXX`　只对当前buffer生效\n\n### autocmd 自动命令\n`:help autocmd`\n`:help Event`\n```\n:autocmd BufNewFild,BufRead *.html :normal gg=G\n         事件                模式   执行命令\n```\n\n`autocmd Event File Command`  对File文件接收到event事件后　触发command\n\nEvent后面的模式每个pattern不一样。\n比如 `:autocmd FileType vim call SomeFun()`\n**这里有个危险的地方**\n单纯的`autocmd` 并不会覆盖之前的命令。如果同一个`autocmd`加载多次他们会同时存在也就是可能对于同一个事件执行多次`SomeFun()`.\n这里vim有一种自动命令组的方法\n```\n:augroup testgroup\n:    autocmd BufWrite * :echom \"Foo\"\n:    autocmd BufWrite * :echom \"Bar\"\n:augroup END\n```\n\n上面将\"Foo\", \"Bar\"两个事件归到testgroup组中。这时testgroup相当于一个`autocmd`　同样多次执行testgroup也会造成上面的情况。同样，如果之后在执行\n```\n:augroup testgroup\n:    autocmd BufWrite * :echom \"Baz\"\n:augroup END\n```\n\n\"Foo\", \"Bar\"并没有清除.而是将\"Baz\"合并到了testgroup中.这样没有解决多次读取事件造成重复调用的问题。\n解决的办法是在组开始的地方调用 `autocmd!`来清除这个组的事件\n```\n:augroup testgroup\n:    autocmd!\n:    autocmd BufWrite * :echom \"Cats\"\n:    autocmd XXXXX....\n:augroup END\n```\n\n这样解决了多次重复调用的问题\n\n### operator_pending\n\n`:onoremap p ic`\n\nw, p, t 各种定位词　ｏｎｏｒｅｍａｐ可以修改定位词映射\n\n### :normal\n`:normal gg`\n`:normal` 后面会跟一个字符串。相当于在ｎｏｒｍａｌ模式下按下这些按键\n\n当然永远不要用normal 而是用`normal!` 后者无视映射。因为你永远不知道用户把按键映射成了什么\n\n### :execute\n`:execute \":normal!  gg\"\n\nexecute 后面跟脚本。\n\n为什么不直接用normal!,而是用execute呢\n因为normal不能识别特殊字符。比如<cr>回车符等所以一般要包个execute命令。\n比如`:normal! a\\<cr>` 我们设想先按下a进入insert模式然后输出回车符换行.但是实际上这个命令进入插入模式后，直\n接将`\\<cr>`输入到了buffer中.我们可以用`execute \"normal! a\\<cr>\"完成这个动作\n\n### set statusline\n```\n:set statusline=%f\\ -\\ %y\n:set statusline+=%=\n:set statusline+=%L\n```\n\n修改状态条显示内容。类似printf %f 是文件名%y是文件类型 %=表示后面的右对齐%L显示总行数。\n\n### let  变量\n```\n:let foo=\"bar\"\n:echo foo  //显示ｂａｒ\n:set number\n:echo &number //1\n:let number = 100\n:echo number //100\n:let &number=&number-1\n:echo &number //0　number是是否显示行号的布尔值\n```\n\nlet 用来定义一个变量,这个变量可以与某个选项同名(set), 只不过选项的引用需要前面加`&`\nset 只能给选项赋值常量值\n而let 可以用变量给变量赋值,如上面的`&number`\n`:let &l:number = 100`可以给本地变量赋值而不影响其他buffer\n\n### 寄存器\n`:register` 查看所有寄存器内容\n`\"ap` a是寄存器名字. 表示将a中的内容粘贴到此处\n`echo @a` 打印a中的内容\n`let @a=\"test\"` 修改a中内容\n`\"`寄存器是为指定寄存器所有为指定寄存器的复制操作,内容都会写入这里\n\n### 管道\n`:echo \"haha\" | echo \"heihei`\n\n\n### if\n```\n:if \"20haha\"\n:   echo \"true\"\n:endif\n\n:if \"haha20\"\n:   echo \"true\"\n:else\n:   echo \"false\"\n:endif\n```\n\n第一个会显示ｔｒｕｅ　第二个是ｆａｌｓｅ　\n因为字符串在强制转换时第一个是数字会转化为相应的数字。否则是０\n\n#### 比较\n不能完全信任`==`\n因为vim的大小写敏感时用户设置的\n```\n:set ignorecase\n:if \"foo\" == \"FOO\"\n```\n\n这个语句真假取决于ignorecase的设置。\n替代品\n`==?` 大小写不敏感比较\n`==#` 大小写敏感比较\n\n### 函数\n```\n:function Test()\n:   XXXXX\n:endfunction\n:function s:testb()\n:   echom \"script test\"\n:endfunction\n:call Test()\n```\n\n**没有限制作用域的函数必须以大写字母开头**\n脚本内的私有函数以`s:`开头\n函数没有显示指定`return XX`则默认返回0\n\n\n#### 参数\n```\n:function EchoTest(name)\n:   echo a:name\n:endfunction\n```\n\n函数的参数总要加a这个作用域否则会提示找不到\n\n#### 可变参数\n```\n:function Test(...)  // 假如 call Test(\"a\", \"b\", \"c\")\n:   echo a:0         // 3 参数个数\n:   echo a:1         // \"a\"\n:   echo a:000       // ['a', 'b', 'c'] 000指参数列表.不能用echom输出只能用echo\n:endfunction\n```\n\n`:call Test(\"a\", \"b\", \"c\")`\na:0 指的是参数数量。 a:1 是 \"a\".以此类推\n\n#### 命名空间\n> |buffer-variable|    b:\t  Local to the current buffer.\n|window-variable|    w:\t  Local to the current window.\n|tabpage-variable|   t:\t  Local to the current tab page.\n|global-variable|    g:\t  Global.\n|local-variable|     l:\t  Local to a function.\n|script-variable|    s:\t  Local to a |:source|'ed Vim script.\n|function-argument|  a:\t  Function argument (only inside a function).\n|vim-variable|\t     v:\t  Global, predefined by Vim.\n\n命名空间可以当做dict使用\n``` \nfor k in keys(b:)\n    unlet b:[k]\nendfor\n```\n\n可以混合可变参数和固定参数\n`:function Test(a, ...)`\n\n不能对函数的参数改变赋值\n```\n:function Test(foo)\n:   let a:foo=\"change\" //这样做会报错\n:   let tmp=a:foo      // 这样才可以\n:   let tmp=\"change\"\n:endfunction\n```\n\n### 字符串\n#### 连接符\n```\n:echo \"haha\".\"heihei\" \n```\n\n上面输出\"hahaheihei\"\n\n#### 字符串函数\n`:help function-list` 查看所有函数分类列表\n\n`strlen(\"string\")`\n`len(\"string\")`\n`echo split(\"one two\")`\n`echo split(\"one,two\",\",\")`\n`echo join([\"one\",\"two\"], \",\")`\n`echo tolower(\"BIG\")`\n`echo toupper(\"low\")`\n\n### 列表\n1. 有序，异质\n2. 索引从0开始 \n```\n:echo [1,2,3][0] // 1\n:echo [1,2,3][-1] //3\n:echo \"abc\"[1] // b\n:echo \"abc\"[-1] // 无效。\n```\n\n3. 切割\n```\n:echo [1,2,3][:1] // [1,2]\n:echo [1,2,3][1:] // [2,3]\n:echo [1,2,3][:1000] // [1,2,3] 可以越界\n:echo [1,2,3,4][-2:-1] //[3,4]\n:echo [1,2,3,4][-2:1] // []\n:echo \"abc\"[-2:-1] // bc。上面的负数索引无效。切割却有效。。。\n```\n\n4.连接\n```\n:echo ['a','b'] + ['c'] // ['a','b','c']\n:echo [1,2] + [3]//[1,2,3]\n:echo [a,b] + [c] // 错误。\n:echo \"ab\".\"c\" //\"abc\"\n```\n\n5. 列表函数\n```\n:echo add([1,2],3) // [1,2,3]\n:echo get([1,2,3], 0, 'default') // 1\n:echo get([1,2,3], 4, 'default') // default\n:echo index([1,2,3], 1) // 0\n:echo index([1,2,3], 4) // -1 不存在返回-1\n:echo join([1,2], \"-\") // 1-2\n:echo reverse([1,2]) //[2,1]\n```\n\n更多阅读`:help List` `:help functions`\n\n### 循环\n#### for\n```\n:for i in [1,2,3,4]\n:   let c += i\n:endfor\n```\n\n```\n:let c=1\n:while c < 3\n: let t += c\n: let c += 1\n:endwhile\n```\n\n### dict\n`{'a':1, 2:\"two\",}` 字典的key总是会自动转为字符串.  应该总是结尾留一个`,` (个人很讨厌这种语法)\n索引可以用.来索引\n```\n:echo {'a':1, 2:\"two\",}['a'] // 1\n:echo {'a':1, 2:\"two\",}[2] // two\n:echo {'a':1, 2:\"two\",}.a // 1\n```\n\n增加键值\n```\n:let dic={'a':1,}\n:let dic.b=2\n:echo dic // {'a':1, 'b':2}\n```\n\n```\n:let tmp=remove(dic, 'a') //移除dic中a，但是把a的值赋值给tmp\n:unlet dic.b //移除b。但是不返回值\n```\n\n```\n:echo has_key({'a':1}, 'a') // 1\n:echo has_key({'a':1}, 'b') //0\n:echo items({'a':1, 'b':2}) // [['a',1],['b',2]] items返回是无序的。因为dict本身是无序的\n:echo keys({'a':1, 'b':2}) // ['a', 'b']\n:echo values({'a':1, 'b':2}) //[1,2]\n```\n\nlist中的get函数同样可以用于dict\n### 函数式编程\n1. 在函数内部赋值传入的参数。已达到不影响外部变量。\n```\nfunction! Reversed(l)\n    let new_list = deepcopy(a:l)\n    call reverse(new_list)\n    return new_list\nendfunction\n```\n\n#### deepcopy 与copy\n 区别如下\n```\nlet a=[1,2]\nlet b=[a,3,4] // [[1,2],3,4]\nlet c=copy(b) // [[1,2],3,4]\nlet d=deepcopy(b) //[[1,2],3,4]\nlet b[0][0]=5\nlet b[1]=6\necho a  //[5,2]\necho b  //[[5,2],6,4]\necho c  //[[5,2],3,4]\necho d  //[[1,2],3,4]\n```\n\n2. 将函数赋值给变量。变量名字首字母大写\n```\n:let Myfunc = function(\"add\")\n:echo Myfunc([1,2],3) // [1,2,3]\n:let funclist=[function(\"add\"), function(\"reverse\")]\n:echo funclist[0]([1,2],3) // [1,2,3]\n```\n\n### 路径\n```\n:echo expand('%') // filename  相对路径\n:echo expand('%:p') // /home/.../filename 绝对路径\n:echo fnamemodify('test.erl', ':p') // /home/youthy/.../test.erl 无论文件test是否存在\n:echo globpath('.', '*.erl') // 显示当前目录下所有erl文件的路径\n:echo split(globpath('.','*.erl'), '\\n') //将上述结果分割成列表\n```\n\n`:set runtimepath=/XX/XXX` 修改运行时路径。\n\n### Regex 正则表达式\nfor starters `:help user_27`\n\n所有的search 受大小写设置的影响\n```\n:set ignorecase // 忽略\n:set noignorecase // 不忽略大小写\n:set ingorecase smartcase //智能模式。 小写时match所有。有一个大写字母时精确匹配。\n```\n\n`\\c`, `\\C` 无视ignorecase设置。用于自己某个特殊的匹配。前者 表示ignorecase 后者是noignorecase\n>\tpattern\t\t\tmatches\t~\n\t\\Cword\t\t\tword\n\t\\CWord\t\t\tWord\n\t\\cword\t\t\tword, Word, WORD, WoRd, etc.\n\t\\cWord\t\t\tword, Word, WORD, WoRd, etc.\n\n`*` 0至多个 \n`\\+` 1至多个\n`\\=` 0至1个\n`'\\{n, m}'` 重复n至m次\n`'\\\\|'` 或者\n```\n'ab*'   // a, ab, abb, abbb...\n'c\\(ab\\)*' // c, cab, cabab, cababab...  需用括号括起，但是需要转义\n'c\\(ab\\)\\{2, 3}' // cabab, cababab\n'ab\\+' // ab, abb, abbb...\n'ab\\=' // a, ab\n```\n\n>\titem\tmatches\t\t\tequivalent ~\n\t\\d\tdigit\t\t\t[0-9]\n\t\\D\tnon-digit\t\t[^0-9]\n\t\\x\thex digit\t\t[0-9a-fA-F]\n\t\\X\tnon-hex digit\t\t[^0-9a-fA-F]\n\t\\s\twhite space\t\t[ \t]     (<Tab> and <Space>)\n\t\\S\tnon-white characters\t[^ \t]     (not <Tab> and <Space>)\n\t\\l\tlowercase alpha\t\t[a-z]\n\t\\L\tnon-lowercase alpha\t[^a-z]\n\t\\u\tuppercase alpha\t\t[A-Z]\n\t\\U\tnon-uppercase alpha\t[^A-Z]\n\t\\h [A-Za-z_]\n\t\\w [A-Za-z0-9_]\n\n以上不能用于`[]`里面\n\n注意　`'`, `\"`的影响。`\"`会转义`\\`, 导致`'\\w\\+'`这种变成`\"\\\\w\\\\+\"`\n\n\n\n[笨方法学vimscript](http://learnvimscriptthehardway.onefloweroneworld.com/)\n\n\n\n\n\n    \n\n\n\n\n","source":"_posts/vimscript笔记.md","raw":"title: vimscript笔记\ndate: 2016-05-06 15:33:21\ntags: vim\ntoc: true\n---\n\n\n> Remeber `:help` always be with you  -- albert einstein\n记住`:help`　与你同在\n\n<!-- more -->\n<!-- toc -->\n\n### First of all\n首先`:help echo/function/....`　help可以查看一个关键词的帮助.首先要习惯使用它\n\n### echo echom  打印信息帮助调试\n```\n:echo \"test\"\n:echo \"test2\"\n:messages\n```\n\ntest2在message中，而test不在。\nechom 主要用来调试。\n\n### 注释\n```\n\" 这是注释\n```\n\n### (布尔)选项\n\n`:set` 用于设置内置的选项。有的是布尔选项，有的不是 see `:help set`\n```\n:set number\n:set nonumber\n:set number!\n:set number?\n:set number numberwidth=4\n:set omnifunc=XXX#complete\n```\n\nnumber是一个布尔选项。任何布尔选项都可以通过`set` ,`set no(Bool)`, 设置开启关闭`set Bool!`切换开关状态.\n`set {Option}?` 用来查看当前值. \n有些选项可以赋值.多选项用空格隔开一次赋值\nnumber是用来显示行号的布尔值\nomnifunc 是补全函数\n在脚本中如果要引用某个选项使用`&`, 比如\n```\nif &filetype == \"vim\"\n```\n\n判断当前文件类型是否是vimscript\n\n### map 映射!映射!\n`:help map-commands`\n```\n:map - x  //  任何模式下将'-'映射为'x'\n:map <space> x\n:map <c-d> x\n:nmap - x\n:vmap - x\n:imap - x\n:noremap - x\n:noremap \\ -\n```\n\nmap通用于所有模式下。nmap,vmap, imap分别映射在不同的模式下。\nnoremap不存在递归风险。任何时候都应该使用这种方式。**对，任何时候**\n\n### leader按键\n`:help mapleader`\n很多插件中存在各种映射都用的<leader>这个按键\n```\n:let mapleader=\"-\"\n:nnoremap <leader>d dd\nlet maplocalleader = \"\\\\\"\n:noremap <buffer> <localleader>d dd\n```\n\nleader 默认为`\\`, 如果修改可以通过`echo mapleader`查看\nlocalleader 只针对某个buffer\n> 除了map 还有各种其他地方指定`<buffer>`的设置。比如autocmd,加上buffer比较安全。\n\n同样有的选项也支持`:setlocal number`\n\n### iabbrev\n```\n:iabbrev waht what\n```\n\n自动替换。　可以将ｗａｈｔ　替换为ｗｈａｔ\niabbrev是结束insert mode时发生的。 如果what前后有别的则不会发生替换.这点与`inoremap waht what`不同\n同样可以接受`:iabbrev <buffer> XXXX`　只对当前buffer生效\n\n### autocmd 自动命令\n`:help autocmd`\n`:help Event`\n```\n:autocmd BufNewFild,BufRead *.html :normal gg=G\n         事件                模式   执行命令\n```\n\n`autocmd Event File Command`  对File文件接收到event事件后　触发command\n\nEvent后面的模式每个pattern不一样。\n比如 `:autocmd FileType vim call SomeFun()`\n**这里有个危险的地方**\n单纯的`autocmd` 并不会覆盖之前的命令。如果同一个`autocmd`加载多次他们会同时存在也就是可能对于同一个事件执行多次`SomeFun()`.\n这里vim有一种自动命令组的方法\n```\n:augroup testgroup\n:    autocmd BufWrite * :echom \"Foo\"\n:    autocmd BufWrite * :echom \"Bar\"\n:augroup END\n```\n\n上面将\"Foo\", \"Bar\"两个事件归到testgroup组中。这时testgroup相当于一个`autocmd`　同样多次执行testgroup也会造成上面的情况。同样，如果之后在执行\n```\n:augroup testgroup\n:    autocmd BufWrite * :echom \"Baz\"\n:augroup END\n```\n\n\"Foo\", \"Bar\"并没有清除.而是将\"Baz\"合并到了testgroup中.这样没有解决多次读取事件造成重复调用的问题。\n解决的办法是在组开始的地方调用 `autocmd!`来清除这个组的事件\n```\n:augroup testgroup\n:    autocmd!\n:    autocmd BufWrite * :echom \"Cats\"\n:    autocmd XXXXX....\n:augroup END\n```\n\n这样解决了多次重复调用的问题\n\n### operator_pending\n\n`:onoremap p ic`\n\nw, p, t 各种定位词　ｏｎｏｒｅｍａｐ可以修改定位词映射\n\n### :normal\n`:normal gg`\n`:normal` 后面会跟一个字符串。相当于在ｎｏｒｍａｌ模式下按下这些按键\n\n当然永远不要用normal 而是用`normal!` 后者无视映射。因为你永远不知道用户把按键映射成了什么\n\n### :execute\n`:execute \":normal!  gg\"\n\nexecute 后面跟脚本。\n\n为什么不直接用normal!,而是用execute呢\n因为normal不能识别特殊字符。比如<cr>回车符等所以一般要包个execute命令。\n比如`:normal! a\\<cr>` 我们设想先按下a进入insert模式然后输出回车符换行.但是实际上这个命令进入插入模式后，直\n接将`\\<cr>`输入到了buffer中.我们可以用`execute \"normal! a\\<cr>\"完成这个动作\n\n### set statusline\n```\n:set statusline=%f\\ -\\ %y\n:set statusline+=%=\n:set statusline+=%L\n```\n\n修改状态条显示内容。类似printf %f 是文件名%y是文件类型 %=表示后面的右对齐%L显示总行数。\n\n### let  变量\n```\n:let foo=\"bar\"\n:echo foo  //显示ｂａｒ\n:set number\n:echo &number //1\n:let number = 100\n:echo number //100\n:let &number=&number-1\n:echo &number //0　number是是否显示行号的布尔值\n```\n\nlet 用来定义一个变量,这个变量可以与某个选项同名(set), 只不过选项的引用需要前面加`&`\nset 只能给选项赋值常量值\n而let 可以用变量给变量赋值,如上面的`&number`\n`:let &l:number = 100`可以给本地变量赋值而不影响其他buffer\n\n### 寄存器\n`:register` 查看所有寄存器内容\n`\"ap` a是寄存器名字. 表示将a中的内容粘贴到此处\n`echo @a` 打印a中的内容\n`let @a=\"test\"` 修改a中内容\n`\"`寄存器是为指定寄存器所有为指定寄存器的复制操作,内容都会写入这里\n\n### 管道\n`:echo \"haha\" | echo \"heihei`\n\n\n### if\n```\n:if \"20haha\"\n:   echo \"true\"\n:endif\n\n:if \"haha20\"\n:   echo \"true\"\n:else\n:   echo \"false\"\n:endif\n```\n\n第一个会显示ｔｒｕｅ　第二个是ｆａｌｓｅ　\n因为字符串在强制转换时第一个是数字会转化为相应的数字。否则是０\n\n#### 比较\n不能完全信任`==`\n因为vim的大小写敏感时用户设置的\n```\n:set ignorecase\n:if \"foo\" == \"FOO\"\n```\n\n这个语句真假取决于ignorecase的设置。\n替代品\n`==?` 大小写不敏感比较\n`==#` 大小写敏感比较\n\n### 函数\n```\n:function Test()\n:   XXXXX\n:endfunction\n:function s:testb()\n:   echom \"script test\"\n:endfunction\n:call Test()\n```\n\n**没有限制作用域的函数必须以大写字母开头**\n脚本内的私有函数以`s:`开头\n函数没有显示指定`return XX`则默认返回0\n\n\n#### 参数\n```\n:function EchoTest(name)\n:   echo a:name\n:endfunction\n```\n\n函数的参数总要加a这个作用域否则会提示找不到\n\n#### 可变参数\n```\n:function Test(...)  // 假如 call Test(\"a\", \"b\", \"c\")\n:   echo a:0         // 3 参数个数\n:   echo a:1         // \"a\"\n:   echo a:000       // ['a', 'b', 'c'] 000指参数列表.不能用echom输出只能用echo\n:endfunction\n```\n\n`:call Test(\"a\", \"b\", \"c\")`\na:0 指的是参数数量。 a:1 是 \"a\".以此类推\n\n#### 命名空间\n> |buffer-variable|    b:\t  Local to the current buffer.\n|window-variable|    w:\t  Local to the current window.\n|tabpage-variable|   t:\t  Local to the current tab page.\n|global-variable|    g:\t  Global.\n|local-variable|     l:\t  Local to a function.\n|script-variable|    s:\t  Local to a |:source|'ed Vim script.\n|function-argument|  a:\t  Function argument (only inside a function).\n|vim-variable|\t     v:\t  Global, predefined by Vim.\n\n命名空间可以当做dict使用\n``` \nfor k in keys(b:)\n    unlet b:[k]\nendfor\n```\n\n可以混合可变参数和固定参数\n`:function Test(a, ...)`\n\n不能对函数的参数改变赋值\n```\n:function Test(foo)\n:   let a:foo=\"change\" //这样做会报错\n:   let tmp=a:foo      // 这样才可以\n:   let tmp=\"change\"\n:endfunction\n```\n\n### 字符串\n#### 连接符\n```\n:echo \"haha\".\"heihei\" \n```\n\n上面输出\"hahaheihei\"\n\n#### 字符串函数\n`:help function-list` 查看所有函数分类列表\n\n`strlen(\"string\")`\n`len(\"string\")`\n`echo split(\"one two\")`\n`echo split(\"one,two\",\",\")`\n`echo join([\"one\",\"two\"], \",\")`\n`echo tolower(\"BIG\")`\n`echo toupper(\"low\")`\n\n### 列表\n1. 有序，异质\n2. 索引从0开始 \n```\n:echo [1,2,3][0] // 1\n:echo [1,2,3][-1] //3\n:echo \"abc\"[1] // b\n:echo \"abc\"[-1] // 无效。\n```\n\n3. 切割\n```\n:echo [1,2,3][:1] // [1,2]\n:echo [1,2,3][1:] // [2,3]\n:echo [1,2,3][:1000] // [1,2,3] 可以越界\n:echo [1,2,3,4][-2:-1] //[3,4]\n:echo [1,2,3,4][-2:1] // []\n:echo \"abc\"[-2:-1] // bc。上面的负数索引无效。切割却有效。。。\n```\n\n4.连接\n```\n:echo ['a','b'] + ['c'] // ['a','b','c']\n:echo [1,2] + [3]//[1,2,3]\n:echo [a,b] + [c] // 错误。\n:echo \"ab\".\"c\" //\"abc\"\n```\n\n5. 列表函数\n```\n:echo add([1,2],3) // [1,2,3]\n:echo get([1,2,3], 0, 'default') // 1\n:echo get([1,2,3], 4, 'default') // default\n:echo index([1,2,3], 1) // 0\n:echo index([1,2,3], 4) // -1 不存在返回-1\n:echo join([1,2], \"-\") // 1-2\n:echo reverse([1,2]) //[2,1]\n```\n\n更多阅读`:help List` `:help functions`\n\n### 循环\n#### for\n```\n:for i in [1,2,3,4]\n:   let c += i\n:endfor\n```\n\n```\n:let c=1\n:while c < 3\n: let t += c\n: let c += 1\n:endwhile\n```\n\n### dict\n`{'a':1, 2:\"two\",}` 字典的key总是会自动转为字符串.  应该总是结尾留一个`,` (个人很讨厌这种语法)\n索引可以用.来索引\n```\n:echo {'a':1, 2:\"two\",}['a'] // 1\n:echo {'a':1, 2:\"two\",}[2] // two\n:echo {'a':1, 2:\"two\",}.a // 1\n```\n\n增加键值\n```\n:let dic={'a':1,}\n:let dic.b=2\n:echo dic // {'a':1, 'b':2}\n```\n\n```\n:let tmp=remove(dic, 'a') //移除dic中a，但是把a的值赋值给tmp\n:unlet dic.b //移除b。但是不返回值\n```\n\n```\n:echo has_key({'a':1}, 'a') // 1\n:echo has_key({'a':1}, 'b') //0\n:echo items({'a':1, 'b':2}) // [['a',1],['b',2]] items返回是无序的。因为dict本身是无序的\n:echo keys({'a':1, 'b':2}) // ['a', 'b']\n:echo values({'a':1, 'b':2}) //[1,2]\n```\n\nlist中的get函数同样可以用于dict\n### 函数式编程\n1. 在函数内部赋值传入的参数。已达到不影响外部变量。\n```\nfunction! Reversed(l)\n    let new_list = deepcopy(a:l)\n    call reverse(new_list)\n    return new_list\nendfunction\n```\n\n#### deepcopy 与copy\n 区别如下\n```\nlet a=[1,2]\nlet b=[a,3,4] // [[1,2],3,4]\nlet c=copy(b) // [[1,2],3,4]\nlet d=deepcopy(b) //[[1,2],3,4]\nlet b[0][0]=5\nlet b[1]=6\necho a  //[5,2]\necho b  //[[5,2],6,4]\necho c  //[[5,2],3,4]\necho d  //[[1,2],3,4]\n```\n\n2. 将函数赋值给变量。变量名字首字母大写\n```\n:let Myfunc = function(\"add\")\n:echo Myfunc([1,2],3) // [1,2,3]\n:let funclist=[function(\"add\"), function(\"reverse\")]\n:echo funclist[0]([1,2],3) // [1,2,3]\n```\n\n### 路径\n```\n:echo expand('%') // filename  相对路径\n:echo expand('%:p') // /home/.../filename 绝对路径\n:echo fnamemodify('test.erl', ':p') // /home/youthy/.../test.erl 无论文件test是否存在\n:echo globpath('.', '*.erl') // 显示当前目录下所有erl文件的路径\n:echo split(globpath('.','*.erl'), '\\n') //将上述结果分割成列表\n```\n\n`:set runtimepath=/XX/XXX` 修改运行时路径。\n\n### Regex 正则表达式\nfor starters `:help user_27`\n\n所有的search 受大小写设置的影响\n```\n:set ignorecase // 忽略\n:set noignorecase // 不忽略大小写\n:set ingorecase smartcase //智能模式。 小写时match所有。有一个大写字母时精确匹配。\n```\n\n`\\c`, `\\C` 无视ignorecase设置。用于自己某个特殊的匹配。前者 表示ignorecase 后者是noignorecase\n>\tpattern\t\t\tmatches\t~\n\t\\Cword\t\t\tword\n\t\\CWord\t\t\tWord\n\t\\cword\t\t\tword, Word, WORD, WoRd, etc.\n\t\\cWord\t\t\tword, Word, WORD, WoRd, etc.\n\n`*` 0至多个 \n`\\+` 1至多个\n`\\=` 0至1个\n`'\\{n, m}'` 重复n至m次\n`'\\\\|'` 或者\n```\n'ab*'   // a, ab, abb, abbb...\n'c\\(ab\\)*' // c, cab, cabab, cababab...  需用括号括起，但是需要转义\n'c\\(ab\\)\\{2, 3}' // cabab, cababab\n'ab\\+' // ab, abb, abbb...\n'ab\\=' // a, ab\n```\n\n>\titem\tmatches\t\t\tequivalent ~\n\t\\d\tdigit\t\t\t[0-9]\n\t\\D\tnon-digit\t\t[^0-9]\n\t\\x\thex digit\t\t[0-9a-fA-F]\n\t\\X\tnon-hex digit\t\t[^0-9a-fA-F]\n\t\\s\twhite space\t\t[ \t]     (<Tab> and <Space>)\n\t\\S\tnon-white characters\t[^ \t]     (not <Tab> and <Space>)\n\t\\l\tlowercase alpha\t\t[a-z]\n\t\\L\tnon-lowercase alpha\t[^a-z]\n\t\\u\tuppercase alpha\t\t[A-Z]\n\t\\U\tnon-uppercase alpha\t[^A-Z]\n\t\\h [A-Za-z_]\n\t\\w [A-Za-z0-9_]\n\n以上不能用于`[]`里面\n\n注意　`'`, `\"`的影响。`\"`会转义`\\`, 导致`'\\w\\+'`这种变成`\"\\\\w\\\\+\"`\n\n\n\n[笨方法学vimscript](http://learnvimscriptthehardway.onefloweroneworld.com/)\n\n\n\n\n\n    \n\n\n\n\n","slug":"vimscript笔记","published":1,"updated":"2018-06-26T09:49:27.737Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqw7jdwj00226f1r837g59ud","content":"<blockquote>\n<p>Remeber <code>:help</code> always be with you  -- albert einstein<br>记住<code>:help</code>　与你同在</p>\n</blockquote>\n<span id=\"more\"></span>\n<!-- toc -->\n<ul>\n<li><a href=\"#first-of-all\">First of all</a></li>\n<li><a href=\"#echo-echom----------\">echo echom  打印信息帮助调试</a></li>\n<li><a href=\"#--\">注释</a></li>\n<li><a href=\"#------\">(布尔)选项</a></li>\n<li><a href=\"#map-------\">map 映射!映射!</a></li>\n<li><a href=\"#leader--\">leader按键</a></li>\n<li><a href=\"#iabbrev\">iabbrev</a></li>\n<li><a href=\"#autocmd-----\">autocmd 自动命令</a></li>\n<li><a href=\"#operator-pending\">operator_pending</a></li>\n<li><a href=\"#-normal\">:normal</a></li>\n<li><a href=\"#-execute\">:execute</a></li>\n<li><a href=\"#set-statusline\">set statusline</a></li>\n<li><a href=\"#let----\">let  变量</a></li>\n<li><a href=\"#---\">寄存器</a></li>\n<li><a href=\"#--\">管道</a></li>\n<li><a href=\"#if\">if</a><ul>\n<li><a href=\"#--\">比较</a></li>\n</ul>\n</li>\n<li><a href=\"#--\">函数</a><ul>\n<li><a href=\"#--\">参数</a></li>\n<li><a href=\"#----\">可变参数</a></li>\n<li><a href=\"#----\">命名空间</a></li>\n</ul>\n</li>\n<li><a href=\"#---\">字符串</a><ul>\n<li><a href=\"#---\">连接符</a></li>\n<li><a href=\"#-----\">字符串函数</a></li>\n</ul>\n</li>\n<li><a href=\"#--\">列表</a></li>\n<li><a href=\"#--\">循环</a><ul>\n<li><a href=\"#for\">for</a></li>\n</ul>\n</li>\n<li><a href=\"#dict\">dict</a></li>\n<li><a href=\"#-----\">函数式编程</a><ul>\n<li><a href=\"#deepcopy--copy\">deepcopy 与copy</a></li>\n</ul>\n</li>\n<li><a href=\"#--\">路径</a></li>\n<li><a href=\"#regex------\">Regex 正则表达式</a></li>\n</ul>\n<!-- tocstop -->\n<h3 id=\"First_of_all\">First of all</h3><p>首先<code>:help echo/function/....</code>　help可以查看一个关键词的帮助.首先要习惯使用它</p>\n<h3 id=\"echo_echom_打印信息帮助调试\">echo echom  打印信息帮助调试</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:echo &quot;test&quot;</span><br><span class=\"line\">:echo &quot;test2&quot;</span><br><span class=\"line\">:messages</span><br></pre></td></tr></table></figure>\n<p>test2在message中，而test不在。<br>echom 主要用来调试。</p>\n<h3 id=\"注释\">注释</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot; 这是注释</span><br></pre></td></tr></table></figure>\n<h3 id=\"(布尔)选项\">(布尔)选项</h3><p><code>:set</code> 用于设置内置的选项。有的是布尔选项，有的不是 see <code>:help set</code><br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:set number</span><br><span class=\"line\">:set nonumber</span><br><span class=\"line\">:set number!</span><br><span class=\"line\">:set number?</span><br><span class=\"line\">:set number numberwidth=4</span><br><span class=\"line\">:set omnifunc=XXX#complete</span><br></pre></td></tr></table></figure></p>\n<p>number是一个布尔选项。任何布尔选项都可以通过<code>set</code> ,<code>set no(Bool)</code>, 设置开启关闭<code>set Bool!</code>切换开关状态.<br><code>set &#123;Option&#125;?</code> 用来查看当前值.<br>有些选项可以赋值.多选项用空格隔开一次赋值<br>number是用来显示行号的布尔值<br>omnifunc 是补全函数<br>在脚本中如果要引用某个选项使用<code>&amp;</code>, 比如<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if &amp;filetype == &quot;vim&quot;</span><br></pre></td></tr></table></figure></p>\n<p>判断当前文件类型是否是vimscript</p>\n<h3 id=\"map_映射!映射!\">map 映射!映射!</h3><p><code>:help map-commands</code><br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:map - x  //  任何模式下将&#x27;-&#x27;映射为&#x27;x&#x27;</span><br><span class=\"line\">:map &lt;space&gt; x</span><br><span class=\"line\">:map &lt;c-d&gt; x</span><br><span class=\"line\">:nmap - x</span><br><span class=\"line\">:vmap - x</span><br><span class=\"line\">:imap - x</span><br><span class=\"line\">:noremap - x</span><br><span class=\"line\">:noremap \\ -</span><br></pre></td></tr></table></figure></p>\n<p>map通用于所有模式下。nmap,vmap, imap分别映射在不同的模式下。<br>noremap不存在递归风险。任何时候都应该使用这种方式。<strong>对，任何时候</strong></p>\n<h3 id=\"leader按键\">leader按键</h3><p><code>:help mapleader</code><br>很多插件中存在各种映射都用的<leader>这个按键<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:let mapleader=&quot;-&quot;</span><br><span class=\"line\">:nnoremap &lt;leader&gt;d dd</span><br><span class=\"line\">let maplocalleader = &quot;\\\\&quot;</span><br><span class=\"line\">:noremap &lt;buffer&gt; &lt;localleader&gt;d dd</span><br></pre></td></tr></table></figure></p>\n<p>leader 默认为<code>\\</code>, 如果修改可以通过<code>echo mapleader</code>查看<br>localleader 只针对某个buffer</p>\n<blockquote>\n<p>除了map 还有各种其他地方指定<code>&lt;buffer&gt;</code>的设置。比如autocmd,加上buffer比较安全。</p>\n</blockquote>\n<p>同样有的选项也支持<code>:setlocal number</code></p>\n<h3 id=\"iabbrev\">iabbrev</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:iabbrev waht what</span><br></pre></td></tr></table></figure>\n<p>自动替换。　可以将ｗａｈｔ　替换为ｗｈａｔ<br>iabbrev是结束insert mode时发生的。 如果what前后有别的则不会发生替换.这点与<code>inoremap waht what</code>不同<br>同样可以接受<code>:iabbrev &lt;buffer&gt; XXXX</code>　只对当前buffer生效</p>\n<h3 id=\"autocmd_自动命令\">autocmd 自动命令</h3><p><code>:help autocmd</code><br><code>:help Event</code><br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:autocmd BufNewFild,BufRead *.html :normal gg=G</span><br><span class=\"line\">         事件                模式   执行命令</span><br></pre></td></tr></table></figure></p>\n<p><code>autocmd Event File Command</code>  对File文件接收到event事件后　触发command</p>\n<p>Event后面的模式每个pattern不一样。<br>比如 <code>:autocmd FileType vim call SomeFun()</code><br><strong>这里有个危险的地方</strong><br>单纯的<code>autocmd</code> 并不会覆盖之前的命令。如果同一个<code>autocmd</code>加载多次他们会同时存在也就是可能对于同一个事件执行多次<code>SomeFun()</code>.<br>这里vim有一种自动命令组的方法<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:augroup testgroup</span><br><span class=\"line\">:    autocmd BufWrite * :echom &quot;Foo&quot;</span><br><span class=\"line\">:    autocmd BufWrite * :echom &quot;Bar&quot;</span><br><span class=\"line\">:augroup END</span><br></pre></td></tr></table></figure></p>\n<p>上面将&quot;Foo&quot;, &quot;Bar&quot;两个事件归到testgroup组中。这时testgroup相当于一个<code>autocmd</code>　同样多次执行testgroup也会造成上面的情况。同样，如果之后在执行<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:augroup testgroup</span><br><span class=\"line\">:    autocmd BufWrite * :echom &quot;Baz&quot;</span><br><span class=\"line\">:augroup END</span><br></pre></td></tr></table></figure></p>\n<p>&quot;Foo&quot;, &quot;Bar&quot;并没有清除.而是将&quot;Baz&quot;合并到了testgroup中.这样没有解决多次读取事件造成重复调用的问题。<br>解决的办法是在组开始的地方调用 <code>autocmd!</code>来清除这个组的事件<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:augroup testgroup</span><br><span class=\"line\">:    autocmd!</span><br><span class=\"line\">:    autocmd BufWrite * :echom &quot;Cats&quot;</span><br><span class=\"line\">:    autocmd XXXXX....</span><br><span class=\"line\">:augroup END</span><br></pre></td></tr></table></figure></p>\n<p>这样解决了多次重复调用的问题</p>\n<h3 id=\"operator_pending\">operator_pending</h3><p><code>:onoremap p ic</code></p>\n<p>w, p, t 各种定位词　ｏｎｏｒｅｍａｐ可以修改定位词映射</p>\n<h3 id=\":normal\">:normal</h3><p><code>:normal gg</code><br><code>:normal</code> 后面会跟一个字符串。相当于在ｎｏｒｍａｌ模式下按下这些按键</p>\n<p>当然永远不要用normal 而是用<code>normal!</code> 后者无视映射。因为你永远不知道用户把按键映射成了什么</p>\n<h3 id=\":execute\">:execute</h3><p>`:execute &quot;:normal!  gg&quot;</p>\n<p>execute 后面跟脚本。</p>\n<p>为什么不直接用normal!,而是用execute呢<br>因为normal不能识别特殊字符。比如<cr>回车符等所以一般要包个execute命令。<br>比如<code>:normal! a\\&lt;cr&gt;</code> 我们设想先按下a进入insert模式然后输出回车符换行.但是实际上这个命令进入插入模式后，直<br>接将<code>\\&lt;cr&gt;</code>输入到了buffer中.我们可以用`execute &quot;normal! a\\<cr>&quot;完成这个动作</p>\n<h3 id=\"set_statusline\">set statusline</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:set statusline=%f\\ -\\ %y</span><br><span class=\"line\">:set statusline+=%=</span><br><span class=\"line\">:set statusline+=%L</span><br></pre></td></tr></table></figure>\n<p>修改状态条显示内容。类似printf %f 是文件名%y是文件类型 %=表示后面的右对齐%L显示总行数。</p>\n<h3 id=\"let_变量\">let  变量</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:let foo=&quot;bar&quot;</span><br><span class=\"line\">:echo foo  //显示ｂａｒ</span><br><span class=\"line\">:set number</span><br><span class=\"line\">:echo &amp;number //1</span><br><span class=\"line\">:let number = 100</span><br><span class=\"line\">:echo number //100</span><br><span class=\"line\">:let &amp;number=&amp;number-1</span><br><span class=\"line\">:echo &amp;number //0　number是是否显示行号的布尔值</span><br></pre></td></tr></table></figure>\n<p>let 用来定义一个变量,这个变量可以与某个选项同名(set), 只不过选项的引用需要前面加<code>&amp;</code><br>set 只能给选项赋值常量值<br>而let 可以用变量给变量赋值,如上面的<code>&amp;number</code><br><code>:let &amp;l:number = 100</code>可以给本地变量赋值而不影响其他buffer</p>\n<h3 id=\"寄存器\">寄存器</h3><p><code>:register</code> 查看所有寄存器内容<br><code>&quot;ap</code> a是寄存器名字. 表示将a中的内容粘贴到此处<br><code>echo @a</code> 打印a中的内容<br><code>let @a=&quot;test&quot;</code> 修改a中内容<br><code>&quot;</code>寄存器是为指定寄存器所有为指定寄存器的复制操作,内容都会写入这里</p>\n<h3 id=\"管道\">管道</h3><p><code>:echo &quot;haha&quot; | echo &quot;heihei</code></p>\n<h3 id=\"if\">if</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:if &quot;20haha&quot;</span><br><span class=\"line\">:   echo &quot;true&quot;</span><br><span class=\"line\">:endif</span><br><span class=\"line\"></span><br><span class=\"line\">:if &quot;haha20&quot;</span><br><span class=\"line\">:   echo &quot;true&quot;</span><br><span class=\"line\">:else</span><br><span class=\"line\">:   echo &quot;false&quot;</span><br><span class=\"line\">:endif</span><br></pre></td></tr></table></figure>\n<p>第一个会显示ｔｒｕｅ　第二个是ｆａｌｓｅ　<br>因为字符串在强制转换时第一个是数字会转化为相应的数字。否则是０</p>\n<h4 id=\"比较\">比较</h4><p>不能完全信任<code>==</code><br>因为vim的大小写敏感时用户设置的<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:set ignorecase</span><br><span class=\"line\">:if &quot;foo&quot; == &quot;FOO&quot;</span><br></pre></td></tr></table></figure></p>\n<p>这个语句真假取决于ignorecase的设置。<br>替代品<br><code>==?</code> 大小写不敏感比较<br><code>==#</code> 大小写敏感比较</p>\n<h3 id=\"函数\">函数</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:function Test()</span><br><span class=\"line\">:   XXXXX</span><br><span class=\"line\">:endfunction</span><br><span class=\"line\">:function s:testb()</span><br><span class=\"line\">:   echom &quot;script test&quot;</span><br><span class=\"line\">:endfunction</span><br><span class=\"line\">:call Test()</span><br></pre></td></tr></table></figure>\n<p><strong>没有限制作用域的函数必须以大写字母开头</strong><br>脚本内的私有函数以<code>s:</code>开头<br>函数没有显示指定<code>return XX</code>则默认返回0</p>\n<h4 id=\"参数\">参数</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:function EchoTest(name)</span><br><span class=\"line\">:   echo a:name</span><br><span class=\"line\">:endfunction</span><br></pre></td></tr></table></figure>\n<p>函数的参数总要加a这个作用域否则会提示找不到</p>\n<h4 id=\"可变参数\">可变参数</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:function Test(...)  // 假如 call Test(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)</span><br><span class=\"line\">:   echo a:0         // 3 参数个数</span><br><span class=\"line\">:   echo a:1         // &quot;a&quot;</span><br><span class=\"line\">:   echo a:000       // [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;] 000指参数列表.不能用echom输出只能用echo</span><br><span class=\"line\">:endfunction</span><br></pre></td></tr></table></figure>\n<p><code>:call Test(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)</code><br>a:0 指的是参数数量。 a:1 是 &quot;a&quot;.以此类推</p>\n<h4 id=\"命名空间\">命名空间</h4><blockquote>\n<p>|buffer-variable|    b:      Local to the current buffer.<br>|window-variable|    w:      Local to the current window.<br>|tabpage-variable|   t:      Local to the current tab page.<br>|global-variable|    g:      Global.<br>|local-variable|     l:      Local to a function.<br>|script-variable|    s:      Local to a |:source|&#39;ed Vim script.<br>|function-argument|  a:      Function argument (only inside a function).<br>|vim-variable|         v:      Global, predefined by Vim.</p>\n</blockquote>\n<p>命名空间可以当做dict使用<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for k in keys(b:)</span><br><span class=\"line\">    unlet b:[k]</span><br><span class=\"line\">endfor</span><br></pre></td></tr></table></figure></p>\n<p>可以混合可变参数和固定参数<br><code>:function Test(a, ...)</code></p>\n<p>不能对函数的参数改变赋值<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:function Test(foo)</span><br><span class=\"line\">:   let a:foo=&quot;change&quot; //这样做会报错</span><br><span class=\"line\">:   let tmp=a:foo      // 这样才可以</span><br><span class=\"line\">:   let tmp=&quot;change&quot;</span><br><span class=\"line\">:endfunction</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"字符串\">字符串</h3><h4 id=\"连接符\">连接符</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:echo &quot;haha&quot;.&quot;heihei&quot; </span><br></pre></td></tr></table></figure>\n<p>上面输出&quot;hahaheihei&quot;</p>\n<h4 id=\"字符串函数\">字符串函数</h4><p><code>:help function-list</code> 查看所有函数分类列表</p>\n<p><code>strlen(&quot;string&quot;)</code><br><code>len(&quot;string&quot;)</code><br><code>echo split(&quot;one two&quot;)</code><br><code>echo split(&quot;one,two&quot;,&quot;,&quot;)</code><br><code>echo join([&quot;one&quot;,&quot;two&quot;], &quot;,&quot;)</code><br><code>echo tolower(&quot;BIG&quot;)</code><br><code>echo toupper(&quot;low&quot;)</code></p>\n<h3 id=\"列表\">列表</h3><ol>\n<li>有序，异质</li>\n<li><p>索引从0开始 </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:echo [1,2,3][0] // 1</span><br><span class=\"line\">:echo [1,2,3][-1] //3</span><br><span class=\"line\">:echo &quot;abc&quot;[1] // b</span><br><span class=\"line\">:echo &quot;abc&quot;[-1] // 无效。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>切割</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:echo [1,2,3][:1] // [1,2]</span><br><span class=\"line\">:echo [1,2,3][1:] // [2,3]</span><br><span class=\"line\">:echo [1,2,3][:1000] // [1,2,3] 可以越界</span><br><span class=\"line\">:echo [1,2,3,4][-2:-1] //[3,4]</span><br><span class=\"line\">:echo [1,2,3,4][-2:1] // []</span><br><span class=\"line\">:echo &quot;abc&quot;[-2:-1] // bc。上面的负数索引无效。切割却有效。。。</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>4.连接<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:echo [&#x27;a&#x27;,&#x27;b&#x27;] + [&#x27;c&#x27;] // [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;]</span><br><span class=\"line\">:echo [1,2] + [3]//[1,2,3]</span><br><span class=\"line\">:echo [a,b] + [c] // 错误。</span><br><span class=\"line\">:echo &quot;ab&quot;.&quot;c&quot; //&quot;abc&quot;</span><br></pre></td></tr></table></figure></p>\n<ol start=\"5\">\n<li>列表函数<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:echo add([1,2],3) // [1,2,3]</span><br><span class=\"line\">:echo get([1,2,3], 0, &#x27;default&#x27;) // 1</span><br><span class=\"line\">:echo get([1,2,3], 4, &#x27;default&#x27;) // default</span><br><span class=\"line\">:echo index([1,2,3], 1) // 0</span><br><span class=\"line\">:echo index([1,2,3], 4) // -1 不存在返回-1</span><br><span class=\"line\">:echo join([1,2], &quot;-&quot;) // 1-2</span><br><span class=\"line\">:echo reverse([1,2]) //[2,1]</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>更多阅读<code>:help List</code> <code>:help functions</code></p>\n<h3 id=\"循环\">循环</h3><h4 id=\"for\">for</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:for i in [1,2,3,4]</span><br><span class=\"line\">:   let c += i</span><br><span class=\"line\">:endfor</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:let c=1</span><br><span class=\"line\">:while c &lt; 3</span><br><span class=\"line\">: let t += c</span><br><span class=\"line\">: let c += 1</span><br><span class=\"line\">:endwhile</span><br></pre></td></tr></table></figure>\n<h3 id=\"dict\">dict</h3><p><code>&#123;&#39;a&#39;:1, 2:&quot;two&quot;,&#125;</code> 字典的key总是会自动转为字符串.  应该总是结尾留一个<code>,</code> (个人很讨厌这种语法)<br>索引可以用.来索引<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:echo &#123;&#x27;a&#x27;:1, 2:&quot;two&quot;,&#125;[&#x27;a&#x27;] // 1</span><br><span class=\"line\">:echo &#123;&#x27;a&#x27;:1, 2:&quot;two&quot;,&#125;[2] // two</span><br><span class=\"line\">:echo &#123;&#x27;a&#x27;:1, 2:&quot;two&quot;,&#125;.a // 1</span><br></pre></td></tr></table></figure></p>\n<p>增加键值<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:let dic=&#123;&#x27;a&#x27;:1,&#125;</span><br><span class=\"line\">:let dic.b=2</span><br><span class=\"line\">:echo dic // &#123;&#x27;a&#x27;:1, &#x27;b&#x27;:2&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:let tmp=remove(dic, &#x27;a&#x27;) //移除dic中a，但是把a的值赋值给tmp</span><br><span class=\"line\">:unlet dic.b //移除b。但是不返回值</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:echo has_key(&#123;&#x27;a&#x27;:1&#125;, &#x27;a&#x27;) // 1</span><br><span class=\"line\">:echo has_key(&#123;&#x27;a&#x27;:1&#125;, &#x27;b&#x27;) //0</span><br><span class=\"line\">:echo items(&#123;&#x27;a&#x27;:1, &#x27;b&#x27;:2&#125;) // [[&#x27;a&#x27;,1],[&#x27;b&#x27;,2]] items返回是无序的。因为dict本身是无序的</span><br><span class=\"line\">:echo keys(&#123;&#x27;a&#x27;:1, &#x27;b&#x27;:2&#125;) // [&#x27;a&#x27;, &#x27;b&#x27;]</span><br><span class=\"line\">:echo values(&#123;&#x27;a&#x27;:1, &#x27;b&#x27;:2&#125;) //[1,2]</span><br></pre></td></tr></table></figure>\n<p>list中的get函数同样可以用于dict</p>\n<h3 id=\"函数式编程\">函数式编程</h3><ol>\n<li>在函数内部赋值传入的参数。已达到不影响外部变量。<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function! Reversed(l)</span><br><span class=\"line\">    let new_list = deepcopy(a:l)</span><br><span class=\"line\">    call reverse(new_list)</span><br><span class=\"line\">    return new_list</span><br><span class=\"line\">endfunction</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"deepcopy_与copy\">deepcopy 与copy</h4><p> 区别如下<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a=[1,2]</span><br><span class=\"line\">let b=[a,3,4] // [[1,2],3,4]</span><br><span class=\"line\">let c=copy(b) // [[1,2],3,4]</span><br><span class=\"line\">let d=deepcopy(b) //[[1,2],3,4]</span><br><span class=\"line\">let b[0][0]=5</span><br><span class=\"line\">let b[1]=6</span><br><span class=\"line\">echo a  //[5,2]</span><br><span class=\"line\">echo b  //[[5,2],6,4]</span><br><span class=\"line\">echo c  //[[5,2],3,4]</span><br><span class=\"line\">echo d  //[[1,2],3,4]</span><br></pre></td></tr></table></figure></p>\n<ol start=\"2\">\n<li>将函数赋值给变量。变量名字首字母大写<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:let Myfunc = function(&quot;add&quot;)</span><br><span class=\"line\">:echo Myfunc([1,2],3) // [1,2,3]</span><br><span class=\"line\">:let funclist=[function(&quot;add&quot;), function(&quot;reverse&quot;)]</span><br><span class=\"line\">:echo funclist[0]([1,2],3) // [1,2,3]</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"路径\">路径</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:echo expand(&#x27;%&#x27;) // filename  相对路径</span><br><span class=\"line\">:echo expand(&#x27;%:p&#x27;) // /home/.../filename 绝对路径</span><br><span class=\"line\">:echo fnamemodify(&#x27;test.erl&#x27;, &#x27;:p&#x27;) // /home/youthy/.../test.erl 无论文件test是否存在</span><br><span class=\"line\">:echo globpath(&#x27;.&#x27;, &#x27;*.erl&#x27;) // 显示当前目录下所有erl文件的路径</span><br><span class=\"line\">:echo split(globpath(&#x27;.&#x27;,&#x27;*.erl&#x27;), &#x27;\\n&#x27;) //将上述结果分割成列表</span><br></pre></td></tr></table></figure>\n<p><code>:set runtimepath=/XX/XXX</code> 修改运行时路径。</p>\n<h3 id=\"Regex_正则表达式\">Regex 正则表达式</h3><p>for starters <code>:help user_27</code></p>\n<p>所有的search 受大小写设置的影响<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:set ignorecase // 忽略</span><br><span class=\"line\">:set noignorecase // 不忽略大小写</span><br><span class=\"line\">:set ingorecase smartcase //智能模式。 小写时match所有。有一个大写字母时精确匹配。</span><br></pre></td></tr></table></figure></p>\n<p><code>\\c</code>, <code>\\C</code> 无视ignorecase设置。用于自己某个特殊的匹配。前者 表示ignorecase 后者是noignorecase</p>\n<blockquote>\n<p>   pattern            matches    ~<br>    \\Cword            word<br>    \\CWord            Word<br>    \\cword            word, Word, WORD, WoRd, etc.<br>    \\cWord            word, Word, WORD, WoRd, etc.</p>\n</blockquote>\n<p><code>*</code> 0至多个<br><code>\\+</code> 1至多个<br><code>\\=</code> 0至1个<br><code>&#39;\\&#123;n, m&#125;&#39;</code> 重复n至m次<br><code>&#39;\\\\|&#39;</code> 或者<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x27;ab*&#x27;   // a, ab, abb, abbb...</span><br><span class=\"line\">&#x27;c\\(ab\\)*&#x27; // c, cab, cabab, cababab...  需用括号括起，但是需要转义</span><br><span class=\"line\">&#x27;c\\(ab\\)\\&#123;2, 3&#125;&#x27; // cabab, cababab</span><br><span class=\"line\">&#x27;ab\\+&#x27; // ab, abb, abbb...</span><br><span class=\"line\">&#x27;ab\\=&#x27; // a, ab</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>   item    matches            equivalent ~<br>    \\d    digit            [0-9]<br>    \\D    non-digit        [^0-9]<br>    \\x    hex digit        [0-9a-fA-F]<br>    \\X    non-hex digit        [^0-9a-fA-F]<br>    \\s    white space        [     ]     (<Tab> and <Space>)<br>    \\S    non-white characters    [^     ]     (not <Tab> and <Space>)<br>    \\l    lowercase alpha        [a-z]<br>    \\L    non-lowercase alpha    [^a-z]<br>    \\u    uppercase alpha        [A-Z]<br>    \\U    non-uppercase alpha    [^A-Z]<br>    \\h [A-Za-z_]<br>    \\w [A-Za-z0-9_]</p>\n</blockquote>\n<p>以上不能用于<code>[]</code>里面</p>\n<p>注意　<code>&#39;</code>, <code>&quot;</code>的影响。<code>&quot;</code>会转义<code>\\</code>, 导致<code>&#39;\\w\\+&#39;</code>这种变成<code>&quot;\\\\w\\\\+&quot;</code></p>\n<p><a href=\"http://learnvimscriptthehardway.onefloweroneworld.com/\">笨方法学vimscript</a></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>Remeber <code>:help</code> always be with you  -- albert einstein<br>记住<code>:help</code>　与你同在</p>\n</blockquote>","more":"<!-- toc -->\n<ul>\n<li><a href=\"#first-of-all\">First of all</a></li>\n<li><a href=\"#echo-echom----------\">echo echom  打印信息帮助调试</a></li>\n<li><a href=\"#--\">注释</a></li>\n<li><a href=\"#------\">(布尔)选项</a></li>\n<li><a href=\"#map-------\">map 映射!映射!</a></li>\n<li><a href=\"#leader--\">leader按键</a></li>\n<li><a href=\"#iabbrev\">iabbrev</a></li>\n<li><a href=\"#autocmd-----\">autocmd 自动命令</a></li>\n<li><a href=\"#operator-pending\">operator_pending</a></li>\n<li><a href=\"#-normal\">:normal</a></li>\n<li><a href=\"#-execute\">:execute</a></li>\n<li><a href=\"#set-statusline\">set statusline</a></li>\n<li><a href=\"#let----\">let  变量</a></li>\n<li><a href=\"#---\">寄存器</a></li>\n<li><a href=\"#--\">管道</a></li>\n<li><a href=\"#if\">if</a><ul>\n<li><a href=\"#--\">比较</a></li>\n</ul>\n</li>\n<li><a href=\"#--\">函数</a><ul>\n<li><a href=\"#--\">参数</a></li>\n<li><a href=\"#----\">可变参数</a></li>\n<li><a href=\"#----\">命名空间</a></li>\n</ul>\n</li>\n<li><a href=\"#---\">字符串</a><ul>\n<li><a href=\"#---\">连接符</a></li>\n<li><a href=\"#-----\">字符串函数</a></li>\n</ul>\n</li>\n<li><a href=\"#--\">列表</a></li>\n<li><a href=\"#--\">循环</a><ul>\n<li><a href=\"#for\">for</a></li>\n</ul>\n</li>\n<li><a href=\"#dict\">dict</a></li>\n<li><a href=\"#-----\">函数式编程</a><ul>\n<li><a href=\"#deepcopy--copy\">deepcopy 与copy</a></li>\n</ul>\n</li>\n<li><a href=\"#--\">路径</a></li>\n<li><a href=\"#regex------\">Regex 正则表达式</a></li>\n</ul>\n<!-- tocstop -->\n<h3 id=\"First_of_all\">First of all</h3><p>首先<code>:help echo/function/....</code>　help可以查看一个关键词的帮助.首先要习惯使用它</p>\n<h3 id=\"echo_echom_打印信息帮助调试\">echo echom  打印信息帮助调试</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:echo &quot;test&quot;</span><br><span class=\"line\">:echo &quot;test2&quot;</span><br><span class=\"line\">:messages</span><br></pre></td></tr></table></figure>\n<p>test2在message中，而test不在。<br>echom 主要用来调试。</p>\n<h3 id=\"注释\">注释</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot; 这是注释</span><br></pre></td></tr></table></figure>\n<h3 id=\"(布尔)选项\">(布尔)选项</h3><p><code>:set</code> 用于设置内置的选项。有的是布尔选项，有的不是 see <code>:help set</code><br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:set number</span><br><span class=\"line\">:set nonumber</span><br><span class=\"line\">:set number!</span><br><span class=\"line\">:set number?</span><br><span class=\"line\">:set number numberwidth=4</span><br><span class=\"line\">:set omnifunc=XXX#complete</span><br></pre></td></tr></table></figure></p>\n<p>number是一个布尔选项。任何布尔选项都可以通过<code>set</code> ,<code>set no(Bool)</code>, 设置开启关闭<code>set Bool!</code>切换开关状态.<br><code>set &#123;Option&#125;?</code> 用来查看当前值.<br>有些选项可以赋值.多选项用空格隔开一次赋值<br>number是用来显示行号的布尔值<br>omnifunc 是补全函数<br>在脚本中如果要引用某个选项使用<code>&amp;</code>, 比如<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if &amp;filetype == &quot;vim&quot;</span><br></pre></td></tr></table></figure></p>\n<p>判断当前文件类型是否是vimscript</p>\n<h3 id=\"map_映射!映射!\">map 映射!映射!</h3><p><code>:help map-commands</code><br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:map - x  //  任何模式下将&#x27;-&#x27;映射为&#x27;x&#x27;</span><br><span class=\"line\">:map &lt;space&gt; x</span><br><span class=\"line\">:map &lt;c-d&gt; x</span><br><span class=\"line\">:nmap - x</span><br><span class=\"line\">:vmap - x</span><br><span class=\"line\">:imap - x</span><br><span class=\"line\">:noremap - x</span><br><span class=\"line\">:noremap \\ -</span><br></pre></td></tr></table></figure></p>\n<p>map通用于所有模式下。nmap,vmap, imap分别映射在不同的模式下。<br>noremap不存在递归风险。任何时候都应该使用这种方式。<strong>对，任何时候</strong></p>\n<h3 id=\"leader按键\">leader按键</h3><p><code>:help mapleader</code><br>很多插件中存在各种映射都用的<leader>这个按键<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:let mapleader=&quot;-&quot;</span><br><span class=\"line\">:nnoremap &lt;leader&gt;d dd</span><br><span class=\"line\">let maplocalleader = &quot;\\\\&quot;</span><br><span class=\"line\">:noremap &lt;buffer&gt; &lt;localleader&gt;d dd</span><br></pre></td></tr></table></figure></p>\n<p>leader 默认为<code>\\</code>, 如果修改可以通过<code>echo mapleader</code>查看<br>localleader 只针对某个buffer</p>\n<blockquote>\n<p>除了map 还有各种其他地方指定<code>&lt;buffer&gt;</code>的设置。比如autocmd,加上buffer比较安全。</p>\n</blockquote>\n<p>同样有的选项也支持<code>:setlocal number</code></p>\n<h3 id=\"iabbrev\">iabbrev</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:iabbrev waht what</span><br></pre></td></tr></table></figure>\n<p>自动替换。　可以将ｗａｈｔ　替换为ｗｈａｔ<br>iabbrev是结束insert mode时发生的。 如果what前后有别的则不会发生替换.这点与<code>inoremap waht what</code>不同<br>同样可以接受<code>:iabbrev &lt;buffer&gt; XXXX</code>　只对当前buffer生效</p>\n<h3 id=\"autocmd_自动命令\">autocmd 自动命令</h3><p><code>:help autocmd</code><br><code>:help Event</code><br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:autocmd BufNewFild,BufRead *.html :normal gg=G</span><br><span class=\"line\">         事件                模式   执行命令</span><br></pre></td></tr></table></figure></p>\n<p><code>autocmd Event File Command</code>  对File文件接收到event事件后　触发command</p>\n<p>Event后面的模式每个pattern不一样。<br>比如 <code>:autocmd FileType vim call SomeFun()</code><br><strong>这里有个危险的地方</strong><br>单纯的<code>autocmd</code> 并不会覆盖之前的命令。如果同一个<code>autocmd</code>加载多次他们会同时存在也就是可能对于同一个事件执行多次<code>SomeFun()</code>.<br>这里vim有一种自动命令组的方法<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:augroup testgroup</span><br><span class=\"line\">:    autocmd BufWrite * :echom &quot;Foo&quot;</span><br><span class=\"line\">:    autocmd BufWrite * :echom &quot;Bar&quot;</span><br><span class=\"line\">:augroup END</span><br></pre></td></tr></table></figure></p>\n<p>上面将&quot;Foo&quot;, &quot;Bar&quot;两个事件归到testgroup组中。这时testgroup相当于一个<code>autocmd</code>　同样多次执行testgroup也会造成上面的情况。同样，如果之后在执行<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:augroup testgroup</span><br><span class=\"line\">:    autocmd BufWrite * :echom &quot;Baz&quot;</span><br><span class=\"line\">:augroup END</span><br></pre></td></tr></table></figure></p>\n<p>&quot;Foo&quot;, &quot;Bar&quot;并没有清除.而是将&quot;Baz&quot;合并到了testgroup中.这样没有解决多次读取事件造成重复调用的问题。<br>解决的办法是在组开始的地方调用 <code>autocmd!</code>来清除这个组的事件<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:augroup testgroup</span><br><span class=\"line\">:    autocmd!</span><br><span class=\"line\">:    autocmd BufWrite * :echom &quot;Cats&quot;</span><br><span class=\"line\">:    autocmd XXXXX....</span><br><span class=\"line\">:augroup END</span><br></pre></td></tr></table></figure></p>\n<p>这样解决了多次重复调用的问题</p>\n<h3 id=\"operator_pending\">operator_pending</h3><p><code>:onoremap p ic</code></p>\n<p>w, p, t 各种定位词　ｏｎｏｒｅｍａｐ可以修改定位词映射</p>\n<h3 id=\":normal\">:normal</h3><p><code>:normal gg</code><br><code>:normal</code> 后面会跟一个字符串。相当于在ｎｏｒｍａｌ模式下按下这些按键</p>\n<p>当然永远不要用normal 而是用<code>normal!</code> 后者无视映射。因为你永远不知道用户把按键映射成了什么</p>\n<h3 id=\":execute\">:execute</h3><p>`:execute &quot;:normal!  gg&quot;</p>\n<p>execute 后面跟脚本。</p>\n<p>为什么不直接用normal!,而是用execute呢<br>因为normal不能识别特殊字符。比如<cr>回车符等所以一般要包个execute命令。<br>比如<code>:normal! a\\&lt;cr&gt;</code> 我们设想先按下a进入insert模式然后输出回车符换行.但是实际上这个命令进入插入模式后，直<br>接将<code>\\&lt;cr&gt;</code>输入到了buffer中.我们可以用`execute &quot;normal! a\\<cr>&quot;完成这个动作</p>\n<h3 id=\"set_statusline\">set statusline</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:set statusline=%f\\ -\\ %y</span><br><span class=\"line\">:set statusline+=%=</span><br><span class=\"line\">:set statusline+=%L</span><br></pre></td></tr></table></figure>\n<p>修改状态条显示内容。类似printf %f 是文件名%y是文件类型 %=表示后面的右对齐%L显示总行数。</p>\n<h3 id=\"let_变量\">let  变量</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:let foo=&quot;bar&quot;</span><br><span class=\"line\">:echo foo  //显示ｂａｒ</span><br><span class=\"line\">:set number</span><br><span class=\"line\">:echo &amp;number //1</span><br><span class=\"line\">:let number = 100</span><br><span class=\"line\">:echo number //100</span><br><span class=\"line\">:let &amp;number=&amp;number-1</span><br><span class=\"line\">:echo &amp;number //0　number是是否显示行号的布尔值</span><br></pre></td></tr></table></figure>\n<p>let 用来定义一个变量,这个变量可以与某个选项同名(set), 只不过选项的引用需要前面加<code>&amp;</code><br>set 只能给选项赋值常量值<br>而let 可以用变量给变量赋值,如上面的<code>&amp;number</code><br><code>:let &amp;l:number = 100</code>可以给本地变量赋值而不影响其他buffer</p>\n<h3 id=\"寄存器\">寄存器</h3><p><code>:register</code> 查看所有寄存器内容<br><code>&quot;ap</code> a是寄存器名字. 表示将a中的内容粘贴到此处<br><code>echo @a</code> 打印a中的内容<br><code>let @a=&quot;test&quot;</code> 修改a中内容<br><code>&quot;</code>寄存器是为指定寄存器所有为指定寄存器的复制操作,内容都会写入这里</p>\n<h3 id=\"管道\">管道</h3><p><code>:echo &quot;haha&quot; | echo &quot;heihei</code></p>\n<h3 id=\"if\">if</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:if &quot;20haha&quot;</span><br><span class=\"line\">:   echo &quot;true&quot;</span><br><span class=\"line\">:endif</span><br><span class=\"line\"></span><br><span class=\"line\">:if &quot;haha20&quot;</span><br><span class=\"line\">:   echo &quot;true&quot;</span><br><span class=\"line\">:else</span><br><span class=\"line\">:   echo &quot;false&quot;</span><br><span class=\"line\">:endif</span><br></pre></td></tr></table></figure>\n<p>第一个会显示ｔｒｕｅ　第二个是ｆａｌｓｅ　<br>因为字符串在强制转换时第一个是数字会转化为相应的数字。否则是０</p>\n<h4 id=\"比较\">比较</h4><p>不能完全信任<code>==</code><br>因为vim的大小写敏感时用户设置的<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:set ignorecase</span><br><span class=\"line\">:if &quot;foo&quot; == &quot;FOO&quot;</span><br></pre></td></tr></table></figure></p>\n<p>这个语句真假取决于ignorecase的设置。<br>替代品<br><code>==?</code> 大小写不敏感比较<br><code>==#</code> 大小写敏感比较</p>\n<h3 id=\"函数\">函数</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:function Test()</span><br><span class=\"line\">:   XXXXX</span><br><span class=\"line\">:endfunction</span><br><span class=\"line\">:function s:testb()</span><br><span class=\"line\">:   echom &quot;script test&quot;</span><br><span class=\"line\">:endfunction</span><br><span class=\"line\">:call Test()</span><br></pre></td></tr></table></figure>\n<p><strong>没有限制作用域的函数必须以大写字母开头</strong><br>脚本内的私有函数以<code>s:</code>开头<br>函数没有显示指定<code>return XX</code>则默认返回0</p>\n<h4 id=\"参数\">参数</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:function EchoTest(name)</span><br><span class=\"line\">:   echo a:name</span><br><span class=\"line\">:endfunction</span><br></pre></td></tr></table></figure>\n<p>函数的参数总要加a这个作用域否则会提示找不到</p>\n<h4 id=\"可变参数\">可变参数</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:function Test(...)  // 假如 call Test(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)</span><br><span class=\"line\">:   echo a:0         // 3 参数个数</span><br><span class=\"line\">:   echo a:1         // &quot;a&quot;</span><br><span class=\"line\">:   echo a:000       // [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;] 000指参数列表.不能用echom输出只能用echo</span><br><span class=\"line\">:endfunction</span><br></pre></td></tr></table></figure>\n<p><code>:call Test(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)</code><br>a:0 指的是参数数量。 a:1 是 &quot;a&quot;.以此类推</p>\n<h4 id=\"命名空间\">命名空间</h4><blockquote>\n<p>|buffer-variable|    b:      Local to the current buffer.<br>|window-variable|    w:      Local to the current window.<br>|tabpage-variable|   t:      Local to the current tab page.<br>|global-variable|    g:      Global.<br>|local-variable|     l:      Local to a function.<br>|script-variable|    s:      Local to a |:source|&#39;ed Vim script.<br>|function-argument|  a:      Function argument (only inside a function).<br>|vim-variable|         v:      Global, predefined by Vim.</p>\n</blockquote>\n<p>命名空间可以当做dict使用<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for k in keys(b:)</span><br><span class=\"line\">    unlet b:[k]</span><br><span class=\"line\">endfor</span><br></pre></td></tr></table></figure></p>\n<p>可以混合可变参数和固定参数<br><code>:function Test(a, ...)</code></p>\n<p>不能对函数的参数改变赋值<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:function Test(foo)</span><br><span class=\"line\">:   let a:foo=&quot;change&quot; //这样做会报错</span><br><span class=\"line\">:   let tmp=a:foo      // 这样才可以</span><br><span class=\"line\">:   let tmp=&quot;change&quot;</span><br><span class=\"line\">:endfunction</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"字符串\">字符串</h3><h4 id=\"连接符\">连接符</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:echo &quot;haha&quot;.&quot;heihei&quot; </span><br></pre></td></tr></table></figure>\n<p>上面输出&quot;hahaheihei&quot;</p>\n<h4 id=\"字符串函数\">字符串函数</h4><p><code>:help function-list</code> 查看所有函数分类列表</p>\n<p><code>strlen(&quot;string&quot;)</code><br><code>len(&quot;string&quot;)</code><br><code>echo split(&quot;one two&quot;)</code><br><code>echo split(&quot;one,two&quot;,&quot;,&quot;)</code><br><code>echo join([&quot;one&quot;,&quot;two&quot;], &quot;,&quot;)</code><br><code>echo tolower(&quot;BIG&quot;)</code><br><code>echo toupper(&quot;low&quot;)</code></p>\n<h3 id=\"列表\">列表</h3><ol>\n<li>有序，异质</li>\n<li><p>索引从0开始 </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:echo [1,2,3][0] // 1</span><br><span class=\"line\">:echo [1,2,3][-1] //3</span><br><span class=\"line\">:echo &quot;abc&quot;[1] // b</span><br><span class=\"line\">:echo &quot;abc&quot;[-1] // 无效。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>切割</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:echo [1,2,3][:1] // [1,2]</span><br><span class=\"line\">:echo [1,2,3][1:] // [2,3]</span><br><span class=\"line\">:echo [1,2,3][:1000] // [1,2,3] 可以越界</span><br><span class=\"line\">:echo [1,2,3,4][-2:-1] //[3,4]</span><br><span class=\"line\">:echo [1,2,3,4][-2:1] // []</span><br><span class=\"line\">:echo &quot;abc&quot;[-2:-1] // bc。上面的负数索引无效。切割却有效。。。</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>4.连接<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:echo [&#x27;a&#x27;,&#x27;b&#x27;] + [&#x27;c&#x27;] // [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;]</span><br><span class=\"line\">:echo [1,2] + [3]//[1,2,3]</span><br><span class=\"line\">:echo [a,b] + [c] // 错误。</span><br><span class=\"line\">:echo &quot;ab&quot;.&quot;c&quot; //&quot;abc&quot;</span><br></pre></td></tr></table></figure></p>\n<ol start=\"5\">\n<li>列表函数<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:echo add([1,2],3) // [1,2,3]</span><br><span class=\"line\">:echo get([1,2,3], 0, &#x27;default&#x27;) // 1</span><br><span class=\"line\">:echo get([1,2,3], 4, &#x27;default&#x27;) // default</span><br><span class=\"line\">:echo index([1,2,3], 1) // 0</span><br><span class=\"line\">:echo index([1,2,3], 4) // -1 不存在返回-1</span><br><span class=\"line\">:echo join([1,2], &quot;-&quot;) // 1-2</span><br><span class=\"line\">:echo reverse([1,2]) //[2,1]</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>更多阅读<code>:help List</code> <code>:help functions</code></p>\n<h3 id=\"循环\">循环</h3><h4 id=\"for\">for</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:for i in [1,2,3,4]</span><br><span class=\"line\">:   let c += i</span><br><span class=\"line\">:endfor</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:let c=1</span><br><span class=\"line\">:while c &lt; 3</span><br><span class=\"line\">: let t += c</span><br><span class=\"line\">: let c += 1</span><br><span class=\"line\">:endwhile</span><br></pre></td></tr></table></figure>\n<h3 id=\"dict\">dict</h3><p><code>&#123;&#39;a&#39;:1, 2:&quot;two&quot;,&#125;</code> 字典的key总是会自动转为字符串.  应该总是结尾留一个<code>,</code> (个人很讨厌这种语法)<br>索引可以用.来索引<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:echo &#123;&#x27;a&#x27;:1, 2:&quot;two&quot;,&#125;[&#x27;a&#x27;] // 1</span><br><span class=\"line\">:echo &#123;&#x27;a&#x27;:1, 2:&quot;two&quot;,&#125;[2] // two</span><br><span class=\"line\">:echo &#123;&#x27;a&#x27;:1, 2:&quot;two&quot;,&#125;.a // 1</span><br></pre></td></tr></table></figure></p>\n<p>增加键值<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:let dic=&#123;&#x27;a&#x27;:1,&#125;</span><br><span class=\"line\">:let dic.b=2</span><br><span class=\"line\">:echo dic // &#123;&#x27;a&#x27;:1, &#x27;b&#x27;:2&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:let tmp=remove(dic, &#x27;a&#x27;) //移除dic中a，但是把a的值赋值给tmp</span><br><span class=\"line\">:unlet dic.b //移除b。但是不返回值</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:echo has_key(&#123;&#x27;a&#x27;:1&#125;, &#x27;a&#x27;) // 1</span><br><span class=\"line\">:echo has_key(&#123;&#x27;a&#x27;:1&#125;, &#x27;b&#x27;) //0</span><br><span class=\"line\">:echo items(&#123;&#x27;a&#x27;:1, &#x27;b&#x27;:2&#125;) // [[&#x27;a&#x27;,1],[&#x27;b&#x27;,2]] items返回是无序的。因为dict本身是无序的</span><br><span class=\"line\">:echo keys(&#123;&#x27;a&#x27;:1, &#x27;b&#x27;:2&#125;) // [&#x27;a&#x27;, &#x27;b&#x27;]</span><br><span class=\"line\">:echo values(&#123;&#x27;a&#x27;:1, &#x27;b&#x27;:2&#125;) //[1,2]</span><br></pre></td></tr></table></figure>\n<p>list中的get函数同样可以用于dict</p>\n<h3 id=\"函数式编程\">函数式编程</h3><ol>\n<li>在函数内部赋值传入的参数。已达到不影响外部变量。<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function! Reversed(l)</span><br><span class=\"line\">    let new_list = deepcopy(a:l)</span><br><span class=\"line\">    call reverse(new_list)</span><br><span class=\"line\">    return new_list</span><br><span class=\"line\">endfunction</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"deepcopy_与copy\">deepcopy 与copy</h4><p> 区别如下<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a=[1,2]</span><br><span class=\"line\">let b=[a,3,4] // [[1,2],3,4]</span><br><span class=\"line\">let c=copy(b) // [[1,2],3,4]</span><br><span class=\"line\">let d=deepcopy(b) //[[1,2],3,4]</span><br><span class=\"line\">let b[0][0]=5</span><br><span class=\"line\">let b[1]=6</span><br><span class=\"line\">echo a  //[5,2]</span><br><span class=\"line\">echo b  //[[5,2],6,4]</span><br><span class=\"line\">echo c  //[[5,2],3,4]</span><br><span class=\"line\">echo d  //[[1,2],3,4]</span><br></pre></td></tr></table></figure></p>\n<ol start=\"2\">\n<li>将函数赋值给变量。变量名字首字母大写<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:let Myfunc = function(&quot;add&quot;)</span><br><span class=\"line\">:echo Myfunc([1,2],3) // [1,2,3]</span><br><span class=\"line\">:let funclist=[function(&quot;add&quot;), function(&quot;reverse&quot;)]</span><br><span class=\"line\">:echo funclist[0]([1,2],3) // [1,2,3]</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"路径\">路径</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:echo expand(&#x27;%&#x27;) // filename  相对路径</span><br><span class=\"line\">:echo expand(&#x27;%:p&#x27;) // /home/.../filename 绝对路径</span><br><span class=\"line\">:echo fnamemodify(&#x27;test.erl&#x27;, &#x27;:p&#x27;) // /home/youthy/.../test.erl 无论文件test是否存在</span><br><span class=\"line\">:echo globpath(&#x27;.&#x27;, &#x27;*.erl&#x27;) // 显示当前目录下所有erl文件的路径</span><br><span class=\"line\">:echo split(globpath(&#x27;.&#x27;,&#x27;*.erl&#x27;), &#x27;\\n&#x27;) //将上述结果分割成列表</span><br></pre></td></tr></table></figure>\n<p><code>:set runtimepath=/XX/XXX</code> 修改运行时路径。</p>\n<h3 id=\"Regex_正则表达式\">Regex 正则表达式</h3><p>for starters <code>:help user_27</code></p>\n<p>所有的search 受大小写设置的影响<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:set ignorecase // 忽略</span><br><span class=\"line\">:set noignorecase // 不忽略大小写</span><br><span class=\"line\">:set ingorecase smartcase //智能模式。 小写时match所有。有一个大写字母时精确匹配。</span><br></pre></td></tr></table></figure></p>\n<p><code>\\c</code>, <code>\\C</code> 无视ignorecase设置。用于自己某个特殊的匹配。前者 表示ignorecase 后者是noignorecase</p>\n<blockquote>\n<p>   pattern            matches    ~<br>    \\Cword            word<br>    \\CWord            Word<br>    \\cword            word, Word, WORD, WoRd, etc.<br>    \\cWord            word, Word, WORD, WoRd, etc.</p>\n</blockquote>\n<p><code>*</code> 0至多个<br><code>\\+</code> 1至多个<br><code>\\=</code> 0至1个<br><code>&#39;\\&#123;n, m&#125;&#39;</code> 重复n至m次<br><code>&#39;\\\\|&#39;</code> 或者<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x27;ab*&#x27;   // a, ab, abb, abbb...</span><br><span class=\"line\">&#x27;c\\(ab\\)*&#x27; // c, cab, cabab, cababab...  需用括号括起，但是需要转义</span><br><span class=\"line\">&#x27;c\\(ab\\)\\&#123;2, 3&#125;&#x27; // cabab, cababab</span><br><span class=\"line\">&#x27;ab\\+&#x27; // ab, abb, abbb...</span><br><span class=\"line\">&#x27;ab\\=&#x27; // a, ab</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>   item    matches            equivalent ~<br>    \\d    digit            [0-9]<br>    \\D    non-digit        [^0-9]<br>    \\x    hex digit        [0-9a-fA-F]<br>    \\X    non-hex digit        [^0-9a-fA-F]<br>    \\s    white space        [     ]     (<Tab> and <Space>)<br>    \\S    non-white characters    [^     ]     (not <Tab> and <Space>)<br>    \\l    lowercase alpha        [a-z]<br>    \\L    non-lowercase alpha    [^a-z]<br>    \\u    uppercase alpha        [A-Z]<br>    \\U    non-uppercase alpha    [^A-Z]<br>    \\h [A-Za-z_]<br>    \\w [A-Za-z0-9_]</p>\n</blockquote>\n<p>以上不能用于<code>[]</code>里面</p>\n<p>注意　<code>&#39;</code>, <code>&quot;</code>的影响。<code>&quot;</code>会转义<code>\\</code>, 导致<code>&#39;\\w\\+&#39;</code>这种变成<code>&quot;\\\\w\\\\+&quot;</code></p>\n<p><a href=\"http://learnvimscriptthehardway.onefloweroneworld.com/\">笨方法学vimscript</a></p>"},{"title":"使用github管理hexo本地文件","date":"2014-06-28T03:43:57.000Z","_content":"\n# 用github管理hexo本地文件夹实现两台电脑同步\n---\n> 由于hexo+github搭建博客很依赖hexo本地文件,如果家里和公司的hexo本地文件夹不同那么生成的博客样子就不同,每次deploy的时候就有可能会覆盖.加入公司的_post里面有4篇日志,家里的里面有3篇,那么在家里`hexo generate`后在`hexo deploy`就有可能将4篇覆盖成3篇,所以需要公司和家里电脑的hexo本地文件夹同步,我采用github托管.\n\n<!--more-->\n1. 首先需要安装git,当然既然已经用hexo写blog了那就肯定安装了git,npm,python,nodejs等了.\n2. 然后要有github账户,当然和上面一样,既然在github上写blog肯定也已经有了.(废话)\n3. 我们新建一个repository,我命名为hexoblog吧.\n4. 假设本地hexo文件夹为hexoblog,我们首先需要用git初始化管理这个目录.\n`git init`\n这时hexoblog下有个.git隐藏文件夹可以用 ls -al查看出,这是git管理这个文件夹的所有用到的文件.\n5.init后git只不过建立了.git还未对任何文件进行管理,我们需要用\n`git add .`\n\".\"代表所有文件,我们把hexoblog所有文件加入到git的管理中,这时我们用`git status`可以看到一大片绿的文件名,表明我们已经添加了这些文件的管理.\n6. 我们在运行\n `git commit -m \"first commit\"`提交这些文件的修改.这时我们本的hexoblog管理就完成了,但是还没有提交的github上.\n7. 我们在运行\n`git remote add origin https://github.com/你的用户名/你的repository名字.git`\n指定把本地的文件托管到这个地方.加入我托管的地址是 \n>https://github.com/youthy/hexoblog (就是浏览器上面的地址)\n\n那么我的命令就是\n`git remote add origin https://github.com/youthy/hexoblog.git`\n8. 我们这次制定了托管的地址,下面就可以提交了\n`git push origin master`\norigin就是我们制定的地址,类似于c++中 define定义的名字一样,如果制定的是`git remote add another http***.git`\n那么就可以用another代替origin. master是分支名字,如果你建立了其他分支可以更换这个名字.\n这时我们回到github上可以看到提交成功了.\n![](http://youthy-picture.qiniudn.com/%E9%80%89%E5%8C%BA_004.png)\n9. 之后在家里的电脑上执行\n`git clone https://你的托管的地址.git`\n就可以将文件复制到本地了\n\n***\n\n###实际上还有点小问题.\n我们进入themes文件夹下会看到\n![](http://youthy-picture.qiniudn.com/%E9%80%89%E5%8C%BA_005.png)\n主题中有几个没有提交成功.只有landscape提交成功了,对比他们我发现失败的原因是其他的theme本身就有git在负责管理,比如我们在light下执行ls -al 可以看到.git文件夹,但是landscape中没有,这是没有提交成功的原因.\n我用`rm -rf .git`\n移除了这几个文件夹的git管理文件,然后回到hexoblog下同样移除.git文件.再按上述步骤重新生成提交了一遍就ok了\n![](http://youthy-picture.qiniudn.com/%E9%80%89%E5%8C%BA_007.png)\n这下终于可以再公司和家两端同步写blog了.\n\n> ##另外发现用git管理hexo后每次进行deploy提交时不用输入用户名和密码了,以前每次deploy都需要输入验证信息.顺便解决了这个反复验证的烦人问题.\n","source":"_posts/使用github管理hexo本地文件.md","raw":"title: 使用github管理hexo本地文件\ndate: 2014-06-28 11:43:57\ntags: [github,hexo]\ncategories: hexo\n---\n\n# 用github管理hexo本地文件夹实现两台电脑同步\n---\n> 由于hexo+github搭建博客很依赖hexo本地文件,如果家里和公司的hexo本地文件夹不同那么生成的博客样子就不同,每次deploy的时候就有可能会覆盖.加入公司的_post里面有4篇日志,家里的里面有3篇,那么在家里`hexo generate`后在`hexo deploy`就有可能将4篇覆盖成3篇,所以需要公司和家里电脑的hexo本地文件夹同步,我采用github托管.\n\n<!--more-->\n1. 首先需要安装git,当然既然已经用hexo写blog了那就肯定安装了git,npm,python,nodejs等了.\n2. 然后要有github账户,当然和上面一样,既然在github上写blog肯定也已经有了.(废话)\n3. 我们新建一个repository,我命名为hexoblog吧.\n4. 假设本地hexo文件夹为hexoblog,我们首先需要用git初始化管理这个目录.\n`git init`\n这时hexoblog下有个.git隐藏文件夹可以用 ls -al查看出,这是git管理这个文件夹的所有用到的文件.\n5.init后git只不过建立了.git还未对任何文件进行管理,我们需要用\n`git add .`\n\".\"代表所有文件,我们把hexoblog所有文件加入到git的管理中,这时我们用`git status`可以看到一大片绿的文件名,表明我们已经添加了这些文件的管理.\n6. 我们在运行\n `git commit -m \"first commit\"`提交这些文件的修改.这时我们本的hexoblog管理就完成了,但是还没有提交的github上.\n7. 我们在运行\n`git remote add origin https://github.com/你的用户名/你的repository名字.git`\n指定把本地的文件托管到这个地方.加入我托管的地址是 \n>https://github.com/youthy/hexoblog (就是浏览器上面的地址)\n\n那么我的命令就是\n`git remote add origin https://github.com/youthy/hexoblog.git`\n8. 我们这次制定了托管的地址,下面就可以提交了\n`git push origin master`\norigin就是我们制定的地址,类似于c++中 define定义的名字一样,如果制定的是`git remote add another http***.git`\n那么就可以用another代替origin. master是分支名字,如果你建立了其他分支可以更换这个名字.\n这时我们回到github上可以看到提交成功了.\n![](http://youthy-picture.qiniudn.com/%E9%80%89%E5%8C%BA_004.png)\n9. 之后在家里的电脑上执行\n`git clone https://你的托管的地址.git`\n就可以将文件复制到本地了\n\n***\n\n###实际上还有点小问题.\n我们进入themes文件夹下会看到\n![](http://youthy-picture.qiniudn.com/%E9%80%89%E5%8C%BA_005.png)\n主题中有几个没有提交成功.只有landscape提交成功了,对比他们我发现失败的原因是其他的theme本身就有git在负责管理,比如我们在light下执行ls -al 可以看到.git文件夹,但是landscape中没有,这是没有提交成功的原因.\n我用`rm -rf .git`\n移除了这几个文件夹的git管理文件,然后回到hexoblog下同样移除.git文件.再按上述步骤重新生成提交了一遍就ok了\n![](http://youthy-picture.qiniudn.com/%E9%80%89%E5%8C%BA_007.png)\n这下终于可以再公司和家两端同步写blog了.\n\n> ##另外发现用git管理hexo后每次进行deploy提交时不用输入用户名和密码了,以前每次deploy都需要输入验证信息.顺便解决了这个反复验证的烦人问题.\n","slug":"使用github管理hexo本地文件","published":1,"updated":"2018-06-26T09:49:27.739Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqw7jdwk00256f1re3z8ee9h","content":"<h1 id=\"用github管理hexo本地文件夹实现两台电脑同步\">用github管理hexo本地文件夹实现两台电脑同步</h1><hr>\n<blockquote>\n<p>由于hexo+github搭建博客很依赖hexo本地文件,如果家里和公司的hexo本地文件夹不同那么生成的博客样子就不同,每次deploy的时候就有可能会覆盖.加入公司的_post里面有4篇日志,家里的里面有3篇,那么在家里<code>hexo generate</code>后在<code>hexo deploy</code>就有可能将4篇覆盖成3篇,所以需要公司和家里电脑的hexo本地文件夹同步,我采用github托管.</p>\n</blockquote>\n<span id=\"more\"></span>\n<ol>\n<li>首先需要安装git,当然既然已经用hexo写blog了那就肯定安装了git,npm,python,nodejs等了.</li>\n<li>然后要有github账户,当然和上面一样,既然在github上写blog肯定也已经有了.(废话)</li>\n<li>我们新建一个repository,我命名为hexoblog吧.</li>\n<li>假设本地hexo文件夹为hexoblog,我们首先需要用git初始化管理这个目录.<br><code>git init</code><br>这时hexoblog下有个.git隐藏文件夹可以用 ls -al查看出,这是git管理这个文件夹的所有用到的文件.<br>5.init后git只不过建立了.git还未对任何文件进行管理,我们需要用<br><code>git add .</code><br>&quot;.&quot;代表所有文件,我们把hexoblog所有文件加入到git的管理中,这时我们用<code>git status</code>可以看到一大片绿的文件名,表明我们已经添加了这些文件的管理.</li>\n<li>我们在运行<br><code>git commit -m &quot;first commit&quot;</code>提交这些文件的修改.这时我们本的hexoblog管理就完成了,但是还没有提交的github上.</li>\n<li>我们在运行<br><code>git remote add origin https://github.com/你的用户名/你的repository名字.git</code><br>指定把本地的文件托管到这个地方.加入我托管的地址是 <blockquote>\n<p><a href=\"https://github.com/youthy/hexoblog\">https://github.com/youthy/hexoblog</a> (就是浏览器上面的地址)</p>\n</blockquote>\n</li>\n</ol>\n<p>那么我的命令就是<br><code>git remote add origin https://github.com/youthy/hexoblog.git</code></p>\n<ol start=\"8\">\n<li>我们这次制定了托管的地址,下面就可以提交了<br><code>git push origin master</code><br>origin就是我们制定的地址,类似于c++中 define定义的名字一样,如果制定的是<code>git remote add another http***.git</code><br>那么就可以用another代替origin. master是分支名字,如果你建立了其他分支可以更换这个名字.<br>这时我们回到github上可以看到提交成功了.<br><img src=\"http://youthy-picture.qiniudn.com/%E9%80%89%E5%8C%BA_004.png\" alt=\"\"></li>\n<li>之后在家里的电脑上执行<br><code>git clone https://你的托管的地址.git</code><br>就可以将文件复制到本地了</li>\n</ol>\n<hr>\n<p>###实际上还有点小问题.<br>我们进入themes文件夹下会看到<br><img src=\"http://youthy-picture.qiniudn.com/%E9%80%89%E5%8C%BA_005.png\" alt=\"\"><br>主题中有几个没有提交成功.只有landscape提交成功了,对比他们我发现失败的原因是其他的theme本身就有git在负责管理,比如我们在light下执行ls -al 可以看到.git文件夹,但是landscape中没有,这是没有提交成功的原因.<br>我用<code>rm -rf .git</code><br>移除了这几个文件夹的git管理文件,然后回到hexoblog下同样移除.git文件.再按上述步骤重新生成提交了一遍就ok了<br><img src=\"http://youthy-picture.qiniudn.com/%E9%80%89%E5%8C%BA_007.png\" alt=\"\"><br>这下终于可以再公司和家两端同步写blog了.</p>\n<blockquote>\n<p>##另外发现用git管理hexo后每次进行deploy提交时不用输入用户名和密码了,以前每次deploy都需要输入验证信息.顺便解决了这个反复验证的烦人问题.</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h1 id=\"用github管理hexo本地文件夹实现两台电脑同步\">用github管理hexo本地文件夹实现两台电脑同步</h1><hr>\n<blockquote>\n<p>由于hexo+github搭建博客很依赖hexo本地文件,如果家里和公司的hexo本地文件夹不同那么生成的博客样子就不同,每次deploy的时候就有可能会覆盖.加入公司的_post里面有4篇日志,家里的里面有3篇,那么在家里<code>hexo generate</code>后在<code>hexo deploy</code>就有可能将4篇覆盖成3篇,所以需要公司和家里电脑的hexo本地文件夹同步,我采用github托管.</p>\n</blockquote>","more":"<ol>\n<li>首先需要安装git,当然既然已经用hexo写blog了那就肯定安装了git,npm,python,nodejs等了.</li>\n<li>然后要有github账户,当然和上面一样,既然在github上写blog肯定也已经有了.(废话)</li>\n<li>我们新建一个repository,我命名为hexoblog吧.</li>\n<li>假设本地hexo文件夹为hexoblog,我们首先需要用git初始化管理这个目录.<br><code>git init</code><br>这时hexoblog下有个.git隐藏文件夹可以用 ls -al查看出,这是git管理这个文件夹的所有用到的文件.<br>5.init后git只不过建立了.git还未对任何文件进行管理,我们需要用<br><code>git add .</code><br>&quot;.&quot;代表所有文件,我们把hexoblog所有文件加入到git的管理中,这时我们用<code>git status</code>可以看到一大片绿的文件名,表明我们已经添加了这些文件的管理.</li>\n<li>我们在运行<br><code>git commit -m &quot;first commit&quot;</code>提交这些文件的修改.这时我们本的hexoblog管理就完成了,但是还没有提交的github上.</li>\n<li>我们在运行<br><code>git remote add origin https://github.com/你的用户名/你的repository名字.git</code><br>指定把本地的文件托管到这个地方.加入我托管的地址是 <blockquote>\n<p><a href=\"https://github.com/youthy/hexoblog\">https://github.com/youthy/hexoblog</a> (就是浏览器上面的地址)</p>\n</blockquote>\n</li>\n</ol>\n<p>那么我的命令就是<br><code>git remote add origin https://github.com/youthy/hexoblog.git</code></p>\n<ol start=\"8\">\n<li>我们这次制定了托管的地址,下面就可以提交了<br><code>git push origin master</code><br>origin就是我们制定的地址,类似于c++中 define定义的名字一样,如果制定的是<code>git remote add another http***.git</code><br>那么就可以用another代替origin. master是分支名字,如果你建立了其他分支可以更换这个名字.<br>这时我们回到github上可以看到提交成功了.<br><img src=\"http://youthy-picture.qiniudn.com/%E9%80%89%E5%8C%BA_004.png\" alt=\"\"></li>\n<li>之后在家里的电脑上执行<br><code>git clone https://你的托管的地址.git</code><br>就可以将文件复制到本地了</li>\n</ol>\n<hr>\n<p>###实际上还有点小问题.<br>我们进入themes文件夹下会看到<br><img src=\"http://youthy-picture.qiniudn.com/%E9%80%89%E5%8C%BA_005.png\" alt=\"\"><br>主题中有几个没有提交成功.只有landscape提交成功了,对比他们我发现失败的原因是其他的theme本身就有git在负责管理,比如我们在light下执行ls -al 可以看到.git文件夹,但是landscape中没有,这是没有提交成功的原因.<br>我用<code>rm -rf .git</code><br>移除了这几个文件夹的git管理文件,然后回到hexoblog下同样移除.git文件.再按上述步骤重新生成提交了一遍就ok了<br><img src=\"http://youthy-picture.qiniudn.com/%E9%80%89%E5%8C%BA_007.png\" alt=\"\"><br>这下终于可以再公司和家两端同步写blog了.</p>\n<blockquote>\n<p>##另外发现用git管理hexo后每次进行deploy提交时不用输入用户名和密码了,以前每次deploy都需要输入验证信息.顺便解决了这个反复验证的烦人问题.</p>\n</blockquote>"},{"title":"关于hexo的toc","date":"2015-06-15T04:53:16.000Z","_content":"\n\n15.7.20更新\n\n###hexo 3.1.1 以上时\n当我换到hexo3.1.1以上时，修改article.ejs的方式不在奇效果，甚至会导致文章乱码。\n这时需要用到hexo-toc插件。[hexo-toc](https://github.com/bubkoo/hexo-toc)\n不过要注意hexo-toc识别title的形式是`### title`, 不是`###title`。\n安装完后只需要在想要放置的地方加上\n```\n<!-- toc -->\n```\n\n就可以了。\n\n****************\n以下用于2.x版本\n\n  前几天换了下blog的主题，发现以前用的YesLandscape里面的TOC还是蛮好用的。但是新的主题没有。想把这个功能加进来。不过没看过node.js的东西。勉勉强强算是弄过来了。\n  首先，tommy351给出了toc的一些使用帮助。如下\n  [toc helper](https://github.com/hexojs/hexo/issues/408)\n\n<!--more-->\n> <%- toc(str, [options]) %>\nstr - Input string\noptions - Options\nclass - Class name\nlist_number - Display list number\n\n  我现在用的是yilia主题，找到layout/_partial/article.ejs文件，在如下地方加入以下内容\n```\n      <div class=\"article-entry\" itemprop=\"articleBody\">\n      <% if (post.excerpt && index){ %>\n        <%- post.excerpt %>\n      <% } else { %>\n      <!-- 此处插入 --> \n      <% if(post.toc !== false){ %>\n      <div id=\"toc\" class=\"toc-article\">\n         <%- toc(post.content) %>\n      </div>\n      <!-- 结束插入 --> \n      <% } %>\n              <%- post.content %>\n      <% } %>\n      </div>\n```\n\ntoc_article是一个css类，我把原来主题的css用了下，即在source/css/_partial/里面建立一个toc.styl文件，这个是toc需要的css样式。\n我在里面用来原来的样式\n```\n.toc-article \n  background #2D2D2D\n  margin 0.5em\n  border-left 10px solid color-border\n  padding 0.5em\n  strong\n```\n\n`post.content`根据情况使用post或者page，上下文中用的post就用post，用page的就用page。\n这样生成出来的是这样子。\n![](../../../../img/082.png)\n\n发现有两种数字在每个标题的左边。其中黑色的数字是由css中控制的，可以在.toc-child中设置list-style none取消这个数字\n```#toc\n  line-height 1.2em\n  font-size 1em\n  float right\n  .toc \n    padding 0\n    li\n      list-style-type none\n  .toc-child \n    list-style none\n    padding-left 1.0em\n```\n\n![](../../../../img/084.png)\n后面的数字需要修改下article,将上面的插入代码加上list_number:false.\n```\n <% if(post.toc !== false){ %>\n      <div id=\"toc\" class=\"toc-article\">\n         <%- toc(post.content, {list_number:false}) %>\n      </div>\n```\n\n![](../../../../img/083.png)\n这样就没有后面的数字了。 post.toc!== false 可以让我们决定哪些文章需要显示toc。如果不需要，只需在文章开头属性的地方加上一条`toc:false`就可以了。\ncss我直接将Yeslandscape的复制了一下而已。省事。\n```\n//toc\n.toc-article \n  background #2D2D2D\n  margin 0.5em\n  border-left 10px solid color-border\n  padding 0.5em\n  strong\n\n#toc\n  line-height 1.2em\n  font-size 1em\n  float right\n  .toc \n    padding 0\n    li\n      list-style-type none\n  .toc-child \n    list-style none\n    padding-left 1.0em\n\n#toc.toc-aside\n  display none\n  width 13%\n  position fixed\n  right 2%\n  top 320px\n  overflow hidden\n  line-height 1.5em\n  font-size 1em\n  color color-heading\n  opacity .6\n  transition opacity 1s ease-out\n  strong\n    padding 0.3em 0\n    color color-font\n  &:hover\n    transition opacity .3s ease-out\n    opacity 1\n  a\n    transition color 1s ease-out\n    &:hover\n      color color-theme\n      transition color .3s ease-out\n.active\n  \n  color color-theme !important\n```\n\n\n","source":"_posts/关于hexo的toc.md","raw":"title: 关于hexo的toc\ndate: 2015-06-15 12:53:16\ntags:\ncategories:\n---\n\n\n15.7.20更新\n\n###hexo 3.1.1 以上时\n当我换到hexo3.1.1以上时，修改article.ejs的方式不在奇效果，甚至会导致文章乱码。\n这时需要用到hexo-toc插件。[hexo-toc](https://github.com/bubkoo/hexo-toc)\n不过要注意hexo-toc识别title的形式是`### title`, 不是`###title`。\n安装完后只需要在想要放置的地方加上\n```\n<!-- toc -->\n```\n\n就可以了。\n\n****************\n以下用于2.x版本\n\n  前几天换了下blog的主题，发现以前用的YesLandscape里面的TOC还是蛮好用的。但是新的主题没有。想把这个功能加进来。不过没看过node.js的东西。勉勉强强算是弄过来了。\n  首先，tommy351给出了toc的一些使用帮助。如下\n  [toc helper](https://github.com/hexojs/hexo/issues/408)\n\n<!--more-->\n> <%- toc(str, [options]) %>\nstr - Input string\noptions - Options\nclass - Class name\nlist_number - Display list number\n\n  我现在用的是yilia主题，找到layout/_partial/article.ejs文件，在如下地方加入以下内容\n```\n      <div class=\"article-entry\" itemprop=\"articleBody\">\n      <% if (post.excerpt && index){ %>\n        <%- post.excerpt %>\n      <% } else { %>\n      <!-- 此处插入 --> \n      <% if(post.toc !== false){ %>\n      <div id=\"toc\" class=\"toc-article\">\n         <%- toc(post.content) %>\n      </div>\n      <!-- 结束插入 --> \n      <% } %>\n              <%- post.content %>\n      <% } %>\n      </div>\n```\n\ntoc_article是一个css类，我把原来主题的css用了下，即在source/css/_partial/里面建立一个toc.styl文件，这个是toc需要的css样式。\n我在里面用来原来的样式\n```\n.toc-article \n  background #2D2D2D\n  margin 0.5em\n  border-left 10px solid color-border\n  padding 0.5em\n  strong\n```\n\n`post.content`根据情况使用post或者page，上下文中用的post就用post，用page的就用page。\n这样生成出来的是这样子。\n![](../../../../img/082.png)\n\n发现有两种数字在每个标题的左边。其中黑色的数字是由css中控制的，可以在.toc-child中设置list-style none取消这个数字\n```#toc\n  line-height 1.2em\n  font-size 1em\n  float right\n  .toc \n    padding 0\n    li\n      list-style-type none\n  .toc-child \n    list-style none\n    padding-left 1.0em\n```\n\n![](../../../../img/084.png)\n后面的数字需要修改下article,将上面的插入代码加上list_number:false.\n```\n <% if(post.toc !== false){ %>\n      <div id=\"toc\" class=\"toc-article\">\n         <%- toc(post.content, {list_number:false}) %>\n      </div>\n```\n\n![](../../../../img/083.png)\n这样就没有后面的数字了。 post.toc!== false 可以让我们决定哪些文章需要显示toc。如果不需要，只需在文章开头属性的地方加上一条`toc:false`就可以了。\ncss我直接将Yeslandscape的复制了一下而已。省事。\n```\n//toc\n.toc-article \n  background #2D2D2D\n  margin 0.5em\n  border-left 10px solid color-border\n  padding 0.5em\n  strong\n\n#toc\n  line-height 1.2em\n  font-size 1em\n  float right\n  .toc \n    padding 0\n    li\n      list-style-type none\n  .toc-child \n    list-style none\n    padding-left 1.0em\n\n#toc.toc-aside\n  display none\n  width 13%\n  position fixed\n  right 2%\n  top 320px\n  overflow hidden\n  line-height 1.5em\n  font-size 1em\n  color color-heading\n  opacity .6\n  transition opacity 1s ease-out\n  strong\n    padding 0.3em 0\n    color color-font\n  &:hover\n    transition opacity .3s ease-out\n    opacity 1\n  a\n    transition color 1s ease-out\n    &:hover\n      color color-theme\n      transition color .3s ease-out\n.active\n  \n  color color-theme !important\n```\n\n\n","slug":"关于hexo的toc","published":1,"updated":"2018-06-26T09:49:27.739Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqw7jdwl00276f1r29ghamkg","content":"<p>15.7.20更新</p>\n<p>###hexo 3.1.1 以上时<br>当我换到hexo3.1.1以上时，修改article.ejs的方式不在奇效果，甚至会导致文章乱码。<br>这时需要用到hexo-toc插件。<a href=\"https://github.com/bubkoo/hexo-toc\">hexo-toc</a><br>不过要注意hexo-toc识别title的形式是<code>### title</code>, 不是<code>###title</code>。<br>安装完后只需要在想要放置的地方加上<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- toc --&gt;</span><br></pre></td></tr></table></figure></p>\n<p>就可以了。</p>\n<hr>\n<p>以下用于2.x版本</p>\n<p>  前几天换了下blog的主题，发现以前用的YesLandscape里面的TOC还是蛮好用的。但是新的主题没有。想把这个功能加进来。不过没看过node.js的东西。勉勉强强算是弄过来了。<br>  首先，tommy351给出了toc的一些使用帮助。如下<br>  <a href=\"https://github.com/hexojs/hexo/issues/408\">toc helper</a></p>\n<span id=\"more\"></span>\n<blockquote>\n<p>&lt;%- toc(str, [options]) %&gt;<br>str - Input string<br>options - Options<br>class - Class name<br>list_number - Display list number</p>\n</blockquote>\n<p>  我现在用的是yilia主题，找到layout/_partial/article.ejs文件，在如下地方加入以下内容<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div class=&quot;article-entry&quot; itemprop=&quot;articleBody&quot;&gt;</span><br><span class=\"line\">&lt;% if (post.excerpt &amp;&amp; index)&#123; %&gt;</span><br><span class=\"line\">  &lt;%- post.excerpt %&gt;</span><br><span class=\"line\">&lt;% &#125; else &#123; %&gt;</span><br><span class=\"line\">&lt;!-- 此处插入 --&gt; </span><br><span class=\"line\">&lt;% if(post.toc !== false)&#123; %&gt;</span><br><span class=\"line\">&lt;div id=&quot;toc&quot; class=&quot;toc-article&quot;&gt;</span><br><span class=\"line\">   &lt;%- toc(post.content) %&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;!-- 结束插入 --&gt; </span><br><span class=\"line\">&lt;% &#125; %&gt;</span><br><span class=\"line\">        &lt;%- post.content %&gt;</span><br><span class=\"line\">&lt;% &#125; %&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<p>toc_article是一个css类，我把原来主题的css用了下，即在source/css/_partial/里面建立一个toc.styl文件，这个是toc需要的css样式。<br>我在里面用来原来的样式<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.toc-article </span><br><span class=\"line\">  background #2D2D2D</span><br><span class=\"line\">  margin 0.5em</span><br><span class=\"line\">  border-left 10px solid color-border</span><br><span class=\"line\">  padding 0.5em</span><br><span class=\"line\">  strong</span><br></pre></td></tr></table></figure></p>\n<p><code>post.content</code>根据情况使用post或者page，上下文中用的post就用post，用page的就用page。<br>这样生成出来的是这样子。<br><img src=\"../../../../img/082.png\" alt=\"\"></p>\n<p>发现有两种数字在每个标题的左边。其中黑色的数字是由css中控制的，可以在.toc-child中设置list-style none取消这个数字<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">line-height 1.2em</span><br><span class=\"line\">font-size 1em</span><br><span class=\"line\">float right</span><br><span class=\"line\">.toc </span><br><span class=\"line\">  padding 0</span><br><span class=\"line\">  li</span><br><span class=\"line\">    list-style-type none</span><br><span class=\"line\">.toc-child </span><br><span class=\"line\">  list-style none</span><br><span class=\"line\">  padding-left 1.0em</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"../../../../img/084.png\" alt=\"\"><br>后面的数字需要修改下article,将上面的插入代码加上list_number:false.<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;% if(post.toc !== false)&#123; %&gt;</span><br><span class=\"line\">     &lt;div id=&quot;toc&quot; class=&quot;toc-article&quot;&gt;</span><br><span class=\"line\">        &lt;%- toc(post.content, &#123;list_number:false&#125;) %&gt;</span><br><span class=\"line\">     &lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"../../../../img/083.png\" alt=\"\"><br>这样就没有后面的数字了。 post.toc!== false 可以让我们决定哪些文章需要显示toc。如果不需要，只需在文章开头属性的地方加上一条<code>toc:false</code>就可以了。<br>css我直接将Yeslandscape的复制了一下而已。省事。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//toc</span><br><span class=\"line\">.toc-article </span><br><span class=\"line\">  background #2D2D2D</span><br><span class=\"line\">  margin 0.5em</span><br><span class=\"line\">  border-left 10px solid color-border</span><br><span class=\"line\">  padding 0.5em</span><br><span class=\"line\">  strong</span><br><span class=\"line\"></span><br><span class=\"line\">#toc</span><br><span class=\"line\">  line-height 1.2em</span><br><span class=\"line\">  font-size 1em</span><br><span class=\"line\">  float right</span><br><span class=\"line\">  .toc </span><br><span class=\"line\">    padding 0</span><br><span class=\"line\">    li</span><br><span class=\"line\">      list-style-type none</span><br><span class=\"line\">  .toc-child </span><br><span class=\"line\">    list-style none</span><br><span class=\"line\">    padding-left 1.0em</span><br><span class=\"line\"></span><br><span class=\"line\">#toc.toc-aside</span><br><span class=\"line\">  display none</span><br><span class=\"line\">  width 13%</span><br><span class=\"line\">  position fixed</span><br><span class=\"line\">  right 2%</span><br><span class=\"line\">  top 320px</span><br><span class=\"line\">  overflow hidden</span><br><span class=\"line\">  line-height 1.5em</span><br><span class=\"line\">  font-size 1em</span><br><span class=\"line\">  color color-heading</span><br><span class=\"line\">  opacity .6</span><br><span class=\"line\">  transition opacity 1s ease-out</span><br><span class=\"line\">  strong</span><br><span class=\"line\">    padding 0.3em 0</span><br><span class=\"line\">    color color-font</span><br><span class=\"line\">  &amp;:hover</span><br><span class=\"line\">    transition opacity .3s ease-out</span><br><span class=\"line\">    opacity 1</span><br><span class=\"line\">  a</span><br><span class=\"line\">    transition color 1s ease-out</span><br><span class=\"line\">    &amp;:hover</span><br><span class=\"line\">      color color-theme</span><br><span class=\"line\">      transition color .3s ease-out</span><br><span class=\"line\">.active</span><br><span class=\"line\">  </span><br><span class=\"line\">  color color-theme !important</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>15.7.20更新</p>\n<p>###hexo 3.1.1 以上时<br>当我换到hexo3.1.1以上时，修改article.ejs的方式不在奇效果，甚至会导致文章乱码。<br>这时需要用到hexo-toc插件。<a href=\"https://github.com/bubkoo/hexo-toc\">hexo-toc</a><br>不过要注意hexo-toc识别title的形式是<code>### title</code>, 不是<code>###title</code>。<br>安装完后只需要在想要放置的地方加上<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- toc --&gt;</span><br></pre></td></tr></table></figure></p>\n<p>就可以了。</p>\n<hr>\n<p>以下用于2.x版本</p>\n<p>  前几天换了下blog的主题，发现以前用的YesLandscape里面的TOC还是蛮好用的。但是新的主题没有。想把这个功能加进来。不过没看过node.js的东西。勉勉强强算是弄过来了。<br>  首先，tommy351给出了toc的一些使用帮助。如下<br>  <a href=\"https://github.com/hexojs/hexo/issues/408\">toc helper</a></p>","more":"<blockquote>\n<p>&lt;%- toc(str, [options]) %&gt;<br>str - Input string<br>options - Options<br>class - Class name<br>list_number - Display list number</p>\n</blockquote>\n<p>  我现在用的是yilia主题，找到layout/_partial/article.ejs文件，在如下地方加入以下内容<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div class=&quot;article-entry&quot; itemprop=&quot;articleBody&quot;&gt;</span><br><span class=\"line\">&lt;% if (post.excerpt &amp;&amp; index)&#123; %&gt;</span><br><span class=\"line\">  &lt;%- post.excerpt %&gt;</span><br><span class=\"line\">&lt;% &#125; else &#123; %&gt;</span><br><span class=\"line\">&lt;!-- 此处插入 --&gt; </span><br><span class=\"line\">&lt;% if(post.toc !== false)&#123; %&gt;</span><br><span class=\"line\">&lt;div id=&quot;toc&quot; class=&quot;toc-article&quot;&gt;</span><br><span class=\"line\">   &lt;%- toc(post.content) %&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;!-- 结束插入 --&gt; </span><br><span class=\"line\">&lt;% &#125; %&gt;</span><br><span class=\"line\">        &lt;%- post.content %&gt;</span><br><span class=\"line\">&lt;% &#125; %&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<p>toc_article是一个css类，我把原来主题的css用了下，即在source/css/_partial/里面建立一个toc.styl文件，这个是toc需要的css样式。<br>我在里面用来原来的样式<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.toc-article </span><br><span class=\"line\">  background #2D2D2D</span><br><span class=\"line\">  margin 0.5em</span><br><span class=\"line\">  border-left 10px solid color-border</span><br><span class=\"line\">  padding 0.5em</span><br><span class=\"line\">  strong</span><br></pre></td></tr></table></figure></p>\n<p><code>post.content</code>根据情况使用post或者page，上下文中用的post就用post，用page的就用page。<br>这样生成出来的是这样子。<br><img src=\"../../../../img/082.png\" alt=\"\"></p>\n<p>发现有两种数字在每个标题的左边。其中黑色的数字是由css中控制的，可以在.toc-child中设置list-style none取消这个数字<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">line-height 1.2em</span><br><span class=\"line\">font-size 1em</span><br><span class=\"line\">float right</span><br><span class=\"line\">.toc </span><br><span class=\"line\">  padding 0</span><br><span class=\"line\">  li</span><br><span class=\"line\">    list-style-type none</span><br><span class=\"line\">.toc-child </span><br><span class=\"line\">  list-style none</span><br><span class=\"line\">  padding-left 1.0em</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"../../../../img/084.png\" alt=\"\"><br>后面的数字需要修改下article,将上面的插入代码加上list_number:false.<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;% if(post.toc !== false)&#123; %&gt;</span><br><span class=\"line\">     &lt;div id=&quot;toc&quot; class=&quot;toc-article&quot;&gt;</span><br><span class=\"line\">        &lt;%- toc(post.content, &#123;list_number:false&#125;) %&gt;</span><br><span class=\"line\">     &lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"../../../../img/083.png\" alt=\"\"><br>这样就没有后面的数字了。 post.toc!== false 可以让我们决定哪些文章需要显示toc。如果不需要，只需在文章开头属性的地方加上一条<code>toc:false</code>就可以了。<br>css我直接将Yeslandscape的复制了一下而已。省事。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//toc</span><br><span class=\"line\">.toc-article </span><br><span class=\"line\">  background #2D2D2D</span><br><span class=\"line\">  margin 0.5em</span><br><span class=\"line\">  border-left 10px solid color-border</span><br><span class=\"line\">  padding 0.5em</span><br><span class=\"line\">  strong</span><br><span class=\"line\"></span><br><span class=\"line\">#toc</span><br><span class=\"line\">  line-height 1.2em</span><br><span class=\"line\">  font-size 1em</span><br><span class=\"line\">  float right</span><br><span class=\"line\">  .toc </span><br><span class=\"line\">    padding 0</span><br><span class=\"line\">    li</span><br><span class=\"line\">      list-style-type none</span><br><span class=\"line\">  .toc-child </span><br><span class=\"line\">    list-style none</span><br><span class=\"line\">    padding-left 1.0em</span><br><span class=\"line\"></span><br><span class=\"line\">#toc.toc-aside</span><br><span class=\"line\">  display none</span><br><span class=\"line\">  width 13%</span><br><span class=\"line\">  position fixed</span><br><span class=\"line\">  right 2%</span><br><span class=\"line\">  top 320px</span><br><span class=\"line\">  overflow hidden</span><br><span class=\"line\">  line-height 1.5em</span><br><span class=\"line\">  font-size 1em</span><br><span class=\"line\">  color color-heading</span><br><span class=\"line\">  opacity .6</span><br><span class=\"line\">  transition opacity 1s ease-out</span><br><span class=\"line\">  strong</span><br><span class=\"line\">    padding 0.3em 0</span><br><span class=\"line\">    color color-font</span><br><span class=\"line\">  &amp;:hover</span><br><span class=\"line\">    transition opacity .3s ease-out</span><br><span class=\"line\">    opacity 1</span><br><span class=\"line\">  a</span><br><span class=\"line\">    transition color 1s ease-out</span><br><span class=\"line\">    &amp;:hover</span><br><span class=\"line\">      color color-theme</span><br><span class=\"line\">      transition color .3s ease-out</span><br><span class=\"line\">.active</span><br><span class=\"line\">  </span><br><span class=\"line\">  color color-theme !important</span><br></pre></td></tr></table></figure></p>"},{"title":"工作五个月后","date":"2014-10-13T13:18:05.000Z","_content":"\n今天天气实在妩媚妖娆,人的心情也会变得很好,很早之前看过一句话,不要在这种天气出去玩,因为很可能你会爱上对面走来的任何人.\n<!--more-->\n\n 时至今日工作差不多五个月了,三个月试用期,两个月正式员工,从没想到这么快就永远的和学生身份say goodbye,昨天和几个大学同学吃了自助,玩了几个小时桌游,很开心,这种机会是在太难得了~~因为我总是在加班,哇啊啊啊啊%>_<%,他们大体没什么变化,这样也好,年轻最好.\n 吃完饭后有个女生临走拿个苹果,那苹果外边很鲜艳,我一时想到了我高中时经常买这种水果,外表鲜艳,里面却时有腐烂,都是药剂催的,于是我没经大脑的bulabula讲:\"这种水果虽然看起来好看,但是里面各种......我高中时...\",然后那个女生满脸黑线,说\"你能别说了么-_-||\"旁边的小伙伴笑了出来,吐槽我怪不得找不到女朋友,我一向是很瞧不起这种情商低的行为的,没想到,哎..\"岁月就像一把无情刻刀,改变了我模样~ (泪奔\"\n\n  9月过的很是拮据,因为我和小伙伴的笔记本被偷了,攒了台式,然后给爸妈一人弄了个手机,还是智能机,尽管他们不懂,也不需要,但是我还是希望他们不被时代所抛弃,给他们弄了微信,安了点软件,希望他们能多学就多学一点.不然真的很孤独.然后又买了台ps3,圆了我很久以来的一个梦想,曾经那遥不可及,高不可攀的主机领域,终于触摸到了,在之后我更加体会到一点,当我有时间时没有金钱支付,当我有能力支付时,却没了时间,想起了之前很火的一个图片,那个韩国人穿着boss创业的图片,里面说的真的很对\"你现在就要幸福,不要等未来,现在就要\".\n\n  学习方面最近陷入了瓶颈,平常工作上的已经很快就能完成了,但是感觉还不够深入,陷入了重复的过程,每天做的事情学不到新东西.然后又没有时间研究更底层的代码.因为我还有很多游戏没有玩--.真捉急.\n  有时也挺佩服我自己,已经不知道多少天2,3点睡觉了,精力很旺盛,白天也不怎么困.难道是因为童子身??想起月初我哥结婚,我回去碰到了我小学两个同学,聊起来女朋友,我说我没有女朋友,他们竟然嘲笑\"你不会还是处男吧?\"我了个大擦,MB!很久之前我看爱情公寓时,里面胡一菲嘲笑曾小贤处男,我还觉得纳闷,处男有什么可嘲笑的,没想到我很快就被同等对待,我突然感到这个世界充满了恶意...我的世界观也受到重创...\n\n  上面算是小吐槽,最近我意识到自己可能多巴胺水平比较低,越来越容易多愁善感,曾经幻想自己是持剑的骑士,为了我的命中注定的女人与世界为敌,曾幻想投身商海,玩弄权术心机,坐拥大笔财富,然而实际上自己也为了生活,奔波在刚刚涨价的地铁线上,曾经对自己说你不能成为齿轮那样的人,而最后像故事所说成了自己小时候所讨厌的人,血已经凉了.一个人的力量是在太过渺小,微不足道.地球为何存在,人类为何特殊,不过是偶然罢了.我们先存在于世,然后为了显得不像他人那样盲目,总得给自己找个活着的意义,然而终究不会有什么分别.\n\n  昨天买了个跑步机,先锻炼锻炼身体吧,希望有时间再拿起放在角落里的吉他,寻找曾经让我热血的事情.\n","source":"_posts/工作五个月后.md","raw":"title: 工作五个月后\ndate: 2014-10-13 21:18:05\ntags: 杂记\ncategories:\n---\n\n今天天气实在妩媚妖娆,人的心情也会变得很好,很早之前看过一句话,不要在这种天气出去玩,因为很可能你会爱上对面走来的任何人.\n<!--more-->\n\n 时至今日工作差不多五个月了,三个月试用期,两个月正式员工,从没想到这么快就永远的和学生身份say goodbye,昨天和几个大学同学吃了自助,玩了几个小时桌游,很开心,这种机会是在太难得了~~因为我总是在加班,哇啊啊啊啊%>_<%,他们大体没什么变化,这样也好,年轻最好.\n 吃完饭后有个女生临走拿个苹果,那苹果外边很鲜艳,我一时想到了我高中时经常买这种水果,外表鲜艳,里面却时有腐烂,都是药剂催的,于是我没经大脑的bulabula讲:\"这种水果虽然看起来好看,但是里面各种......我高中时...\",然后那个女生满脸黑线,说\"你能别说了么-_-||\"旁边的小伙伴笑了出来,吐槽我怪不得找不到女朋友,我一向是很瞧不起这种情商低的行为的,没想到,哎..\"岁月就像一把无情刻刀,改变了我模样~ (泪奔\"\n\n  9月过的很是拮据,因为我和小伙伴的笔记本被偷了,攒了台式,然后给爸妈一人弄了个手机,还是智能机,尽管他们不懂,也不需要,但是我还是希望他们不被时代所抛弃,给他们弄了微信,安了点软件,希望他们能多学就多学一点.不然真的很孤独.然后又买了台ps3,圆了我很久以来的一个梦想,曾经那遥不可及,高不可攀的主机领域,终于触摸到了,在之后我更加体会到一点,当我有时间时没有金钱支付,当我有能力支付时,却没了时间,想起了之前很火的一个图片,那个韩国人穿着boss创业的图片,里面说的真的很对\"你现在就要幸福,不要等未来,现在就要\".\n\n  学习方面最近陷入了瓶颈,平常工作上的已经很快就能完成了,但是感觉还不够深入,陷入了重复的过程,每天做的事情学不到新东西.然后又没有时间研究更底层的代码.因为我还有很多游戏没有玩--.真捉急.\n  有时也挺佩服我自己,已经不知道多少天2,3点睡觉了,精力很旺盛,白天也不怎么困.难道是因为童子身??想起月初我哥结婚,我回去碰到了我小学两个同学,聊起来女朋友,我说我没有女朋友,他们竟然嘲笑\"你不会还是处男吧?\"我了个大擦,MB!很久之前我看爱情公寓时,里面胡一菲嘲笑曾小贤处男,我还觉得纳闷,处男有什么可嘲笑的,没想到我很快就被同等对待,我突然感到这个世界充满了恶意...我的世界观也受到重创...\n\n  上面算是小吐槽,最近我意识到自己可能多巴胺水平比较低,越来越容易多愁善感,曾经幻想自己是持剑的骑士,为了我的命中注定的女人与世界为敌,曾幻想投身商海,玩弄权术心机,坐拥大笔财富,然而实际上自己也为了生活,奔波在刚刚涨价的地铁线上,曾经对自己说你不能成为齿轮那样的人,而最后像故事所说成了自己小时候所讨厌的人,血已经凉了.一个人的力量是在太过渺小,微不足道.地球为何存在,人类为何特殊,不过是偶然罢了.我们先存在于世,然后为了显得不像他人那样盲目,总得给自己找个活着的意义,然而终究不会有什么分别.\n\n  昨天买了个跑步机,先锻炼锻炼身体吧,希望有时间再拿起放在角落里的吉他,寻找曾经让我热血的事情.\n","slug":"工作五个月后","published":1,"updated":"2018-06-26T09:49:27.740Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqw7jdwm002c6f1r92kk2b43","content":"<p>今天天气实在妩媚妖娆,人的心情也会变得很好,很早之前看过一句话,不要在这种天气出去玩,因为很可能你会爱上对面走来的任何人.<br><span id=\"more\"></span></p>\n<p> 时至今日工作差不多五个月了,三个月试用期,两个月正式员工,从没想到这么快就永远的和学生身份say goodbye,昨天和几个大学同学吃了自助,玩了几个小时桌游,很开心,这种机会是在太难得了~~因为我总是在加班,哇啊啊啊啊%&gt;<em>&lt;%,他们大体没什么变化,这样也好,年轻最好.<br> 吃完饭后有个女生临走拿个苹果,那苹果外边很鲜艳,我一时想到了我高中时经常买这种水果,外表鲜艳,里面却时有腐烂,都是药剂催的,于是我没经大脑的bulabula讲:&quot;这种水果虽然看起来好看,但是里面各种......我高中时...&quot;,然后那个女生满脸黑线,说&quot;你能别说了么-</em>-||&quot;旁边的小伙伴笑了出来,吐槽我怪不得找不到女朋友,我一向是很瞧不起这种情商低的行为的,没想到,哎..&quot;岁月就像一把无情刻刀,改变了我模样~ (泪奔&quot;</p>\n<p>  9月过的很是拮据,因为我和小伙伴的笔记本被偷了,攒了台式,然后给爸妈一人弄了个手机,还是智能机,尽管他们不懂,也不需要,但是我还是希望他们不被时代所抛弃,给他们弄了微信,安了点软件,希望他们能多学就多学一点.不然真的很孤独.然后又买了台ps3,圆了我很久以来的一个梦想,曾经那遥不可及,高不可攀的主机领域,终于触摸到了,在之后我更加体会到一点,当我有时间时没有金钱支付,当我有能力支付时,却没了时间,想起了之前很火的一个图片,那个韩国人穿着boss创业的图片,里面说的真的很对&quot;你现在就要幸福,不要等未来,现在就要&quot;.</p>\n<p>  学习方面最近陷入了瓶颈,平常工作上的已经很快就能完成了,但是感觉还不够深入,陷入了重复的过程,每天做的事情学不到新东西.然后又没有时间研究更底层的代码.因为我还有很多游戏没有玩--.真捉急.<br>  有时也挺佩服我自己,已经不知道多少天2,3点睡觉了,精力很旺盛,白天也不怎么困.难道是因为童子身??想起月初我哥结婚,我回去碰到了我小学两个同学,聊起来女朋友,我说我没有女朋友,他们竟然嘲笑&quot;你不会还是处男吧?&quot;我了个大擦,MB!很久之前我看爱情公寓时,里面胡一菲嘲笑曾小贤处男,我还觉得纳闷,处男有什么可嘲笑的,没想到我很快就被同等对待,我突然感到这个世界充满了恶意...我的世界观也受到重创...</p>\n<p>  上面算是小吐槽,最近我意识到自己可能多巴胺水平比较低,越来越容易多愁善感,曾经幻想自己是持剑的骑士,为了我的命中注定的女人与世界为敌,曾幻想投身商海,玩弄权术心机,坐拥大笔财富,然而实际上自己也为了生活,奔波在刚刚涨价的地铁线上,曾经对自己说你不能成为齿轮那样的人,而最后像故事所说成了自己小时候所讨厌的人,血已经凉了.一个人的力量是在太过渺小,微不足道.地球为何存在,人类为何特殊,不过是偶然罢了.我们先存在于世,然后为了显得不像他人那样盲目,总得给自己找个活着的意义,然而终究不会有什么分别.</p>\n<p>  昨天买了个跑步机,先锻炼锻炼身体吧,希望有时间再拿起放在角落里的吉他,寻找曾经让我热血的事情.</p>\n","site":{"data":{}},"excerpt":"<p>今天天气实在妩媚妖娆,人的心情也会变得很好,很早之前看过一句话,不要在这种天气出去玩,因为很可能你会爱上对面走来的任何人.<br>","more":"</p>\n<p> 时至今日工作差不多五个月了,三个月试用期,两个月正式员工,从没想到这么快就永远的和学生身份say goodbye,昨天和几个大学同学吃了自助,玩了几个小时桌游,很开心,这种机会是在太难得了~~因为我总是在加班,哇啊啊啊啊%&gt;<em>&lt;%,他们大体没什么变化,这样也好,年轻最好.<br> 吃完饭后有个女生临走拿个苹果,那苹果外边很鲜艳,我一时想到了我高中时经常买这种水果,外表鲜艳,里面却时有腐烂,都是药剂催的,于是我没经大脑的bulabula讲:&quot;这种水果虽然看起来好看,但是里面各种......我高中时...&quot;,然后那个女生满脸黑线,说&quot;你能别说了么-</em>-||&quot;旁边的小伙伴笑了出来,吐槽我怪不得找不到女朋友,我一向是很瞧不起这种情商低的行为的,没想到,哎..&quot;岁月就像一把无情刻刀,改变了我模样~ (泪奔&quot;</p>\n<p>  9月过的很是拮据,因为我和小伙伴的笔记本被偷了,攒了台式,然后给爸妈一人弄了个手机,还是智能机,尽管他们不懂,也不需要,但是我还是希望他们不被时代所抛弃,给他们弄了微信,安了点软件,希望他们能多学就多学一点.不然真的很孤独.然后又买了台ps3,圆了我很久以来的一个梦想,曾经那遥不可及,高不可攀的主机领域,终于触摸到了,在之后我更加体会到一点,当我有时间时没有金钱支付,当我有能力支付时,却没了时间,想起了之前很火的一个图片,那个韩国人穿着boss创业的图片,里面说的真的很对&quot;你现在就要幸福,不要等未来,现在就要&quot;.</p>\n<p>  学习方面最近陷入了瓶颈,平常工作上的已经很快就能完成了,但是感觉还不够深入,陷入了重复的过程,每天做的事情学不到新东西.然后又没有时间研究更底层的代码.因为我还有很多游戏没有玩--.真捉急.<br>  有时也挺佩服我自己,已经不知道多少天2,3点睡觉了,精力很旺盛,白天也不怎么困.难道是因为童子身??想起月初我哥结婚,我回去碰到了我小学两个同学,聊起来女朋友,我说我没有女朋友,他们竟然嘲笑&quot;你不会还是处男吧?&quot;我了个大擦,MB!很久之前我看爱情公寓时,里面胡一菲嘲笑曾小贤处男,我还觉得纳闷,处男有什么可嘲笑的,没想到我很快就被同等对待,我突然感到这个世界充满了恶意...我的世界观也受到重创...</p>\n<p>  上面算是小吐槽,最近我意识到自己可能多巴胺水平比较低,越来越容易多愁善感,曾经幻想自己是持剑的骑士,为了我的命中注定的女人与世界为敌,曾幻想投身商海,玩弄权术心机,坐拥大笔财富,然而实际上自己也为了生活,奔波在刚刚涨价的地铁线上,曾经对自己说你不能成为齿轮那样的人,而最后像故事所说成了自己小时候所讨厌的人,血已经凉了.一个人的力量是在太过渺小,微不足道.地球为何存在,人类为何特殊,不过是偶然罢了.我们先存在于世,然后为了显得不像他人那样盲目,总得给自己找个活着的意义,然而终究不会有什么分别.</p>\n<p>  昨天买了个跑步机,先锻炼锻炼身体吧,希望有时间再拿起放在角落里的吉他,寻找曾经让我热血的事情.</p>"},{"title":"欢迎来到youthy的博客","date":"2014-06-25T03:48:51.000Z","_content":"###为啥开始写博客了\n毕业了,在工作的过程中时常是有些灵感,或者是学习上的note,亦或是对生活的无处倾诉的吐槽.\n这两天我的工作已经完成了所以说花了点时间鼓捣下博客.名字就叫伟大航路了,毕竟作为海贼王\n骨灰粉哈哈\n<!--more-->\n###搭建\n搭建环境是**linux**,采用hexo静态博客生成,deploy到github上,编写用vim,安装了markdown的语法高亮,git地址在\n> https://github.com/plasticboy/vim-markdown  \n\nmarkdown语法和hexo的配置还有好多地方不明白,日后在完善博客的功能,由于公司封了weibo,weibo秀暂时没弄,评论用的是多说的模块.\n期待大家多在评论里和我交流.\n\n第一篇就这样了,日子还长.\n","source":"_posts/欢迎来到youthy的博客.md","raw":"title: 欢迎来到youthy的博客\ndate: 2014-06-25 11:48:51\ntags:\ncategories: 杂谈\n---\n###为啥开始写博客了\n毕业了,在工作的过程中时常是有些灵感,或者是学习上的note,亦或是对生活的无处倾诉的吐槽.\n这两天我的工作已经完成了所以说花了点时间鼓捣下博客.名字就叫伟大航路了,毕竟作为海贼王\n骨灰粉哈哈\n<!--more-->\n###搭建\n搭建环境是**linux**,采用hexo静态博客生成,deploy到github上,编写用vim,安装了markdown的语法高亮,git地址在\n> https://github.com/plasticboy/vim-markdown  \n\nmarkdown语法和hexo的配置还有好多地方不明白,日后在完善博客的功能,由于公司封了weibo,weibo秀暂时没弄,评论用的是多说的模块.\n期待大家多在评论里和我交流.\n\n第一篇就这样了,日子还长.\n","slug":"欢迎来到youthy的博客","published":1,"updated":"2018-06-26T09:49:27.740Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqw7jdwn002e6f1r0ggg6bc1","content":"<p>###为啥开始写博客了<br>毕业了,在工作的过程中时常是有些灵感,或者是学习上的note,亦或是对生活的无处倾诉的吐槽.<br>这两天我的工作已经完成了所以说花了点时间鼓捣下博客.名字就叫伟大航路了,毕竟作为海贼王<br>骨灰粉哈哈<br><span id=\"more\"></span></p>\n<p>###搭建<br>搭建环境是<strong>linux</strong>,采用hexo静态博客生成,deploy到github上,编写用vim,安装了markdown的语法高亮,git地址在</p>\n<blockquote>\n<p><a href=\"https://github.com/plasticboy/vim-markdown\">https://github.com/plasticboy/vim-markdown</a>  </p>\n</blockquote>\n<p>markdown语法和hexo的配置还有好多地方不明白,日后在完善博客的功能,由于公司封了weibo,weibo秀暂时没弄,评论用的是多说的模块.<br>期待大家多在评论里和我交流.</p>\n<p>第一篇就这样了,日子还长.</p>\n","site":{"data":{}},"excerpt":"<p>###为啥开始写博客了<br>毕业了,在工作的过程中时常是有些灵感,或者是学习上的note,亦或是对生活的无处倾诉的吐槽.<br>这两天我的工作已经完成了所以说花了点时间鼓捣下博客.名字就叫伟大航路了,毕竟作为海贼王<br>骨灰粉哈哈<br>","more":"</p>\n<p>###搭建<br>搭建环境是<strong>linux</strong>,采用hexo静态博客生成,deploy到github上,编写用vim,安装了markdown的语法高亮,git地址在</p>\n<blockquote>\n<p><a href=\"https://github.com/plasticboy/vim-markdown\">https://github.com/plasticboy/vim-markdown</a>  </p>\n</blockquote>\n<p>markdown语法和hexo的配置还有好多地方不明白,日后在完善博客的功能,由于公司封了weibo,weibo秀暂时没弄,评论用的是多说的模块.<br>期待大家多在评论里和我交流.</p>\n<p>第一篇就这样了,日子还长.</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"ckqw7jdve00016f1rerd94mqo","category_id":"ckqw7jdvj00046f1rdocwffqu","_id":"ckqw7jdvs000f6f1rdsk2g9fi"},{"post_id":"ckqw7jdvi00036f1r91no5wo1","category_id":"ckqw7jdvo000a6f1rbcmu8okt","_id":"ckqw7jdvw000o6f1r310h2wsu"},{"post_id":"ckqw7jdvt000j6f1r7fli2tmn","category_id":"ckqw7jdvj00046f1rdocwffqu","_id":"ckqw7jdvy000t6f1r30eihbed"},{"post_id":"ckqw7jdvm00076f1r6xsnbrjt","category_id":"ckqw7jdvo000a6f1rbcmu8okt","_id":"ckqw7jdw1000y6f1r9o5t54a8"},{"post_id":"ckqw7jdvv000l6f1rgwpj5skw","category_id":"ckqw7jdvj00046f1rdocwffqu","_id":"ckqw7jdw300116f1r4p8beuu0"},{"post_id":"ckqw7jdvw000q6f1rc8nkcxga","category_id":"ckqw7jdvj00046f1rdocwffqu","_id":"ckqw7jdw700156f1r9pff26h6"},{"post_id":"ckqw7jdvn00086f1rfp6360jp","category_id":"ckqw7jdvw000n6f1rfy60dttg","_id":"ckqw7jdw800186f1r9ypcb0n6"},{"post_id":"ckqw7jdvx000s6f1r5xgm6l08","category_id":"ckqw7jdvo000a6f1rbcmu8okt","_id":"ckqw7jdwa001c6f1rblqg198w"},{"post_id":"ckqw7jdw1000x6f1ra99w11r6","category_id":"ckqw7jdvj00046f1rdocwffqu","_id":"ckqw7jdwb001f6f1r33kcacrl"},{"post_id":"ckqw7jdvo00096f1rf2az3t5m","category_id":"ckqw7jdw0000v6f1rh4e4awmo","_id":"ckqw7jdwc001i6f1r9rf09tge"},{"post_id":"ckqw7jdw700176f1r3b2t7zzj","category_id":"ckqw7jdvw000n6f1rfy60dttg","_id":"ckqw7jdwd001m6f1r37js67qb"},{"post_id":"ckqw7jdwd001o6f1r26iy7v0g","category_id":"ckqw7jdvw000n6f1rfy60dttg","_id":"ckqw7jdwh001x6f1r2vm7asiq"},{"post_id":"ckqw7jdwe001r6f1reqyuds8k","category_id":"ckqw7jdwg001v6f1r9btv59vu","_id":"ckqw7jdwl00286f1r23m5b4xu"},{"post_id":"ckqw7jdwf001t6f1rh8uw5lb4","category_id":"ckqw7jdwj00236f1r250tbsqu","_id":"ckqw7jdwo002g6f1rabe0ezlx"},{"post_id":"ckqw7jdwh001w6f1r586z6dtv","category_id":"ckqw7jdwg001v6f1r9btv59vu","_id":"ckqw7jdwp002k6f1rhb6t1win"},{"post_id":"ckqw7jdwn002e6f1r0ggg6bc1","category_id":"ckqw7jdwg001v6f1r9btv59vu","_id":"ckqw7jdwp002n6f1r510seb3y"},{"post_id":"ckqw7jdwk00256f1re3z8ee9h","category_id":"ckqw7jdwo002f6f1req9g2vy5","_id":"ckqw7jdwq002p6f1r5jcj17sr"}],"PostTag":[{"post_id":"ckqw7jdve00016f1rerd94mqo","tag_id":"ckqw7jdvl00056f1r81ay3ep7","_id":"ckqw7jdvq000c6f1rhyag07o0"},{"post_id":"ckqw7jdvi00036f1r91no5wo1","tag_id":"ckqw7jdvl00056f1r81ay3ep7","_id":"ckqw7jdvt000i6f1r7xlv06g7"},{"post_id":"ckqw7jdvr000e6f1r085e51j7","tag_id":"ckqw7jdvl00056f1r81ay3ep7","_id":"ckqw7jdvu000k6f1r1z1udt05"},{"post_id":"ckqw7jdvt000j6f1r7fli2tmn","tag_id":"ckqw7jdvl00056f1r81ay3ep7","_id":"ckqw7jdvw000p6f1rb2uvh348"},{"post_id":"ckqw7jdvm00076f1r6xsnbrjt","tag_id":"ckqw7jdvl00056f1r81ay3ep7","_id":"ckqw7jdvx000r6f1raeljbz1n"},{"post_id":"ckqw7jdvv000l6f1rgwpj5skw","tag_id":"ckqw7jdvl00056f1r81ay3ep7","_id":"ckqw7jdw1000w6f1r4sq58s63"},{"post_id":"ckqw7jdvw000q6f1rc8nkcxga","tag_id":"ckqw7jdvl00056f1r81ay3ep7","_id":"ckqw7jdw2000z6f1r5u5d1l38"},{"post_id":"ckqw7jdvn00086f1rfp6360jp","tag_id":"ckqw7jdvv000m6f1r5bkm54rt","_id":"ckqw7jdw600136f1rh48dcfyh"},{"post_id":"ckqw7jdw1000x6f1ra99w11r6","tag_id":"ckqw7jdvl00056f1r81ay3ep7","_id":"ckqw7jdw700166f1rb7w92mch"},{"post_id":"ckqw7jdvo00096f1rf2az3t5m","tag_id":"ckqw7jdvy000u6f1rhfz57jwl","_id":"ckqw7jdw9001a6f1r5buqcyur"},{"post_id":"ckqw7jdw200106f1rehp2b0ia","tag_id":"ckqw7jdvl00056f1r81ay3ep7","_id":"ckqw7jdwa001d6f1rclkq2jfh"},{"post_id":"ckqw7jdvq000d6f1rgwgjhwv1","tag_id":"ckqw7jdvl00056f1r81ay3ep7","_id":"ckqw7jdwb001g6f1r1lh4c5qh"},{"post_id":"ckqw7jdvq000d6f1rgwgjhwv1","tag_id":"ckqw7jdw300126f1rdaktbjkf","_id":"ckqw7jdwc001k6f1rh9bla68a"},{"post_id":"ckqw7jdwa001e6f1rem5rbdpv","tag_id":"ckqw7jdvv000m6f1r5bkm54rt","_id":"ckqw7jdwd001n6f1rbudn049u"},{"post_id":"ckqw7jdvx000s6f1r5xgm6l08","tag_id":"ckqw7jdvl00056f1r81ay3ep7","_id":"ckqw7jdwe001q6f1r7ectbzzh"},{"post_id":"ckqw7jdvx000s6f1r5xgm6l08","tag_id":"ckqw7jdw900196f1rbvgl5vae","_id":"ckqw7jdwf001s6f1rehy0fudp"},{"post_id":"ckqw7jdw600146f1rau1vakwg","tag_id":"ckqw7jdwc001j6f1r7b81501q","_id":"ckqw7jdwh001y6f1r7ytydvvz"},{"post_id":"ckqw7jdw600146f1rau1vakwg","tag_id":"ckqw7jdwe001p6f1rbo14g3b2","_id":"ckqw7jdwi00206f1rfhegcx46"},{"post_id":"ckqw7jdw700176f1r3b2t7zzj","tag_id":"ckqw7jdwg001u6f1r7r28glwi","_id":"ckqw7jdwk00246f1ravhnexim"},{"post_id":"ckqw7jdwj00226f1r837g59ud","tag_id":"ckqw7jdw300126f1rdaktbjkf","_id":"ckqw7jdwk00266f1r3ukobdi6"},{"post_id":"ckqw7jdwk00256f1re3z8ee9h","tag_id":"ckqw7jdwe001p6f1rbo14g3b2","_id":"ckqw7jdwm002b6f1r2gsj6ljq"},{"post_id":"ckqw7jdwk00256f1re3z8ee9h","tag_id":"ckqw7jdwc001j6f1r7b81501q","_id":"ckqw7jdwn002d6f1r697rbu1d"},{"post_id":"ckqw7jdw9001b6f1re3aa54su","tag_id":"ckqw7jdvl00056f1r81ay3ep7","_id":"ckqw7jdwo002i6f1rf8i06que"},{"post_id":"ckqw7jdw9001b6f1re3aa54su","tag_id":"ckqw7jdwi00216f1rd8tg7frn","_id":"ckqw7jdwp002j6f1r8l9b1xbs"},{"post_id":"ckqw7jdwb001h6f1rabrv5tye","tag_id":"ckqw7jdwl00296f1rf5z0bbp1","_id":"ckqw7jdwp002m6f1r0ag09vhx"},{"post_id":"ckqw7jdwd001l6f1rez4p779o","tag_id":"ckqw7jdwo002h6f1r3ghf14pm","_id":"ckqw7jdwp002o6f1r608t6c07"},{"post_id":"ckqw7jdwd001o6f1r26iy7v0g","tag_id":"ckqw7jdw300126f1rdaktbjkf","_id":"ckqw7jdwq002r6f1rbgxn0jx9"},{"post_id":"ckqw7jdwd001o6f1r26iy7v0g","tag_id":"ckqw7jdwp002l6f1r76x8371o","_id":"ckqw7jdwq002s6f1rb5ov4941"},{"post_id":"ckqw7jdwe001r6f1reqyuds8k","tag_id":"ckqw7jdwq002q6f1raon7d1yu","_id":"ckqw7jdwq002u6f1rdiebfwf4"},{"post_id":"ckqw7jdwf001t6f1rh8uw5lb4","tag_id":"ckqw7jdwq002t6f1r4efa4k2q","_id":"ckqw7jdwr002w6f1r4uhlcole"},{"post_id":"ckqw7jdwh001w6f1r586z6dtv","tag_id":"ckqw7jdwr002v6f1ra5zm231h","_id":"ckqw7jdwr002y6f1rdeihagvz"},{"post_id":"ckqw7jdwh001z6f1rh2n29x1c","tag_id":"ckqw7jdwr002x6f1r9fxzazml","_id":"ckqw7jdws00306f1r3m2ghqpa"},{"post_id":"ckqw7jdwm002c6f1r92kk2b43","tag_id":"ckqw7jdwr002z6f1r1tai00ax","_id":"ckqw7jdws00316f1r6q1624zd"}],"Tag":[{"name":"erlang","_id":"ckqw7jdvl00056f1r81ay3ep7"},{"name":"linux","_id":"ckqw7jdvv000m6f1r5bkm54rt"},{"name":"markdown","_id":"ckqw7jdvy000u6f1rhfz57jwl"},{"name":"vim","_id":"ckqw7jdw300126f1rdaktbjkf"},{"name":"代码","_id":"ckqw7jdw900196f1rbvgl5vae"},{"name":"hexo","_id":"ckqw7jdwc001j6f1r7b81501q"},{"name":"github","_id":"ckqw7jdwe001p6f1rbo14g3b2"},{"name":"xmodmap，vim","_id":"ckqw7jdwg001u6f1r7r28glwi"},{"name":"ranch","_id":"ckqw7jdwi00216f1rd8tg7frn"},{"name":"git","_id":"ckqw7jdwl00296f1rf5z0bbp1"},{"name":"ubuntu","_id":"ckqw7jdwo002h6f1r3ghf14pm"},{"name":"教程","_id":"ckqw7jdwp002l6f1r76x8371o"},{"name":"情感","_id":"ckqw7jdwq002q6f1raon7d1yu"},{"name":"二次元","_id":"ckqw7jdwq002t6f1r4efa4k2q"},{"name":"电影","_id":"ckqw7jdwr002v6f1ra5zm231h"},{"name":"makefile","_id":"ckqw7jdwr002x6f1r9fxzazml"},{"name":"杂记","_id":"ckqw7jdwr002z6f1r1tai00ax"}]}}